{
  "/docs/agents/java-agent/additional-installation/install-java-agent-using-maven": [
    {
      "sections": [
        "Install New Relic Java agent for Docker",
        "Tip",
        "Get the Java agent",
        "Download using curl",
        "Download using Invoke-WebRequest (PowerShell)",
        "Download from the New Relic UI",
        "Set up the installation directory",
        "Modify startup scripts",
        "Set agent configurations",
        "Application name",
        "License key",
        "Logs",
        "Environment (optional)",
        "Important",
        "Enabled (optional)",
        "Additional Tomcat Dockerfile examples",
        "Tomcat with environment and Java system properties",
        "How to start an application with the Java agent",
        "Next steps"
      ],
      "title": "Install New Relic Java agent for Docker",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "4de0ccd173c9851b045cfa036089e2f703b4a0f7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/install-new-relic-java-agent-docker/",
      "published_at": "2021-05-04T17:59:15Z",
      "updated_at": "2021-03-16T14:29:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains a basic installation of the APM agent for Java applications in a Docker container. We discuss required configurations and also explore some optional configurations, including: How to use identical New Relic configuration files for each container, regardless of the environment where the containers are used How to use the Docker layer when every agent in every environment needs slightly different configuration data How to disable the New Relic agent in some environments and enable it in others Although we don't discuss advanced options here, you can install the Java agent in Docker volumes and use your Docker container image in other software such as Swarm, ECS, AKS, EKS, OpenShift, and Kubernetes. Our Docker examples refer to Tomcat, so if you are using another application server, refer to your vendor’s documentation. Tip To use Java or any other agent, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Get the Java agent Download newrelic-java.zip using curl, Invoke-WebRequest (PowerShell), or the New Relic UI: Download using curl Complete the following: Start a command-line session. Change to a temporary directory where you can download the zip file. Execute this curl command: curl -O https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip Copy Unzip newrelic-java.zip Download using Invoke-WebRequest (PowerShell) Complete the following: Start a PowerShell session. Change to a temporary directory where you can download the zip file. Execute this PowerShell command: Invoke-WebRequest -Uri https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip -OutFile newrelic-java.zip Copy Unzip newrelic-java.zip: Expand-Archive -Path newrelic-java.zip -DestinationPath DESTINATION_PATH Copy Download from the New Relic UI Complete the following: Log in to New Relic. From the account dropdown in the New Relic UI, select Account settings. In the right sidebar under Most recent, select the Java agent, and save the newrelic-java.zip to a temporary directory. Unzip newrelic-java.zip. Set up the installation directory You can unzip the newrelic-java.zip file wherever it is convenient for you. In the subsequent sections we assume you extracted it in the current working directory, which puts the files we need in ./newrelic. Modify startup scripts The startup script that contains the command to start your application server must include Java’s built-in argument -javaagent. We recommend that you set this argument with the JAVA_OPTS environment variable. The value of that argument must contain the location where you ADD the Java APM agent’s jar file to the image. For example, with Tomcat, use commands like these in the Dockerfile: RUN mkdir -p /usr/local/tomcat/newrelic ADD ./newrelic/newrelic.jar /usr/local/tomcat/newrelic/newrelic.jar ENV JAVA_OPTS=\"$JAVA_OPTS -javaagent:/usr/local/tomcat/newrelic/newrelic.jar\" Copy Set agent configurations By default, agent behavior is controlled by configuration entries in newrelic.yml, which is typically located in the same directory as the agent. This section explains how to override these newrelic.yml configurations by using environment variables or Java system properties in the Dockerfile. Before we look at some specific configurations, here’s how to load newrelic.yml using the Dockerfile: ADD ./newrelic/newrelic.yml /usr/local/tomcat/newrelic/newrelic.yml Copy For a basic Docker installation, complete these configurations: Application name License key Logs Environment (optional) Enabled (optional) Application name The application name is a configuration you set to identify your application in New Relic. Tip You can reuse an application name for multiple apps serving the same role so that all the data from those apps rolls up into the same logical application in New Relic. For more detail about additional grouping options, see Use multiple names for an app. Replace MY_APP_NAME with your application name in one of these Dockerfile commands: Option Command Environment variable ENV NEW_RELIC_APP_NAME=\"MY_APP_NAME\" Copy Java system property ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.app_name='MY_APP_NAME'\" Copy After you boot the container, your application name appears in New Relic. License key This configuration is required for you to report on any data in your New Relic Account. To copy your license key: Go to one.newrelic.com > (account dropdown) > Account settings. Under Account information, copy the license key. In one of these Dockerfile commands, replace MY_LICENSE_KEY with your license key: Option Command Environment variable ENV NEW_RELIC_LICENSE_KEY=\"MY_LICENSE_KEY\" Copy Java system property ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.license_key='MY_LICENSE_KEY'\" Copy Logs By default, logs are written into the logs directory relative to the location of newrelic.jar. Make sure that the user account that starts your application server also has the right to perform tasks such as: Creating the logs directory. Creating and appending to the log files in that directory. Here’s a Dockerfile example where tomcat is the user who starts Tomcat: RUN mkdir -p /usr/local/tomcat/newrelic/logs RUN chown -R tomcat:tomcat /usr/local/tomcat/newrelic/logs Copy You can also send the logs to STDOUT by adding one of the following to the Dockerfile: Option Command Environment Variable ENV NEW_RELIC_LOG_FILE_NAME=STDOUT Copy Java system property ENV JAVA_OPTS=-Dnewrelic.config.log_file_name=STDOUT Copy Environment (optional) You can pass either a Java property or an environment variable to determine which of the environment-specific stanzas the agent uses in newrelic.yml. Use this approach if you prefer to have the newrelic.yml file control environment-specific configurations instead of passing all the configurations via Docker. Here’s a Dockerfile example of passing the newrelic.environment Java system property via Docker to use the custom value dev in the environment stanza of newrelic.yml: Using the shell form of the CMD instruction, include a reference to a new environment variable you choose (for example, ENV): CMD java -Dnewrelic.environment=$ENV -jar myjar.jar Copy In your docker run command line, include an argument to set the environment variable in the container: docker run -it -e \"ENV=dev\" myDockerImage Copy Important If you don’t specify a value for newrelic.environment, the agent assumes it is running in your production environment and uses the values from the main body of the configuration file. Enabled (optional) This configuration controls whether the agent is enabled. Let’s say you want the same Docker image for every installation. However, you don’t want to run the New Relic agent every time an engineer spins up a test app because you don’t want to run up your instance count. This problem can be solved using the newrelic.environment Java system property. In the main body of newrelic.yml, disable the Java agent by setting enabled: false. In specific environment stanzas of newrelic.yml, set enabled: true. Then, you can run specific agents by specifying the environment at runtime. Additional Tomcat Dockerfile examples Tomcat with environment and Java system properties FROM tomcat:9 # Add the newrelic.jar and -javaagent parameters RUN mkdir -p /usr/local/tomcat/newrelic ADD ./newrelic/newrelic.jar /usr/local/tomcat/newrelic/ ENV JAVA_OPTS=\"$JAVA_OPTS -javaagent:/usr/local/tomcat/newrelic/newrelic.jar\" # Add the configuration file ADD ./newrelic/newrelic.yml /usr/local/tomcat/newrelic/ # An example of setting a system property config ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.app_name='My Application'\" # An example of setting an Environment variable config ENV NEW_RELIC_LICENSE_KEY=\"license_key\" # Config to include the agent logs in Docker's stdout logging ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.log_file_name=STDOUT\" EXPOSE 8080 CMD [\"catalina.sh\", \"run\"] Copy How to start an application with the Java agent FROM openjdk:8 ADD my-application.jar /app ADD newrelic.jar /app ADD newrelic.yml /app ENV NEW_RELIC_APP_NAME=\"My Application\" ENV NEW_RELIC_LICENSE_KEY=\"license_key\" ENV NEW_RELIC_LOG_FILE_NAME=\"STDOUT\" ENTRYPOINT [\"java\",\"-javaagent:/app/newrelic.jar\",\"-jar\",\"/app/my-application.jar\"] Copy Next steps Now that you have a basic agent installation in Docker, here are some additional steps to consider: Review other configurations for the agent. Read a detailed Explorers Hub post about Docker and New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.51317,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> for Docker",
        "sections": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> for Docker",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": "This document explains a basic <em>installation</em> of the APM <em>agent</em> for <em>Java</em> applications in a Docker container. We discuss required configurations and also explore some optional configurations, including: How to use identical New Relic configuration files for each container, regardless of the environment"
      },
      "id": "603ea3dc28ccbc8889eba765"
    },
    {
      "sections": [
        "WildFly installation for Java",
        "Install WildFly versions earlier than 11",
        "Install WildFly version 11 or higher"
      ],
      "title": "WildFly installation for Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "7f9259f3b77efb78cd4861a9d7b519fe44191e3c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/wildfly-installation-java/",
      "published_at": "2021-05-05T00:37:37Z",
      "updated_at": "2021-03-16T14:29:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Before you install New Relic's Java agent, make sure your WildFly version is supported. Depending on which WildFly version your application uses, additional configuration steps may be required. Install WildFly versions earlier than 11 If your supported WildFly version is earlier than v11, follow standard Java installation procedures. You do not need to do any additional configuration. Install WildFly version 11 or higher If you use WildFly version 11 or higher, New Relic's Java agent requires additional configuration after you install it. Install the Java agent. If you already have it installed, update to the latest Java agent version. Versions 5.0.0 and higher include fixes for later WildFly versions 11 and higher. Open the standalone configuration file appropriate for your operating system and add the -javaagent property to JAVA_OPTS. For example, if you use Linux, edit the /bin/standalone.conf file or /bin/standalone.conf.bat for Windows. Make sure the agent jar is visible to all JBoss modules by adding com.newrelic to the JBoss modules system packages using either of these options in the standalone script: Recommended: Option 1 (same as adding -javaagent property): JAVA_OPTS=\"$JAVA_OPTS -Djboss.modules.system.pkgs=$JBOSS_MODULES_SYSTEM_PKGS,com.newrelic Copy Option 2: if [ \"x$JBOSS_MODULES_SYSTEM_PKGS\" = \"x\" ]; then JBOSS_MODULES_SYSTEM_PKGS=\"org.jboss.byteman,com.newrelic\" fi Copy Restart your application server.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.51317,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "WildFly <em>installation</em> for <em>Java</em>",
        "sections": "WildFly <em>installation</em> for <em>Java</em>",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": " standard <em>Java</em> <em>installation</em> procedures. You do not need to do any <em>additional</em> configuration. Install WildFly version 11 or higher If you use WildFly version 11 or higher, New Relic&#x27;s <em>Java</em> <em>agent</em> requires <em>additional</em> configuration after you install it. Install the <em>Java</em> <em>agent</em>. If you already have"
      },
      "id": "603e791764441f18724e88ab"
    },
    {
      "sections": [
        "Install New Relic Java agent with Ansible",
        "Compatibility and requirements",
        "Overview of process",
        "Step 1. Install the role",
        "Step 2. Incorporate the role into playbook",
        "Step 3. Configure the role",
        "Step 4. Configure the agent",
        "Step 5. Enable custom instrumentation (optional)",
        "For more help"
      ],
      "title": "Install New Relic Java agent with Ansible",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "328592f6b75e0eb638a0916082e034bb9782cad7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/install-new-relic-java-agent-ansible/",
      "published_at": "2021-05-05T06:55:40Z",
      "updated_at": "2021-03-16T14:28:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM for Java allows you to use an Ansible role for installation and configuration. Compatibility and requirements New Relic's Ansible role for the Java agent is open source and community-supported. It supports setting up our Java agent to instrument applications running under Tomcat, Jetty, and Wildfly (formerly JBoss) on Linux servers. The most common agent parameters can be configured through Ansible variables. You'll need to install Ansible to run this role. Ansible is run from a central server to configure target hosts; these hosts must be running Linux and have unzip installed. The role should be compatible with most popular Linux distributions. Overview of process There are several steps that may be involved for installation and configuration: Install the role Incorporate role in your playbook Configure the role Configure the agent Enable custom instrumentation (optional) Step 1. Install the role To install this role, use the ansible-galaxy command on the system where you run Ansible: $ ansible-galaxy install newrelic.newrelic_java_agent Copy This will download the role from Ansible Galaxy and make it available for use in Ansible playbooks. Step 2. Incorporate the role into playbook You'll need to call the role from your playbook using the include_role module. The role's GitHub repository contains an example playbook for you to start from, which looks like this: - hosts: YOUR_HOST_GROUP vars: nr_java_agent_config: license_key: YOUR_LICENSE_KEY app_name: YOUR_APP_NAME log_file_path: /tmp/newrelic server_type: tomcat server_root: /var/lib/tomcat8 jvm_conf_file: /usr/share/tomcat8/bin/setenv.sh server_user: tomcat8 server_group: tomcat8 service_name: tomcat8 restart_web_server: true tasks: - include_role: name: newrelic.newrelic_java_agent Copy The vars section contains a dictionary called nr_java_agent_config, which holds settings for the agent itself, and a number of variables for configuring the role's installation process. See the sections on agent configuration and role configuration for details. Step 3. Configure the role These variables are used to configure the install process. Most are required. For more information, see the examples on GitHub. Variable Description server_type Required. Web server used by your application. Possible values are: tomcat, jetty, and wildfly (standalone mode only). server_root Required. Location of the web server on the host. The agent's JAR, configuration, and (by default) log files will live in a subdirectory of this directory. jvm_conf_file Required. Path to the web server configuration file to reference the New Relic Java agent. For Tomcat, for instance, it's typically the setenv.sh file. If the file doesn't exist, it may be created, depending on the server_type. server_user server_group Required. User and group under which the web server runs. Used to set the ownership of the newrelic.jar and newrelic.yml files. restart_web_server Optional. Default: true. If set to false, the role does not restart the web server after installing the agent. Note that the agent is not activated until the web server is restarted. service_name Required (unless restart_web_server is set to false). Service name under which the web server runs. Used by Ansible to restart the web server after the agent is installed. nr_java_agent_version Optional; default: currentSpecifies the version of the Java agent to install. current will install the latest version. You can also install a specific version, like 5.9.0. For available versions, see Java agent downloads directory. Step 4. Configure the agent The following variables are used to configure the Java agent itself. These are just a few of the available options. For a full list of supported variables, see the README file on GitHub. For more about how to configure the agent, see Java agent configuration. Variable Description license_key Required. Your New Relic license key. app_name Required. Name of the application being instrumented. For more details, see App naming. proxy_host proxy_port proxy_user proxy_password proxy_scheme Optional. If you connect to the New Relic collector via a proxy, you can configure your proxy settings with these values. labels Optional. User-configurable custom labels for the agent. Labels are name-value pairs. Names and values are limited to 255 characters and cannot contain colons (:) nor semicolons (;). Value should be a semicolon-separated list of key-value pairs, for example Server:One;Data Center:Primary. Step 5. Enable custom instrumentation (optional) If you want to enable custom instrumentation, you can provide a list of XML files using the custom_instrumentation_files variable. For instance, you can specify that all Java agents being installed should use a file called my_instrumentation.xml by adding something like the following to your playbook: vars: custom_instrumentation_files: - /path/to/my_instrumentation.xml Copy See the README and examples on GitHub for more information. For more help If you need additional help, file an issue at newrelic/newrelic-java-agent-ansible-role on GitHub.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.512924,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> with Ansible",
        "sections": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> with Ansible",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": "APM for <em>Java</em> allows you to use an Ansible role for <em>installation</em> and configuration. Compatibility and requirements New Relic&#x27;s Ansible role for the <em>Java</em> <em>agent</em> is open source and community-supported. It supports setting up our <em>Java</em> <em>agent</em> to instrument applications running under Tomcat, Jetty"
      },
      "id": "603e92dce7b9d2a5d32a080c"
    }
  ],
  "/docs/agents/java-agent/additional-installation/install-new-relic-java-agent-ansible": [
    {
      "sections": [
        "Install New Relic Java agent for Docker",
        "Tip",
        "Get the Java agent",
        "Download using curl",
        "Download using Invoke-WebRequest (PowerShell)",
        "Download from the New Relic UI",
        "Set up the installation directory",
        "Modify startup scripts",
        "Set agent configurations",
        "Application name",
        "License key",
        "Logs",
        "Environment (optional)",
        "Important",
        "Enabled (optional)",
        "Additional Tomcat Dockerfile examples",
        "Tomcat with environment and Java system properties",
        "How to start an application with the Java agent",
        "Next steps"
      ],
      "title": "Install New Relic Java agent for Docker",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "4de0ccd173c9851b045cfa036089e2f703b4a0f7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/install-new-relic-java-agent-docker/",
      "published_at": "2021-05-04T17:59:15Z",
      "updated_at": "2021-03-16T14:29:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains a basic installation of the APM agent for Java applications in a Docker container. We discuss required configurations and also explore some optional configurations, including: How to use identical New Relic configuration files for each container, regardless of the environment where the containers are used How to use the Docker layer when every agent in every environment needs slightly different configuration data How to disable the New Relic agent in some environments and enable it in others Although we don't discuss advanced options here, you can install the Java agent in Docker volumes and use your Docker container image in other software such as Swarm, ECS, AKS, EKS, OpenShift, and Kubernetes. Our Docker examples refer to Tomcat, so if you are using another application server, refer to your vendor’s documentation. Tip To use Java or any other agent, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Get the Java agent Download newrelic-java.zip using curl, Invoke-WebRequest (PowerShell), or the New Relic UI: Download using curl Complete the following: Start a command-line session. Change to a temporary directory where you can download the zip file. Execute this curl command: curl -O https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip Copy Unzip newrelic-java.zip Download using Invoke-WebRequest (PowerShell) Complete the following: Start a PowerShell session. Change to a temporary directory where you can download the zip file. Execute this PowerShell command: Invoke-WebRequest -Uri https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip -OutFile newrelic-java.zip Copy Unzip newrelic-java.zip: Expand-Archive -Path newrelic-java.zip -DestinationPath DESTINATION_PATH Copy Download from the New Relic UI Complete the following: Log in to New Relic. From the account dropdown in the New Relic UI, select Account settings. In the right sidebar under Most recent, select the Java agent, and save the newrelic-java.zip to a temporary directory. Unzip newrelic-java.zip. Set up the installation directory You can unzip the newrelic-java.zip file wherever it is convenient for you. In the subsequent sections we assume you extracted it in the current working directory, which puts the files we need in ./newrelic. Modify startup scripts The startup script that contains the command to start your application server must include Java’s built-in argument -javaagent. We recommend that you set this argument with the JAVA_OPTS environment variable. The value of that argument must contain the location where you ADD the Java APM agent’s jar file to the image. For example, with Tomcat, use commands like these in the Dockerfile: RUN mkdir -p /usr/local/tomcat/newrelic ADD ./newrelic/newrelic.jar /usr/local/tomcat/newrelic/newrelic.jar ENV JAVA_OPTS=\"$JAVA_OPTS -javaagent:/usr/local/tomcat/newrelic/newrelic.jar\" Copy Set agent configurations By default, agent behavior is controlled by configuration entries in newrelic.yml, which is typically located in the same directory as the agent. This section explains how to override these newrelic.yml configurations by using environment variables or Java system properties in the Dockerfile. Before we look at some specific configurations, here’s how to load newrelic.yml using the Dockerfile: ADD ./newrelic/newrelic.yml /usr/local/tomcat/newrelic/newrelic.yml Copy For a basic Docker installation, complete these configurations: Application name License key Logs Environment (optional) Enabled (optional) Application name The application name is a configuration you set to identify your application in New Relic. Tip You can reuse an application name for multiple apps serving the same role so that all the data from those apps rolls up into the same logical application in New Relic. For more detail about additional grouping options, see Use multiple names for an app. Replace MY_APP_NAME with your application name in one of these Dockerfile commands: Option Command Environment variable ENV NEW_RELIC_APP_NAME=\"MY_APP_NAME\" Copy Java system property ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.app_name='MY_APP_NAME'\" Copy After you boot the container, your application name appears in New Relic. License key This configuration is required for you to report on any data in your New Relic Account. To copy your license key: Go to one.newrelic.com > (account dropdown) > Account settings. Under Account information, copy the license key. In one of these Dockerfile commands, replace MY_LICENSE_KEY with your license key: Option Command Environment variable ENV NEW_RELIC_LICENSE_KEY=\"MY_LICENSE_KEY\" Copy Java system property ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.license_key='MY_LICENSE_KEY'\" Copy Logs By default, logs are written into the logs directory relative to the location of newrelic.jar. Make sure that the user account that starts your application server also has the right to perform tasks such as: Creating the logs directory. Creating and appending to the log files in that directory. Here’s a Dockerfile example where tomcat is the user who starts Tomcat: RUN mkdir -p /usr/local/tomcat/newrelic/logs RUN chown -R tomcat:tomcat /usr/local/tomcat/newrelic/logs Copy You can also send the logs to STDOUT by adding one of the following to the Dockerfile: Option Command Environment Variable ENV NEW_RELIC_LOG_FILE_NAME=STDOUT Copy Java system property ENV JAVA_OPTS=-Dnewrelic.config.log_file_name=STDOUT Copy Environment (optional) You can pass either a Java property or an environment variable to determine which of the environment-specific stanzas the agent uses in newrelic.yml. Use this approach if you prefer to have the newrelic.yml file control environment-specific configurations instead of passing all the configurations via Docker. Here’s a Dockerfile example of passing the newrelic.environment Java system property via Docker to use the custom value dev in the environment stanza of newrelic.yml: Using the shell form of the CMD instruction, include a reference to a new environment variable you choose (for example, ENV): CMD java -Dnewrelic.environment=$ENV -jar myjar.jar Copy In your docker run command line, include an argument to set the environment variable in the container: docker run -it -e \"ENV=dev\" myDockerImage Copy Important If you don’t specify a value for newrelic.environment, the agent assumes it is running in your production environment and uses the values from the main body of the configuration file. Enabled (optional) This configuration controls whether the agent is enabled. Let’s say you want the same Docker image for every installation. However, you don’t want to run the New Relic agent every time an engineer spins up a test app because you don’t want to run up your instance count. This problem can be solved using the newrelic.environment Java system property. In the main body of newrelic.yml, disable the Java agent by setting enabled: false. In specific environment stanzas of newrelic.yml, set enabled: true. Then, you can run specific agents by specifying the environment at runtime. Additional Tomcat Dockerfile examples Tomcat with environment and Java system properties FROM tomcat:9 # Add the newrelic.jar and -javaagent parameters RUN mkdir -p /usr/local/tomcat/newrelic ADD ./newrelic/newrelic.jar /usr/local/tomcat/newrelic/ ENV JAVA_OPTS=\"$JAVA_OPTS -javaagent:/usr/local/tomcat/newrelic/newrelic.jar\" # Add the configuration file ADD ./newrelic/newrelic.yml /usr/local/tomcat/newrelic/ # An example of setting a system property config ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.app_name='My Application'\" # An example of setting an Environment variable config ENV NEW_RELIC_LICENSE_KEY=\"license_key\" # Config to include the agent logs in Docker's stdout logging ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.log_file_name=STDOUT\" EXPOSE 8080 CMD [\"catalina.sh\", \"run\"] Copy How to start an application with the Java agent FROM openjdk:8 ADD my-application.jar /app ADD newrelic.jar /app ADD newrelic.yml /app ENV NEW_RELIC_APP_NAME=\"My Application\" ENV NEW_RELIC_LICENSE_KEY=\"license_key\" ENV NEW_RELIC_LOG_FILE_NAME=\"STDOUT\" ENTRYPOINT [\"java\",\"-javaagent:/app/newrelic.jar\",\"-jar\",\"/app/my-application.jar\"] Copy Next steps Now that you have a basic agent installation in Docker, here are some additional steps to consider: Review other configurations for the agent. Read a detailed Explorers Hub post about Docker and New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.51317,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> for Docker",
        "sections": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> for Docker",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": "This document explains a basic <em>installation</em> of the APM <em>agent</em> for <em>Java</em> applications in a Docker container. We discuss required configurations and also explore some optional configurations, including: How to use identical New Relic configuration files for each container, regardless of the environment"
      },
      "id": "603ea3dc28ccbc8889eba765"
    },
    {
      "sections": [
        "WildFly installation for Java",
        "Install WildFly versions earlier than 11",
        "Install WildFly version 11 or higher"
      ],
      "title": "WildFly installation for Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "7f9259f3b77efb78cd4861a9d7b519fe44191e3c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/wildfly-installation-java/",
      "published_at": "2021-05-05T00:37:37Z",
      "updated_at": "2021-03-16T14:29:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Before you install New Relic's Java agent, make sure your WildFly version is supported. Depending on which WildFly version your application uses, additional configuration steps may be required. Install WildFly versions earlier than 11 If your supported WildFly version is earlier than v11, follow standard Java installation procedures. You do not need to do any additional configuration. Install WildFly version 11 or higher If you use WildFly version 11 or higher, New Relic's Java agent requires additional configuration after you install it. Install the Java agent. If you already have it installed, update to the latest Java agent version. Versions 5.0.0 and higher include fixes for later WildFly versions 11 and higher. Open the standalone configuration file appropriate for your operating system and add the -javaagent property to JAVA_OPTS. For example, if you use Linux, edit the /bin/standalone.conf file or /bin/standalone.conf.bat for Windows. Make sure the agent jar is visible to all JBoss modules by adding com.newrelic to the JBoss modules system packages using either of these options in the standalone script: Recommended: Option 1 (same as adding -javaagent property): JAVA_OPTS=\"$JAVA_OPTS -Djboss.modules.system.pkgs=$JBOSS_MODULES_SYSTEM_PKGS,com.newrelic Copy Option 2: if [ \"x$JBOSS_MODULES_SYSTEM_PKGS\" = \"x\" ]; then JBOSS_MODULES_SYSTEM_PKGS=\"org.jboss.byteman,com.newrelic\" fi Copy Restart your application server.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.51317,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "WildFly <em>installation</em> for <em>Java</em>",
        "sections": "WildFly <em>installation</em> for <em>Java</em>",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": " standard <em>Java</em> <em>installation</em> procedures. You do not need to do any <em>additional</em> configuration. Install WildFly version 11 or higher If you use WildFly version 11 or higher, New Relic&#x27;s <em>Java</em> <em>agent</em> requires <em>additional</em> configuration after you install it. Install the <em>Java</em> <em>agent</em>. If you already have"
      },
      "id": "603e791764441f18724e88ab"
    },
    {
      "sections": [
        "Install Java agent using Gradle",
        "Install agent package using Gradle",
        "Install complete agent package",
        "Here is an example build.gradle file for working with the zip file:",
        "Install individual components",
        "Here is an example build.gradle for working with the individual components (Java agent and API jars)."
      ],
      "title": "Install Java agent using Gradle",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "a9a3c2bee77544d95482e06548e6da73a8ddb713",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/install-java-agent-using-gradle/",
      "published_at": "2021-05-05T06:59:43Z",
      "updated_at": "2021-03-16T14:17:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install the Java agent using Gradle. For information on manually installing the Java agent, see Install the Java agent and Java agent configuration: Config file. Install agent package using Gradle Install the New Relic Java agent, using either of these options: Install complete agent package This section explains how to configure Gradle to download and unzip the newrelic-java.zip file, which contains all New Relic Java agent components: newrelic.yml (agent configuration file) newrelic.jar (Java agent jar) newrelic-api.jar (Java agent API jar) README To do this: Configure your build.gradle file with the plugin you will use to download the agent. For example: plugins { id \"de.undercouch.download\" version \"3.4.3\" } Copy Add tasks to download and unzip the agent. For example: task downloadNewrelic(type: Download) { mkdir 'newrelic' src 'https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip' dest file('newrelic') } task unzipNewrelic(type: Copy) { from zipTree(file('newrelic/newrelic-java.zip')) into rootDir } Copy Run the tasks to download and unzip the agent. For example: ./gradlew downloadNewrelic ./gradlew unzipNewrelic Copy This will download the newrelic-java.zip file into a newrelic/ directory and then unzip it in the same directory. Here is an example build.gradle file for working with the zip file: plugins { id 'java' id \"de.undercouch.download\" version \"3.4.3\" } group 'example_group' version '1.0-SNAPSHOT' sourceCompatibility = 1.8 repositories { mavenCentral() } task downloadNewrelic(type: Download) { mkdir 'newrelic' src 'https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip' dest file('newrelic') } task unzipNewrelic(type: Copy) { from zipTree(file('newrelic/newrelic-java.zip')) into rootDir } Copy Install individual components This section explains how to configure Gradle to download individual components of the Java agent, specifically the newrelic.jar and the newrelic-api.jar. Configure your build.gradle file to download either newrelic.jar or newrelic-api.jar. Here's an example for downloading newrelic.jar: dependencies { compile group: 'com.newrelic.agent.java', name: 'newrelic-agent', version: 'JAVA_AGENT_VERSION' } Copy Here's an example for downloading newrelic-api.jar: dependencies { compile group: 'com.newrelic.agent.java', name: 'newrelic-api', version: 'JAVA_AGENT_VERSION' } Copy Replace JAVA_AGENT_VERSION with the latest Java agent version. Locate the newrelic.yml file you received when creating your New Relic account or download one for the version of the agent that you are using. Here is an example build.gradle for working with the individual components (Java agent and API jars). plugins { id 'java' } group 'example_group' version '1.0-SNAPSHOT' sourceCompatibility = 1.8 repositories { mavenCentral() } dependencies { compile group: 'com.newrelic.agent.java', name: 'newrelic-agent', version: '4.11.0' compile group: 'com.newrelic.agent.java', name: 'newrelic-api', version: '4.11.0' } Copy Place newrelic.yml in the same folder as newrelic.jar, unless you specify otherwise in the JVM arg Dnewrelic.config.file. Configure the newrelic.yml file (or JVM system properties) with your license_key and app_name. Pass -javaagent:/path/to/newrelic.jar to the JVM running your application server. Optional: If using the New Relic Java agent API, make the API jar available at compile time by adding it to your application class path. Generate some traffic for your app, then wait a few minutes for data to appear in the APM Summary page. If nothing appears, follow the troubleshooting procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.510414,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> <em>Java</em> <em>agent</em> using Gradle",
        "sections": "<em>Install</em> <em>Java</em> <em>agent</em> using Gradle",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": "This document explains how to install the <em>Java</em> <em>agent</em> using Gradle. For information on manually installing the <em>Java</em> <em>agent</em>, see Install the <em>Java</em> <em>agent</em> and <em>Java</em> <em>agent</em> configuration: Config file. Install <em>agent</em> package using Gradle Install the New Relic <em>Java</em> <em>agent</em>, using either of these options: Install"
      },
      "id": "603eb0c964441f5b964e8839"
    }
  ],
  "/docs/agents/java-agent/additional-installation/install-new-relic-java-agent-docker": [
    {
      "sections": [
        "WildFly installation for Java",
        "Install WildFly versions earlier than 11",
        "Install WildFly version 11 or higher"
      ],
      "title": "WildFly installation for Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "7f9259f3b77efb78cd4861a9d7b519fe44191e3c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/wildfly-installation-java/",
      "published_at": "2021-05-05T00:37:37Z",
      "updated_at": "2021-03-16T14:29:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Before you install New Relic's Java agent, make sure your WildFly version is supported. Depending on which WildFly version your application uses, additional configuration steps may be required. Install WildFly versions earlier than 11 If your supported WildFly version is earlier than v11, follow standard Java installation procedures. You do not need to do any additional configuration. Install WildFly version 11 or higher If you use WildFly version 11 or higher, New Relic's Java agent requires additional configuration after you install it. Install the Java agent. If you already have it installed, update to the latest Java agent version. Versions 5.0.0 and higher include fixes for later WildFly versions 11 and higher. Open the standalone configuration file appropriate for your operating system and add the -javaagent property to JAVA_OPTS. For example, if you use Linux, edit the /bin/standalone.conf file or /bin/standalone.conf.bat for Windows. Make sure the agent jar is visible to all JBoss modules by adding com.newrelic to the JBoss modules system packages using either of these options in the standalone script: Recommended: Option 1 (same as adding -javaagent property): JAVA_OPTS=\"$JAVA_OPTS -Djboss.modules.system.pkgs=$JBOSS_MODULES_SYSTEM_PKGS,com.newrelic Copy Option 2: if [ \"x$JBOSS_MODULES_SYSTEM_PKGS\" = \"x\" ]; then JBOSS_MODULES_SYSTEM_PKGS=\"org.jboss.byteman,com.newrelic\" fi Copy Restart your application server.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.51317,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "WildFly <em>installation</em> for <em>Java</em>",
        "sections": "WildFly <em>installation</em> for <em>Java</em>",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": " standard <em>Java</em> <em>installation</em> procedures. You do not need to do any <em>additional</em> configuration. Install WildFly version 11 or higher If you use WildFly version 11 or higher, New Relic&#x27;s <em>Java</em> <em>agent</em> requires <em>additional</em> configuration after you install it. Install the <em>Java</em> <em>agent</em>. If you already have"
      },
      "id": "603e791764441f18724e88ab"
    },
    {
      "sections": [
        "Install New Relic Java agent with Ansible",
        "Compatibility and requirements",
        "Overview of process",
        "Step 1. Install the role",
        "Step 2. Incorporate the role into playbook",
        "Step 3. Configure the role",
        "Step 4. Configure the agent",
        "Step 5. Enable custom instrumentation (optional)",
        "For more help"
      ],
      "title": "Install New Relic Java agent with Ansible",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "328592f6b75e0eb638a0916082e034bb9782cad7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/install-new-relic-java-agent-ansible/",
      "published_at": "2021-05-05T06:55:40Z",
      "updated_at": "2021-03-16T14:28:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM for Java allows you to use an Ansible role for installation and configuration. Compatibility and requirements New Relic's Ansible role for the Java agent is open source and community-supported. It supports setting up our Java agent to instrument applications running under Tomcat, Jetty, and Wildfly (formerly JBoss) on Linux servers. The most common agent parameters can be configured through Ansible variables. You'll need to install Ansible to run this role. Ansible is run from a central server to configure target hosts; these hosts must be running Linux and have unzip installed. The role should be compatible with most popular Linux distributions. Overview of process There are several steps that may be involved for installation and configuration: Install the role Incorporate role in your playbook Configure the role Configure the agent Enable custom instrumentation (optional) Step 1. Install the role To install this role, use the ansible-galaxy command on the system where you run Ansible: $ ansible-galaxy install newrelic.newrelic_java_agent Copy This will download the role from Ansible Galaxy and make it available for use in Ansible playbooks. Step 2. Incorporate the role into playbook You'll need to call the role from your playbook using the include_role module. The role's GitHub repository contains an example playbook for you to start from, which looks like this: - hosts: YOUR_HOST_GROUP vars: nr_java_agent_config: license_key: YOUR_LICENSE_KEY app_name: YOUR_APP_NAME log_file_path: /tmp/newrelic server_type: tomcat server_root: /var/lib/tomcat8 jvm_conf_file: /usr/share/tomcat8/bin/setenv.sh server_user: tomcat8 server_group: tomcat8 service_name: tomcat8 restart_web_server: true tasks: - include_role: name: newrelic.newrelic_java_agent Copy The vars section contains a dictionary called nr_java_agent_config, which holds settings for the agent itself, and a number of variables for configuring the role's installation process. See the sections on agent configuration and role configuration for details. Step 3. Configure the role These variables are used to configure the install process. Most are required. For more information, see the examples on GitHub. Variable Description server_type Required. Web server used by your application. Possible values are: tomcat, jetty, and wildfly (standalone mode only). server_root Required. Location of the web server on the host. The agent's JAR, configuration, and (by default) log files will live in a subdirectory of this directory. jvm_conf_file Required. Path to the web server configuration file to reference the New Relic Java agent. For Tomcat, for instance, it's typically the setenv.sh file. If the file doesn't exist, it may be created, depending on the server_type. server_user server_group Required. User and group under which the web server runs. Used to set the ownership of the newrelic.jar and newrelic.yml files. restart_web_server Optional. Default: true. If set to false, the role does not restart the web server after installing the agent. Note that the agent is not activated until the web server is restarted. service_name Required (unless restart_web_server is set to false). Service name under which the web server runs. Used by Ansible to restart the web server after the agent is installed. nr_java_agent_version Optional; default: currentSpecifies the version of the Java agent to install. current will install the latest version. You can also install a specific version, like 5.9.0. For available versions, see Java agent downloads directory. Step 4. Configure the agent The following variables are used to configure the Java agent itself. These are just a few of the available options. For a full list of supported variables, see the README file on GitHub. For more about how to configure the agent, see Java agent configuration. Variable Description license_key Required. Your New Relic license key. app_name Required. Name of the application being instrumented. For more details, see App naming. proxy_host proxy_port proxy_user proxy_password proxy_scheme Optional. If you connect to the New Relic collector via a proxy, you can configure your proxy settings with these values. labels Optional. User-configurable custom labels for the agent. Labels are name-value pairs. Names and values are limited to 255 characters and cannot contain colons (:) nor semicolons (;). Value should be a semicolon-separated list of key-value pairs, for example Server:One;Data Center:Primary. Step 5. Enable custom instrumentation (optional) If you want to enable custom instrumentation, you can provide a list of XML files using the custom_instrumentation_files variable. For instance, you can specify that all Java agents being installed should use a file called my_instrumentation.xml by adding something like the following to your playbook: vars: custom_instrumentation_files: - /path/to/my_instrumentation.xml Copy See the README and examples on GitHub for more information. For more help If you need additional help, file an issue at newrelic/newrelic-java-agent-ansible-role on GitHub.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.512924,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> with Ansible",
        "sections": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> with Ansible",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": "APM for <em>Java</em> allows you to use an Ansible role for <em>installation</em> and configuration. Compatibility and requirements New Relic&#x27;s Ansible role for the <em>Java</em> <em>agent</em> is open source and community-supported. It supports setting up our <em>Java</em> <em>agent</em> to instrument applications running under Tomcat, Jetty"
      },
      "id": "603e92dce7b9d2a5d32a080c"
    },
    {
      "sections": [
        "Install Java agent using Gradle",
        "Install agent package using Gradle",
        "Install complete agent package",
        "Here is an example build.gradle file for working with the zip file:",
        "Install individual components",
        "Here is an example build.gradle for working with the individual components (Java agent and API jars)."
      ],
      "title": "Install Java agent using Gradle",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "a9a3c2bee77544d95482e06548e6da73a8ddb713",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/install-java-agent-using-gradle/",
      "published_at": "2021-05-05T06:59:43Z",
      "updated_at": "2021-03-16T14:17:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install the Java agent using Gradle. For information on manually installing the Java agent, see Install the Java agent and Java agent configuration: Config file. Install agent package using Gradle Install the New Relic Java agent, using either of these options: Install complete agent package This section explains how to configure Gradle to download and unzip the newrelic-java.zip file, which contains all New Relic Java agent components: newrelic.yml (agent configuration file) newrelic.jar (Java agent jar) newrelic-api.jar (Java agent API jar) README To do this: Configure your build.gradle file with the plugin you will use to download the agent. For example: plugins { id \"de.undercouch.download\" version \"3.4.3\" } Copy Add tasks to download and unzip the agent. For example: task downloadNewrelic(type: Download) { mkdir 'newrelic' src 'https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip' dest file('newrelic') } task unzipNewrelic(type: Copy) { from zipTree(file('newrelic/newrelic-java.zip')) into rootDir } Copy Run the tasks to download and unzip the agent. For example: ./gradlew downloadNewrelic ./gradlew unzipNewrelic Copy This will download the newrelic-java.zip file into a newrelic/ directory and then unzip it in the same directory. Here is an example build.gradle file for working with the zip file: plugins { id 'java' id \"de.undercouch.download\" version \"3.4.3\" } group 'example_group' version '1.0-SNAPSHOT' sourceCompatibility = 1.8 repositories { mavenCentral() } task downloadNewrelic(type: Download) { mkdir 'newrelic' src 'https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip' dest file('newrelic') } task unzipNewrelic(type: Copy) { from zipTree(file('newrelic/newrelic-java.zip')) into rootDir } Copy Install individual components This section explains how to configure Gradle to download individual components of the Java agent, specifically the newrelic.jar and the newrelic-api.jar. Configure your build.gradle file to download either newrelic.jar or newrelic-api.jar. Here's an example for downloading newrelic.jar: dependencies { compile group: 'com.newrelic.agent.java', name: 'newrelic-agent', version: 'JAVA_AGENT_VERSION' } Copy Here's an example for downloading newrelic-api.jar: dependencies { compile group: 'com.newrelic.agent.java', name: 'newrelic-api', version: 'JAVA_AGENT_VERSION' } Copy Replace JAVA_AGENT_VERSION with the latest Java agent version. Locate the newrelic.yml file you received when creating your New Relic account or download one for the version of the agent that you are using. Here is an example build.gradle for working with the individual components (Java agent and API jars). plugins { id 'java' } group 'example_group' version '1.0-SNAPSHOT' sourceCompatibility = 1.8 repositories { mavenCentral() } dependencies { compile group: 'com.newrelic.agent.java', name: 'newrelic-agent', version: '4.11.0' compile group: 'com.newrelic.agent.java', name: 'newrelic-api', version: '4.11.0' } Copy Place newrelic.yml in the same folder as newrelic.jar, unless you specify otherwise in the JVM arg Dnewrelic.config.file. Configure the newrelic.yml file (or JVM system properties) with your license_key and app_name. Pass -javaagent:/path/to/newrelic.jar to the JVM running your application server. Optional: If using the New Relic Java agent API, make the API jar available at compile time by adding it to your application class path. Generate some traffic for your app, then wait a few minutes for data to appear in the APM Summary page. If nothing appears, follow the troubleshooting procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.510414,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> <em>Java</em> <em>agent</em> using Gradle",
        "sections": "<em>Install</em> <em>Java</em> <em>agent</em> using Gradle",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": "This document explains how to install the <em>Java</em> <em>agent</em> using Gradle. For information on manually installing the <em>Java</em> <em>agent</em>, see Install the <em>Java</em> <em>agent</em> and <em>Java</em> <em>agent</em> configuration: Config file. Install <em>agent</em> package using Gradle Install the New Relic <em>Java</em> <em>agent</em>, using either of these options: Install"
      },
      "id": "603eb0c964441f5b964e8839"
    }
  ],
  "/docs/agents/java-agent/additional-installation/install-new-relic-java-agent-gae-flexible-environment": [
    {
      "sections": [
        "Install New Relic Java agent for Docker",
        "Tip",
        "Get the Java agent",
        "Download using curl",
        "Download using Invoke-WebRequest (PowerShell)",
        "Download from the New Relic UI",
        "Set up the installation directory",
        "Modify startup scripts",
        "Set agent configurations",
        "Application name",
        "License key",
        "Logs",
        "Environment (optional)",
        "Important",
        "Enabled (optional)",
        "Additional Tomcat Dockerfile examples",
        "Tomcat with environment and Java system properties",
        "How to start an application with the Java agent",
        "Next steps"
      ],
      "title": "Install New Relic Java agent for Docker",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "4de0ccd173c9851b045cfa036089e2f703b4a0f7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/install-new-relic-java-agent-docker/",
      "published_at": "2021-05-04T17:59:15Z",
      "updated_at": "2021-03-16T14:29:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains a basic installation of the APM agent for Java applications in a Docker container. We discuss required configurations and also explore some optional configurations, including: How to use identical New Relic configuration files for each container, regardless of the environment where the containers are used How to use the Docker layer when every agent in every environment needs slightly different configuration data How to disable the New Relic agent in some environments and enable it in others Although we don't discuss advanced options here, you can install the Java agent in Docker volumes and use your Docker container image in other software such as Swarm, ECS, AKS, EKS, OpenShift, and Kubernetes. Our Docker examples refer to Tomcat, so if you are using another application server, refer to your vendor’s documentation. Tip To use Java or any other agent, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Get the Java agent Download newrelic-java.zip using curl, Invoke-WebRequest (PowerShell), or the New Relic UI: Download using curl Complete the following: Start a command-line session. Change to a temporary directory where you can download the zip file. Execute this curl command: curl -O https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip Copy Unzip newrelic-java.zip Download using Invoke-WebRequest (PowerShell) Complete the following: Start a PowerShell session. Change to a temporary directory where you can download the zip file. Execute this PowerShell command: Invoke-WebRequest -Uri https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip -OutFile newrelic-java.zip Copy Unzip newrelic-java.zip: Expand-Archive -Path newrelic-java.zip -DestinationPath DESTINATION_PATH Copy Download from the New Relic UI Complete the following: Log in to New Relic. From the account dropdown in the New Relic UI, select Account settings. In the right sidebar under Most recent, select the Java agent, and save the newrelic-java.zip to a temporary directory. Unzip newrelic-java.zip. Set up the installation directory You can unzip the newrelic-java.zip file wherever it is convenient for you. In the subsequent sections we assume you extracted it in the current working directory, which puts the files we need in ./newrelic. Modify startup scripts The startup script that contains the command to start your application server must include Java’s built-in argument -javaagent. We recommend that you set this argument with the JAVA_OPTS environment variable. The value of that argument must contain the location where you ADD the Java APM agent’s jar file to the image. For example, with Tomcat, use commands like these in the Dockerfile: RUN mkdir -p /usr/local/tomcat/newrelic ADD ./newrelic/newrelic.jar /usr/local/tomcat/newrelic/newrelic.jar ENV JAVA_OPTS=\"$JAVA_OPTS -javaagent:/usr/local/tomcat/newrelic/newrelic.jar\" Copy Set agent configurations By default, agent behavior is controlled by configuration entries in newrelic.yml, which is typically located in the same directory as the agent. This section explains how to override these newrelic.yml configurations by using environment variables or Java system properties in the Dockerfile. Before we look at some specific configurations, here’s how to load newrelic.yml using the Dockerfile: ADD ./newrelic/newrelic.yml /usr/local/tomcat/newrelic/newrelic.yml Copy For a basic Docker installation, complete these configurations: Application name License key Logs Environment (optional) Enabled (optional) Application name The application name is a configuration you set to identify your application in New Relic. Tip You can reuse an application name for multiple apps serving the same role so that all the data from those apps rolls up into the same logical application in New Relic. For more detail about additional grouping options, see Use multiple names for an app. Replace MY_APP_NAME with your application name in one of these Dockerfile commands: Option Command Environment variable ENV NEW_RELIC_APP_NAME=\"MY_APP_NAME\" Copy Java system property ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.app_name='MY_APP_NAME'\" Copy After you boot the container, your application name appears in New Relic. License key This configuration is required for you to report on any data in your New Relic Account. To copy your license key: Go to one.newrelic.com > (account dropdown) > Account settings. Under Account information, copy the license key. In one of these Dockerfile commands, replace MY_LICENSE_KEY with your license key: Option Command Environment variable ENV NEW_RELIC_LICENSE_KEY=\"MY_LICENSE_KEY\" Copy Java system property ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.license_key='MY_LICENSE_KEY'\" Copy Logs By default, logs are written into the logs directory relative to the location of newrelic.jar. Make sure that the user account that starts your application server also has the right to perform tasks such as: Creating the logs directory. Creating and appending to the log files in that directory. Here’s a Dockerfile example where tomcat is the user who starts Tomcat: RUN mkdir -p /usr/local/tomcat/newrelic/logs RUN chown -R tomcat:tomcat /usr/local/tomcat/newrelic/logs Copy You can also send the logs to STDOUT by adding one of the following to the Dockerfile: Option Command Environment Variable ENV NEW_RELIC_LOG_FILE_NAME=STDOUT Copy Java system property ENV JAVA_OPTS=-Dnewrelic.config.log_file_name=STDOUT Copy Environment (optional) You can pass either a Java property or an environment variable to determine which of the environment-specific stanzas the agent uses in newrelic.yml. Use this approach if you prefer to have the newrelic.yml file control environment-specific configurations instead of passing all the configurations via Docker. Here’s a Dockerfile example of passing the newrelic.environment Java system property via Docker to use the custom value dev in the environment stanza of newrelic.yml: Using the shell form of the CMD instruction, include a reference to a new environment variable you choose (for example, ENV): CMD java -Dnewrelic.environment=$ENV -jar myjar.jar Copy In your docker run command line, include an argument to set the environment variable in the container: docker run -it -e \"ENV=dev\" myDockerImage Copy Important If you don’t specify a value for newrelic.environment, the agent assumes it is running in your production environment and uses the values from the main body of the configuration file. Enabled (optional) This configuration controls whether the agent is enabled. Let’s say you want the same Docker image for every installation. However, you don’t want to run the New Relic agent every time an engineer spins up a test app because you don’t want to run up your instance count. This problem can be solved using the newrelic.environment Java system property. In the main body of newrelic.yml, disable the Java agent by setting enabled: false. In specific environment stanzas of newrelic.yml, set enabled: true. Then, you can run specific agents by specifying the environment at runtime. Additional Tomcat Dockerfile examples Tomcat with environment and Java system properties FROM tomcat:9 # Add the newrelic.jar and -javaagent parameters RUN mkdir -p /usr/local/tomcat/newrelic ADD ./newrelic/newrelic.jar /usr/local/tomcat/newrelic/ ENV JAVA_OPTS=\"$JAVA_OPTS -javaagent:/usr/local/tomcat/newrelic/newrelic.jar\" # Add the configuration file ADD ./newrelic/newrelic.yml /usr/local/tomcat/newrelic/ # An example of setting a system property config ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.app_name='My Application'\" # An example of setting an Environment variable config ENV NEW_RELIC_LICENSE_KEY=\"license_key\" # Config to include the agent logs in Docker's stdout logging ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.log_file_name=STDOUT\" EXPOSE 8080 CMD [\"catalina.sh\", \"run\"] Copy How to start an application with the Java agent FROM openjdk:8 ADD my-application.jar /app ADD newrelic.jar /app ADD newrelic.yml /app ENV NEW_RELIC_APP_NAME=\"My Application\" ENV NEW_RELIC_LICENSE_KEY=\"license_key\" ENV NEW_RELIC_LOG_FILE_NAME=\"STDOUT\" ENTRYPOINT [\"java\",\"-javaagent:/app/newrelic.jar\",\"-jar\",\"/app/my-application.jar\"] Copy Next steps Now that you have a basic agent installation in Docker, here are some additional steps to consider: Review other configurations for the agent. Read a detailed Explorers Hub post about Docker and New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.51317,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> for Docker",
        "sections": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> for Docker",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": "This document explains a basic <em>installation</em> of the APM <em>agent</em> for <em>Java</em> applications in a Docker container. We discuss required configurations and also explore some optional configurations, including: How to use identical New Relic configuration files for each container, regardless of the environment"
      },
      "id": "603ea3dc28ccbc8889eba765"
    },
    {
      "sections": [
        "WildFly installation for Java",
        "Install WildFly versions earlier than 11",
        "Install WildFly version 11 or higher"
      ],
      "title": "WildFly installation for Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "7f9259f3b77efb78cd4861a9d7b519fe44191e3c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/wildfly-installation-java/",
      "published_at": "2021-05-05T00:37:37Z",
      "updated_at": "2021-03-16T14:29:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Before you install New Relic's Java agent, make sure your WildFly version is supported. Depending on which WildFly version your application uses, additional configuration steps may be required. Install WildFly versions earlier than 11 If your supported WildFly version is earlier than v11, follow standard Java installation procedures. You do not need to do any additional configuration. Install WildFly version 11 or higher If you use WildFly version 11 or higher, New Relic's Java agent requires additional configuration after you install it. Install the Java agent. If you already have it installed, update to the latest Java agent version. Versions 5.0.0 and higher include fixes for later WildFly versions 11 and higher. Open the standalone configuration file appropriate for your operating system and add the -javaagent property to JAVA_OPTS. For example, if you use Linux, edit the /bin/standalone.conf file or /bin/standalone.conf.bat for Windows. Make sure the agent jar is visible to all JBoss modules by adding com.newrelic to the JBoss modules system packages using either of these options in the standalone script: Recommended: Option 1 (same as adding -javaagent property): JAVA_OPTS=\"$JAVA_OPTS -Djboss.modules.system.pkgs=$JBOSS_MODULES_SYSTEM_PKGS,com.newrelic Copy Option 2: if [ \"x$JBOSS_MODULES_SYSTEM_PKGS\" = \"x\" ]; then JBOSS_MODULES_SYSTEM_PKGS=\"org.jboss.byteman,com.newrelic\" fi Copy Restart your application server.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.51317,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "WildFly <em>installation</em> for <em>Java</em>",
        "sections": "WildFly <em>installation</em> for <em>Java</em>",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": " standard <em>Java</em> <em>installation</em> procedures. You do not need to do any <em>additional</em> configuration. Install WildFly version 11 or higher If you use WildFly version 11 or higher, New Relic&#x27;s <em>Java</em> <em>agent</em> requires <em>additional</em> configuration after you install it. Install the <em>Java</em> <em>agent</em>. If you already have"
      },
      "id": "603e791764441f18724e88ab"
    },
    {
      "sections": [
        "Install New Relic Java agent with Ansible",
        "Compatibility and requirements",
        "Overview of process",
        "Step 1. Install the role",
        "Step 2. Incorporate the role into playbook",
        "Step 3. Configure the role",
        "Step 4. Configure the agent",
        "Step 5. Enable custom instrumentation (optional)",
        "For more help"
      ],
      "title": "Install New Relic Java agent with Ansible",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "328592f6b75e0eb638a0916082e034bb9782cad7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/install-new-relic-java-agent-ansible/",
      "published_at": "2021-05-05T06:55:40Z",
      "updated_at": "2021-03-16T14:28:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM for Java allows you to use an Ansible role for installation and configuration. Compatibility and requirements New Relic's Ansible role for the Java agent is open source and community-supported. It supports setting up our Java agent to instrument applications running under Tomcat, Jetty, and Wildfly (formerly JBoss) on Linux servers. The most common agent parameters can be configured through Ansible variables. You'll need to install Ansible to run this role. Ansible is run from a central server to configure target hosts; these hosts must be running Linux and have unzip installed. The role should be compatible with most popular Linux distributions. Overview of process There are several steps that may be involved for installation and configuration: Install the role Incorporate role in your playbook Configure the role Configure the agent Enable custom instrumentation (optional) Step 1. Install the role To install this role, use the ansible-galaxy command on the system where you run Ansible: $ ansible-galaxy install newrelic.newrelic_java_agent Copy This will download the role from Ansible Galaxy and make it available for use in Ansible playbooks. Step 2. Incorporate the role into playbook You'll need to call the role from your playbook using the include_role module. The role's GitHub repository contains an example playbook for you to start from, which looks like this: - hosts: YOUR_HOST_GROUP vars: nr_java_agent_config: license_key: YOUR_LICENSE_KEY app_name: YOUR_APP_NAME log_file_path: /tmp/newrelic server_type: tomcat server_root: /var/lib/tomcat8 jvm_conf_file: /usr/share/tomcat8/bin/setenv.sh server_user: tomcat8 server_group: tomcat8 service_name: tomcat8 restart_web_server: true tasks: - include_role: name: newrelic.newrelic_java_agent Copy The vars section contains a dictionary called nr_java_agent_config, which holds settings for the agent itself, and a number of variables for configuring the role's installation process. See the sections on agent configuration and role configuration for details. Step 3. Configure the role These variables are used to configure the install process. Most are required. For more information, see the examples on GitHub. Variable Description server_type Required. Web server used by your application. Possible values are: tomcat, jetty, and wildfly (standalone mode only). server_root Required. Location of the web server on the host. The agent's JAR, configuration, and (by default) log files will live in a subdirectory of this directory. jvm_conf_file Required. Path to the web server configuration file to reference the New Relic Java agent. For Tomcat, for instance, it's typically the setenv.sh file. If the file doesn't exist, it may be created, depending on the server_type. server_user server_group Required. User and group under which the web server runs. Used to set the ownership of the newrelic.jar and newrelic.yml files. restart_web_server Optional. Default: true. If set to false, the role does not restart the web server after installing the agent. Note that the agent is not activated until the web server is restarted. service_name Required (unless restart_web_server is set to false). Service name under which the web server runs. Used by Ansible to restart the web server after the agent is installed. nr_java_agent_version Optional; default: currentSpecifies the version of the Java agent to install. current will install the latest version. You can also install a specific version, like 5.9.0. For available versions, see Java agent downloads directory. Step 4. Configure the agent The following variables are used to configure the Java agent itself. These are just a few of the available options. For a full list of supported variables, see the README file on GitHub. For more about how to configure the agent, see Java agent configuration. Variable Description license_key Required. Your New Relic license key. app_name Required. Name of the application being instrumented. For more details, see App naming. proxy_host proxy_port proxy_user proxy_password proxy_scheme Optional. If you connect to the New Relic collector via a proxy, you can configure your proxy settings with these values. labels Optional. User-configurable custom labels for the agent. Labels are name-value pairs. Names and values are limited to 255 characters and cannot contain colons (:) nor semicolons (;). Value should be a semicolon-separated list of key-value pairs, for example Server:One;Data Center:Primary. Step 5. Enable custom instrumentation (optional) If you want to enable custom instrumentation, you can provide a list of XML files using the custom_instrumentation_files variable. For instance, you can specify that all Java agents being installed should use a file called my_instrumentation.xml by adding something like the following to your playbook: vars: custom_instrumentation_files: - /path/to/my_instrumentation.xml Copy See the README and examples on GitHub for more information. For more help If you need additional help, file an issue at newrelic/newrelic-java-agent-ansible-role on GitHub.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.512924,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> with Ansible",
        "sections": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> with Ansible",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": "APM for <em>Java</em> allows you to use an Ansible role for <em>installation</em> and configuration. Compatibility and requirements New Relic&#x27;s Ansible role for the <em>Java</em> <em>agent</em> is open source and community-supported. It supports setting up our <em>Java</em> <em>agent</em> to instrument applications running under Tomcat, Jetty"
      },
      "id": "603e92dce7b9d2a5d32a080c"
    }
  ],
  "/docs/agents/java-agent/additional-installation/wildfly-installation-java": [
    {
      "sections": [
        "Install New Relic Java agent for Docker",
        "Tip",
        "Get the Java agent",
        "Download using curl",
        "Download using Invoke-WebRequest (PowerShell)",
        "Download from the New Relic UI",
        "Set up the installation directory",
        "Modify startup scripts",
        "Set agent configurations",
        "Application name",
        "License key",
        "Logs",
        "Environment (optional)",
        "Important",
        "Enabled (optional)",
        "Additional Tomcat Dockerfile examples",
        "Tomcat with environment and Java system properties",
        "How to start an application with the Java agent",
        "Next steps"
      ],
      "title": "Install New Relic Java agent for Docker",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "4de0ccd173c9851b045cfa036089e2f703b4a0f7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/install-new-relic-java-agent-docker/",
      "published_at": "2021-05-04T17:59:15Z",
      "updated_at": "2021-03-16T14:29:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains a basic installation of the APM agent for Java applications in a Docker container. We discuss required configurations and also explore some optional configurations, including: How to use identical New Relic configuration files for each container, regardless of the environment where the containers are used How to use the Docker layer when every agent in every environment needs slightly different configuration data How to disable the New Relic agent in some environments and enable it in others Although we don't discuss advanced options here, you can install the Java agent in Docker volumes and use your Docker container image in other software such as Swarm, ECS, AKS, EKS, OpenShift, and Kubernetes. Our Docker examples refer to Tomcat, so if you are using another application server, refer to your vendor’s documentation. Tip To use Java or any other agent, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Get the Java agent Download newrelic-java.zip using curl, Invoke-WebRequest (PowerShell), or the New Relic UI: Download using curl Complete the following: Start a command-line session. Change to a temporary directory where you can download the zip file. Execute this curl command: curl -O https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip Copy Unzip newrelic-java.zip Download using Invoke-WebRequest (PowerShell) Complete the following: Start a PowerShell session. Change to a temporary directory where you can download the zip file. Execute this PowerShell command: Invoke-WebRequest -Uri https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip -OutFile newrelic-java.zip Copy Unzip newrelic-java.zip: Expand-Archive -Path newrelic-java.zip -DestinationPath DESTINATION_PATH Copy Download from the New Relic UI Complete the following: Log in to New Relic. From the account dropdown in the New Relic UI, select Account settings. In the right sidebar under Most recent, select the Java agent, and save the newrelic-java.zip to a temporary directory. Unzip newrelic-java.zip. Set up the installation directory You can unzip the newrelic-java.zip file wherever it is convenient for you. In the subsequent sections we assume you extracted it in the current working directory, which puts the files we need in ./newrelic. Modify startup scripts The startup script that contains the command to start your application server must include Java’s built-in argument -javaagent. We recommend that you set this argument with the JAVA_OPTS environment variable. The value of that argument must contain the location where you ADD the Java APM agent’s jar file to the image. For example, with Tomcat, use commands like these in the Dockerfile: RUN mkdir -p /usr/local/tomcat/newrelic ADD ./newrelic/newrelic.jar /usr/local/tomcat/newrelic/newrelic.jar ENV JAVA_OPTS=\"$JAVA_OPTS -javaagent:/usr/local/tomcat/newrelic/newrelic.jar\" Copy Set agent configurations By default, agent behavior is controlled by configuration entries in newrelic.yml, which is typically located in the same directory as the agent. This section explains how to override these newrelic.yml configurations by using environment variables or Java system properties in the Dockerfile. Before we look at some specific configurations, here’s how to load newrelic.yml using the Dockerfile: ADD ./newrelic/newrelic.yml /usr/local/tomcat/newrelic/newrelic.yml Copy For a basic Docker installation, complete these configurations: Application name License key Logs Environment (optional) Enabled (optional) Application name The application name is a configuration you set to identify your application in New Relic. Tip You can reuse an application name for multiple apps serving the same role so that all the data from those apps rolls up into the same logical application in New Relic. For more detail about additional grouping options, see Use multiple names for an app. Replace MY_APP_NAME with your application name in one of these Dockerfile commands: Option Command Environment variable ENV NEW_RELIC_APP_NAME=\"MY_APP_NAME\" Copy Java system property ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.app_name='MY_APP_NAME'\" Copy After you boot the container, your application name appears in New Relic. License key This configuration is required for you to report on any data in your New Relic Account. To copy your license key: Go to one.newrelic.com > (account dropdown) > Account settings. Under Account information, copy the license key. In one of these Dockerfile commands, replace MY_LICENSE_KEY with your license key: Option Command Environment variable ENV NEW_RELIC_LICENSE_KEY=\"MY_LICENSE_KEY\" Copy Java system property ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.license_key='MY_LICENSE_KEY'\" Copy Logs By default, logs are written into the logs directory relative to the location of newrelic.jar. Make sure that the user account that starts your application server also has the right to perform tasks such as: Creating the logs directory. Creating and appending to the log files in that directory. Here’s a Dockerfile example where tomcat is the user who starts Tomcat: RUN mkdir -p /usr/local/tomcat/newrelic/logs RUN chown -R tomcat:tomcat /usr/local/tomcat/newrelic/logs Copy You can also send the logs to STDOUT by adding one of the following to the Dockerfile: Option Command Environment Variable ENV NEW_RELIC_LOG_FILE_NAME=STDOUT Copy Java system property ENV JAVA_OPTS=-Dnewrelic.config.log_file_name=STDOUT Copy Environment (optional) You can pass either a Java property or an environment variable to determine which of the environment-specific stanzas the agent uses in newrelic.yml. Use this approach if you prefer to have the newrelic.yml file control environment-specific configurations instead of passing all the configurations via Docker. Here’s a Dockerfile example of passing the newrelic.environment Java system property via Docker to use the custom value dev in the environment stanza of newrelic.yml: Using the shell form of the CMD instruction, include a reference to a new environment variable you choose (for example, ENV): CMD java -Dnewrelic.environment=$ENV -jar myjar.jar Copy In your docker run command line, include an argument to set the environment variable in the container: docker run -it -e \"ENV=dev\" myDockerImage Copy Important If you don’t specify a value for newrelic.environment, the agent assumes it is running in your production environment and uses the values from the main body of the configuration file. Enabled (optional) This configuration controls whether the agent is enabled. Let’s say you want the same Docker image for every installation. However, you don’t want to run the New Relic agent every time an engineer spins up a test app because you don’t want to run up your instance count. This problem can be solved using the newrelic.environment Java system property. In the main body of newrelic.yml, disable the Java agent by setting enabled: false. In specific environment stanzas of newrelic.yml, set enabled: true. Then, you can run specific agents by specifying the environment at runtime. Additional Tomcat Dockerfile examples Tomcat with environment and Java system properties FROM tomcat:9 # Add the newrelic.jar and -javaagent parameters RUN mkdir -p /usr/local/tomcat/newrelic ADD ./newrelic/newrelic.jar /usr/local/tomcat/newrelic/ ENV JAVA_OPTS=\"$JAVA_OPTS -javaagent:/usr/local/tomcat/newrelic/newrelic.jar\" # Add the configuration file ADD ./newrelic/newrelic.yml /usr/local/tomcat/newrelic/ # An example of setting a system property config ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.app_name='My Application'\" # An example of setting an Environment variable config ENV NEW_RELIC_LICENSE_KEY=\"license_key\" # Config to include the agent logs in Docker's stdout logging ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.log_file_name=STDOUT\" EXPOSE 8080 CMD [\"catalina.sh\", \"run\"] Copy How to start an application with the Java agent FROM openjdk:8 ADD my-application.jar /app ADD newrelic.jar /app ADD newrelic.yml /app ENV NEW_RELIC_APP_NAME=\"My Application\" ENV NEW_RELIC_LICENSE_KEY=\"license_key\" ENV NEW_RELIC_LOG_FILE_NAME=\"STDOUT\" ENTRYPOINT [\"java\",\"-javaagent:/app/newrelic.jar\",\"-jar\",\"/app/my-application.jar\"] Copy Next steps Now that you have a basic agent installation in Docker, here are some additional steps to consider: Review other configurations for the agent. Read a detailed Explorers Hub post about Docker and New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.51317,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> for Docker",
        "sections": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> for Docker",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": "This document explains a basic <em>installation</em> of the APM <em>agent</em> for <em>Java</em> applications in a Docker container. We discuss required configurations and also explore some optional configurations, including: How to use identical New Relic configuration files for each container, regardless of the environment"
      },
      "id": "603ea3dc28ccbc8889eba765"
    },
    {
      "sections": [
        "Install New Relic Java agent with Ansible",
        "Compatibility and requirements",
        "Overview of process",
        "Step 1. Install the role",
        "Step 2. Incorporate the role into playbook",
        "Step 3. Configure the role",
        "Step 4. Configure the agent",
        "Step 5. Enable custom instrumentation (optional)",
        "For more help"
      ],
      "title": "Install New Relic Java agent with Ansible",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "328592f6b75e0eb638a0916082e034bb9782cad7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/install-new-relic-java-agent-ansible/",
      "published_at": "2021-05-05T06:55:40Z",
      "updated_at": "2021-03-16T14:28:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM for Java allows you to use an Ansible role for installation and configuration. Compatibility and requirements New Relic's Ansible role for the Java agent is open source and community-supported. It supports setting up our Java agent to instrument applications running under Tomcat, Jetty, and Wildfly (formerly JBoss) on Linux servers. The most common agent parameters can be configured through Ansible variables. You'll need to install Ansible to run this role. Ansible is run from a central server to configure target hosts; these hosts must be running Linux and have unzip installed. The role should be compatible with most popular Linux distributions. Overview of process There are several steps that may be involved for installation and configuration: Install the role Incorporate role in your playbook Configure the role Configure the agent Enable custom instrumentation (optional) Step 1. Install the role To install this role, use the ansible-galaxy command on the system where you run Ansible: $ ansible-galaxy install newrelic.newrelic_java_agent Copy This will download the role from Ansible Galaxy and make it available for use in Ansible playbooks. Step 2. Incorporate the role into playbook You'll need to call the role from your playbook using the include_role module. The role's GitHub repository contains an example playbook for you to start from, which looks like this: - hosts: YOUR_HOST_GROUP vars: nr_java_agent_config: license_key: YOUR_LICENSE_KEY app_name: YOUR_APP_NAME log_file_path: /tmp/newrelic server_type: tomcat server_root: /var/lib/tomcat8 jvm_conf_file: /usr/share/tomcat8/bin/setenv.sh server_user: tomcat8 server_group: tomcat8 service_name: tomcat8 restart_web_server: true tasks: - include_role: name: newrelic.newrelic_java_agent Copy The vars section contains a dictionary called nr_java_agent_config, which holds settings for the agent itself, and a number of variables for configuring the role's installation process. See the sections on agent configuration and role configuration for details. Step 3. Configure the role These variables are used to configure the install process. Most are required. For more information, see the examples on GitHub. Variable Description server_type Required. Web server used by your application. Possible values are: tomcat, jetty, and wildfly (standalone mode only). server_root Required. Location of the web server on the host. The agent's JAR, configuration, and (by default) log files will live in a subdirectory of this directory. jvm_conf_file Required. Path to the web server configuration file to reference the New Relic Java agent. For Tomcat, for instance, it's typically the setenv.sh file. If the file doesn't exist, it may be created, depending on the server_type. server_user server_group Required. User and group under which the web server runs. Used to set the ownership of the newrelic.jar and newrelic.yml files. restart_web_server Optional. Default: true. If set to false, the role does not restart the web server after installing the agent. Note that the agent is not activated until the web server is restarted. service_name Required (unless restart_web_server is set to false). Service name under which the web server runs. Used by Ansible to restart the web server after the agent is installed. nr_java_agent_version Optional; default: currentSpecifies the version of the Java agent to install. current will install the latest version. You can also install a specific version, like 5.9.0. For available versions, see Java agent downloads directory. Step 4. Configure the agent The following variables are used to configure the Java agent itself. These are just a few of the available options. For a full list of supported variables, see the README file on GitHub. For more about how to configure the agent, see Java agent configuration. Variable Description license_key Required. Your New Relic license key. app_name Required. Name of the application being instrumented. For more details, see App naming. proxy_host proxy_port proxy_user proxy_password proxy_scheme Optional. If you connect to the New Relic collector via a proxy, you can configure your proxy settings with these values. labels Optional. User-configurable custom labels for the agent. Labels are name-value pairs. Names and values are limited to 255 characters and cannot contain colons (:) nor semicolons (;). Value should be a semicolon-separated list of key-value pairs, for example Server:One;Data Center:Primary. Step 5. Enable custom instrumentation (optional) If you want to enable custom instrumentation, you can provide a list of XML files using the custom_instrumentation_files variable. For instance, you can specify that all Java agents being installed should use a file called my_instrumentation.xml by adding something like the following to your playbook: vars: custom_instrumentation_files: - /path/to/my_instrumentation.xml Copy See the README and examples on GitHub for more information. For more help If you need additional help, file an issue at newrelic/newrelic-java-agent-ansible-role on GitHub.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.512924,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> with Ansible",
        "sections": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> with Ansible",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": "APM for <em>Java</em> allows you to use an Ansible role for <em>installation</em> and configuration. Compatibility and requirements New Relic&#x27;s Ansible role for the <em>Java</em> <em>agent</em> is open source and community-supported. It supports setting up our <em>Java</em> <em>agent</em> to instrument applications running under Tomcat, Jetty"
      },
      "id": "603e92dce7b9d2a5d32a080c"
    },
    {
      "sections": [
        "Install Java agent using Gradle",
        "Install agent package using Gradle",
        "Install complete agent package",
        "Here is an example build.gradle file for working with the zip file:",
        "Install individual components",
        "Here is an example build.gradle for working with the individual components (Java agent and API jars)."
      ],
      "title": "Install Java agent using Gradle",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "a9a3c2bee77544d95482e06548e6da73a8ddb713",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/install-java-agent-using-gradle/",
      "published_at": "2021-05-05T06:59:43Z",
      "updated_at": "2021-03-16T14:17:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install the Java agent using Gradle. For information on manually installing the Java agent, see Install the Java agent and Java agent configuration: Config file. Install agent package using Gradle Install the New Relic Java agent, using either of these options: Install complete agent package This section explains how to configure Gradle to download and unzip the newrelic-java.zip file, which contains all New Relic Java agent components: newrelic.yml (agent configuration file) newrelic.jar (Java agent jar) newrelic-api.jar (Java agent API jar) README To do this: Configure your build.gradle file with the plugin you will use to download the agent. For example: plugins { id \"de.undercouch.download\" version \"3.4.3\" } Copy Add tasks to download and unzip the agent. For example: task downloadNewrelic(type: Download) { mkdir 'newrelic' src 'https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip' dest file('newrelic') } task unzipNewrelic(type: Copy) { from zipTree(file('newrelic/newrelic-java.zip')) into rootDir } Copy Run the tasks to download and unzip the agent. For example: ./gradlew downloadNewrelic ./gradlew unzipNewrelic Copy This will download the newrelic-java.zip file into a newrelic/ directory and then unzip it in the same directory. Here is an example build.gradle file for working with the zip file: plugins { id 'java' id \"de.undercouch.download\" version \"3.4.3\" } group 'example_group' version '1.0-SNAPSHOT' sourceCompatibility = 1.8 repositories { mavenCentral() } task downloadNewrelic(type: Download) { mkdir 'newrelic' src 'https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip' dest file('newrelic') } task unzipNewrelic(type: Copy) { from zipTree(file('newrelic/newrelic-java.zip')) into rootDir } Copy Install individual components This section explains how to configure Gradle to download individual components of the Java agent, specifically the newrelic.jar and the newrelic-api.jar. Configure your build.gradle file to download either newrelic.jar or newrelic-api.jar. Here's an example for downloading newrelic.jar: dependencies { compile group: 'com.newrelic.agent.java', name: 'newrelic-agent', version: 'JAVA_AGENT_VERSION' } Copy Here's an example for downloading newrelic-api.jar: dependencies { compile group: 'com.newrelic.agent.java', name: 'newrelic-api', version: 'JAVA_AGENT_VERSION' } Copy Replace JAVA_AGENT_VERSION with the latest Java agent version. Locate the newrelic.yml file you received when creating your New Relic account or download one for the version of the agent that you are using. Here is an example build.gradle for working with the individual components (Java agent and API jars). plugins { id 'java' } group 'example_group' version '1.0-SNAPSHOT' sourceCompatibility = 1.8 repositories { mavenCentral() } dependencies { compile group: 'com.newrelic.agent.java', name: 'newrelic-agent', version: '4.11.0' compile group: 'com.newrelic.agent.java', name: 'newrelic-api', version: '4.11.0' } Copy Place newrelic.yml in the same folder as newrelic.jar, unless you specify otherwise in the JVM arg Dnewrelic.config.file. Configure the newrelic.yml file (or JVM system properties) with your license_key and app_name. Pass -javaagent:/path/to/newrelic.jar to the JVM running your application server. Optional: If using the New Relic Java agent API, make the API jar available at compile time by adding it to your application class path. Generate some traffic for your app, then wait a few minutes for data to appear in the APM Summary page. If nothing appears, follow the troubleshooting procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.510414,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> <em>Java</em> <em>agent</em> using Gradle",
        "sections": "<em>Install</em> <em>Java</em> <em>agent</em> using Gradle",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": "This document explains how to install the <em>Java</em> <em>agent</em> using Gradle. For information on manually installing the <em>Java</em> <em>agent</em>, see Install the <em>Java</em> <em>agent</em> and <em>Java</em> <em>agent</em> configuration: Config file. Install <em>agent</em> package using Gradle Install the New Relic <em>Java</em> <em>agent</em>, using either of these options: Install"
      },
      "id": "603eb0c964441f5b964e8839"
    }
  ],
  "/docs/agents/java-agent/api-guides/guide-using-java-agent-api": [
    {
      "sections": [
        "Java agent API: Custom instrumentation with annotation of an example app",
        "Important",
        "Complete example app using API",
        "Tip",
        "Complete API call example",
        "How the example uses the API",
        "Import the needed packages",
        "Set @Trace for transaction traces",
        "Create custom names for web transactions",
        "Bypass Apdex when collecting non-public data",
        "Record the user ID",
        "Collect promotion data",
        "Send instructions to the handler",
        "Include page load timing code in the HTTP response",
        "Complete the HTTP response"
      ],
      "title": "Java agent API: Custom instrumentation with annotation of an example app",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "a6a2aadf63f8282b7d599579f67010fbd600d183",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/java-agent-api-custom-instrumentation-annotation-example-app/",
      "published_at": "2021-05-05T07:03:35Z",
      "updated_at": "2021-03-16T14:30:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you set up custom instrumentation for your Java application. This document shows an example of using custom instrumentation with annotation in an imaginary application. Important For best results when using the API, ensure you have the latest Java agent release. Complete example app using API Below is an example of an imaginary store app's servlet using the Java agent API. Tip If you copy and paste example code, be sure to use appropriate spacing on your command lines. Complete API call example package test; import java.io.IOException; import java.io.PrintWriter; import java.util.Random; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; // Java agent API imports import com.newrelic.api.agent.NewRelic; import com.newrelic.api.agent.Trace; public class TestServlet extends HttpServlet { // instrumentation via annotation @Trace(dispatcher = true) protected void processRequest(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { saveNewRelicInfo(req); doRequestWork(req); writeResponse(resp); } private void saveNewRelicInfo(HttpServletRequest req) { String storeId = req.getParameter(\"storeId\"); if (storeId != null) { // set the name of the Transaction NewRelic.setTransactionName(null, \"/store\"); if (storeId.equals(\"betaStore\")) { // prevent the method from contributing to the Apdex score NewRelic.ignoreApdex(); } } String userId = req.getParameter(\"userId\"); if (userId != null) { // set the user name to associate with the RUM JavaScript footer // for the current web transaction NewRelic.setUserName(userId); // add a key/value pair to the current transaction NewRelic.addCustomParameter(\"userId\", userId); } String promotionId = req.getParameter(\"promotionId\"); if (promotionId != null) { // increment the metric counter for the given name NewRelic.incrementCounter(\"Custom/Promotion\"); } } protected void doRequestWork(HttpServletRequest req) { try { long millisToSleep = new Random().nextInt(5000); Thread.sleep(millisToSleep); // record a response time in milliseconds for the given metric name NewRelic.recordResponseTimeMetric(\"Custom/RandomSleep\", millisToSleep); } catch (InterruptedException e) { // report a handled exception NewRelic.noticeError(e, false); } } protected void writeResponse(HttpServletResponse resp) throws IOException { resp.setContentType(\"text/html;charset=UTF-8\"); PrintWriter out = resp.getWriter(); out.println(\"<html>\"); out.println(\"<head>\"); // get the RUM JavaScript header for the current web transaction out.println(NewRelic.getBrowserTimingHeader()); out.println(\"<title>NewRelic API example servlet</title>\"); out.println(\"</head>\"); out.println(\"<body>\"); out.println(\"<h1>API example</h1>\"); // get the RUM JavaScript footer for the current web transaction out.println(NewRelic.getBrowserTimingFooter()); out.println(\"</body>\"); out.println(\"</html>\"); out.close(); } protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { processRequest(req, resp); } protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { processRequest(req, resp); } } Copy How the example uses the API Here is the same example app divided into sections that describe how the API is used: Import the needed packages This part of the example shows the imports needed for the example application and Java agent API. package test; import java.io.IOException; import java.io.PrintWriter; import java.util.Random; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; // Java agent API imports import com.newrelic.api.agent.NewRelic; import com.newrelic.api.agent.Trace; Copy Set @Trace for transaction traces This part of the API call provides instructions to instrument this call using New Relic's trace annotation @Trace. Any requests that hit processRequest will now show a segment in APM's Transaction trace call chart. public class TestServlet extends HttpServlet { // instrumentation via annotation @Trace(dispatcher = true) protected void processRequest(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { saveNewRelicInfo(req); doRequestWork(req); writeResponse(resp); } Copy Create custom names for web transactions This part of the API call instructs web transactions containing a storeId value to appear in APM's Transactions page with the custom transaction name you set. A request to any one store will appear under the same, aggregate name. private void saveNewRelicInfo(HttpServletRequest req) { String storeId = req.getParameter(\"storeId\"); if (storeId != null) { // set the name of the Transaction NewRelic.setTransactionName(null, \"/store\"); } } Copy Bypass Apdex when collecting non-public data This part of the API call excludes the non-public beta storeID from affecting the Apdex score. if (storeId.equals(\"betaStore\")) { // prevent the method from contributing to the Apdex score NewRelic.ignoreApdex(); } Copy Record the user ID This part of the API call inserts additional metadata into the page load timing request so that browser traces can be tied with the userId. It also records the userId as a custom parameter on the transaction so that it appears in the parameter details of a transaction trace. (Page load timing sometimes is referred to as real user monitoring or RUM.) String userId = req.getParameter(\"userId\"); if (userId != null) { // set the user name to associate with the RUM JavaScript footer // for the current web transaction NewRelic.setUserName(userId); // add a key/value pair to the current transaction NewRelic.addCustomParameter(\"userId\", userId); } Copy Collect promotion data This part of the API call records the number of times a promotion was viewed so that the metrics can appear on a custom dashboard. Important For metrics you want to graph in custom dashboards, be sure to prepend Custom/ to the metric name; for example, Custom/Promotion. String promotionId = req.getParameter(\"promotionId\"); if (promotionId != null) { // increment the metric counter for the given name NewRelic.incrementCounter(\"Custom/Promotion\"); } Copy Send instructions to the handler This part of the API call sends a set of instructions to the handler for processing requests and handling exceptions. protected void doRequestWork(HttpServletRequest req) { try { long millisToSleep = new Random().nextInt(5000); Thread.sleep(millisToSleep); // record a response time in milliseconds for the given metric name NewRelic.recordResponseTimeMetric(\"Custom/RandomSleep\", millisToSleep); } catch (InterruptedException e) { // report a handled exception NewRelic.noticeError(e, false); } } protected void writeResponse(HttpServletResponse resp) throws IOException { Copy Include page load timing code in the HTTP response This part of the API call defines what to include in the HttpServletResponse. For manual instrumentation of Browser monitoring to monitor page load timing (sometimes referred to as real user monitoring or RUM): Set the header after the < head> tag. Set the footer at the end of < body> tag. resp.setContentType(\"text/html;charset=UTF-8\"); PrintWriter out = resp.getWriter(); out.println(\"<html>\"); out.println(\"<head>\"); // get the RUM JavaScript header for the current web transaction out.println(NewRelic.getBrowserTimingHeader()); out.println(\"<title>NewRelic API example servlet</title>\"); out.println(\"</head>\"); out.println(\"<body>\"); out.println(\"<h1>API example</h1>\"); // get the RUM JavaScript footer for the current web transaction out.println(NewRelic.getBrowserTimingFooter()); out.println(\"</body>\"); out.println(\"</html>\"); out.close(); } Copy Complete the HTTP response This part of the API call defines the remaining information to include in the HttpServletResponse response. protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { processRequest(req, resp); } protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { processRequest(req, resp); } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.81137,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> <em>API</em>: Custom instrumentation with annotation of an example app",
        "sections": "<em>Java</em> <em>agent</em> <em>API</em>: Custom instrumentation with annotation of an example app",
        "tags": "<em>API</em> <em>guides</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> <em>API</em> lets you set up custom instrumentation for your <em>Java</em> application. This document shows an example of using custom instrumentation with annotation in an imaginary application. Important For best results when using the <em>API</em>, ensure you have the latest <em>Java</em> <em>agent</em> release"
      },
      "id": "603eb76a64441f48424e886b"
    },
    {
      "sections": [
        "Java agent API: Instrument using annotation",
        "Important",
        "Configure your agent for annotations",
        "Tip",
        "Create a new transaction",
        "Add detail to your transactions",
        "Convert a transaction to a web request",
        "Define your own @Trace annotation class",
        "Properties for @Trace",
        "dispatcher",
        "async",
        "metricName",
        "excludeFromTransactionTrace",
        "leaf",
        "More API functions"
      ],
      "title": "Java agent API: Instrument using annotation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "4a373504c0682b36745d2283fdd902ead43510ec",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/java-agent-api-instrument-using-annotation/",
      "published_at": "2021-05-05T06:57:49Z",
      "updated_at": "2021-03-16T04:31:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent provides several options for custom instrumentation. One of those options is adding the Java agent API's @Trace annotations to your application code. This document describes how to use annotations. Important To use annotations, you must modify the source code. If you can't or don't want to modify your source code, see Custom instrumentation for other instrumentation options. Configure your agent for annotations By default, the configuration setting enable_custom_tracing is set to true in the Java agent, which is the setting required for @Trace annotations to function. This setting is not included in the newrelic.yml by default. The only time you need to incorporate this setting into your configuration file is if you want to disable @Trace annotations altogether. To do this, set enable_custom_tracing: false (prefaced with two spaces) in the common stanza of your newrelic.yml. To detect custom traces: Make sure that newrelic-api.jar appears in your classpath. Add @Trace annotations to your code. In each class containing a method you want to instrument, call: import com.newrelic.api.agent.Trace; Copy Place the @Trace annotation on each target method. Tip The annotation com.newrelic.api.agent.Trace is located in the newrelic-api.jar. Create a new transaction If transactions do not appear and you want to start a new transaction, include dispatcher=true with the @Trace annotation: @Trace (dispatcher=true) public void run() { // background task } Copy Add detail to your transactions If your transaction traces show large blocks of uninstrumented time and you want to include some more methods within the trace, you can use the @Trace annotation without parameters: @Trace protected void methodWithinTransaction() { // work } Copy Convert a transaction to a web request To make a background task report as a web browser transaction with a Java agent API call: In the method annotated with @Trace(dispatcher=true), call: NewRelic.setRequestAndResponse(Request request, Response response) Copy The arguments are implementations of the Request and Response interfaces in newrelic-api.jar. Important Even if your Request and Response objects already are present, you still need to add this API call. Define your own @Trace annotation class If you define your own @Trace annotation class, there is no dependency on the newrelic-api.jar. To define the class: package com.test; @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Trace { public static final String NULL = \"\"; String metricName() default NULL; boolean dispatcher() default false; String tracerFactoryName() default NULL; } Copy Then, configure the agent to use this annotation in the common section of the newrelic.yml: class_transformer: trace_annotation_class_name: com.test.Trace Copy Properties for @Trace The @Trace annotation supports the following properties. dispatcher Type: Boolean Default: false If true, the agent will start a transaction when it reaches a method with this @Trace annotation if a transaction is not already in progress. If a transaction is already in progress, the method with this annotation will be included in the ongoing transaction, rather than starting a new one. If false (default), no metrics will be recorded if the agent has not started a transaction before the @Trace annotation is reached. For example: @Trace(dispatcher=true) Copy async Type: Boolean Default: false If true, this method is marked as asynchronous and the agent will trace this method if it linked to an existing transaction. For example: @Trace(async=true) Copy If false (default), the method is not marked as asynchronous. If other @Trace annotations are present and the method is not executing asynchronously, it will still be traced. metricName Type: String Default: (none) This property affects transaction traces and error reporting. By default, the metric name will include the class name followed by the method name. If you do not want class followed by method, then you can use this property to change the metric name. If you set the metricName, as in @Trace(metricName=\"YourMessageHere\"), then the time spent in this method will appear as YourMessageHere in any transaction trace. If you set the metricName in addition to the dispatcher, as in @Trace(metricName=\"YourMessageHere\", dispatcher=true), then the transaction name will appear as YourMessageHere in the APM Transactions page but the time spent in this method will not appear as YourMessageHere in any transaction trace. Here is an example: @Trace(metricName=\"YourMetricName\") Copy Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. excludeFromTransactionTrace Type: Boolean Default: false If true, the method will be excluded from the transaction trace. The agent will still collect metrics for the method. Here is an example: @Trace(excludeFromTransactionTrace=true) Copy leaf Type: Boolean Default: false A leaf tracer has no child tracers. This is useful when you want all time attributed to the tracer, even if other trace points are encountered the tracer's execution. Database tracers often act as a leaf so that all time is attributed to database activity, even if instrumented external calls are made. Here is an example: @Trace(leaf=true) Copy If a leaf tracer does not participate in transaction traces, the agent can create a tracer with lower overhead. Here is an example: @Trace(excludeFromTransactionTrace=true, leaf=true) Copy More API functions For more about the Java agent API and its functionality, see the Java agent API introduction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.698456,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> <em>API</em>: Instrument using annotation",
        "sections": "<em>Java</em> <em>agent</em> <em>API</em>: Instrument using annotation",
        "tags": "<em>API</em> <em>guides</em>",
        "body": "New Relic&#x27;s <em>Java</em> <em>agent</em> provides several options for custom instrumentation. One of those options is adding the <em>Java</em> <em>agent</em> <em>API</em>&#x27;s @Trace annotations to your application code. This document describes how to use annotations. Important To use annotations, you must modify the source code. If you can&#x27;t"
      },
      "id": "603eb64a28ccbc9ca2eba79f"
    },
    {
      "sections": [
        "Java agent API: Instrument external calls, messaging, datastore, web frameworks",
        "External API",
        "External parameters builders",
        "Important",
        "Cross application tracing API",
        "Client wrappers",
        "OutbounderHeaders implementation",
        "InboundHeaders implementation",
        "Server wrappers",
        "Extend ExtendedRequest class",
        "Response interface implementation",
        "CAT implementation using wrappers",
        "Cross application tracing: Client-side",
        "Cross application tracing: Server-side",
        "Messaging API",
        "Messaging API implementation",
        "Message with CAT headers implementation",
        "Datastore API",
        "Datastore API implementation",
        "Datastore API: Slow query",
        "Datastore with slow query implementation",
        "WebFrameworks API",
        "Tip",
        "WebFrameworks API implementation",
        "For more help"
      ],
      "title": "Java agent API: Instrument external calls, messaging, datastore, web frameworks",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "714d226d7cc81508ecd006cb53c26c7525abfd4e",
      "image": "https://docs.newrelic.com/static/00e2b7a703330efa62b14e15dda69907/1ff84/CAT_diagram.png",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/java-agent-api-instrument-external-calls-messaging-datastore-web-frameworks/",
      "published_at": "2021-05-05T06:59:42Z",
      "updated_at": "2021-03-11T03:37:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent collects and reports information on web transactions and non-web transactions, such as background tasks. The agent should instrument supported frameworks automatically, without any need to modify your application code. However, in addition to custom code and frameworks or technology not listed in the Compatibility and requirements for the Java agent documentation, some implementations of supported frameworks may require custom instrumentation. This document describes how to use the Java agent API to instrument external calls, messaging frameworks, cross application tracing (CAT), datastores, and web frameworks. For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 3.36.0 or higher. External API The External API enables applications to report external service calls to New Relic. This information appears on the External services page in APM. To report HTTP external activity, simply create an instance of ExternalParameters using the HttpParameters builder, and call reportAsExternal(ExternalParameters parameters) on the traced method you want to report. External API String library = \"HttpClient\"; // a user-recognizable name for the library that is being used URI uri = request.getURI(); // the URI that is being requested String procedure = \"execute\"; // these are typically named after the method in the library that's being instrumented // construct external parameters ExternalParameters params = HttpParameters .library(library) .uri(uri) .procedure(procedure) .inboundHeaders(inboundHeaders) .build(); // report the current method as doing external activity NewRelic.getAgent().getTracedMethod().reportAsExternal(params); Copy External parameters builders There are several builders to create ExternalParameters: DatastoreParameters HttpParameters GenericParameters MessageConsumeParameters MessageProduceParameters These builders create the input parameter object for TracedMethod's reportAsExternal API call. These parameter objects are used for things like linking HTTP external calls via cross application tracing, tracing external calls to a datastore, tracing external calls to a datastore with additional slow query processing, as well as tracing calls between message producers and consumers. Important All of the methods of this class have the potential to expose sensitive private information. Use caution when creating the arguments, paying particular attention to URIs and string values. Cross application tracing API The cross application tracing (CAT) API allows the New Relic Java agent to link transactions across applications monitored by New Relic. The API uses client and server wrappers that allow the agent to read headers from requests, and add headers to responses. Client wrappers For the agent to write outbound request headers in the client initiating the request, use the OutboundHeaders interface. For example: OutbounderHeaders implementation class OutboundWrapper implements OutboundHeaders { private final HttpUriRequest delegate; // OutboundHeaders is implemented by delegating to the library's request object public OutboundWrapper(HttpUriRequest request) { this.delegate = request; } // This allows the agent to add the correct headers to the HTTP request @Override public void setHeader(String name, String value) { delegate.addHeader(name, value); } // New Relic CAT specifies different header names for HTTP and MESSAGE @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } } Copy For the agent to read inbound response headers in the client receiving the response, implement the InboundHeaders. For example: InboundHeaders implementation class InboundWrapper implements InboundHeaders { private final CloseableHttpResponse responseHeaders; // OutboundHeaders is implemented by delegating to the library's response object public InboundWrapper(CloseableHttpResponse responseHeaders) { this.responseHeaders = responseHeaders; } // New Relic CAT specifies different header names for HTTP and MESSAGE @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } // this allows the agent to read the correct headers from the HTTP response @Override public String getHeader(String name) { return responseHeaders.getFirstHeader(name).getValue(); } } Copy Server wrappers For the agent to get web request headers, you must extend the ExtendedRequest class: Extend ExtendedRequest class // Extend ExtendedRequest class to create a wrapper for the Request object class RequestWrapper extends ExtendedRequest { private IHTTPSession session; public RequestWrapper(IHTTPSession session) { super(); this.session = session; } @Override public String getRequestURI() { return session.getUri(); } @Override public String getHeader(String name) { return session.getHeaders().get(name); } @Override public String getRemoteUser() { return null; } @SuppressWarnings(\"rawtypes\") @Override public Enumeration getParameterNames() { return Collections.enumeration(session.getParms().keySet()); } @Override public String[] getParameterValues(String name) { return new String[]{session.getParms().get(name)}; } @Override public Object getAttribute(String name) { return null; } @Override public String getCookieValue(String name) { return null; } @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } @Override public String getMethod() { return session.getMethod().toString(); } } Copy For the agent to set the web response headers, implement the Response interface: Response interface implementation // Implement Response interface to create a wrapper for the outgoing Response object public class ResponseWrapper implements com.newrelic.api.agent.Response { private final Response httpResponse; public ResponseWrapper(Response httpResponse) { this.httpResponse = httpResponse; } @Override public int getStatus() throws Exception { return 200; } @Override public String getStatusMessage() throws Exception { return null; } @Override public void setHeader(String name, String value) { httpResponse.addHeader(name, value); } @Override public String getContentType() { return \"\"; } @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } } Copy CAT implementation using wrappers Using the wrapper objects described in the previous sections, you can enable the Java agent to do cross application tracing (CAT) on the client and server side. For example: Cross application tracing: Client-side @Trace public int makeExternalCall(URI uri) throws IOException { String library = \"HTTPClient\"; String procedure = \"Execute\"; HttpUriRequest request = RequestBuilder.get().setUri(uri).build(); // Wrap the outbound Request object OutboundWrapper outboundHeaders = new OutboundWrapper(request); // Obtain a reference to the method currently being traced TracedMethod tracedMethod = NewRelic.getAgent().getTracedMethod(); // Add headers for outbound external request tracedMethod.addOutboundRequestHeaders(outboundHeaders); CloseableHttpClient connection = HttpClientBuilder.create().build(); CloseableHttpResponse response = connection.execute(request); // Wrap the incoming Response object InboundWrapper inboundHeaders = new InboundWrapper(response); // Create an input parameter object for a call to an external HTTP service ExternalParameters params = HttpParameters .library(library) .uri(uri) .procedure(procedure) .inboundHeaders(inboundHeaders) .build(); // Report a call to an external HTTP service tracedMethod.reportAsExternal(params); return response.getStatusLine().getStatusCode(); } Copy In this sample code, the agent is configured to report an external call using CAT on the client that is initiating the request. These steps can be summarized as follows: Implement OutboundHeaders and InboundHeaders using framework classes on the client. Use addOutboundRequestHeaders(OutboundHeaders outboundHeaders) to have the agent add appropriate headers to the outbound request. Create ExternalParameters object using HttpParameters builder and provide inbound response headers. Report as an external request using reportAsExternal(ExternalParameters params). Cross application tracing: Server-side @Trace(dispatcher = true) @Override public Response serve(IHTTPSession session) { // Obtain a reference to the current Transaction Transaction tx = NewRelic.getAgent().getTransaction(); // Set the name of the current transaction NewRelic.setTransactionName(\"Custom\", \"ExternalHTTPServer\"); // Wrap the Request object ExtendedRequest req = new RequestWrapper(session); // Set the request for the current transaction and convert it into a web transaction tx.setWebRequest(req); queryDB(); Response res = newFixedLengthResponse(\"<html><body><h1>SuccessfulResponse</h1>\\n</body></html>\\n\"); // Set the response for the current transaction and convert it into a web transaction tx.setWebResponse(new ResponseWrapper(res)); // Instruct the transaction to write the outbound response headers tx.addOutboundResponseHeaders(); // Mark the time when the response left the server tx.markResponseSent(); return res; } Copy In this sample code, the agent is configured to report an external call using CAT on the server that is responding to the request. These steps can be summarized as follows: Implement Response and extend the ExtendedRequest class using framework classes on the server. Use setWebRequest(ExtendedRequest request) and setWebResponse(Response response) to convert the transaction into a web transaction and together provide the agent with the inbound request headers and a place to record the outbound headers. It's important to use both setWebRequest(ExtendedRequest request) and setWebResponse(Response response) together, because the transaction name depends on the request object, and the response code depends on the response object. Use addOutboundResponseHeaders() to have the agent add appropriate headers to the outbound response. Mark the end of the response with a call to markResponseSent(). Messaging API The messaging API allows applications to report interactions with message queue brokers. It builds on top of the External API by providing the MessageConsumerParametersMessage and MessageConsumerParameters. This API generates the necessary metrics to identify message broker interactions. The UI will use these metrics to display messaging data including segments in transactions with the appropriate action and count (message put, or message take), a dedicated messages tab in transaction traces, and more. Providing inbound and outbound headers to the API also allows the agent to add CAT headers, and record CAT metrics, which enables the UI to draw service maps that show connections between applications. Important The messaging API relies on two-way communication between producers and consumers. If your producer does not receive an acknowledgment from a consumer, like in a fire-and-forget pattern, the messaging API will not accurately reflect the interactions with message queue brokers. The following example demonstrates how to instrument a fictional JMS library. Messaging API implementation public class MessageProducer { // instrument the method that puts messages on a queue @Trace public void sendMessageToQueue(Message message) { ExternalParameters messageProduceParameters = MessageProduceParameters.library(\"JMS\") .destinationType(DestinationType.NAMED_QUEUE) .destinationName(message.getJMSDestination()) .outboundHeaders(new OutboundWrapper(message)) .build(); NewRelic.getAgent().getTracedMethod().reportAsExternal(messageProduceParameters); } } Copy To simplify things, the agent assumes that sendMessageToQueue always puts a message in a named queue. In reality, a message can be sent to different destination types, including named queues, temporary queues, topics, and temporary topics. The API provides an enum to report messages to different destination types: NAMED_QUEUE, TEMP_QUEUE, NAMED_TOPIC, TEMP_TOPIC. It's important to specify the appropriate destination type because the UI will display the names of named queues and named topics and will omit the names of temporary queues and temporary topics. If the library is capable of transmitting CAT headers, an OutboundHeaders object will be provided to the API so that the agent can add CAT headers. Message with CAT headers implementation public class MessageConsumer { @Trace public Message messageReceive() { ExternalParameters messageConsumeParameters = MessageConsumeParameters.library(\"JMS\") .destinationType(DestinationType.NAMED_QUEUE) .destinationName(message.getJMSDestination()) .inboundHeaders(new InboundWrapper(message)) .build(); NewRelic.getAgent().getTracedMethod().reportAsExternal(messageConsumeParameters); return message; } } Copy Datastore API When a traced method is reported as an external datastore call, the call is shown in the APM Databases page. Because datastores are external to the running application, the method is reported as datastore activity using the reportAsExternal(ExternalParameters params) method. The only difference is that a different builder, DatastoreParameters, is used to create the appropriate ExternalParameters object. Datastore API implementation TracedMethod tracedMethod = NewRelic.getAgent().getTracedMethod(); tracedMethod.reportAsExternal( DatastoreParameters .product(\"sqlite\") // the datastore vendor .collection(\"test.db\") // the name of the collection (or table for SQL databases) .operation(\"select\") // the operation being performed, e.g. \"SELECT\" or \"UPDATE\" for SQL databases .instance(\"localhost\", 8080) // the datastore instance information - generally can be found as part of the connection .databaseName(\"test.db\") // may be null, indicating no keyspace for the command .build()); Copy Datastore API: Slow query This API call provides the same behavior as the Datastore API call and extends it to allow slow query information to be tracked. The same reportAsExternal(ExternalParameters params) method and builder are used, but with an additional builder method. Datastore with slow query implementation Creating the appropriate ExternalParameters object is illustrated below: //Reporting a method as doing datastore activity TracedMethod tracedMethod = NewRelic.getAgent().getTracedMethod(); tracedMethod.reportAsExternal( DatastoreParameters .product(\"sqlite\") // the datastore vendor .collection(\"test.db\") // the name of the collection (or table for SQL databases) .operation(\"select\") // the operation being performed, e.g. \"SELECT\" or \"UPDATE\" for SQL databases .instance(\"localhost\", 8080) // the datastore instance information - generally can be found as part of the connection .databaseName(\"test.db\") // may be null, indicating no keyspace for the command .slowQuery(rawQuery,QUERY_CONVERTER) .build()); private static QueryConverter<String> QUERY_CONVERTER = new QueryConverter<String>() { @Override public String toRawQueryString(String statement) { // Do work to transform raw query object to string return statement; } @Override public String toObfuscatedQueryString(String statement) { // Do work to remove any sensitive information here return obfuscateQuery(statement); } }; Copy WebFrameworks API The WebFrameworks API allows the agent to report additional identifying information about the application. // Set the dispatcher name and version which is reported to APM. // The dispatcherName is intended to represent the type of server that this // application is running on such as: Tomcat, Jetty, Netty, etc. NewRelic.setServerInfo(String dispatcherName, String version) // Set the app server port which is reported to APM. NewRelic.setAppServerPort(int port) // Set the instance name in the environment. // A single host:port may support multiple JVM instances. // The instance name is intended to help identify a specific JVM instance. NewRelic.setInstanceName(String instanceName) Copy Tip These values can be set only once. Subsequent calls will have no effect. WebFrameworks API implementation public NewRelicApiClient() throws IOException, URISyntaxException { super(8080); // Set Dispatcher name and version. NewRelic.setServerInfo(\"NanoHttp\", \"2.3.1\"); // Set Appserver port for jvm identification NewRelic.setAppServerPort(8080); // Set JVM instance name NewRelic.setInstanceName(\"Client:8080\"); start(NanoHTTPD.SOCKET_READ_TIMEOUT, false); System.out.println(\"\\nRunning on http://localhost:8080/ \\n\"); } Copy For more help Additional documentation resources include: New Relic Java agent API Javadoc (detailed API documentation on GitHub) Java agent API example (example application using custom instrumentation for cross application tracing and external datastore calls) Java agent API guide (goal-driven guide to using the Java agent API) Java instrumentation by annotation (how to use annotations to instrument your application code)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.44668,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> <em>API</em>: Instrument external calls, messaging, datastore, web frameworks",
        "sections": "<em>Java</em> <em>agent</em> <em>API</em>: Instrument external calls, messaging, datastore, web frameworks",
        "tags": "<em>API</em> <em>guides</em>",
        "body": " or technology not listed in the Compatibility and requirements for the <em>Java</em> <em>agent</em> documentation, some implementations of supported frameworks may require custom instrumentation. This document describes how to use the <em>Java</em> <em>agent</em> <em>API</em> to instrument external calls, messaging frameworks, cross application"
      },
      "id": "6043c7f828ccbcef982c6077"
    }
  ],
  "/docs/agents/java-agent/api-guides/java-agent-api-custom-instrumentation-annotation-example-app": [
    {
      "sections": [
        "Java agent API: Instrument using annotation",
        "Important",
        "Configure your agent for annotations",
        "Tip",
        "Create a new transaction",
        "Add detail to your transactions",
        "Convert a transaction to a web request",
        "Define your own @Trace annotation class",
        "Properties for @Trace",
        "dispatcher",
        "async",
        "metricName",
        "excludeFromTransactionTrace",
        "leaf",
        "More API functions"
      ],
      "title": "Java agent API: Instrument using annotation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "4a373504c0682b36745d2283fdd902ead43510ec",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/java-agent-api-instrument-using-annotation/",
      "published_at": "2021-05-05T06:57:49Z",
      "updated_at": "2021-03-16T04:31:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent provides several options for custom instrumentation. One of those options is adding the Java agent API's @Trace annotations to your application code. This document describes how to use annotations. Important To use annotations, you must modify the source code. If you can't or don't want to modify your source code, see Custom instrumentation for other instrumentation options. Configure your agent for annotations By default, the configuration setting enable_custom_tracing is set to true in the Java agent, which is the setting required for @Trace annotations to function. This setting is not included in the newrelic.yml by default. The only time you need to incorporate this setting into your configuration file is if you want to disable @Trace annotations altogether. To do this, set enable_custom_tracing: false (prefaced with two spaces) in the common stanza of your newrelic.yml. To detect custom traces: Make sure that newrelic-api.jar appears in your classpath. Add @Trace annotations to your code. In each class containing a method you want to instrument, call: import com.newrelic.api.agent.Trace; Copy Place the @Trace annotation on each target method. Tip The annotation com.newrelic.api.agent.Trace is located in the newrelic-api.jar. Create a new transaction If transactions do not appear and you want to start a new transaction, include dispatcher=true with the @Trace annotation: @Trace (dispatcher=true) public void run() { // background task } Copy Add detail to your transactions If your transaction traces show large blocks of uninstrumented time and you want to include some more methods within the trace, you can use the @Trace annotation without parameters: @Trace protected void methodWithinTransaction() { // work } Copy Convert a transaction to a web request To make a background task report as a web browser transaction with a Java agent API call: In the method annotated with @Trace(dispatcher=true), call: NewRelic.setRequestAndResponse(Request request, Response response) Copy The arguments are implementations of the Request and Response interfaces in newrelic-api.jar. Important Even if your Request and Response objects already are present, you still need to add this API call. Define your own @Trace annotation class If you define your own @Trace annotation class, there is no dependency on the newrelic-api.jar. To define the class: package com.test; @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Trace { public static final String NULL = \"\"; String metricName() default NULL; boolean dispatcher() default false; String tracerFactoryName() default NULL; } Copy Then, configure the agent to use this annotation in the common section of the newrelic.yml: class_transformer: trace_annotation_class_name: com.test.Trace Copy Properties for @Trace The @Trace annotation supports the following properties. dispatcher Type: Boolean Default: false If true, the agent will start a transaction when it reaches a method with this @Trace annotation if a transaction is not already in progress. If a transaction is already in progress, the method with this annotation will be included in the ongoing transaction, rather than starting a new one. If false (default), no metrics will be recorded if the agent has not started a transaction before the @Trace annotation is reached. For example: @Trace(dispatcher=true) Copy async Type: Boolean Default: false If true, this method is marked as asynchronous and the agent will trace this method if it linked to an existing transaction. For example: @Trace(async=true) Copy If false (default), the method is not marked as asynchronous. If other @Trace annotations are present and the method is not executing asynchronously, it will still be traced. metricName Type: String Default: (none) This property affects transaction traces and error reporting. By default, the metric name will include the class name followed by the method name. If you do not want class followed by method, then you can use this property to change the metric name. If you set the metricName, as in @Trace(metricName=\"YourMessageHere\"), then the time spent in this method will appear as YourMessageHere in any transaction trace. If you set the metricName in addition to the dispatcher, as in @Trace(metricName=\"YourMessageHere\", dispatcher=true), then the transaction name will appear as YourMessageHere in the APM Transactions page but the time spent in this method will not appear as YourMessageHere in any transaction trace. Here is an example: @Trace(metricName=\"YourMetricName\") Copy Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. excludeFromTransactionTrace Type: Boolean Default: false If true, the method will be excluded from the transaction trace. The agent will still collect metrics for the method. Here is an example: @Trace(excludeFromTransactionTrace=true) Copy leaf Type: Boolean Default: false A leaf tracer has no child tracers. This is useful when you want all time attributed to the tracer, even if other trace points are encountered the tracer's execution. Database tracers often act as a leaf so that all time is attributed to database activity, even if instrumented external calls are made. Here is an example: @Trace(leaf=true) Copy If a leaf tracer does not participate in transaction traces, the agent can create a tracer with lower overhead. Here is an example: @Trace(excludeFromTransactionTrace=true, leaf=true) Copy More API functions For more about the Java agent API and its functionality, see the Java agent API introduction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.698456,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> <em>API</em>: Instrument using annotation",
        "sections": "<em>Java</em> <em>agent</em> <em>API</em>: Instrument using annotation",
        "tags": "<em>API</em> <em>guides</em>",
        "body": "New Relic&#x27;s <em>Java</em> <em>agent</em> provides several options for custom instrumentation. One of those options is adding the <em>Java</em> <em>agent</em> <em>API</em>&#x27;s @Trace annotations to your application code. This document describes how to use annotations. Important To use annotations, you must modify the source code. If you can&#x27;t"
      },
      "id": "603eb64a28ccbc9ca2eba79f"
    },
    {
      "sections": [
        "Java agent API: Instrument external calls, messaging, datastore, web frameworks",
        "External API",
        "External parameters builders",
        "Important",
        "Cross application tracing API",
        "Client wrappers",
        "OutbounderHeaders implementation",
        "InboundHeaders implementation",
        "Server wrappers",
        "Extend ExtendedRequest class",
        "Response interface implementation",
        "CAT implementation using wrappers",
        "Cross application tracing: Client-side",
        "Cross application tracing: Server-side",
        "Messaging API",
        "Messaging API implementation",
        "Message with CAT headers implementation",
        "Datastore API",
        "Datastore API implementation",
        "Datastore API: Slow query",
        "Datastore with slow query implementation",
        "WebFrameworks API",
        "Tip",
        "WebFrameworks API implementation",
        "For more help"
      ],
      "title": "Java agent API: Instrument external calls, messaging, datastore, web frameworks",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "714d226d7cc81508ecd006cb53c26c7525abfd4e",
      "image": "https://docs.newrelic.com/static/00e2b7a703330efa62b14e15dda69907/1ff84/CAT_diagram.png",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/java-agent-api-instrument-external-calls-messaging-datastore-web-frameworks/",
      "published_at": "2021-05-05T06:59:42Z",
      "updated_at": "2021-03-11T03:37:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent collects and reports information on web transactions and non-web transactions, such as background tasks. The agent should instrument supported frameworks automatically, without any need to modify your application code. However, in addition to custom code and frameworks or technology not listed in the Compatibility and requirements for the Java agent documentation, some implementations of supported frameworks may require custom instrumentation. This document describes how to use the Java agent API to instrument external calls, messaging frameworks, cross application tracing (CAT), datastores, and web frameworks. For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 3.36.0 or higher. External API The External API enables applications to report external service calls to New Relic. This information appears on the External services page in APM. To report HTTP external activity, simply create an instance of ExternalParameters using the HttpParameters builder, and call reportAsExternal(ExternalParameters parameters) on the traced method you want to report. External API String library = \"HttpClient\"; // a user-recognizable name for the library that is being used URI uri = request.getURI(); // the URI that is being requested String procedure = \"execute\"; // these are typically named after the method in the library that's being instrumented // construct external parameters ExternalParameters params = HttpParameters .library(library) .uri(uri) .procedure(procedure) .inboundHeaders(inboundHeaders) .build(); // report the current method as doing external activity NewRelic.getAgent().getTracedMethod().reportAsExternal(params); Copy External parameters builders There are several builders to create ExternalParameters: DatastoreParameters HttpParameters GenericParameters MessageConsumeParameters MessageProduceParameters These builders create the input parameter object for TracedMethod's reportAsExternal API call. These parameter objects are used for things like linking HTTP external calls via cross application tracing, tracing external calls to a datastore, tracing external calls to a datastore with additional slow query processing, as well as tracing calls between message producers and consumers. Important All of the methods of this class have the potential to expose sensitive private information. Use caution when creating the arguments, paying particular attention to URIs and string values. Cross application tracing API The cross application tracing (CAT) API allows the New Relic Java agent to link transactions across applications monitored by New Relic. The API uses client and server wrappers that allow the agent to read headers from requests, and add headers to responses. Client wrappers For the agent to write outbound request headers in the client initiating the request, use the OutboundHeaders interface. For example: OutbounderHeaders implementation class OutboundWrapper implements OutboundHeaders { private final HttpUriRequest delegate; // OutboundHeaders is implemented by delegating to the library's request object public OutboundWrapper(HttpUriRequest request) { this.delegate = request; } // This allows the agent to add the correct headers to the HTTP request @Override public void setHeader(String name, String value) { delegate.addHeader(name, value); } // New Relic CAT specifies different header names for HTTP and MESSAGE @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } } Copy For the agent to read inbound response headers in the client receiving the response, implement the InboundHeaders. For example: InboundHeaders implementation class InboundWrapper implements InboundHeaders { private final CloseableHttpResponse responseHeaders; // OutboundHeaders is implemented by delegating to the library's response object public InboundWrapper(CloseableHttpResponse responseHeaders) { this.responseHeaders = responseHeaders; } // New Relic CAT specifies different header names for HTTP and MESSAGE @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } // this allows the agent to read the correct headers from the HTTP response @Override public String getHeader(String name) { return responseHeaders.getFirstHeader(name).getValue(); } } Copy Server wrappers For the agent to get web request headers, you must extend the ExtendedRequest class: Extend ExtendedRequest class // Extend ExtendedRequest class to create a wrapper for the Request object class RequestWrapper extends ExtendedRequest { private IHTTPSession session; public RequestWrapper(IHTTPSession session) { super(); this.session = session; } @Override public String getRequestURI() { return session.getUri(); } @Override public String getHeader(String name) { return session.getHeaders().get(name); } @Override public String getRemoteUser() { return null; } @SuppressWarnings(\"rawtypes\") @Override public Enumeration getParameterNames() { return Collections.enumeration(session.getParms().keySet()); } @Override public String[] getParameterValues(String name) { return new String[]{session.getParms().get(name)}; } @Override public Object getAttribute(String name) { return null; } @Override public String getCookieValue(String name) { return null; } @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } @Override public String getMethod() { return session.getMethod().toString(); } } Copy For the agent to set the web response headers, implement the Response interface: Response interface implementation // Implement Response interface to create a wrapper for the outgoing Response object public class ResponseWrapper implements com.newrelic.api.agent.Response { private final Response httpResponse; public ResponseWrapper(Response httpResponse) { this.httpResponse = httpResponse; } @Override public int getStatus() throws Exception { return 200; } @Override public String getStatusMessage() throws Exception { return null; } @Override public void setHeader(String name, String value) { httpResponse.addHeader(name, value); } @Override public String getContentType() { return \"\"; } @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } } Copy CAT implementation using wrappers Using the wrapper objects described in the previous sections, you can enable the Java agent to do cross application tracing (CAT) on the client and server side. For example: Cross application tracing: Client-side @Trace public int makeExternalCall(URI uri) throws IOException { String library = \"HTTPClient\"; String procedure = \"Execute\"; HttpUriRequest request = RequestBuilder.get().setUri(uri).build(); // Wrap the outbound Request object OutboundWrapper outboundHeaders = new OutboundWrapper(request); // Obtain a reference to the method currently being traced TracedMethod tracedMethod = NewRelic.getAgent().getTracedMethod(); // Add headers for outbound external request tracedMethod.addOutboundRequestHeaders(outboundHeaders); CloseableHttpClient connection = HttpClientBuilder.create().build(); CloseableHttpResponse response = connection.execute(request); // Wrap the incoming Response object InboundWrapper inboundHeaders = new InboundWrapper(response); // Create an input parameter object for a call to an external HTTP service ExternalParameters params = HttpParameters .library(library) .uri(uri) .procedure(procedure) .inboundHeaders(inboundHeaders) .build(); // Report a call to an external HTTP service tracedMethod.reportAsExternal(params); return response.getStatusLine().getStatusCode(); } Copy In this sample code, the agent is configured to report an external call using CAT on the client that is initiating the request. These steps can be summarized as follows: Implement OutboundHeaders and InboundHeaders using framework classes on the client. Use addOutboundRequestHeaders(OutboundHeaders outboundHeaders) to have the agent add appropriate headers to the outbound request. Create ExternalParameters object using HttpParameters builder and provide inbound response headers. Report as an external request using reportAsExternal(ExternalParameters params). Cross application tracing: Server-side @Trace(dispatcher = true) @Override public Response serve(IHTTPSession session) { // Obtain a reference to the current Transaction Transaction tx = NewRelic.getAgent().getTransaction(); // Set the name of the current transaction NewRelic.setTransactionName(\"Custom\", \"ExternalHTTPServer\"); // Wrap the Request object ExtendedRequest req = new RequestWrapper(session); // Set the request for the current transaction and convert it into a web transaction tx.setWebRequest(req); queryDB(); Response res = newFixedLengthResponse(\"<html><body><h1>SuccessfulResponse</h1>\\n</body></html>\\n\"); // Set the response for the current transaction and convert it into a web transaction tx.setWebResponse(new ResponseWrapper(res)); // Instruct the transaction to write the outbound response headers tx.addOutboundResponseHeaders(); // Mark the time when the response left the server tx.markResponseSent(); return res; } Copy In this sample code, the agent is configured to report an external call using CAT on the server that is responding to the request. These steps can be summarized as follows: Implement Response and extend the ExtendedRequest class using framework classes on the server. Use setWebRequest(ExtendedRequest request) and setWebResponse(Response response) to convert the transaction into a web transaction and together provide the agent with the inbound request headers and a place to record the outbound headers. It's important to use both setWebRequest(ExtendedRequest request) and setWebResponse(Response response) together, because the transaction name depends on the request object, and the response code depends on the response object. Use addOutboundResponseHeaders() to have the agent add appropriate headers to the outbound response. Mark the end of the response with a call to markResponseSent(). Messaging API The messaging API allows applications to report interactions with message queue brokers. It builds on top of the External API by providing the MessageConsumerParametersMessage and MessageConsumerParameters. This API generates the necessary metrics to identify message broker interactions. The UI will use these metrics to display messaging data including segments in transactions with the appropriate action and count (message put, or message take), a dedicated messages tab in transaction traces, and more. Providing inbound and outbound headers to the API also allows the agent to add CAT headers, and record CAT metrics, which enables the UI to draw service maps that show connections between applications. Important The messaging API relies on two-way communication between producers and consumers. If your producer does not receive an acknowledgment from a consumer, like in a fire-and-forget pattern, the messaging API will not accurately reflect the interactions with message queue brokers. The following example demonstrates how to instrument a fictional JMS library. Messaging API implementation public class MessageProducer { // instrument the method that puts messages on a queue @Trace public void sendMessageToQueue(Message message) { ExternalParameters messageProduceParameters = MessageProduceParameters.library(\"JMS\") .destinationType(DestinationType.NAMED_QUEUE) .destinationName(message.getJMSDestination()) .outboundHeaders(new OutboundWrapper(message)) .build(); NewRelic.getAgent().getTracedMethod().reportAsExternal(messageProduceParameters); } } Copy To simplify things, the agent assumes that sendMessageToQueue always puts a message in a named queue. In reality, a message can be sent to different destination types, including named queues, temporary queues, topics, and temporary topics. The API provides an enum to report messages to different destination types: NAMED_QUEUE, TEMP_QUEUE, NAMED_TOPIC, TEMP_TOPIC. It's important to specify the appropriate destination type because the UI will display the names of named queues and named topics and will omit the names of temporary queues and temporary topics. If the library is capable of transmitting CAT headers, an OutboundHeaders object will be provided to the API so that the agent can add CAT headers. Message with CAT headers implementation public class MessageConsumer { @Trace public Message messageReceive() { ExternalParameters messageConsumeParameters = MessageConsumeParameters.library(\"JMS\") .destinationType(DestinationType.NAMED_QUEUE) .destinationName(message.getJMSDestination()) .inboundHeaders(new InboundWrapper(message)) .build(); NewRelic.getAgent().getTracedMethod().reportAsExternal(messageConsumeParameters); return message; } } Copy Datastore API When a traced method is reported as an external datastore call, the call is shown in the APM Databases page. Because datastores are external to the running application, the method is reported as datastore activity using the reportAsExternal(ExternalParameters params) method. The only difference is that a different builder, DatastoreParameters, is used to create the appropriate ExternalParameters object. Datastore API implementation TracedMethod tracedMethod = NewRelic.getAgent().getTracedMethod(); tracedMethod.reportAsExternal( DatastoreParameters .product(\"sqlite\") // the datastore vendor .collection(\"test.db\") // the name of the collection (or table for SQL databases) .operation(\"select\") // the operation being performed, e.g. \"SELECT\" or \"UPDATE\" for SQL databases .instance(\"localhost\", 8080) // the datastore instance information - generally can be found as part of the connection .databaseName(\"test.db\") // may be null, indicating no keyspace for the command .build()); Copy Datastore API: Slow query This API call provides the same behavior as the Datastore API call and extends it to allow slow query information to be tracked. The same reportAsExternal(ExternalParameters params) method and builder are used, but with an additional builder method. Datastore with slow query implementation Creating the appropriate ExternalParameters object is illustrated below: //Reporting a method as doing datastore activity TracedMethod tracedMethod = NewRelic.getAgent().getTracedMethod(); tracedMethod.reportAsExternal( DatastoreParameters .product(\"sqlite\") // the datastore vendor .collection(\"test.db\") // the name of the collection (or table for SQL databases) .operation(\"select\") // the operation being performed, e.g. \"SELECT\" or \"UPDATE\" for SQL databases .instance(\"localhost\", 8080) // the datastore instance information - generally can be found as part of the connection .databaseName(\"test.db\") // may be null, indicating no keyspace for the command .slowQuery(rawQuery,QUERY_CONVERTER) .build()); private static QueryConverter<String> QUERY_CONVERTER = new QueryConverter<String>() { @Override public String toRawQueryString(String statement) { // Do work to transform raw query object to string return statement; } @Override public String toObfuscatedQueryString(String statement) { // Do work to remove any sensitive information here return obfuscateQuery(statement); } }; Copy WebFrameworks API The WebFrameworks API allows the agent to report additional identifying information about the application. // Set the dispatcher name and version which is reported to APM. // The dispatcherName is intended to represent the type of server that this // application is running on such as: Tomcat, Jetty, Netty, etc. NewRelic.setServerInfo(String dispatcherName, String version) // Set the app server port which is reported to APM. NewRelic.setAppServerPort(int port) // Set the instance name in the environment. // A single host:port may support multiple JVM instances. // The instance name is intended to help identify a specific JVM instance. NewRelic.setInstanceName(String instanceName) Copy Tip These values can be set only once. Subsequent calls will have no effect. WebFrameworks API implementation public NewRelicApiClient() throws IOException, URISyntaxException { super(8080); // Set Dispatcher name and version. NewRelic.setServerInfo(\"NanoHttp\", \"2.3.1\"); // Set Appserver port for jvm identification NewRelic.setAppServerPort(8080); // Set JVM instance name NewRelic.setInstanceName(\"Client:8080\"); start(NanoHTTPD.SOCKET_READ_TIMEOUT, false); System.out.println(\"\\nRunning on http://localhost:8080/ \\n\"); } Copy For more help Additional documentation resources include: New Relic Java agent API Javadoc (detailed API documentation on GitHub) Java agent API example (example application using custom instrumentation for cross application tracing and external datastore calls) Java agent API guide (goal-driven guide to using the Java agent API) Java instrumentation by annotation (how to use annotations to instrument your application code)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.44668,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> <em>API</em>: Instrument external calls, messaging, datastore, web frameworks",
        "sections": "<em>Java</em> <em>agent</em> <em>API</em>: Instrument external calls, messaging, datastore, web frameworks",
        "tags": "<em>API</em> <em>guides</em>",
        "body": " or technology not listed in the Compatibility and requirements for the <em>Java</em> <em>agent</em> documentation, some implementations of supported frameworks may require custom instrumentation. This document describes how to use the <em>Java</em> <em>agent</em> <em>API</em> to instrument external calls, messaging frameworks, cross application"
      },
      "id": "6043c7f828ccbcef982c6077"
    },
    {
      "sections": [
        "Java agent API: Instrumenting example app for external datastore calls and CAT",
        "Important",
        "Client-side example",
        "Complete client example code",
        "Import Java agent API classes",
        "Start the client and set environment details as displayed in the UI",
        "Start tracing a transaction with the Java agent using @Trace annotation",
        "Make an external call using the Java agent API",
        "Implement the Java agent API's OutboundHeaders Interface",
        "Implement the Java agent API's InboundHeaders Interface",
        "Create a simple database",
        "Server-side example",
        "Complete server example code",
        "Start the server and set its info as displayed in UI",
        "Start tracing a transaction and add outbound Response headers",
        "Implement the Java agent API's Response Interface",
        "Extend the Java agent API's ExtendedRequest class",
        "Instrument an external call to a datastore"
      ],
      "title": "Java agent API: Instrumenting example app for external datastore calls and CAT",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "8e1b18952dde913071d4d5ef121d51e7efc5629b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/java-agent-api-instrumenting-example-app-external-datastore-calls-cat/",
      "published_at": "2021-05-05T07:03:40Z",
      "updated_at": "2021-03-11T03:24:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document demonstrates using the New Relic Java agent API to instrument a simple client and server application. The instrumentation has these goals: To record external HTTP and datastore transactions. To link external transactions between two applications running New Relic agents (known as cross application tracing or CAT). See the Java agent API Javadoc for full descriptions of the available API classes and methods. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 3.36.0 or higher. Client-side example Here is an example of the client-side code for a simple client-server application: Complete client example code package com.newrelic.example; import java.io.IOException; import java.net.URI; import java.net.URISyntaxException; import java.sql.Connection; import java.sql.DriverManager; import java.sql.Statement; // New Relic API imports import com.newrelic.api.agent.ExternalParameters; import com.newrelic.api.agent.HeaderType; import com.newrelic.api.agent.HttpParameters; import com.newrelic.api.agent.InboundHeaders; import com.newrelic.api.agent.NewRelic; import com.newrelic.api.agent.OutboundHeaders; import com.newrelic.api.agent.Trace; import com.newrelic.api.agent.TracedMethod; import fi.iki.elonen.NanoHTTPD; import org.apache.http.client.methods.CloseableHttpResponse; import org.apache.http.client.methods.HttpUriRequest; import org.apache.http.client.methods.RequestBuilder; import org.apache.http.impl.client.CloseableHttpClient; import org.apache.http.impl.client.HttpClientBuilder; public class NewRelicApiExample extends NanoHTTPD { public NewRelicApiExample() throws IOException, URISyntaxException { super(8080); // Set Dispatcher name and version NewRelic.setServerInfo(\"NanoHttp\", \"2.3.1\"); // Set Appserver port for JVM identification NewRelic.setAppServerPort(8080); // Set JVM instance name NewRelic.setInstanceName(\"Client\"); start(NanoHTTPD.SOCKET_READ_TIMEOUT, false); System.out.println(\"Running at: http://localhost:8080/\"); } public static void main(String[] args) throws URISyntaxException { try { new NewRelicApiExample(); } catch (IOException ioe) { System.err.println(\"Unable to start the server:\\n\" + ioe); } } @Trace(dispatcher = true) @Override public Response serve(IHTTPSession session) { URI uri = null; int status = 0; try { createDB(); Thread.sleep(1000); uri = new URI(\"http://localhost:8081\"); status = makeExternalCall(uri); } catch (URISyntaxException | InterruptedException | IOException e) { e.printStackTrace(); } if (status == 200) { return newFixedLengthResponse(\"<html><body><h1>Successful Response</h1>\\n</body></html>\\n\"); } else { return newFixedLengthResponse(\"<html><body><h1>Error\\n\" + status + \"</h1>\\n</body></html>\\n\"); } } @Trace public int makeExternalCall(URI uri) throws IOException { HttpUriRequest request = RequestBuilder.get().setUri(uri).build(); // Wrap the outbound Request object OutboundWrapper outboundHeaders = new OutboundWrapper(request); // Obtain a reference to the method currently being traced TracedMethod tracedMethod = NewRelic.getAgent().getTracedMethod(); // Add headers for outbound external request tracedMethod.addOutboundRequestHeaders(outboundHeaders); CloseableHttpClient connection = HttpClientBuilder.create().build(); CloseableHttpResponse response = connection.execute(request); // Wrap the incoming Response object InboundWrapper inboundHeaders = new InboundWrapper(response); // Create an input parameter object for a call to an external HTTP service ExternalParameters params = HttpParameters .library(\"HttpClient\") .uri(uri) .procedure(\"execute\") .inboundHeaders(inboundHeaders) .build(); // Report a call to an external HTTP service tracedMethod.reportAsExternal(params); return response.getStatusLine().getStatusCode(); } // Implement OutboundHeaders interface to create a wrapper for the outgoing Request headers class OutboundWrapper implements OutboundHeaders { private final HttpUriRequest delegate; public OutboundWrapper(HttpUriRequest request) { this.delegate = request; } @Override public void setHeader(String name, String value) { delegate.addHeader(name, value); } @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } } // Implement InboundHeaders interface to create a wrapper for the incoming Response headers class InboundWrapper implements InboundHeaders { private final CloseableHttpResponse responseHeaders; public InboundWrapper(CloseableHttpResponse requestHeaders) { this.responseHeaders = requestHeaders; } @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } @Override public String getHeader(String name) { return responseHeaders.getFirstHeader(name).getValue(); } } @Trace public void createDB() { Connection c = null; Statement stmt = null; try { Class.forName(\"org.sqlite.JDBC\"); c = DriverManager.getConnection(\"jdbc:sqlite:/tmp/test.db\"); System.out.println(\"Opened database successfully\"); stmt = c.createStatement(); String dropSql = \"DROP TABLE IF EXISTS COMPANY;\"; stmt.executeUpdate(dropSql); String sql = \"CREATE TABLE COMPANY \" + \"(ID INT PRIMARY KEY NOT NULL,\" + \" NAME TEXT NOT NULL, \" + \" AGE INT NOT NULL, \" + \" ADDRESS CHAR(50), \" + \" SALARY REAL)\"; stmt.executeUpdate(sql); sql = \"INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) \" + \"VALUES (1, 'Paul', 32, 'California', 20000.00 );\"; stmt.executeUpdate(sql); sql = \"INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) \" + \"VALUES (2, 'Allen', 25, 'Texas', 15000.00 );\"; stmt.executeUpdate(sql); sql = \"INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) \" + \"VALUES (3, 'Teddy', 23, 'Norway', 20000.00 );\"; stmt.executeUpdate(sql); sql = \"INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) \" + \"VALUES (4, 'Mark', 25, 'Rich-Mond ', 65000.00 );\"; stmt.executeUpdate(sql); stmt.close(); c.close(); } catch (Exception e) { System.err.println(e.getClass().getName() + \": \" + e.getMessage()); System.exit(0); } } } Copy Here is the same client app code divided into sections that describe how the API is used: Import Java agent API classes This section calls the Java agent API imports used to add cross application tracing to the client application later in the example code. import java.io.IOException; import java.net.URI; import java.net.URISyntaxException; import java.sql.Connection; import java.sql.DriverManager; import java.sql.Statement; // New Relic API imports import com.newrelic.api.agent.ExternalParameters; import com.newrelic.api.agent.HeaderType; import com.newrelic.api.agent.InboundHeaders; import com.newrelic.api.agent.NewRelic; import com.newrelic.api.agent.OutboundHeaders; import com.newrelic.api.agent.Trace; import com.newrelic.api.agent.TracedMethod; import fi.iki.elonen.NanoHTTPD; import org.apache.http.client.methods.CloseableHttpResponse; import org.apache.http.client.methods.HttpUriRequest; import org.apache.http.client.methods.RequestBuilder; import org.apache.http.impl.client.CloseableHttpClient; import org.apache.http.impl.client.HttpClientBuilder; Copy Start the client and set environment details as displayed in the UI This section starts up the client server on port 8080 and uses the NewRelic class from the API to call the methods setServerInfo, setAppServerPort, and setInstanceName. These API calls affect what is shown in the New Relic UI. public NewRelicApiExample() throws IOException, URISyntaxException { super(8080); // Set Dispatcher name and version NewRelic.setServerInfo(\"NanoHttp\", \"2.3.1\"); // Set Appserver port for jvm identification NewRelic.setAppServerPort(8080); // Set JVM instance name NewRelic.setInstanceName(\"Client\"); start(NanoHTTPD.SOCKET_READ_TIMEOUT, false); System.out.println(\"Running at: http://localhost:8080/\"); } public static void main(String[] args) throws URISyntaxException { try { new NewRelicApiExample(); } catch (IOException ioe) { System.err.println(\"Unable to start the server:\\n\" + ioe); } } Copy Start tracing a transaction with the Java agent using @Trace annotation This method creates a sample database, sleeps the thread, and makes an external call to the server app listening on port 8081. The @Trace(dispatcher = true) annotation tells the agent to start a new transaction when the serve method is called, if it is not called as part of an existing transaction (and in this case, it is not). If it were called as part of an existing transaction, it would simply be included as part of that transaction rather than start a new one. @Trace(dispatcher = true) @Override public Response serve(IHTTPSession session) { URI uri = null; int status = 0; try { createDB(); Thread.sleep(1000); uri = new URI(\"http://localhost:8081\"); status = makeExternalCall(uri); } catch (URISyntaxException | InterruptedException | IOException e) { e.printStackTrace(); } if (status == 200) { return newFixedLengthResponse(\"<html><body><h1>Successful Response</h1>\\n</body></html>\\n\"); } else { return newFixedLengthResponse(\"<html><body><h1>Error\\n\" + status + \"</h1>\\n</body></html>\\n\"); } } Copy Make an external call using the Java agent API This section contains the code that initiates cross application tracing to the application making the request. The @Trace annotation tells the agent to track this method as part of an existing transaction as started by the serve method. The request object is wrapped by a class that implements the Java agent API's OutboundHeaders interface, which ensures that the proper HeaderType is set (in this case HTTP). A call to addOutboundRequestHeaders adds the headers to the request and the request is sent to the server. When the response returns it is wrapped by a class implementing the Java agent API's InboundHeaders interface. The inboundHeaders, along with the \"library\", URI, and \"procedure\" arguments, are used to build an HttpParameters object. The params object is then passed as an argument to the reportAsExternal method, which reports the TracedMethod as an external HTTP call. @Trace public int makeExternalCall(URI uri) throws IOException { HttpUriRequest request = RequestBuilder.get().setUri(uri).build(); // Wrap the outbound Request object OutboundWrapper outboundHeaders = new OutboundWrapper(request); // Obtain a reference to the method currently being traced TracedMethod tracedMethod = NewRelic.getAgent().getTracedMethod(); // Add headers for outbound external request tracedMethod.addOutboundRequestHeaders(outboundHeaders); CloseableHttpClient connection = HttpClientBuilder.create().build(); CloseableHttpResponse response = connection.execute(request); // Wrap the incoming Response object InboundWrapper inboundHeaders = new InboundWrapper(response); // Create an input parameter object for a call to an external HTTP service ExternalParameters params = HttpParameters .library(\"HttpClient\") .uri(uri) .procedure(\"execute\") .inboundHeaders(inboundHeaders) .build(); // Report a call to an external HTTP service tracedMethod.reportAsExternal(params); return response.getStatusLine().getStatusCode(); } Copy Implement the Java agent API's OutboundHeaders Interface An implementation of the Java agent API's OutboundHeaders Interface is used to wrap the request object of the client server, which in this example is of type HttpUriRequest. The request is passed into the constructor of the OutboundWrapper class and implementations of the setHeader and getHeaderType methods are provided. The getHeaderType method returns a HeaderType enum that can either be HeaderType.HTTP or HeaderType.MESSAGE, as defined by the Java agent API. In this example the external call protocol is HTTP, so HeaderType.HTTP is returned. // Implement OutboundHeaders interface to create a wrapper for the outgoing Request headers class OutboundWrapper implements OutboundHeaders { private final HttpUriRequest delegate; public OutboundWrapper(HttpUriRequest request) { this.delegate = request; } @Override public void setHeader(String name, String value) { delegate.addHeader(name, value); } @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } } Copy Implement the Java agent API's InboundHeaders Interface An implementation of the Java agent API's InboundHeaders Interface is used to wrap the response object returned to the client server, which in this example is of type CloseableHttpResponse. The response is passed into the constructor of the InboundWrapper class, where implementations of the getHeaderType and getHeader methods are provided. The getHeaderType method returns a HeaderType enum that can either be HeaderType.HTTP or HeaderType.MESSAGE, as defined by the Java agent API. In this example the external call protocol is HTTP so HeaderType.HTTP is returned. // Implement InboundHeaders interface to create a wrapper for the incoming Response headers class InboundWrapper implements InboundHeaders { private final CloseableHttpResponse responseHeaders; public InboundWrapper(CloseableHttpResponse requestHeaders) { this.responseHeaders = requestHeaders; } @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } @Override public String getHeader(String name) { return responseHeaders.getFirstHeader(name).getValue(); } } Copy Create a simple database This method simply creates an example SQLite database. The @Trace annotation tells the agent to track this method as part of an existing transaction as started by the serve method. @Trace public void createDB() { Connection c = null; Statement stmt = null; try { Class.forName(\"org.sqlite.JDBC\"); c = DriverManager.getConnection(\"jdbc:sqlite:/tmp/test.db\"); System.out.println(\"Opened database successfully\"); stmt = c.createStatement(); String dropSql = \"DROP TABLE IF EXISTS COMPANY;\"; stmt.executeUpdate(dropSql); String sql = \"CREATE TABLE COMPANY \" + \"(ID INT PRIMARY KEY NOT NULL,\" + \" NAME TEXT NOT NULL, \" + \" AGE INT NOT NULL, \" + \" ADDRESS CHAR(50), \" + \" SALARY REAL)\"; stmt.executeUpdate(sql); sql = \"INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) \" + \"VALUES (1, 'Paul', 32, 'California', 20000.00 );\"; stmt.executeUpdate(sql); sql = \"INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) \" + \"VALUES (2, 'Allen', 25, 'Texas', 15000.00 );\"; stmt.executeUpdate(sql); sql = \"INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) \" + \"VALUES (3, 'Teddy', 23, 'Norway', 20000.00 );\"; stmt.executeUpdate(sql); sql = \"INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) \" + \"VALUES (4, 'Mark', 25, 'Rich-Mond ', 65000.00 );\"; stmt.executeUpdate(sql); stmt.close(); c.close(); } catch (Exception e) { System.err.println(e.getClass().getName() + \": \" + e.getMessage()); System.exit(0); } } Copy Server-side example Here is the server-side code for this example application: Complete server example code package com.newrelic.example; import java.io.IOException; import java.net.URISyntaxException; import java.sql.Connection; import java.sql.DriverManager; import java.sql.ResultSet; import java.sql.Statement; import java.util.Collections; import java.util.Enumeration; // New Relic API imports import com.newrelic.api.agent.DatastoreParameters; import com.newrelic.api.agent.ExtendedRequest; import com.newrelic.api.agent.HeaderType; import com.newrelic.api.agent.NewRelic; import com.newrelic.api.agent.Trace; import com.newrelic.api.agent.TracedMethod; import com.newrelic.api.agent.Transaction; import fi.iki.elonen.NanoHTTPD; public class NewRelicApiServer extends NanoHTTPD { public NewRelicApiServer() throws IOException, URISyntaxException { super(8081); // Set Dispatcher name and version NewRelic.setServerInfo(\"NanoHttp\", \"2.3.1\"); // Set Appserver port for jvm identification NewRelic.setAppServerPort(8081); // Set JVM instance name NewRelic.setInstanceName(\"Server\"); start(NanoHTTPD.SOCKET_READ_TIMEOUT, false); System.out.println(\"\\nRunning on http://localhost:8081/ \\n\"); } public static void main(String[] args) throws URISyntaxException { try { new NewRelicApiServer(); } catch (IOException ioe) { System.err.println(\"Unable to start the server:\\n\" + ioe); } } @Trace(dispatcher = true) @Override public Response serve(IHTTPSession session) { // Obtain a reference to the current Transaction Transaction tx = NewRelic.getAgent().getTransaction(); // Set the name of the current transaction NewRelic.setTransactionName(\"Custom\", \"ExternalHTTPServer\"); // Wrap the Request object ExtendedRequest req = new RequestWrapper(session); // Set the request for the current transaction and convert it into a web transaction tx.setWebRequest(req); queryDB(); Response res = newFixedLengthResponse(\"<html><body><h1>SuccessfulResponse</h1>\\n</body></html>\\n\"); // Set the response for the current transaction and convert it into a web transaction tx.setWebResponse(new ResponseWrapper(res)); // Instruct the transaction to write the outbound response headers tx.addOutboundResponseHeaders(); // Mark the time when the response left the server tx.markResponseSent(); return res; } // Implement Response interface to create a wrapper for the outgoing Response object public class ResponseWrapper implements com.newrelic.api.agent.Response { private final Response httpResponse; public ResponseWrapper(Response httpResponse) { this.httpResponse = httpResponse; } @Override public int getStatus() throws Exception { return 200; } @Override public String getStatusMessage() throws Exception { return null; } @Override public void setHeader(String name, String value) { httpResponse.addHeader(name, value); } @Override public String getContentType() { return \"\"; } @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } } // Extend ExtendedRequest class to create a wrapper for the Request object class RequestWrapper extends ExtendedRequest { private IHTTPSession session; public RequestWrapper(IHTTPSession session) { super(); this.session = session; } @Override public String getRequestURI() { return session.getUri(); } @Override public String getHeader(String name) { return session.getHeaders().get(name.toLowerCase()); } @Override public String getRemoteUser() { return null; } @SuppressWarnings(\"rawtypes\") @Override public Enumeration getParameterNames() { return Collections.enumeration(session.getParms().keySet()); } @Override public String[] getParameterValues(String name) { return new String[]{session.getParms().get(name)}; } @Override public Object getAttribute(String name) { return null; } @Override public String getCookieValue(String name) { return null; } @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } @Override public String getMethod() { return session.getMethod().toString(); } } @Trace public void queryDB() { Connection c = null; Statement stmt = null; try { Class.forName(\"org.sqlite.JDBC\"); c = DriverManager.getConnection(\"jdbc:sqlite:/tmp/test.db\"); c.setAutoCommit(false); System.out.println(\"Opened database successfully\"); stmt = c.createStatement(); ResultSet rs = stmt.executeQuery(\"SELECT * FROM COMPANY;\"); while (rs.next()) { int id = rs.getInt(\"id\"); String name = rs.getString(\"name\"); int age = rs.getInt(\"age\"); String address = rs.getString(\"address\"); float salary = rs.getFloat(\"salary\"); System.out.println(\"ID = \" + id); System.out.println(\"NAME = \" + name); System.out.println(\"AGE = \" + age); System.out.println(\"ADDRESS = \" + address); System.out.println(\"SALARY = \" + salary); System.out.println(); } rs.close(); stmt.close(); c.close(); } catch (Exception e) { System.err.println(e.getClass().getName() + \": \" + e.getMessage()); System.exit(0); } // Obtain a reference to the method currently being traced TracedMethod method = NewRelic.getAgent().getTracedMethod(); // Create a DatastoreParameters object and report a call to an external datastore service method.reportAsExternal( DatastoreParameters .product(\"sqlite\") .collection(\"test.db\") .operation(\"select\") .instance(\"localhost\", 8080) .databaseName(\"test.db\") .build()); } } Copy Here is the same example server code broken into sections that describe how the API is used: Import Java agent API classes This section shows the relevant Java agent API imports needed to add cross application tracing and reporting of external datastore calls to the server application. import java.io.IOException; import java.net.URISyntaxException; import java.sql.Connection; import java.sql.DriverManager; import java.sql.ResultSet; import java.sql.Statement; import java.util.Collections; import java.util.Enumeration; // New Relic API imports import com.newrelic.api.agent.DatastoreParameters; import com.newrelic.api.agent.ExtendedRequest; import com.newrelic.api.agent.HeaderType; import com.newrelic.api.agent.NewRelic; import com.newrelic.api.agent.Trace; import com.newrelic.api.agent.TracedMethod; import com.newrelic.api.agent.Transaction; import fi.iki.elonen.NanoHTTPD; Copy Start the server and set its info as displayed in UI This section starts up the server on port 8081 and uses the NewRelic class from the API to call the methods setServerInfo, setAppServerPort, and setInstanceName. These API calls affect what is shown in the APM UI. public NewRelicApiServer() throws IOException, URISyntaxException { super(8081); // Set Dispatcher name and version NewRelic.setServerInfo(\"NanoHttp\", \"2.3.1\"); // Set Appserver port for jvm identification NewRelic.setAppServerPort(8081); // Set JVM instance name NewRelic.setInstanceName(\"Server\"); start(NanoHTTPD.SOCKET_READ_TIMEOUT, false); System.out.println(\"\\nRunning on http://localhost:8081/ \\n\"); } public static void main(String[] args) throws URISyntaxException { try { new NewRelicApiServer(); } catch (IOException ioe) { System.err.println(\"Unable to start the server:\\n\" + ioe); } } Copy Start tracing a transaction and add outbound Response headers The @Trace(dispatcher = true) annotation tells the agent to start a new transaction when the serve method is called if it is not called as part of an existing transaction (which in this case, it is not). If it were called as part of an existing transaction, it would simply be included as part of that transaction rather than start a new one. A reference to the current Transaction is obtained via a call to getTransaction and the name of the transaction is set via a call to the setTransactionName method. The request object, which in this example is of type IHTTPSession, is then wrapped using a class extending the Java agent API's ExtendedRequest class. The current Transaction is then converted to a web transaction via a call to setWebRequest which takes the wrapped ExtendedRequest as an argument. A call to the database is then made and the response object is generated and wrapped by a class implementing the Java agent API's Response interface. The wrapped response object is passed as an argument to setWebResponse which converts the current Transaction into a web transaction. Once the web request and response are set, a call to addOutboundResponseHeaders adds the headers to the response. This must be called after setWebRequest and setWebResponse, which together provide the agent with the inbound request headers and a place to record the outbound headers. A call to markResponseSent marks the time when the last byte of the response left the server as the current timestamp. @Trace(dispatcher = true) @Override public Response serve(IHTTPSession session) { // Obtain a reference to the current Transaction Transaction tx = NewRelic.getAgent().getTransaction(); // Set the name of the current transaction NewRelic.setTransactionName(\"Custom\", \"ExternalHTTPServer\"); // Wrap the Request object ExtendedRequest req = new RequestWrapper(session); // Set the request for the current transaction and convert it into a web transaction tx.setWebRequest(req); queryDB(); Response res = newFixedLengthResponse(\"<html><body><h1>SuccessfulResponse</h1>\\n</body></html>\\n\"); // Set the response for the current transaction and convert it into a web transaction tx.setWebResponse(new ResponseWrapper(res)); // Instruct the transaction to write the outbound response headers tx.addOutboundResponseHeaders(); // Mark the time when the response left the server tx.markResponseSent(); return res; } Copy Implement the Java agent API's Response Interface An implementation of the Java agent API's Response Interface is used to wrap the response object of the server, which in this example is of type fi.iki.elonen.NanoHTTPD.Response. The response is passed into the constructor of the ResponseWrapper class and implementations of the getStatus, getStatusMessage, setHeader, getContentType and getHeaderType methods are provided. The getHeaderType method returns a HeaderType enum that can either be HeaderType.HTTP or HeaderType.MESSAGE, as defined by the Java agent API. In this example the external call protocol is HTTP, so HeaderType.HTTP is returned. // Implement Response interface to create a wrapper for the outgoing Response object public class ResponseWrapper implements com.newrelic.api.agent.Response { private final Response httpResponse; public ResponseWrapper(Response httpResponse) { this.httpResponse = httpResponse; } @Override public int getStatus() throws Exception { return 200; } @Override public String getStatusMessage() throws Exception { return null; } @Override public void setHeader(String name, String value) { httpResponse.addHeader(name, value); } @Override public String getContentType() { return \"\"; } @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } } Copy Extend the Java agent API's ExtendedRequest class A subclass of the Java agent API's ExtendedRequest class is used to wrap the request object of the server, which in this example is of type IHTTPSession. The request is passed into the constructor of the RequestWrapper class, which provides implementations of the getRequestURI, getHeader, getRemoteUser, getParameterNames, getParameterValues, getAttribute, getCookieValue, getHeaderType, and getMethod methods. The getHeaderType method returns a HeaderType enum that can either be HeaderType.HTTP or HeaderType.MESSAGE, as defined by the Java agent API. In this example the external call protocol is HTTP so HeaderType.HTTP is returned. // Extend ExtendedRequest class to create a wrapper for the Request object class RequestWrapper extends ExtendedRequest { private IHTTPSession session; public RequestWrapper(IHTTPSession session) { super(); this.session = session; } @Override public String getRequestURI() { return session.getUri(); } @Override public String getHeader(String name) { return session.getHeaders().get(name.toLowerCase()); } @Override public String getRemoteUser() { return null; } @SuppressWarnings(\"rawtypes\") @Override public Enumeration getParameterNames() { return Collections.enumeration(session.getParms().keySet()); } @Override public String[] getParameterValues(String name) { return new String[]{session.getParms().get(name)}; } @Override public Object getAttribute(String name) { return null; } @Override public String getCookieValue(String name) { return null; } @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } @Override public String getMethod() { return session.getMethod().toString(); } } Copy Instrument an external call to a datastore This method makes an external call to the SQLite database that is created by the client. The @Trace annotation tells the agent to track this method as part of an existing transaction as started by the serve method. A reference to the current TracedMethod is obtained via a call to getTracedMethod. A DatastoreParameters object is then created using the builder pattern. The ExternalParameters object is then passed as an argument to the reportAsExternal method, which has the effect of reporting the TracedMethod as an external datastore call. @Trace public void queryDB() { Connection c = null; Statement stmt = null; try { Class.forName(\"org.sqlite.JDBC\"); c = DriverManager.getConnection(\"jdbc:sqlite:/tmp/test.db\"); c.setAutoCommit(false); System.out.println(\"Opened database successfully\"); stmt = c.createStatement(); ResultSet rs = stmt.executeQuery(\"SELECT * FROM COMPANY;\"); while (rs.next()) { int id = rs.getInt(\"id\"); String name = rs.getString(\"name\"); int age = rs.getInt(\"age\"); String address = rs.getString(\"address\"); float salary = rs.getFloat(\"salary\"); System.out.println(\"ID = \" + id); System.out.println(\"NAME = \" + name); System.out.println(\"AGE = \" + age); System.out.println(\"ADDRESS = \" + address); System.out.println(\"SALARY = \" + salary); System.out.println(); } rs.close(); stmt.close(); c.close(); } catch (Exception e) { System.err.println(e.getClass().getName() + \": \" + e.getMessage()); System.exit(0); } // Obtain a reference to the method currently being traced TracedMethod method = NewRelic.getAgent().getTracedMethod(); // Create a DatastoreParameters object and report a call to an external datastore service method.reportAsExternal( DatastoreParameters .product(\"sqlite\") .collection(\"test.db\") .operation(\"select\") .instance(\"localhost\", 8080) .databaseName(\"test.db\") .build()); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.44469,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> <em>API</em>: Instrumenting example app for external datastore calls and CAT",
        "sections": "<em>Java</em> <em>agent</em> <em>API</em>: Instrumenting example app for external datastore calls and CAT",
        "tags": "<em>API</em> <em>guides</em>",
        "body": "This document demonstrates using the New Relic <em>Java</em> <em>agent</em> <em>API</em> to instrument a simple client and server application. The instrumentation has these goals: To record external HTTP and datastore transactions. To link external transactions between two applications running New Relic <em>agents</em> (known"
      },
      "id": "6043d431196a67294f960f54"
    }
  ],
  "/docs/agents/java-agent/api-guides/java-agent-api-instrument-external-calls-messaging-datastore-web-frameworks": [
    {
      "sections": [
        "Java agent API: Custom instrumentation with annotation of an example app",
        "Important",
        "Complete example app using API",
        "Tip",
        "Complete API call example",
        "How the example uses the API",
        "Import the needed packages",
        "Set @Trace for transaction traces",
        "Create custom names for web transactions",
        "Bypass Apdex when collecting non-public data",
        "Record the user ID",
        "Collect promotion data",
        "Send instructions to the handler",
        "Include page load timing code in the HTTP response",
        "Complete the HTTP response"
      ],
      "title": "Java agent API: Custom instrumentation with annotation of an example app",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "a6a2aadf63f8282b7d599579f67010fbd600d183",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/java-agent-api-custom-instrumentation-annotation-example-app/",
      "published_at": "2021-05-05T07:03:35Z",
      "updated_at": "2021-03-16T14:30:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you set up custom instrumentation for your Java application. This document shows an example of using custom instrumentation with annotation in an imaginary application. Important For best results when using the API, ensure you have the latest Java agent release. Complete example app using API Below is an example of an imaginary store app's servlet using the Java agent API. Tip If you copy and paste example code, be sure to use appropriate spacing on your command lines. Complete API call example package test; import java.io.IOException; import java.io.PrintWriter; import java.util.Random; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; // Java agent API imports import com.newrelic.api.agent.NewRelic; import com.newrelic.api.agent.Trace; public class TestServlet extends HttpServlet { // instrumentation via annotation @Trace(dispatcher = true) protected void processRequest(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { saveNewRelicInfo(req); doRequestWork(req); writeResponse(resp); } private void saveNewRelicInfo(HttpServletRequest req) { String storeId = req.getParameter(\"storeId\"); if (storeId != null) { // set the name of the Transaction NewRelic.setTransactionName(null, \"/store\"); if (storeId.equals(\"betaStore\")) { // prevent the method from contributing to the Apdex score NewRelic.ignoreApdex(); } } String userId = req.getParameter(\"userId\"); if (userId != null) { // set the user name to associate with the RUM JavaScript footer // for the current web transaction NewRelic.setUserName(userId); // add a key/value pair to the current transaction NewRelic.addCustomParameter(\"userId\", userId); } String promotionId = req.getParameter(\"promotionId\"); if (promotionId != null) { // increment the metric counter for the given name NewRelic.incrementCounter(\"Custom/Promotion\"); } } protected void doRequestWork(HttpServletRequest req) { try { long millisToSleep = new Random().nextInt(5000); Thread.sleep(millisToSleep); // record a response time in milliseconds for the given metric name NewRelic.recordResponseTimeMetric(\"Custom/RandomSleep\", millisToSleep); } catch (InterruptedException e) { // report a handled exception NewRelic.noticeError(e, false); } } protected void writeResponse(HttpServletResponse resp) throws IOException { resp.setContentType(\"text/html;charset=UTF-8\"); PrintWriter out = resp.getWriter(); out.println(\"<html>\"); out.println(\"<head>\"); // get the RUM JavaScript header for the current web transaction out.println(NewRelic.getBrowserTimingHeader()); out.println(\"<title>NewRelic API example servlet</title>\"); out.println(\"</head>\"); out.println(\"<body>\"); out.println(\"<h1>API example</h1>\"); // get the RUM JavaScript footer for the current web transaction out.println(NewRelic.getBrowserTimingFooter()); out.println(\"</body>\"); out.println(\"</html>\"); out.close(); } protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { processRequest(req, resp); } protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { processRequest(req, resp); } } Copy How the example uses the API Here is the same example app divided into sections that describe how the API is used: Import the needed packages This part of the example shows the imports needed for the example application and Java agent API. package test; import java.io.IOException; import java.io.PrintWriter; import java.util.Random; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; // Java agent API imports import com.newrelic.api.agent.NewRelic; import com.newrelic.api.agent.Trace; Copy Set @Trace for transaction traces This part of the API call provides instructions to instrument this call using New Relic's trace annotation @Trace. Any requests that hit processRequest will now show a segment in APM's Transaction trace call chart. public class TestServlet extends HttpServlet { // instrumentation via annotation @Trace(dispatcher = true) protected void processRequest(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { saveNewRelicInfo(req); doRequestWork(req); writeResponse(resp); } Copy Create custom names for web transactions This part of the API call instructs web transactions containing a storeId value to appear in APM's Transactions page with the custom transaction name you set. A request to any one store will appear under the same, aggregate name. private void saveNewRelicInfo(HttpServletRequest req) { String storeId = req.getParameter(\"storeId\"); if (storeId != null) { // set the name of the Transaction NewRelic.setTransactionName(null, \"/store\"); } } Copy Bypass Apdex when collecting non-public data This part of the API call excludes the non-public beta storeID from affecting the Apdex score. if (storeId.equals(\"betaStore\")) { // prevent the method from contributing to the Apdex score NewRelic.ignoreApdex(); } Copy Record the user ID This part of the API call inserts additional metadata into the page load timing request so that browser traces can be tied with the userId. It also records the userId as a custom parameter on the transaction so that it appears in the parameter details of a transaction trace. (Page load timing sometimes is referred to as real user monitoring or RUM.) String userId = req.getParameter(\"userId\"); if (userId != null) { // set the user name to associate with the RUM JavaScript footer // for the current web transaction NewRelic.setUserName(userId); // add a key/value pair to the current transaction NewRelic.addCustomParameter(\"userId\", userId); } Copy Collect promotion data This part of the API call records the number of times a promotion was viewed so that the metrics can appear on a custom dashboard. Important For metrics you want to graph in custom dashboards, be sure to prepend Custom/ to the metric name; for example, Custom/Promotion. String promotionId = req.getParameter(\"promotionId\"); if (promotionId != null) { // increment the metric counter for the given name NewRelic.incrementCounter(\"Custom/Promotion\"); } Copy Send instructions to the handler This part of the API call sends a set of instructions to the handler for processing requests and handling exceptions. protected void doRequestWork(HttpServletRequest req) { try { long millisToSleep = new Random().nextInt(5000); Thread.sleep(millisToSleep); // record a response time in milliseconds for the given metric name NewRelic.recordResponseTimeMetric(\"Custom/RandomSleep\", millisToSleep); } catch (InterruptedException e) { // report a handled exception NewRelic.noticeError(e, false); } } protected void writeResponse(HttpServletResponse resp) throws IOException { Copy Include page load timing code in the HTTP response This part of the API call defines what to include in the HttpServletResponse. For manual instrumentation of Browser monitoring to monitor page load timing (sometimes referred to as real user monitoring or RUM): Set the header after the < head> tag. Set the footer at the end of < body> tag. resp.setContentType(\"text/html;charset=UTF-8\"); PrintWriter out = resp.getWriter(); out.println(\"<html>\"); out.println(\"<head>\"); // get the RUM JavaScript header for the current web transaction out.println(NewRelic.getBrowserTimingHeader()); out.println(\"<title>NewRelic API example servlet</title>\"); out.println(\"</head>\"); out.println(\"<body>\"); out.println(\"<h1>API example</h1>\"); // get the RUM JavaScript footer for the current web transaction out.println(NewRelic.getBrowserTimingFooter()); out.println(\"</body>\"); out.println(\"</html>\"); out.close(); } Copy Complete the HTTP response This part of the API call defines the remaining information to include in the HttpServletResponse response. protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { processRequest(req, resp); } protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { processRequest(req, resp); } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.81137,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> <em>API</em>: Custom instrumentation with annotation of an example app",
        "sections": "<em>Java</em> <em>agent</em> <em>API</em>: Custom instrumentation with annotation of an example app",
        "tags": "<em>API</em> <em>guides</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> <em>API</em> lets you set up custom instrumentation for your <em>Java</em> application. This document shows an example of using custom instrumentation with annotation in an imaginary application. Important For best results when using the <em>API</em>, ensure you have the latest <em>Java</em> <em>agent</em> release"
      },
      "id": "603eb76a64441f48424e886b"
    },
    {
      "sections": [
        "Java agent API: Instrument using annotation",
        "Important",
        "Configure your agent for annotations",
        "Tip",
        "Create a new transaction",
        "Add detail to your transactions",
        "Convert a transaction to a web request",
        "Define your own @Trace annotation class",
        "Properties for @Trace",
        "dispatcher",
        "async",
        "metricName",
        "excludeFromTransactionTrace",
        "leaf",
        "More API functions"
      ],
      "title": "Java agent API: Instrument using annotation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "4a373504c0682b36745d2283fdd902ead43510ec",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/java-agent-api-instrument-using-annotation/",
      "published_at": "2021-05-05T06:57:49Z",
      "updated_at": "2021-03-16T04:31:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent provides several options for custom instrumentation. One of those options is adding the Java agent API's @Trace annotations to your application code. This document describes how to use annotations. Important To use annotations, you must modify the source code. If you can't or don't want to modify your source code, see Custom instrumentation for other instrumentation options. Configure your agent for annotations By default, the configuration setting enable_custom_tracing is set to true in the Java agent, which is the setting required for @Trace annotations to function. This setting is not included in the newrelic.yml by default. The only time you need to incorporate this setting into your configuration file is if you want to disable @Trace annotations altogether. To do this, set enable_custom_tracing: false (prefaced with two spaces) in the common stanza of your newrelic.yml. To detect custom traces: Make sure that newrelic-api.jar appears in your classpath. Add @Trace annotations to your code. In each class containing a method you want to instrument, call: import com.newrelic.api.agent.Trace; Copy Place the @Trace annotation on each target method. Tip The annotation com.newrelic.api.agent.Trace is located in the newrelic-api.jar. Create a new transaction If transactions do not appear and you want to start a new transaction, include dispatcher=true with the @Trace annotation: @Trace (dispatcher=true) public void run() { // background task } Copy Add detail to your transactions If your transaction traces show large blocks of uninstrumented time and you want to include some more methods within the trace, you can use the @Trace annotation without parameters: @Trace protected void methodWithinTransaction() { // work } Copy Convert a transaction to a web request To make a background task report as a web browser transaction with a Java agent API call: In the method annotated with @Trace(dispatcher=true), call: NewRelic.setRequestAndResponse(Request request, Response response) Copy The arguments are implementations of the Request and Response interfaces in newrelic-api.jar. Important Even if your Request and Response objects already are present, you still need to add this API call. Define your own @Trace annotation class If you define your own @Trace annotation class, there is no dependency on the newrelic-api.jar. To define the class: package com.test; @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Trace { public static final String NULL = \"\"; String metricName() default NULL; boolean dispatcher() default false; String tracerFactoryName() default NULL; } Copy Then, configure the agent to use this annotation in the common section of the newrelic.yml: class_transformer: trace_annotation_class_name: com.test.Trace Copy Properties for @Trace The @Trace annotation supports the following properties. dispatcher Type: Boolean Default: false If true, the agent will start a transaction when it reaches a method with this @Trace annotation if a transaction is not already in progress. If a transaction is already in progress, the method with this annotation will be included in the ongoing transaction, rather than starting a new one. If false (default), no metrics will be recorded if the agent has not started a transaction before the @Trace annotation is reached. For example: @Trace(dispatcher=true) Copy async Type: Boolean Default: false If true, this method is marked as asynchronous and the agent will trace this method if it linked to an existing transaction. For example: @Trace(async=true) Copy If false (default), the method is not marked as asynchronous. If other @Trace annotations are present and the method is not executing asynchronously, it will still be traced. metricName Type: String Default: (none) This property affects transaction traces and error reporting. By default, the metric name will include the class name followed by the method name. If you do not want class followed by method, then you can use this property to change the metric name. If you set the metricName, as in @Trace(metricName=\"YourMessageHere\"), then the time spent in this method will appear as YourMessageHere in any transaction trace. If you set the metricName in addition to the dispatcher, as in @Trace(metricName=\"YourMessageHere\", dispatcher=true), then the transaction name will appear as YourMessageHere in the APM Transactions page but the time spent in this method will not appear as YourMessageHere in any transaction trace. Here is an example: @Trace(metricName=\"YourMetricName\") Copy Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. excludeFromTransactionTrace Type: Boolean Default: false If true, the method will be excluded from the transaction trace. The agent will still collect metrics for the method. Here is an example: @Trace(excludeFromTransactionTrace=true) Copy leaf Type: Boolean Default: false A leaf tracer has no child tracers. This is useful when you want all time attributed to the tracer, even if other trace points are encountered the tracer's execution. Database tracers often act as a leaf so that all time is attributed to database activity, even if instrumented external calls are made. Here is an example: @Trace(leaf=true) Copy If a leaf tracer does not participate in transaction traces, the agent can create a tracer with lower overhead. Here is an example: @Trace(excludeFromTransactionTrace=true, leaf=true) Copy More API functions For more about the Java agent API and its functionality, see the Java agent API introduction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.698456,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> <em>API</em>: Instrument using annotation",
        "sections": "<em>Java</em> <em>agent</em> <em>API</em>: Instrument using annotation",
        "tags": "<em>API</em> <em>guides</em>",
        "body": "New Relic&#x27;s <em>Java</em> <em>agent</em> provides several options for custom instrumentation. One of those options is adding the <em>Java</em> <em>agent</em> <em>API</em>&#x27;s @Trace annotations to your application code. This document describes how to use annotations. Important To use annotations, you must modify the source code. If you can&#x27;t"
      },
      "id": "603eb64a28ccbc9ca2eba79f"
    },
    {
      "sections": [
        "Java agent API: Instrumenting example app for external datastore calls and CAT",
        "Important",
        "Client-side example",
        "Complete client example code",
        "Import Java agent API classes",
        "Start the client and set environment details as displayed in the UI",
        "Start tracing a transaction with the Java agent using @Trace annotation",
        "Make an external call using the Java agent API",
        "Implement the Java agent API's OutboundHeaders Interface",
        "Implement the Java agent API's InboundHeaders Interface",
        "Create a simple database",
        "Server-side example",
        "Complete server example code",
        "Start the server and set its info as displayed in UI",
        "Start tracing a transaction and add outbound Response headers",
        "Implement the Java agent API's Response Interface",
        "Extend the Java agent API's ExtendedRequest class",
        "Instrument an external call to a datastore"
      ],
      "title": "Java agent API: Instrumenting example app for external datastore calls and CAT",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "8e1b18952dde913071d4d5ef121d51e7efc5629b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/java-agent-api-instrumenting-example-app-external-datastore-calls-cat/",
      "published_at": "2021-05-05T07:03:40Z",
      "updated_at": "2021-03-11T03:24:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document demonstrates using the New Relic Java agent API to instrument a simple client and server application. The instrumentation has these goals: To record external HTTP and datastore transactions. To link external transactions between two applications running New Relic agents (known as cross application tracing or CAT). See the Java agent API Javadoc for full descriptions of the available API classes and methods. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 3.36.0 or higher. Client-side example Here is an example of the client-side code for a simple client-server application: Complete client example code package com.newrelic.example; import java.io.IOException; import java.net.URI; import java.net.URISyntaxException; import java.sql.Connection; import java.sql.DriverManager; import java.sql.Statement; // New Relic API imports import com.newrelic.api.agent.ExternalParameters; import com.newrelic.api.agent.HeaderType; import com.newrelic.api.agent.HttpParameters; import com.newrelic.api.agent.InboundHeaders; import com.newrelic.api.agent.NewRelic; import com.newrelic.api.agent.OutboundHeaders; import com.newrelic.api.agent.Trace; import com.newrelic.api.agent.TracedMethod; import fi.iki.elonen.NanoHTTPD; import org.apache.http.client.methods.CloseableHttpResponse; import org.apache.http.client.methods.HttpUriRequest; import org.apache.http.client.methods.RequestBuilder; import org.apache.http.impl.client.CloseableHttpClient; import org.apache.http.impl.client.HttpClientBuilder; public class NewRelicApiExample extends NanoHTTPD { public NewRelicApiExample() throws IOException, URISyntaxException { super(8080); // Set Dispatcher name and version NewRelic.setServerInfo(\"NanoHttp\", \"2.3.1\"); // Set Appserver port for JVM identification NewRelic.setAppServerPort(8080); // Set JVM instance name NewRelic.setInstanceName(\"Client\"); start(NanoHTTPD.SOCKET_READ_TIMEOUT, false); System.out.println(\"Running at: http://localhost:8080/\"); } public static void main(String[] args) throws URISyntaxException { try { new NewRelicApiExample(); } catch (IOException ioe) { System.err.println(\"Unable to start the server:\\n\" + ioe); } } @Trace(dispatcher = true) @Override public Response serve(IHTTPSession session) { URI uri = null; int status = 0; try { createDB(); Thread.sleep(1000); uri = new URI(\"http://localhost:8081\"); status = makeExternalCall(uri); } catch (URISyntaxException | InterruptedException | IOException e) { e.printStackTrace(); } if (status == 200) { return newFixedLengthResponse(\"<html><body><h1>Successful Response</h1>\\n</body></html>\\n\"); } else { return newFixedLengthResponse(\"<html><body><h1>Error\\n\" + status + \"</h1>\\n</body></html>\\n\"); } } @Trace public int makeExternalCall(URI uri) throws IOException { HttpUriRequest request = RequestBuilder.get().setUri(uri).build(); // Wrap the outbound Request object OutboundWrapper outboundHeaders = new OutboundWrapper(request); // Obtain a reference to the method currently being traced TracedMethod tracedMethod = NewRelic.getAgent().getTracedMethod(); // Add headers for outbound external request tracedMethod.addOutboundRequestHeaders(outboundHeaders); CloseableHttpClient connection = HttpClientBuilder.create().build(); CloseableHttpResponse response = connection.execute(request); // Wrap the incoming Response object InboundWrapper inboundHeaders = new InboundWrapper(response); // Create an input parameter object for a call to an external HTTP service ExternalParameters params = HttpParameters .library(\"HttpClient\") .uri(uri) .procedure(\"execute\") .inboundHeaders(inboundHeaders) .build(); // Report a call to an external HTTP service tracedMethod.reportAsExternal(params); return response.getStatusLine().getStatusCode(); } // Implement OutboundHeaders interface to create a wrapper for the outgoing Request headers class OutboundWrapper implements OutboundHeaders { private final HttpUriRequest delegate; public OutboundWrapper(HttpUriRequest request) { this.delegate = request; } @Override public void setHeader(String name, String value) { delegate.addHeader(name, value); } @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } } // Implement InboundHeaders interface to create a wrapper for the incoming Response headers class InboundWrapper implements InboundHeaders { private final CloseableHttpResponse responseHeaders; public InboundWrapper(CloseableHttpResponse requestHeaders) { this.responseHeaders = requestHeaders; } @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } @Override public String getHeader(String name) { return responseHeaders.getFirstHeader(name).getValue(); } } @Trace public void createDB() { Connection c = null; Statement stmt = null; try { Class.forName(\"org.sqlite.JDBC\"); c = DriverManager.getConnection(\"jdbc:sqlite:/tmp/test.db\"); System.out.println(\"Opened database successfully\"); stmt = c.createStatement(); String dropSql = \"DROP TABLE IF EXISTS COMPANY;\"; stmt.executeUpdate(dropSql); String sql = \"CREATE TABLE COMPANY \" + \"(ID INT PRIMARY KEY NOT NULL,\" + \" NAME TEXT NOT NULL, \" + \" AGE INT NOT NULL, \" + \" ADDRESS CHAR(50), \" + \" SALARY REAL)\"; stmt.executeUpdate(sql); sql = \"INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) \" + \"VALUES (1, 'Paul', 32, 'California', 20000.00 );\"; stmt.executeUpdate(sql); sql = \"INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) \" + \"VALUES (2, 'Allen', 25, 'Texas', 15000.00 );\"; stmt.executeUpdate(sql); sql = \"INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) \" + \"VALUES (3, 'Teddy', 23, 'Norway', 20000.00 );\"; stmt.executeUpdate(sql); sql = \"INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) \" + \"VALUES (4, 'Mark', 25, 'Rich-Mond ', 65000.00 );\"; stmt.executeUpdate(sql); stmt.close(); c.close(); } catch (Exception e) { System.err.println(e.getClass().getName() + \": \" + e.getMessage()); System.exit(0); } } } Copy Here is the same client app code divided into sections that describe how the API is used: Import Java agent API classes This section calls the Java agent API imports used to add cross application tracing to the client application later in the example code. import java.io.IOException; import java.net.URI; import java.net.URISyntaxException; import java.sql.Connection; import java.sql.DriverManager; import java.sql.Statement; // New Relic API imports import com.newrelic.api.agent.ExternalParameters; import com.newrelic.api.agent.HeaderType; import com.newrelic.api.agent.InboundHeaders; import com.newrelic.api.agent.NewRelic; import com.newrelic.api.agent.OutboundHeaders; import com.newrelic.api.agent.Trace; import com.newrelic.api.agent.TracedMethod; import fi.iki.elonen.NanoHTTPD; import org.apache.http.client.methods.CloseableHttpResponse; import org.apache.http.client.methods.HttpUriRequest; import org.apache.http.client.methods.RequestBuilder; import org.apache.http.impl.client.CloseableHttpClient; import org.apache.http.impl.client.HttpClientBuilder; Copy Start the client and set environment details as displayed in the UI This section starts up the client server on port 8080 and uses the NewRelic class from the API to call the methods setServerInfo, setAppServerPort, and setInstanceName. These API calls affect what is shown in the New Relic UI. public NewRelicApiExample() throws IOException, URISyntaxException { super(8080); // Set Dispatcher name and version NewRelic.setServerInfo(\"NanoHttp\", \"2.3.1\"); // Set Appserver port for jvm identification NewRelic.setAppServerPort(8080); // Set JVM instance name NewRelic.setInstanceName(\"Client\"); start(NanoHTTPD.SOCKET_READ_TIMEOUT, false); System.out.println(\"Running at: http://localhost:8080/\"); } public static void main(String[] args) throws URISyntaxException { try { new NewRelicApiExample(); } catch (IOException ioe) { System.err.println(\"Unable to start the server:\\n\" + ioe); } } Copy Start tracing a transaction with the Java agent using @Trace annotation This method creates a sample database, sleeps the thread, and makes an external call to the server app listening on port 8081. The @Trace(dispatcher = true) annotation tells the agent to start a new transaction when the serve method is called, if it is not called as part of an existing transaction (and in this case, it is not). If it were called as part of an existing transaction, it would simply be included as part of that transaction rather than start a new one. @Trace(dispatcher = true) @Override public Response serve(IHTTPSession session) { URI uri = null; int status = 0; try { createDB(); Thread.sleep(1000); uri = new URI(\"http://localhost:8081\"); status = makeExternalCall(uri); } catch (URISyntaxException | InterruptedException | IOException e) { e.printStackTrace(); } if (status == 200) { return newFixedLengthResponse(\"<html><body><h1>Successful Response</h1>\\n</body></html>\\n\"); } else { return newFixedLengthResponse(\"<html><body><h1>Error\\n\" + status + \"</h1>\\n</body></html>\\n\"); } } Copy Make an external call using the Java agent API This section contains the code that initiates cross application tracing to the application making the request. The @Trace annotation tells the agent to track this method as part of an existing transaction as started by the serve method. The request object is wrapped by a class that implements the Java agent API's OutboundHeaders interface, which ensures that the proper HeaderType is set (in this case HTTP). A call to addOutboundRequestHeaders adds the headers to the request and the request is sent to the server. When the response returns it is wrapped by a class implementing the Java agent API's InboundHeaders interface. The inboundHeaders, along with the \"library\", URI, and \"procedure\" arguments, are used to build an HttpParameters object. The params object is then passed as an argument to the reportAsExternal method, which reports the TracedMethod as an external HTTP call. @Trace public int makeExternalCall(URI uri) throws IOException { HttpUriRequest request = RequestBuilder.get().setUri(uri).build(); // Wrap the outbound Request object OutboundWrapper outboundHeaders = new OutboundWrapper(request); // Obtain a reference to the method currently being traced TracedMethod tracedMethod = NewRelic.getAgent().getTracedMethod(); // Add headers for outbound external request tracedMethod.addOutboundRequestHeaders(outboundHeaders); CloseableHttpClient connection = HttpClientBuilder.create().build(); CloseableHttpResponse response = connection.execute(request); // Wrap the incoming Response object InboundWrapper inboundHeaders = new InboundWrapper(response); // Create an input parameter object for a call to an external HTTP service ExternalParameters params = HttpParameters .library(\"HttpClient\") .uri(uri) .procedure(\"execute\") .inboundHeaders(inboundHeaders) .build(); // Report a call to an external HTTP service tracedMethod.reportAsExternal(params); return response.getStatusLine().getStatusCode(); } Copy Implement the Java agent API's OutboundHeaders Interface An implementation of the Java agent API's OutboundHeaders Interface is used to wrap the request object of the client server, which in this example is of type HttpUriRequest. The request is passed into the constructor of the OutboundWrapper class and implementations of the setHeader and getHeaderType methods are provided. The getHeaderType method returns a HeaderType enum that can either be HeaderType.HTTP or HeaderType.MESSAGE, as defined by the Java agent API. In this example the external call protocol is HTTP, so HeaderType.HTTP is returned. // Implement OutboundHeaders interface to create a wrapper for the outgoing Request headers class OutboundWrapper implements OutboundHeaders { private final HttpUriRequest delegate; public OutboundWrapper(HttpUriRequest request) { this.delegate = request; } @Override public void setHeader(String name, String value) { delegate.addHeader(name, value); } @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } } Copy Implement the Java agent API's InboundHeaders Interface An implementation of the Java agent API's InboundHeaders Interface is used to wrap the response object returned to the client server, which in this example is of type CloseableHttpResponse. The response is passed into the constructor of the InboundWrapper class, where implementations of the getHeaderType and getHeader methods are provided. The getHeaderType method returns a HeaderType enum that can either be HeaderType.HTTP or HeaderType.MESSAGE, as defined by the Java agent API. In this example the external call protocol is HTTP so HeaderType.HTTP is returned. // Implement InboundHeaders interface to create a wrapper for the incoming Response headers class InboundWrapper implements InboundHeaders { private final CloseableHttpResponse responseHeaders; public InboundWrapper(CloseableHttpResponse requestHeaders) { this.responseHeaders = requestHeaders; } @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } @Override public String getHeader(String name) { return responseHeaders.getFirstHeader(name).getValue(); } } Copy Create a simple database This method simply creates an example SQLite database. The @Trace annotation tells the agent to track this method as part of an existing transaction as started by the serve method. @Trace public void createDB() { Connection c = null; Statement stmt = null; try { Class.forName(\"org.sqlite.JDBC\"); c = DriverManager.getConnection(\"jdbc:sqlite:/tmp/test.db\"); System.out.println(\"Opened database successfully\"); stmt = c.createStatement(); String dropSql = \"DROP TABLE IF EXISTS COMPANY;\"; stmt.executeUpdate(dropSql); String sql = \"CREATE TABLE COMPANY \" + \"(ID INT PRIMARY KEY NOT NULL,\" + \" NAME TEXT NOT NULL, \" + \" AGE INT NOT NULL, \" + \" ADDRESS CHAR(50), \" + \" SALARY REAL)\"; stmt.executeUpdate(sql); sql = \"INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) \" + \"VALUES (1, 'Paul', 32, 'California', 20000.00 );\"; stmt.executeUpdate(sql); sql = \"INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) \" + \"VALUES (2, 'Allen', 25, 'Texas', 15000.00 );\"; stmt.executeUpdate(sql); sql = \"INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) \" + \"VALUES (3, 'Teddy', 23, 'Norway', 20000.00 );\"; stmt.executeUpdate(sql); sql = \"INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) \" + \"VALUES (4, 'Mark', 25, 'Rich-Mond ', 65000.00 );\"; stmt.executeUpdate(sql); stmt.close(); c.close(); } catch (Exception e) { System.err.println(e.getClass().getName() + \": \" + e.getMessage()); System.exit(0); } } Copy Server-side example Here is the server-side code for this example application: Complete server example code package com.newrelic.example; import java.io.IOException; import java.net.URISyntaxException; import java.sql.Connection; import java.sql.DriverManager; import java.sql.ResultSet; import java.sql.Statement; import java.util.Collections; import java.util.Enumeration; // New Relic API imports import com.newrelic.api.agent.DatastoreParameters; import com.newrelic.api.agent.ExtendedRequest; import com.newrelic.api.agent.HeaderType; import com.newrelic.api.agent.NewRelic; import com.newrelic.api.agent.Trace; import com.newrelic.api.agent.TracedMethod; import com.newrelic.api.agent.Transaction; import fi.iki.elonen.NanoHTTPD; public class NewRelicApiServer extends NanoHTTPD { public NewRelicApiServer() throws IOException, URISyntaxException { super(8081); // Set Dispatcher name and version NewRelic.setServerInfo(\"NanoHttp\", \"2.3.1\"); // Set Appserver port for jvm identification NewRelic.setAppServerPort(8081); // Set JVM instance name NewRelic.setInstanceName(\"Server\"); start(NanoHTTPD.SOCKET_READ_TIMEOUT, false); System.out.println(\"\\nRunning on http://localhost:8081/ \\n\"); } public static void main(String[] args) throws URISyntaxException { try { new NewRelicApiServer(); } catch (IOException ioe) { System.err.println(\"Unable to start the server:\\n\" + ioe); } } @Trace(dispatcher = true) @Override public Response serve(IHTTPSession session) { // Obtain a reference to the current Transaction Transaction tx = NewRelic.getAgent().getTransaction(); // Set the name of the current transaction NewRelic.setTransactionName(\"Custom\", \"ExternalHTTPServer\"); // Wrap the Request object ExtendedRequest req = new RequestWrapper(session); // Set the request for the current transaction and convert it into a web transaction tx.setWebRequest(req); queryDB(); Response res = newFixedLengthResponse(\"<html><body><h1>SuccessfulResponse</h1>\\n</body></html>\\n\"); // Set the response for the current transaction and convert it into a web transaction tx.setWebResponse(new ResponseWrapper(res)); // Instruct the transaction to write the outbound response headers tx.addOutboundResponseHeaders(); // Mark the time when the response left the server tx.markResponseSent(); return res; } // Implement Response interface to create a wrapper for the outgoing Response object public class ResponseWrapper implements com.newrelic.api.agent.Response { private final Response httpResponse; public ResponseWrapper(Response httpResponse) { this.httpResponse = httpResponse; } @Override public int getStatus() throws Exception { return 200; } @Override public String getStatusMessage() throws Exception { return null; } @Override public void setHeader(String name, String value) { httpResponse.addHeader(name, value); } @Override public String getContentType() { return \"\"; } @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } } // Extend ExtendedRequest class to create a wrapper for the Request object class RequestWrapper extends ExtendedRequest { private IHTTPSession session; public RequestWrapper(IHTTPSession session) { super(); this.session = session; } @Override public String getRequestURI() { return session.getUri(); } @Override public String getHeader(String name) { return session.getHeaders().get(name.toLowerCase()); } @Override public String getRemoteUser() { return null; } @SuppressWarnings(\"rawtypes\") @Override public Enumeration getParameterNames() { return Collections.enumeration(session.getParms().keySet()); } @Override public String[] getParameterValues(String name) { return new String[]{session.getParms().get(name)}; } @Override public Object getAttribute(String name) { return null; } @Override public String getCookieValue(String name) { return null; } @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } @Override public String getMethod() { return session.getMethod().toString(); } } @Trace public void queryDB() { Connection c = null; Statement stmt = null; try { Class.forName(\"org.sqlite.JDBC\"); c = DriverManager.getConnection(\"jdbc:sqlite:/tmp/test.db\"); c.setAutoCommit(false); System.out.println(\"Opened database successfully\"); stmt = c.createStatement(); ResultSet rs = stmt.executeQuery(\"SELECT * FROM COMPANY;\"); while (rs.next()) { int id = rs.getInt(\"id\"); String name = rs.getString(\"name\"); int age = rs.getInt(\"age\"); String address = rs.getString(\"address\"); float salary = rs.getFloat(\"salary\"); System.out.println(\"ID = \" + id); System.out.println(\"NAME = \" + name); System.out.println(\"AGE = \" + age); System.out.println(\"ADDRESS = \" + address); System.out.println(\"SALARY = \" + salary); System.out.println(); } rs.close(); stmt.close(); c.close(); } catch (Exception e) { System.err.println(e.getClass().getName() + \": \" + e.getMessage()); System.exit(0); } // Obtain a reference to the method currently being traced TracedMethod method = NewRelic.getAgent().getTracedMethod(); // Create a DatastoreParameters object and report a call to an external datastore service method.reportAsExternal( DatastoreParameters .product(\"sqlite\") .collection(\"test.db\") .operation(\"select\") .instance(\"localhost\", 8080) .databaseName(\"test.db\") .build()); } } Copy Here is the same example server code broken into sections that describe how the API is used: Import Java agent API classes This section shows the relevant Java agent API imports needed to add cross application tracing and reporting of external datastore calls to the server application. import java.io.IOException; import java.net.URISyntaxException; import java.sql.Connection; import java.sql.DriverManager; import java.sql.ResultSet; import java.sql.Statement; import java.util.Collections; import java.util.Enumeration; // New Relic API imports import com.newrelic.api.agent.DatastoreParameters; import com.newrelic.api.agent.ExtendedRequest; import com.newrelic.api.agent.HeaderType; import com.newrelic.api.agent.NewRelic; import com.newrelic.api.agent.Trace; import com.newrelic.api.agent.TracedMethod; import com.newrelic.api.agent.Transaction; import fi.iki.elonen.NanoHTTPD; Copy Start the server and set its info as displayed in UI This section starts up the server on port 8081 and uses the NewRelic class from the API to call the methods setServerInfo, setAppServerPort, and setInstanceName. These API calls affect what is shown in the APM UI. public NewRelicApiServer() throws IOException, URISyntaxException { super(8081); // Set Dispatcher name and version NewRelic.setServerInfo(\"NanoHttp\", \"2.3.1\"); // Set Appserver port for jvm identification NewRelic.setAppServerPort(8081); // Set JVM instance name NewRelic.setInstanceName(\"Server\"); start(NanoHTTPD.SOCKET_READ_TIMEOUT, false); System.out.println(\"\\nRunning on http://localhost:8081/ \\n\"); } public static void main(String[] args) throws URISyntaxException { try { new NewRelicApiServer(); } catch (IOException ioe) { System.err.println(\"Unable to start the server:\\n\" + ioe); } } Copy Start tracing a transaction and add outbound Response headers The @Trace(dispatcher = true) annotation tells the agent to start a new transaction when the serve method is called if it is not called as part of an existing transaction (which in this case, it is not). If it were called as part of an existing transaction, it would simply be included as part of that transaction rather than start a new one. A reference to the current Transaction is obtained via a call to getTransaction and the name of the transaction is set via a call to the setTransactionName method. The request object, which in this example is of type IHTTPSession, is then wrapped using a class extending the Java agent API's ExtendedRequest class. The current Transaction is then converted to a web transaction via a call to setWebRequest which takes the wrapped ExtendedRequest as an argument. A call to the database is then made and the response object is generated and wrapped by a class implementing the Java agent API's Response interface. The wrapped response object is passed as an argument to setWebResponse which converts the current Transaction into a web transaction. Once the web request and response are set, a call to addOutboundResponseHeaders adds the headers to the response. This must be called after setWebRequest and setWebResponse, which together provide the agent with the inbound request headers and a place to record the outbound headers. A call to markResponseSent marks the time when the last byte of the response left the server as the current timestamp. @Trace(dispatcher = true) @Override public Response serve(IHTTPSession session) { // Obtain a reference to the current Transaction Transaction tx = NewRelic.getAgent().getTransaction(); // Set the name of the current transaction NewRelic.setTransactionName(\"Custom\", \"ExternalHTTPServer\"); // Wrap the Request object ExtendedRequest req = new RequestWrapper(session); // Set the request for the current transaction and convert it into a web transaction tx.setWebRequest(req); queryDB(); Response res = newFixedLengthResponse(\"<html><body><h1>SuccessfulResponse</h1>\\n</body></html>\\n\"); // Set the response for the current transaction and convert it into a web transaction tx.setWebResponse(new ResponseWrapper(res)); // Instruct the transaction to write the outbound response headers tx.addOutboundResponseHeaders(); // Mark the time when the response left the server tx.markResponseSent(); return res; } Copy Implement the Java agent API's Response Interface An implementation of the Java agent API's Response Interface is used to wrap the response object of the server, which in this example is of type fi.iki.elonen.NanoHTTPD.Response. The response is passed into the constructor of the ResponseWrapper class and implementations of the getStatus, getStatusMessage, setHeader, getContentType and getHeaderType methods are provided. The getHeaderType method returns a HeaderType enum that can either be HeaderType.HTTP or HeaderType.MESSAGE, as defined by the Java agent API. In this example the external call protocol is HTTP, so HeaderType.HTTP is returned. // Implement Response interface to create a wrapper for the outgoing Response object public class ResponseWrapper implements com.newrelic.api.agent.Response { private final Response httpResponse; public ResponseWrapper(Response httpResponse) { this.httpResponse = httpResponse; } @Override public int getStatus() throws Exception { return 200; } @Override public String getStatusMessage() throws Exception { return null; } @Override public void setHeader(String name, String value) { httpResponse.addHeader(name, value); } @Override public String getContentType() { return \"\"; } @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } } Copy Extend the Java agent API's ExtendedRequest class A subclass of the Java agent API's ExtendedRequest class is used to wrap the request object of the server, which in this example is of type IHTTPSession. The request is passed into the constructor of the RequestWrapper class, which provides implementations of the getRequestURI, getHeader, getRemoteUser, getParameterNames, getParameterValues, getAttribute, getCookieValue, getHeaderType, and getMethod methods. The getHeaderType method returns a HeaderType enum that can either be HeaderType.HTTP or HeaderType.MESSAGE, as defined by the Java agent API. In this example the external call protocol is HTTP so HeaderType.HTTP is returned. // Extend ExtendedRequest class to create a wrapper for the Request object class RequestWrapper extends ExtendedRequest { private IHTTPSession session; public RequestWrapper(IHTTPSession session) { super(); this.session = session; } @Override public String getRequestURI() { return session.getUri(); } @Override public String getHeader(String name) { return session.getHeaders().get(name.toLowerCase()); } @Override public String getRemoteUser() { return null; } @SuppressWarnings(\"rawtypes\") @Override public Enumeration getParameterNames() { return Collections.enumeration(session.getParms().keySet()); } @Override public String[] getParameterValues(String name) { return new String[]{session.getParms().get(name)}; } @Override public Object getAttribute(String name) { return null; } @Override public String getCookieValue(String name) { return null; } @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } @Override public String getMethod() { return session.getMethod().toString(); } } Copy Instrument an external call to a datastore This method makes an external call to the SQLite database that is created by the client. The @Trace annotation tells the agent to track this method as part of an existing transaction as started by the serve method. A reference to the current TracedMethod is obtained via a call to getTracedMethod. A DatastoreParameters object is then created using the builder pattern. The ExternalParameters object is then passed as an argument to the reportAsExternal method, which has the effect of reporting the TracedMethod as an external datastore call. @Trace public void queryDB() { Connection c = null; Statement stmt = null; try { Class.forName(\"org.sqlite.JDBC\"); c = DriverManager.getConnection(\"jdbc:sqlite:/tmp/test.db\"); c.setAutoCommit(false); System.out.println(\"Opened database successfully\"); stmt = c.createStatement(); ResultSet rs = stmt.executeQuery(\"SELECT * FROM COMPANY;\"); while (rs.next()) { int id = rs.getInt(\"id\"); String name = rs.getString(\"name\"); int age = rs.getInt(\"age\"); String address = rs.getString(\"address\"); float salary = rs.getFloat(\"salary\"); System.out.println(\"ID = \" + id); System.out.println(\"NAME = \" + name); System.out.println(\"AGE = \" + age); System.out.println(\"ADDRESS = \" + address); System.out.println(\"SALARY = \" + salary); System.out.println(); } rs.close(); stmt.close(); c.close(); } catch (Exception e) { System.err.println(e.getClass().getName() + \": \" + e.getMessage()); System.exit(0); } // Obtain a reference to the method currently being traced TracedMethod method = NewRelic.getAgent().getTracedMethod(); // Create a DatastoreParameters object and report a call to an external datastore service method.reportAsExternal( DatastoreParameters .product(\"sqlite\") .collection(\"test.db\") .operation(\"select\") .instance(\"localhost\", 8080) .databaseName(\"test.db\") .build()); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.44469,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> <em>API</em>: Instrumenting example app for external datastore calls and CAT",
        "sections": "<em>Java</em> <em>agent</em> <em>API</em>: Instrumenting example app for external datastore calls and CAT",
        "tags": "<em>API</em> <em>guides</em>",
        "body": "This document demonstrates using the New Relic <em>Java</em> <em>agent</em> <em>API</em> to instrument a simple client and server application. The instrumentation has these goals: To record external HTTP and datastore transactions. To link external transactions between two applications running New Relic <em>agents</em> (known"
      },
      "id": "6043d431196a67294f960f54"
    }
  ],
  "/docs/agents/java-agent/api-guides/java-agent-api-instrument-using-annotation": [
    {
      "sections": [
        "Java agent API: Custom instrumentation with annotation of an example app",
        "Important",
        "Complete example app using API",
        "Tip",
        "Complete API call example",
        "How the example uses the API",
        "Import the needed packages",
        "Set @Trace for transaction traces",
        "Create custom names for web transactions",
        "Bypass Apdex when collecting non-public data",
        "Record the user ID",
        "Collect promotion data",
        "Send instructions to the handler",
        "Include page load timing code in the HTTP response",
        "Complete the HTTP response"
      ],
      "title": "Java agent API: Custom instrumentation with annotation of an example app",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "a6a2aadf63f8282b7d599579f67010fbd600d183",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/java-agent-api-custom-instrumentation-annotation-example-app/",
      "published_at": "2021-05-05T07:03:35Z",
      "updated_at": "2021-03-16T14:30:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you set up custom instrumentation for your Java application. This document shows an example of using custom instrumentation with annotation in an imaginary application. Important For best results when using the API, ensure you have the latest Java agent release. Complete example app using API Below is an example of an imaginary store app's servlet using the Java agent API. Tip If you copy and paste example code, be sure to use appropriate spacing on your command lines. Complete API call example package test; import java.io.IOException; import java.io.PrintWriter; import java.util.Random; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; // Java agent API imports import com.newrelic.api.agent.NewRelic; import com.newrelic.api.agent.Trace; public class TestServlet extends HttpServlet { // instrumentation via annotation @Trace(dispatcher = true) protected void processRequest(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { saveNewRelicInfo(req); doRequestWork(req); writeResponse(resp); } private void saveNewRelicInfo(HttpServletRequest req) { String storeId = req.getParameter(\"storeId\"); if (storeId != null) { // set the name of the Transaction NewRelic.setTransactionName(null, \"/store\"); if (storeId.equals(\"betaStore\")) { // prevent the method from contributing to the Apdex score NewRelic.ignoreApdex(); } } String userId = req.getParameter(\"userId\"); if (userId != null) { // set the user name to associate with the RUM JavaScript footer // for the current web transaction NewRelic.setUserName(userId); // add a key/value pair to the current transaction NewRelic.addCustomParameter(\"userId\", userId); } String promotionId = req.getParameter(\"promotionId\"); if (promotionId != null) { // increment the metric counter for the given name NewRelic.incrementCounter(\"Custom/Promotion\"); } } protected void doRequestWork(HttpServletRequest req) { try { long millisToSleep = new Random().nextInt(5000); Thread.sleep(millisToSleep); // record a response time in milliseconds for the given metric name NewRelic.recordResponseTimeMetric(\"Custom/RandomSleep\", millisToSleep); } catch (InterruptedException e) { // report a handled exception NewRelic.noticeError(e, false); } } protected void writeResponse(HttpServletResponse resp) throws IOException { resp.setContentType(\"text/html;charset=UTF-8\"); PrintWriter out = resp.getWriter(); out.println(\"<html>\"); out.println(\"<head>\"); // get the RUM JavaScript header for the current web transaction out.println(NewRelic.getBrowserTimingHeader()); out.println(\"<title>NewRelic API example servlet</title>\"); out.println(\"</head>\"); out.println(\"<body>\"); out.println(\"<h1>API example</h1>\"); // get the RUM JavaScript footer for the current web transaction out.println(NewRelic.getBrowserTimingFooter()); out.println(\"</body>\"); out.println(\"</html>\"); out.close(); } protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { processRequest(req, resp); } protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { processRequest(req, resp); } } Copy How the example uses the API Here is the same example app divided into sections that describe how the API is used: Import the needed packages This part of the example shows the imports needed for the example application and Java agent API. package test; import java.io.IOException; import java.io.PrintWriter; import java.util.Random; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; // Java agent API imports import com.newrelic.api.agent.NewRelic; import com.newrelic.api.agent.Trace; Copy Set @Trace for transaction traces This part of the API call provides instructions to instrument this call using New Relic's trace annotation @Trace. Any requests that hit processRequest will now show a segment in APM's Transaction trace call chart. public class TestServlet extends HttpServlet { // instrumentation via annotation @Trace(dispatcher = true) protected void processRequest(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { saveNewRelicInfo(req); doRequestWork(req); writeResponse(resp); } Copy Create custom names for web transactions This part of the API call instructs web transactions containing a storeId value to appear in APM's Transactions page with the custom transaction name you set. A request to any one store will appear under the same, aggregate name. private void saveNewRelicInfo(HttpServletRequest req) { String storeId = req.getParameter(\"storeId\"); if (storeId != null) { // set the name of the Transaction NewRelic.setTransactionName(null, \"/store\"); } } Copy Bypass Apdex when collecting non-public data This part of the API call excludes the non-public beta storeID from affecting the Apdex score. if (storeId.equals(\"betaStore\")) { // prevent the method from contributing to the Apdex score NewRelic.ignoreApdex(); } Copy Record the user ID This part of the API call inserts additional metadata into the page load timing request so that browser traces can be tied with the userId. It also records the userId as a custom parameter on the transaction so that it appears in the parameter details of a transaction trace. (Page load timing sometimes is referred to as real user monitoring or RUM.) String userId = req.getParameter(\"userId\"); if (userId != null) { // set the user name to associate with the RUM JavaScript footer // for the current web transaction NewRelic.setUserName(userId); // add a key/value pair to the current transaction NewRelic.addCustomParameter(\"userId\", userId); } Copy Collect promotion data This part of the API call records the number of times a promotion was viewed so that the metrics can appear on a custom dashboard. Important For metrics you want to graph in custom dashboards, be sure to prepend Custom/ to the metric name; for example, Custom/Promotion. String promotionId = req.getParameter(\"promotionId\"); if (promotionId != null) { // increment the metric counter for the given name NewRelic.incrementCounter(\"Custom/Promotion\"); } Copy Send instructions to the handler This part of the API call sends a set of instructions to the handler for processing requests and handling exceptions. protected void doRequestWork(HttpServletRequest req) { try { long millisToSleep = new Random().nextInt(5000); Thread.sleep(millisToSleep); // record a response time in milliseconds for the given metric name NewRelic.recordResponseTimeMetric(\"Custom/RandomSleep\", millisToSleep); } catch (InterruptedException e) { // report a handled exception NewRelic.noticeError(e, false); } } protected void writeResponse(HttpServletResponse resp) throws IOException { Copy Include page load timing code in the HTTP response This part of the API call defines what to include in the HttpServletResponse. For manual instrumentation of Browser monitoring to monitor page load timing (sometimes referred to as real user monitoring or RUM): Set the header after the < head> tag. Set the footer at the end of < body> tag. resp.setContentType(\"text/html;charset=UTF-8\"); PrintWriter out = resp.getWriter(); out.println(\"<html>\"); out.println(\"<head>\"); // get the RUM JavaScript header for the current web transaction out.println(NewRelic.getBrowserTimingHeader()); out.println(\"<title>NewRelic API example servlet</title>\"); out.println(\"</head>\"); out.println(\"<body>\"); out.println(\"<h1>API example</h1>\"); // get the RUM JavaScript footer for the current web transaction out.println(NewRelic.getBrowserTimingFooter()); out.println(\"</body>\"); out.println(\"</html>\"); out.close(); } Copy Complete the HTTP response This part of the API call defines the remaining information to include in the HttpServletResponse response. protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { processRequest(req, resp); } protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { processRequest(req, resp); } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.81137,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> <em>API</em>: Custom instrumentation with annotation of an example app",
        "sections": "<em>Java</em> <em>agent</em> <em>API</em>: Custom instrumentation with annotation of an example app",
        "tags": "<em>API</em> <em>guides</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> <em>API</em> lets you set up custom instrumentation for your <em>Java</em> application. This document shows an example of using custom instrumentation with annotation in an imaginary application. Important For best results when using the <em>API</em>, ensure you have the latest <em>Java</em> <em>agent</em> release"
      },
      "id": "603eb76a64441f48424e886b"
    },
    {
      "sections": [
        "Java agent API: Instrument external calls, messaging, datastore, web frameworks",
        "External API",
        "External parameters builders",
        "Important",
        "Cross application tracing API",
        "Client wrappers",
        "OutbounderHeaders implementation",
        "InboundHeaders implementation",
        "Server wrappers",
        "Extend ExtendedRequest class",
        "Response interface implementation",
        "CAT implementation using wrappers",
        "Cross application tracing: Client-side",
        "Cross application tracing: Server-side",
        "Messaging API",
        "Messaging API implementation",
        "Message with CAT headers implementation",
        "Datastore API",
        "Datastore API implementation",
        "Datastore API: Slow query",
        "Datastore with slow query implementation",
        "WebFrameworks API",
        "Tip",
        "WebFrameworks API implementation",
        "For more help"
      ],
      "title": "Java agent API: Instrument external calls, messaging, datastore, web frameworks",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "714d226d7cc81508ecd006cb53c26c7525abfd4e",
      "image": "https://docs.newrelic.com/static/00e2b7a703330efa62b14e15dda69907/1ff84/CAT_diagram.png",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/java-agent-api-instrument-external-calls-messaging-datastore-web-frameworks/",
      "published_at": "2021-05-05T06:59:42Z",
      "updated_at": "2021-03-11T03:37:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent collects and reports information on web transactions and non-web transactions, such as background tasks. The agent should instrument supported frameworks automatically, without any need to modify your application code. However, in addition to custom code and frameworks or technology not listed in the Compatibility and requirements for the Java agent documentation, some implementations of supported frameworks may require custom instrumentation. This document describes how to use the Java agent API to instrument external calls, messaging frameworks, cross application tracing (CAT), datastores, and web frameworks. For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 3.36.0 or higher. External API The External API enables applications to report external service calls to New Relic. This information appears on the External services page in APM. To report HTTP external activity, simply create an instance of ExternalParameters using the HttpParameters builder, and call reportAsExternal(ExternalParameters parameters) on the traced method you want to report. External API String library = \"HttpClient\"; // a user-recognizable name for the library that is being used URI uri = request.getURI(); // the URI that is being requested String procedure = \"execute\"; // these are typically named after the method in the library that's being instrumented // construct external parameters ExternalParameters params = HttpParameters .library(library) .uri(uri) .procedure(procedure) .inboundHeaders(inboundHeaders) .build(); // report the current method as doing external activity NewRelic.getAgent().getTracedMethod().reportAsExternal(params); Copy External parameters builders There are several builders to create ExternalParameters: DatastoreParameters HttpParameters GenericParameters MessageConsumeParameters MessageProduceParameters These builders create the input parameter object for TracedMethod's reportAsExternal API call. These parameter objects are used for things like linking HTTP external calls via cross application tracing, tracing external calls to a datastore, tracing external calls to a datastore with additional slow query processing, as well as tracing calls between message producers and consumers. Important All of the methods of this class have the potential to expose sensitive private information. Use caution when creating the arguments, paying particular attention to URIs and string values. Cross application tracing API The cross application tracing (CAT) API allows the New Relic Java agent to link transactions across applications monitored by New Relic. The API uses client and server wrappers that allow the agent to read headers from requests, and add headers to responses. Client wrappers For the agent to write outbound request headers in the client initiating the request, use the OutboundHeaders interface. For example: OutbounderHeaders implementation class OutboundWrapper implements OutboundHeaders { private final HttpUriRequest delegate; // OutboundHeaders is implemented by delegating to the library's request object public OutboundWrapper(HttpUriRequest request) { this.delegate = request; } // This allows the agent to add the correct headers to the HTTP request @Override public void setHeader(String name, String value) { delegate.addHeader(name, value); } // New Relic CAT specifies different header names for HTTP and MESSAGE @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } } Copy For the agent to read inbound response headers in the client receiving the response, implement the InboundHeaders. For example: InboundHeaders implementation class InboundWrapper implements InboundHeaders { private final CloseableHttpResponse responseHeaders; // OutboundHeaders is implemented by delegating to the library's response object public InboundWrapper(CloseableHttpResponse responseHeaders) { this.responseHeaders = responseHeaders; } // New Relic CAT specifies different header names for HTTP and MESSAGE @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } // this allows the agent to read the correct headers from the HTTP response @Override public String getHeader(String name) { return responseHeaders.getFirstHeader(name).getValue(); } } Copy Server wrappers For the agent to get web request headers, you must extend the ExtendedRequest class: Extend ExtendedRequest class // Extend ExtendedRequest class to create a wrapper for the Request object class RequestWrapper extends ExtendedRequest { private IHTTPSession session; public RequestWrapper(IHTTPSession session) { super(); this.session = session; } @Override public String getRequestURI() { return session.getUri(); } @Override public String getHeader(String name) { return session.getHeaders().get(name); } @Override public String getRemoteUser() { return null; } @SuppressWarnings(\"rawtypes\") @Override public Enumeration getParameterNames() { return Collections.enumeration(session.getParms().keySet()); } @Override public String[] getParameterValues(String name) { return new String[]{session.getParms().get(name)}; } @Override public Object getAttribute(String name) { return null; } @Override public String getCookieValue(String name) { return null; } @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } @Override public String getMethod() { return session.getMethod().toString(); } } Copy For the agent to set the web response headers, implement the Response interface: Response interface implementation // Implement Response interface to create a wrapper for the outgoing Response object public class ResponseWrapper implements com.newrelic.api.agent.Response { private final Response httpResponse; public ResponseWrapper(Response httpResponse) { this.httpResponse = httpResponse; } @Override public int getStatus() throws Exception { return 200; } @Override public String getStatusMessage() throws Exception { return null; } @Override public void setHeader(String name, String value) { httpResponse.addHeader(name, value); } @Override public String getContentType() { return \"\"; } @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } } Copy CAT implementation using wrappers Using the wrapper objects described in the previous sections, you can enable the Java agent to do cross application tracing (CAT) on the client and server side. For example: Cross application tracing: Client-side @Trace public int makeExternalCall(URI uri) throws IOException { String library = \"HTTPClient\"; String procedure = \"Execute\"; HttpUriRequest request = RequestBuilder.get().setUri(uri).build(); // Wrap the outbound Request object OutboundWrapper outboundHeaders = new OutboundWrapper(request); // Obtain a reference to the method currently being traced TracedMethod tracedMethod = NewRelic.getAgent().getTracedMethod(); // Add headers for outbound external request tracedMethod.addOutboundRequestHeaders(outboundHeaders); CloseableHttpClient connection = HttpClientBuilder.create().build(); CloseableHttpResponse response = connection.execute(request); // Wrap the incoming Response object InboundWrapper inboundHeaders = new InboundWrapper(response); // Create an input parameter object for a call to an external HTTP service ExternalParameters params = HttpParameters .library(library) .uri(uri) .procedure(procedure) .inboundHeaders(inboundHeaders) .build(); // Report a call to an external HTTP service tracedMethod.reportAsExternal(params); return response.getStatusLine().getStatusCode(); } Copy In this sample code, the agent is configured to report an external call using CAT on the client that is initiating the request. These steps can be summarized as follows: Implement OutboundHeaders and InboundHeaders using framework classes on the client. Use addOutboundRequestHeaders(OutboundHeaders outboundHeaders) to have the agent add appropriate headers to the outbound request. Create ExternalParameters object using HttpParameters builder and provide inbound response headers. Report as an external request using reportAsExternal(ExternalParameters params). Cross application tracing: Server-side @Trace(dispatcher = true) @Override public Response serve(IHTTPSession session) { // Obtain a reference to the current Transaction Transaction tx = NewRelic.getAgent().getTransaction(); // Set the name of the current transaction NewRelic.setTransactionName(\"Custom\", \"ExternalHTTPServer\"); // Wrap the Request object ExtendedRequest req = new RequestWrapper(session); // Set the request for the current transaction and convert it into a web transaction tx.setWebRequest(req); queryDB(); Response res = newFixedLengthResponse(\"<html><body><h1>SuccessfulResponse</h1>\\n</body></html>\\n\"); // Set the response for the current transaction and convert it into a web transaction tx.setWebResponse(new ResponseWrapper(res)); // Instruct the transaction to write the outbound response headers tx.addOutboundResponseHeaders(); // Mark the time when the response left the server tx.markResponseSent(); return res; } Copy In this sample code, the agent is configured to report an external call using CAT on the server that is responding to the request. These steps can be summarized as follows: Implement Response and extend the ExtendedRequest class using framework classes on the server. Use setWebRequest(ExtendedRequest request) and setWebResponse(Response response) to convert the transaction into a web transaction and together provide the agent with the inbound request headers and a place to record the outbound headers. It's important to use both setWebRequest(ExtendedRequest request) and setWebResponse(Response response) together, because the transaction name depends on the request object, and the response code depends on the response object. Use addOutboundResponseHeaders() to have the agent add appropriate headers to the outbound response. Mark the end of the response with a call to markResponseSent(). Messaging API The messaging API allows applications to report interactions with message queue brokers. It builds on top of the External API by providing the MessageConsumerParametersMessage and MessageConsumerParameters. This API generates the necessary metrics to identify message broker interactions. The UI will use these metrics to display messaging data including segments in transactions with the appropriate action and count (message put, or message take), a dedicated messages tab in transaction traces, and more. Providing inbound and outbound headers to the API also allows the agent to add CAT headers, and record CAT metrics, which enables the UI to draw service maps that show connections between applications. Important The messaging API relies on two-way communication between producers and consumers. If your producer does not receive an acknowledgment from a consumer, like in a fire-and-forget pattern, the messaging API will not accurately reflect the interactions with message queue brokers. The following example demonstrates how to instrument a fictional JMS library. Messaging API implementation public class MessageProducer { // instrument the method that puts messages on a queue @Trace public void sendMessageToQueue(Message message) { ExternalParameters messageProduceParameters = MessageProduceParameters.library(\"JMS\") .destinationType(DestinationType.NAMED_QUEUE) .destinationName(message.getJMSDestination()) .outboundHeaders(new OutboundWrapper(message)) .build(); NewRelic.getAgent().getTracedMethod().reportAsExternal(messageProduceParameters); } } Copy To simplify things, the agent assumes that sendMessageToQueue always puts a message in a named queue. In reality, a message can be sent to different destination types, including named queues, temporary queues, topics, and temporary topics. The API provides an enum to report messages to different destination types: NAMED_QUEUE, TEMP_QUEUE, NAMED_TOPIC, TEMP_TOPIC. It's important to specify the appropriate destination type because the UI will display the names of named queues and named topics and will omit the names of temporary queues and temporary topics. If the library is capable of transmitting CAT headers, an OutboundHeaders object will be provided to the API so that the agent can add CAT headers. Message with CAT headers implementation public class MessageConsumer { @Trace public Message messageReceive() { ExternalParameters messageConsumeParameters = MessageConsumeParameters.library(\"JMS\") .destinationType(DestinationType.NAMED_QUEUE) .destinationName(message.getJMSDestination()) .inboundHeaders(new InboundWrapper(message)) .build(); NewRelic.getAgent().getTracedMethod().reportAsExternal(messageConsumeParameters); return message; } } Copy Datastore API When a traced method is reported as an external datastore call, the call is shown in the APM Databases page. Because datastores are external to the running application, the method is reported as datastore activity using the reportAsExternal(ExternalParameters params) method. The only difference is that a different builder, DatastoreParameters, is used to create the appropriate ExternalParameters object. Datastore API implementation TracedMethod tracedMethod = NewRelic.getAgent().getTracedMethod(); tracedMethod.reportAsExternal( DatastoreParameters .product(\"sqlite\") // the datastore vendor .collection(\"test.db\") // the name of the collection (or table for SQL databases) .operation(\"select\") // the operation being performed, e.g. \"SELECT\" or \"UPDATE\" for SQL databases .instance(\"localhost\", 8080) // the datastore instance information - generally can be found as part of the connection .databaseName(\"test.db\") // may be null, indicating no keyspace for the command .build()); Copy Datastore API: Slow query This API call provides the same behavior as the Datastore API call and extends it to allow slow query information to be tracked. The same reportAsExternal(ExternalParameters params) method and builder are used, but with an additional builder method. Datastore with slow query implementation Creating the appropriate ExternalParameters object is illustrated below: //Reporting a method as doing datastore activity TracedMethod tracedMethod = NewRelic.getAgent().getTracedMethod(); tracedMethod.reportAsExternal( DatastoreParameters .product(\"sqlite\") // the datastore vendor .collection(\"test.db\") // the name of the collection (or table for SQL databases) .operation(\"select\") // the operation being performed, e.g. \"SELECT\" or \"UPDATE\" for SQL databases .instance(\"localhost\", 8080) // the datastore instance information - generally can be found as part of the connection .databaseName(\"test.db\") // may be null, indicating no keyspace for the command .slowQuery(rawQuery,QUERY_CONVERTER) .build()); private static QueryConverter<String> QUERY_CONVERTER = new QueryConverter<String>() { @Override public String toRawQueryString(String statement) { // Do work to transform raw query object to string return statement; } @Override public String toObfuscatedQueryString(String statement) { // Do work to remove any sensitive information here return obfuscateQuery(statement); } }; Copy WebFrameworks API The WebFrameworks API allows the agent to report additional identifying information about the application. // Set the dispatcher name and version which is reported to APM. // The dispatcherName is intended to represent the type of server that this // application is running on such as: Tomcat, Jetty, Netty, etc. NewRelic.setServerInfo(String dispatcherName, String version) // Set the app server port which is reported to APM. NewRelic.setAppServerPort(int port) // Set the instance name in the environment. // A single host:port may support multiple JVM instances. // The instance name is intended to help identify a specific JVM instance. NewRelic.setInstanceName(String instanceName) Copy Tip These values can be set only once. Subsequent calls will have no effect. WebFrameworks API implementation public NewRelicApiClient() throws IOException, URISyntaxException { super(8080); // Set Dispatcher name and version. NewRelic.setServerInfo(\"NanoHttp\", \"2.3.1\"); // Set Appserver port for jvm identification NewRelic.setAppServerPort(8080); // Set JVM instance name NewRelic.setInstanceName(\"Client:8080\"); start(NanoHTTPD.SOCKET_READ_TIMEOUT, false); System.out.println(\"\\nRunning on http://localhost:8080/ \\n\"); } Copy For more help Additional documentation resources include: New Relic Java agent API Javadoc (detailed API documentation on GitHub) Java agent API example (example application using custom instrumentation for cross application tracing and external datastore calls) Java agent API guide (goal-driven guide to using the Java agent API) Java instrumentation by annotation (how to use annotations to instrument your application code)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.44667,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> <em>API</em>: Instrument external calls, messaging, datastore, web frameworks",
        "sections": "<em>Java</em> <em>agent</em> <em>API</em>: Instrument external calls, messaging, datastore, web frameworks",
        "tags": "<em>API</em> <em>guides</em>",
        "body": " or technology not listed in the Compatibility and requirements for the <em>Java</em> <em>agent</em> documentation, some implementations of supported frameworks may require custom instrumentation. This document describes how to use the <em>Java</em> <em>agent</em> <em>API</em> to instrument external calls, messaging frameworks, cross application"
      },
      "id": "6043c7f828ccbcef982c6077"
    },
    {
      "sections": [
        "Java agent API: Instrumenting example app for external datastore calls and CAT",
        "Important",
        "Client-side example",
        "Complete client example code",
        "Import Java agent API classes",
        "Start the client and set environment details as displayed in the UI",
        "Start tracing a transaction with the Java agent using @Trace annotation",
        "Make an external call using the Java agent API",
        "Implement the Java agent API's OutboundHeaders Interface",
        "Implement the Java agent API's InboundHeaders Interface",
        "Create a simple database",
        "Server-side example",
        "Complete server example code",
        "Start the server and set its info as displayed in UI",
        "Start tracing a transaction and add outbound Response headers",
        "Implement the Java agent API's Response Interface",
        "Extend the Java agent API's ExtendedRequest class",
        "Instrument an external call to a datastore"
      ],
      "title": "Java agent API: Instrumenting example app for external datastore calls and CAT",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "8e1b18952dde913071d4d5ef121d51e7efc5629b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/java-agent-api-instrumenting-example-app-external-datastore-calls-cat/",
      "published_at": "2021-05-05T07:03:40Z",
      "updated_at": "2021-03-11T03:24:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document demonstrates using the New Relic Java agent API to instrument a simple client and server application. The instrumentation has these goals: To record external HTTP and datastore transactions. To link external transactions between two applications running New Relic agents (known as cross application tracing or CAT). See the Java agent API Javadoc for full descriptions of the available API classes and methods. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 3.36.0 or higher. Client-side example Here is an example of the client-side code for a simple client-server application: Complete client example code package com.newrelic.example; import java.io.IOException; import java.net.URI; import java.net.URISyntaxException; import java.sql.Connection; import java.sql.DriverManager; import java.sql.Statement; // New Relic API imports import com.newrelic.api.agent.ExternalParameters; import com.newrelic.api.agent.HeaderType; import com.newrelic.api.agent.HttpParameters; import com.newrelic.api.agent.InboundHeaders; import com.newrelic.api.agent.NewRelic; import com.newrelic.api.agent.OutboundHeaders; import com.newrelic.api.agent.Trace; import com.newrelic.api.agent.TracedMethod; import fi.iki.elonen.NanoHTTPD; import org.apache.http.client.methods.CloseableHttpResponse; import org.apache.http.client.methods.HttpUriRequest; import org.apache.http.client.methods.RequestBuilder; import org.apache.http.impl.client.CloseableHttpClient; import org.apache.http.impl.client.HttpClientBuilder; public class NewRelicApiExample extends NanoHTTPD { public NewRelicApiExample() throws IOException, URISyntaxException { super(8080); // Set Dispatcher name and version NewRelic.setServerInfo(\"NanoHttp\", \"2.3.1\"); // Set Appserver port for JVM identification NewRelic.setAppServerPort(8080); // Set JVM instance name NewRelic.setInstanceName(\"Client\"); start(NanoHTTPD.SOCKET_READ_TIMEOUT, false); System.out.println(\"Running at: http://localhost:8080/\"); } public static void main(String[] args) throws URISyntaxException { try { new NewRelicApiExample(); } catch (IOException ioe) { System.err.println(\"Unable to start the server:\\n\" + ioe); } } @Trace(dispatcher = true) @Override public Response serve(IHTTPSession session) { URI uri = null; int status = 0; try { createDB(); Thread.sleep(1000); uri = new URI(\"http://localhost:8081\"); status = makeExternalCall(uri); } catch (URISyntaxException | InterruptedException | IOException e) { e.printStackTrace(); } if (status == 200) { return newFixedLengthResponse(\"<html><body><h1>Successful Response</h1>\\n</body></html>\\n\"); } else { return newFixedLengthResponse(\"<html><body><h1>Error\\n\" + status + \"</h1>\\n</body></html>\\n\"); } } @Trace public int makeExternalCall(URI uri) throws IOException { HttpUriRequest request = RequestBuilder.get().setUri(uri).build(); // Wrap the outbound Request object OutboundWrapper outboundHeaders = new OutboundWrapper(request); // Obtain a reference to the method currently being traced TracedMethod tracedMethod = NewRelic.getAgent().getTracedMethod(); // Add headers for outbound external request tracedMethod.addOutboundRequestHeaders(outboundHeaders); CloseableHttpClient connection = HttpClientBuilder.create().build(); CloseableHttpResponse response = connection.execute(request); // Wrap the incoming Response object InboundWrapper inboundHeaders = new InboundWrapper(response); // Create an input parameter object for a call to an external HTTP service ExternalParameters params = HttpParameters .library(\"HttpClient\") .uri(uri) .procedure(\"execute\") .inboundHeaders(inboundHeaders) .build(); // Report a call to an external HTTP service tracedMethod.reportAsExternal(params); return response.getStatusLine().getStatusCode(); } // Implement OutboundHeaders interface to create a wrapper for the outgoing Request headers class OutboundWrapper implements OutboundHeaders { private final HttpUriRequest delegate; public OutboundWrapper(HttpUriRequest request) { this.delegate = request; } @Override public void setHeader(String name, String value) { delegate.addHeader(name, value); } @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } } // Implement InboundHeaders interface to create a wrapper for the incoming Response headers class InboundWrapper implements InboundHeaders { private final CloseableHttpResponse responseHeaders; public InboundWrapper(CloseableHttpResponse requestHeaders) { this.responseHeaders = requestHeaders; } @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } @Override public String getHeader(String name) { return responseHeaders.getFirstHeader(name).getValue(); } } @Trace public void createDB() { Connection c = null; Statement stmt = null; try { Class.forName(\"org.sqlite.JDBC\"); c = DriverManager.getConnection(\"jdbc:sqlite:/tmp/test.db\"); System.out.println(\"Opened database successfully\"); stmt = c.createStatement(); String dropSql = \"DROP TABLE IF EXISTS COMPANY;\"; stmt.executeUpdate(dropSql); String sql = \"CREATE TABLE COMPANY \" + \"(ID INT PRIMARY KEY NOT NULL,\" + \" NAME TEXT NOT NULL, \" + \" AGE INT NOT NULL, \" + \" ADDRESS CHAR(50), \" + \" SALARY REAL)\"; stmt.executeUpdate(sql); sql = \"INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) \" + \"VALUES (1, 'Paul', 32, 'California', 20000.00 );\"; stmt.executeUpdate(sql); sql = \"INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) \" + \"VALUES (2, 'Allen', 25, 'Texas', 15000.00 );\"; stmt.executeUpdate(sql); sql = \"INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) \" + \"VALUES (3, 'Teddy', 23, 'Norway', 20000.00 );\"; stmt.executeUpdate(sql); sql = \"INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) \" + \"VALUES (4, 'Mark', 25, 'Rich-Mond ', 65000.00 );\"; stmt.executeUpdate(sql); stmt.close(); c.close(); } catch (Exception e) { System.err.println(e.getClass().getName() + \": \" + e.getMessage()); System.exit(0); } } } Copy Here is the same client app code divided into sections that describe how the API is used: Import Java agent API classes This section calls the Java agent API imports used to add cross application tracing to the client application later in the example code. import java.io.IOException; import java.net.URI; import java.net.URISyntaxException; import java.sql.Connection; import java.sql.DriverManager; import java.sql.Statement; // New Relic API imports import com.newrelic.api.agent.ExternalParameters; import com.newrelic.api.agent.HeaderType; import com.newrelic.api.agent.InboundHeaders; import com.newrelic.api.agent.NewRelic; import com.newrelic.api.agent.OutboundHeaders; import com.newrelic.api.agent.Trace; import com.newrelic.api.agent.TracedMethod; import fi.iki.elonen.NanoHTTPD; import org.apache.http.client.methods.CloseableHttpResponse; import org.apache.http.client.methods.HttpUriRequest; import org.apache.http.client.methods.RequestBuilder; import org.apache.http.impl.client.CloseableHttpClient; import org.apache.http.impl.client.HttpClientBuilder; Copy Start the client and set environment details as displayed in the UI This section starts up the client server on port 8080 and uses the NewRelic class from the API to call the methods setServerInfo, setAppServerPort, and setInstanceName. These API calls affect what is shown in the New Relic UI. public NewRelicApiExample() throws IOException, URISyntaxException { super(8080); // Set Dispatcher name and version NewRelic.setServerInfo(\"NanoHttp\", \"2.3.1\"); // Set Appserver port for jvm identification NewRelic.setAppServerPort(8080); // Set JVM instance name NewRelic.setInstanceName(\"Client\"); start(NanoHTTPD.SOCKET_READ_TIMEOUT, false); System.out.println(\"Running at: http://localhost:8080/\"); } public static void main(String[] args) throws URISyntaxException { try { new NewRelicApiExample(); } catch (IOException ioe) { System.err.println(\"Unable to start the server:\\n\" + ioe); } } Copy Start tracing a transaction with the Java agent using @Trace annotation This method creates a sample database, sleeps the thread, and makes an external call to the server app listening on port 8081. The @Trace(dispatcher = true) annotation tells the agent to start a new transaction when the serve method is called, if it is not called as part of an existing transaction (and in this case, it is not). If it were called as part of an existing transaction, it would simply be included as part of that transaction rather than start a new one. @Trace(dispatcher = true) @Override public Response serve(IHTTPSession session) { URI uri = null; int status = 0; try { createDB(); Thread.sleep(1000); uri = new URI(\"http://localhost:8081\"); status = makeExternalCall(uri); } catch (URISyntaxException | InterruptedException | IOException e) { e.printStackTrace(); } if (status == 200) { return newFixedLengthResponse(\"<html><body><h1>Successful Response</h1>\\n</body></html>\\n\"); } else { return newFixedLengthResponse(\"<html><body><h1>Error\\n\" + status + \"</h1>\\n</body></html>\\n\"); } } Copy Make an external call using the Java agent API This section contains the code that initiates cross application tracing to the application making the request. The @Trace annotation tells the agent to track this method as part of an existing transaction as started by the serve method. The request object is wrapped by a class that implements the Java agent API's OutboundHeaders interface, which ensures that the proper HeaderType is set (in this case HTTP). A call to addOutboundRequestHeaders adds the headers to the request and the request is sent to the server. When the response returns it is wrapped by a class implementing the Java agent API's InboundHeaders interface. The inboundHeaders, along with the \"library\", URI, and \"procedure\" arguments, are used to build an HttpParameters object. The params object is then passed as an argument to the reportAsExternal method, which reports the TracedMethod as an external HTTP call. @Trace public int makeExternalCall(URI uri) throws IOException { HttpUriRequest request = RequestBuilder.get().setUri(uri).build(); // Wrap the outbound Request object OutboundWrapper outboundHeaders = new OutboundWrapper(request); // Obtain a reference to the method currently being traced TracedMethod tracedMethod = NewRelic.getAgent().getTracedMethod(); // Add headers for outbound external request tracedMethod.addOutboundRequestHeaders(outboundHeaders); CloseableHttpClient connection = HttpClientBuilder.create().build(); CloseableHttpResponse response = connection.execute(request); // Wrap the incoming Response object InboundWrapper inboundHeaders = new InboundWrapper(response); // Create an input parameter object for a call to an external HTTP service ExternalParameters params = HttpParameters .library(\"HttpClient\") .uri(uri) .procedure(\"execute\") .inboundHeaders(inboundHeaders) .build(); // Report a call to an external HTTP service tracedMethod.reportAsExternal(params); return response.getStatusLine().getStatusCode(); } Copy Implement the Java agent API's OutboundHeaders Interface An implementation of the Java agent API's OutboundHeaders Interface is used to wrap the request object of the client server, which in this example is of type HttpUriRequest. The request is passed into the constructor of the OutboundWrapper class and implementations of the setHeader and getHeaderType methods are provided. The getHeaderType method returns a HeaderType enum that can either be HeaderType.HTTP or HeaderType.MESSAGE, as defined by the Java agent API. In this example the external call protocol is HTTP, so HeaderType.HTTP is returned. // Implement OutboundHeaders interface to create a wrapper for the outgoing Request headers class OutboundWrapper implements OutboundHeaders { private final HttpUriRequest delegate; public OutboundWrapper(HttpUriRequest request) { this.delegate = request; } @Override public void setHeader(String name, String value) { delegate.addHeader(name, value); } @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } } Copy Implement the Java agent API's InboundHeaders Interface An implementation of the Java agent API's InboundHeaders Interface is used to wrap the response object returned to the client server, which in this example is of type CloseableHttpResponse. The response is passed into the constructor of the InboundWrapper class, where implementations of the getHeaderType and getHeader methods are provided. The getHeaderType method returns a HeaderType enum that can either be HeaderType.HTTP or HeaderType.MESSAGE, as defined by the Java agent API. In this example the external call protocol is HTTP so HeaderType.HTTP is returned. // Implement InboundHeaders interface to create a wrapper for the incoming Response headers class InboundWrapper implements InboundHeaders { private final CloseableHttpResponse responseHeaders; public InboundWrapper(CloseableHttpResponse requestHeaders) { this.responseHeaders = requestHeaders; } @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } @Override public String getHeader(String name) { return responseHeaders.getFirstHeader(name).getValue(); } } Copy Create a simple database This method simply creates an example SQLite database. The @Trace annotation tells the agent to track this method as part of an existing transaction as started by the serve method. @Trace public void createDB() { Connection c = null; Statement stmt = null; try { Class.forName(\"org.sqlite.JDBC\"); c = DriverManager.getConnection(\"jdbc:sqlite:/tmp/test.db\"); System.out.println(\"Opened database successfully\"); stmt = c.createStatement(); String dropSql = \"DROP TABLE IF EXISTS COMPANY;\"; stmt.executeUpdate(dropSql); String sql = \"CREATE TABLE COMPANY \" + \"(ID INT PRIMARY KEY NOT NULL,\" + \" NAME TEXT NOT NULL, \" + \" AGE INT NOT NULL, \" + \" ADDRESS CHAR(50), \" + \" SALARY REAL)\"; stmt.executeUpdate(sql); sql = \"INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) \" + \"VALUES (1, 'Paul', 32, 'California', 20000.00 );\"; stmt.executeUpdate(sql); sql = \"INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) \" + \"VALUES (2, 'Allen', 25, 'Texas', 15000.00 );\"; stmt.executeUpdate(sql); sql = \"INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) \" + \"VALUES (3, 'Teddy', 23, 'Norway', 20000.00 );\"; stmt.executeUpdate(sql); sql = \"INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) \" + \"VALUES (4, 'Mark', 25, 'Rich-Mond ', 65000.00 );\"; stmt.executeUpdate(sql); stmt.close(); c.close(); } catch (Exception e) { System.err.println(e.getClass().getName() + \": \" + e.getMessage()); System.exit(0); } } Copy Server-side example Here is the server-side code for this example application: Complete server example code package com.newrelic.example; import java.io.IOException; import java.net.URISyntaxException; import java.sql.Connection; import java.sql.DriverManager; import java.sql.ResultSet; import java.sql.Statement; import java.util.Collections; import java.util.Enumeration; // New Relic API imports import com.newrelic.api.agent.DatastoreParameters; import com.newrelic.api.agent.ExtendedRequest; import com.newrelic.api.agent.HeaderType; import com.newrelic.api.agent.NewRelic; import com.newrelic.api.agent.Trace; import com.newrelic.api.agent.TracedMethod; import com.newrelic.api.agent.Transaction; import fi.iki.elonen.NanoHTTPD; public class NewRelicApiServer extends NanoHTTPD { public NewRelicApiServer() throws IOException, URISyntaxException { super(8081); // Set Dispatcher name and version NewRelic.setServerInfo(\"NanoHttp\", \"2.3.1\"); // Set Appserver port for jvm identification NewRelic.setAppServerPort(8081); // Set JVM instance name NewRelic.setInstanceName(\"Server\"); start(NanoHTTPD.SOCKET_READ_TIMEOUT, false); System.out.println(\"\\nRunning on http://localhost:8081/ \\n\"); } public static void main(String[] args) throws URISyntaxException { try { new NewRelicApiServer(); } catch (IOException ioe) { System.err.println(\"Unable to start the server:\\n\" + ioe); } } @Trace(dispatcher = true) @Override public Response serve(IHTTPSession session) { // Obtain a reference to the current Transaction Transaction tx = NewRelic.getAgent().getTransaction(); // Set the name of the current transaction NewRelic.setTransactionName(\"Custom\", \"ExternalHTTPServer\"); // Wrap the Request object ExtendedRequest req = new RequestWrapper(session); // Set the request for the current transaction and convert it into a web transaction tx.setWebRequest(req); queryDB(); Response res = newFixedLengthResponse(\"<html><body><h1>SuccessfulResponse</h1>\\n</body></html>\\n\"); // Set the response for the current transaction and convert it into a web transaction tx.setWebResponse(new ResponseWrapper(res)); // Instruct the transaction to write the outbound response headers tx.addOutboundResponseHeaders(); // Mark the time when the response left the server tx.markResponseSent(); return res; } // Implement Response interface to create a wrapper for the outgoing Response object public class ResponseWrapper implements com.newrelic.api.agent.Response { private final Response httpResponse; public ResponseWrapper(Response httpResponse) { this.httpResponse = httpResponse; } @Override public int getStatus() throws Exception { return 200; } @Override public String getStatusMessage() throws Exception { return null; } @Override public void setHeader(String name, String value) { httpResponse.addHeader(name, value); } @Override public String getContentType() { return \"\"; } @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } } // Extend ExtendedRequest class to create a wrapper for the Request object class RequestWrapper extends ExtendedRequest { private IHTTPSession session; public RequestWrapper(IHTTPSession session) { super(); this.session = session; } @Override public String getRequestURI() { return session.getUri(); } @Override public String getHeader(String name) { return session.getHeaders().get(name.toLowerCase()); } @Override public String getRemoteUser() { return null; } @SuppressWarnings(\"rawtypes\") @Override public Enumeration getParameterNames() { return Collections.enumeration(session.getParms().keySet()); } @Override public String[] getParameterValues(String name) { return new String[]{session.getParms().get(name)}; } @Override public Object getAttribute(String name) { return null; } @Override public String getCookieValue(String name) { return null; } @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } @Override public String getMethod() { return session.getMethod().toString(); } } @Trace public void queryDB() { Connection c = null; Statement stmt = null; try { Class.forName(\"org.sqlite.JDBC\"); c = DriverManager.getConnection(\"jdbc:sqlite:/tmp/test.db\"); c.setAutoCommit(false); System.out.println(\"Opened database successfully\"); stmt = c.createStatement(); ResultSet rs = stmt.executeQuery(\"SELECT * FROM COMPANY;\"); while (rs.next()) { int id = rs.getInt(\"id\"); String name = rs.getString(\"name\"); int age = rs.getInt(\"age\"); String address = rs.getString(\"address\"); float salary = rs.getFloat(\"salary\"); System.out.println(\"ID = \" + id); System.out.println(\"NAME = \" + name); System.out.println(\"AGE = \" + age); System.out.println(\"ADDRESS = \" + address); System.out.println(\"SALARY = \" + salary); System.out.println(); } rs.close(); stmt.close(); c.close(); } catch (Exception e) { System.err.println(e.getClass().getName() + \": \" + e.getMessage()); System.exit(0); } // Obtain a reference to the method currently being traced TracedMethod method = NewRelic.getAgent().getTracedMethod(); // Create a DatastoreParameters object and report a call to an external datastore service method.reportAsExternal( DatastoreParameters .product(\"sqlite\") .collection(\"test.db\") .operation(\"select\") .instance(\"localhost\", 8080) .databaseName(\"test.db\") .build()); } } Copy Here is the same example server code broken into sections that describe how the API is used: Import Java agent API classes This section shows the relevant Java agent API imports needed to add cross application tracing and reporting of external datastore calls to the server application. import java.io.IOException; import java.net.URISyntaxException; import java.sql.Connection; import java.sql.DriverManager; import java.sql.ResultSet; import java.sql.Statement; import java.util.Collections; import java.util.Enumeration; // New Relic API imports import com.newrelic.api.agent.DatastoreParameters; import com.newrelic.api.agent.ExtendedRequest; import com.newrelic.api.agent.HeaderType; import com.newrelic.api.agent.NewRelic; import com.newrelic.api.agent.Trace; import com.newrelic.api.agent.TracedMethod; import com.newrelic.api.agent.Transaction; import fi.iki.elonen.NanoHTTPD; Copy Start the server and set its info as displayed in UI This section starts up the server on port 8081 and uses the NewRelic class from the API to call the methods setServerInfo, setAppServerPort, and setInstanceName. These API calls affect what is shown in the APM UI. public NewRelicApiServer() throws IOException, URISyntaxException { super(8081); // Set Dispatcher name and version NewRelic.setServerInfo(\"NanoHttp\", \"2.3.1\"); // Set Appserver port for jvm identification NewRelic.setAppServerPort(8081); // Set JVM instance name NewRelic.setInstanceName(\"Server\"); start(NanoHTTPD.SOCKET_READ_TIMEOUT, false); System.out.println(\"\\nRunning on http://localhost:8081/ \\n\"); } public static void main(String[] args) throws URISyntaxException { try { new NewRelicApiServer(); } catch (IOException ioe) { System.err.println(\"Unable to start the server:\\n\" + ioe); } } Copy Start tracing a transaction and add outbound Response headers The @Trace(dispatcher = true) annotation tells the agent to start a new transaction when the serve method is called if it is not called as part of an existing transaction (which in this case, it is not). If it were called as part of an existing transaction, it would simply be included as part of that transaction rather than start a new one. A reference to the current Transaction is obtained via a call to getTransaction and the name of the transaction is set via a call to the setTransactionName method. The request object, which in this example is of type IHTTPSession, is then wrapped using a class extending the Java agent API's ExtendedRequest class. The current Transaction is then converted to a web transaction via a call to setWebRequest which takes the wrapped ExtendedRequest as an argument. A call to the database is then made and the response object is generated and wrapped by a class implementing the Java agent API's Response interface. The wrapped response object is passed as an argument to setWebResponse which converts the current Transaction into a web transaction. Once the web request and response are set, a call to addOutboundResponseHeaders adds the headers to the response. This must be called after setWebRequest and setWebResponse, which together provide the agent with the inbound request headers and a place to record the outbound headers. A call to markResponseSent marks the time when the last byte of the response left the server as the current timestamp. @Trace(dispatcher = true) @Override public Response serve(IHTTPSession session) { // Obtain a reference to the current Transaction Transaction tx = NewRelic.getAgent().getTransaction(); // Set the name of the current transaction NewRelic.setTransactionName(\"Custom\", \"ExternalHTTPServer\"); // Wrap the Request object ExtendedRequest req = new RequestWrapper(session); // Set the request for the current transaction and convert it into a web transaction tx.setWebRequest(req); queryDB(); Response res = newFixedLengthResponse(\"<html><body><h1>SuccessfulResponse</h1>\\n</body></html>\\n\"); // Set the response for the current transaction and convert it into a web transaction tx.setWebResponse(new ResponseWrapper(res)); // Instruct the transaction to write the outbound response headers tx.addOutboundResponseHeaders(); // Mark the time when the response left the server tx.markResponseSent(); return res; } Copy Implement the Java agent API's Response Interface An implementation of the Java agent API's Response Interface is used to wrap the response object of the server, which in this example is of type fi.iki.elonen.NanoHTTPD.Response. The response is passed into the constructor of the ResponseWrapper class and implementations of the getStatus, getStatusMessage, setHeader, getContentType and getHeaderType methods are provided. The getHeaderType method returns a HeaderType enum that can either be HeaderType.HTTP or HeaderType.MESSAGE, as defined by the Java agent API. In this example the external call protocol is HTTP, so HeaderType.HTTP is returned. // Implement Response interface to create a wrapper for the outgoing Response object public class ResponseWrapper implements com.newrelic.api.agent.Response { private final Response httpResponse; public ResponseWrapper(Response httpResponse) { this.httpResponse = httpResponse; } @Override public int getStatus() throws Exception { return 200; } @Override public String getStatusMessage() throws Exception { return null; } @Override public void setHeader(String name, String value) { httpResponse.addHeader(name, value); } @Override public String getContentType() { return \"\"; } @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } } Copy Extend the Java agent API's ExtendedRequest class A subclass of the Java agent API's ExtendedRequest class is used to wrap the request object of the server, which in this example is of type IHTTPSession. The request is passed into the constructor of the RequestWrapper class, which provides implementations of the getRequestURI, getHeader, getRemoteUser, getParameterNames, getParameterValues, getAttribute, getCookieValue, getHeaderType, and getMethod methods. The getHeaderType method returns a HeaderType enum that can either be HeaderType.HTTP or HeaderType.MESSAGE, as defined by the Java agent API. In this example the external call protocol is HTTP so HeaderType.HTTP is returned. // Extend ExtendedRequest class to create a wrapper for the Request object class RequestWrapper extends ExtendedRequest { private IHTTPSession session; public RequestWrapper(IHTTPSession session) { super(); this.session = session; } @Override public String getRequestURI() { return session.getUri(); } @Override public String getHeader(String name) { return session.getHeaders().get(name.toLowerCase()); } @Override public String getRemoteUser() { return null; } @SuppressWarnings(\"rawtypes\") @Override public Enumeration getParameterNames() { return Collections.enumeration(session.getParms().keySet()); } @Override public String[] getParameterValues(String name) { return new String[]{session.getParms().get(name)}; } @Override public Object getAttribute(String name) { return null; } @Override public String getCookieValue(String name) { return null; } @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } @Override public String getMethod() { return session.getMethod().toString(); } } Copy Instrument an external call to a datastore This method makes an external call to the SQLite database that is created by the client. The @Trace annotation tells the agent to track this method as part of an existing transaction as started by the serve method. A reference to the current TracedMethod is obtained via a call to getTracedMethod. A DatastoreParameters object is then created using the builder pattern. The ExternalParameters object is then passed as an argument to the reportAsExternal method, which has the effect of reporting the TracedMethod as an external datastore call. @Trace public void queryDB() { Connection c = null; Statement stmt = null; try { Class.forName(\"org.sqlite.JDBC\"); c = DriverManager.getConnection(\"jdbc:sqlite:/tmp/test.db\"); c.setAutoCommit(false); System.out.println(\"Opened database successfully\"); stmt = c.createStatement(); ResultSet rs = stmt.executeQuery(\"SELECT * FROM COMPANY;\"); while (rs.next()) { int id = rs.getInt(\"id\"); String name = rs.getString(\"name\"); int age = rs.getInt(\"age\"); String address = rs.getString(\"address\"); float salary = rs.getFloat(\"salary\"); System.out.println(\"ID = \" + id); System.out.println(\"NAME = \" + name); System.out.println(\"AGE = \" + age); System.out.println(\"ADDRESS = \" + address); System.out.println(\"SALARY = \" + salary); System.out.println(); } rs.close(); stmt.close(); c.close(); } catch (Exception e) { System.err.println(e.getClass().getName() + \": \" + e.getMessage()); System.exit(0); } // Obtain a reference to the method currently being traced TracedMethod method = NewRelic.getAgent().getTracedMethod(); // Create a DatastoreParameters object and report a call to an external datastore service method.reportAsExternal( DatastoreParameters .product(\"sqlite\") .collection(\"test.db\") .operation(\"select\") .instance(\"localhost\", 8080) .databaseName(\"test.db\") .build()); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.44469,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> <em>API</em>: Instrumenting example app for external datastore calls and CAT",
        "sections": "<em>Java</em> <em>agent</em> <em>API</em>: Instrumenting example app for external datastore calls and CAT",
        "tags": "<em>API</em> <em>guides</em>",
        "body": "This document demonstrates using the New Relic <em>Java</em> <em>agent</em> <em>API</em> to instrument a simple client and server application. The instrumentation has these goals: To record external HTTP and datastore transactions. To link external transactions between two applications running New Relic <em>agents</em> (known"
      },
      "id": "6043d431196a67294f960f54"
    }
  ],
  "/docs/agents/java-agent/api-guides/java-agent-api-instrumenting-example-app-external-datastore-calls-cat": [
    {
      "sections": [
        "Java agent API: Custom instrumentation with annotation of an example app",
        "Important",
        "Complete example app using API",
        "Tip",
        "Complete API call example",
        "How the example uses the API",
        "Import the needed packages",
        "Set @Trace for transaction traces",
        "Create custom names for web transactions",
        "Bypass Apdex when collecting non-public data",
        "Record the user ID",
        "Collect promotion data",
        "Send instructions to the handler",
        "Include page load timing code in the HTTP response",
        "Complete the HTTP response"
      ],
      "title": "Java agent API: Custom instrumentation with annotation of an example app",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "a6a2aadf63f8282b7d599579f67010fbd600d183",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/java-agent-api-custom-instrumentation-annotation-example-app/",
      "published_at": "2021-05-05T07:03:35Z",
      "updated_at": "2021-03-16T14:30:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you set up custom instrumentation for your Java application. This document shows an example of using custom instrumentation with annotation in an imaginary application. Important For best results when using the API, ensure you have the latest Java agent release. Complete example app using API Below is an example of an imaginary store app's servlet using the Java agent API. Tip If you copy and paste example code, be sure to use appropriate spacing on your command lines. Complete API call example package test; import java.io.IOException; import java.io.PrintWriter; import java.util.Random; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; // Java agent API imports import com.newrelic.api.agent.NewRelic; import com.newrelic.api.agent.Trace; public class TestServlet extends HttpServlet { // instrumentation via annotation @Trace(dispatcher = true) protected void processRequest(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { saveNewRelicInfo(req); doRequestWork(req); writeResponse(resp); } private void saveNewRelicInfo(HttpServletRequest req) { String storeId = req.getParameter(\"storeId\"); if (storeId != null) { // set the name of the Transaction NewRelic.setTransactionName(null, \"/store\"); if (storeId.equals(\"betaStore\")) { // prevent the method from contributing to the Apdex score NewRelic.ignoreApdex(); } } String userId = req.getParameter(\"userId\"); if (userId != null) { // set the user name to associate with the RUM JavaScript footer // for the current web transaction NewRelic.setUserName(userId); // add a key/value pair to the current transaction NewRelic.addCustomParameter(\"userId\", userId); } String promotionId = req.getParameter(\"promotionId\"); if (promotionId != null) { // increment the metric counter for the given name NewRelic.incrementCounter(\"Custom/Promotion\"); } } protected void doRequestWork(HttpServletRequest req) { try { long millisToSleep = new Random().nextInt(5000); Thread.sleep(millisToSleep); // record a response time in milliseconds for the given metric name NewRelic.recordResponseTimeMetric(\"Custom/RandomSleep\", millisToSleep); } catch (InterruptedException e) { // report a handled exception NewRelic.noticeError(e, false); } } protected void writeResponse(HttpServletResponse resp) throws IOException { resp.setContentType(\"text/html;charset=UTF-8\"); PrintWriter out = resp.getWriter(); out.println(\"<html>\"); out.println(\"<head>\"); // get the RUM JavaScript header for the current web transaction out.println(NewRelic.getBrowserTimingHeader()); out.println(\"<title>NewRelic API example servlet</title>\"); out.println(\"</head>\"); out.println(\"<body>\"); out.println(\"<h1>API example</h1>\"); // get the RUM JavaScript footer for the current web transaction out.println(NewRelic.getBrowserTimingFooter()); out.println(\"</body>\"); out.println(\"</html>\"); out.close(); } protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { processRequest(req, resp); } protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { processRequest(req, resp); } } Copy How the example uses the API Here is the same example app divided into sections that describe how the API is used: Import the needed packages This part of the example shows the imports needed for the example application and Java agent API. package test; import java.io.IOException; import java.io.PrintWriter; import java.util.Random; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; // Java agent API imports import com.newrelic.api.agent.NewRelic; import com.newrelic.api.agent.Trace; Copy Set @Trace for transaction traces This part of the API call provides instructions to instrument this call using New Relic's trace annotation @Trace. Any requests that hit processRequest will now show a segment in APM's Transaction trace call chart. public class TestServlet extends HttpServlet { // instrumentation via annotation @Trace(dispatcher = true) protected void processRequest(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { saveNewRelicInfo(req); doRequestWork(req); writeResponse(resp); } Copy Create custom names for web transactions This part of the API call instructs web transactions containing a storeId value to appear in APM's Transactions page with the custom transaction name you set. A request to any one store will appear under the same, aggregate name. private void saveNewRelicInfo(HttpServletRequest req) { String storeId = req.getParameter(\"storeId\"); if (storeId != null) { // set the name of the Transaction NewRelic.setTransactionName(null, \"/store\"); } } Copy Bypass Apdex when collecting non-public data This part of the API call excludes the non-public beta storeID from affecting the Apdex score. if (storeId.equals(\"betaStore\")) { // prevent the method from contributing to the Apdex score NewRelic.ignoreApdex(); } Copy Record the user ID This part of the API call inserts additional metadata into the page load timing request so that browser traces can be tied with the userId. It also records the userId as a custom parameter on the transaction so that it appears in the parameter details of a transaction trace. (Page load timing sometimes is referred to as real user monitoring or RUM.) String userId = req.getParameter(\"userId\"); if (userId != null) { // set the user name to associate with the RUM JavaScript footer // for the current web transaction NewRelic.setUserName(userId); // add a key/value pair to the current transaction NewRelic.addCustomParameter(\"userId\", userId); } Copy Collect promotion data This part of the API call records the number of times a promotion was viewed so that the metrics can appear on a custom dashboard. Important For metrics you want to graph in custom dashboards, be sure to prepend Custom/ to the metric name; for example, Custom/Promotion. String promotionId = req.getParameter(\"promotionId\"); if (promotionId != null) { // increment the metric counter for the given name NewRelic.incrementCounter(\"Custom/Promotion\"); } Copy Send instructions to the handler This part of the API call sends a set of instructions to the handler for processing requests and handling exceptions. protected void doRequestWork(HttpServletRequest req) { try { long millisToSleep = new Random().nextInt(5000); Thread.sleep(millisToSleep); // record a response time in milliseconds for the given metric name NewRelic.recordResponseTimeMetric(\"Custom/RandomSleep\", millisToSleep); } catch (InterruptedException e) { // report a handled exception NewRelic.noticeError(e, false); } } protected void writeResponse(HttpServletResponse resp) throws IOException { Copy Include page load timing code in the HTTP response This part of the API call defines what to include in the HttpServletResponse. For manual instrumentation of Browser monitoring to monitor page load timing (sometimes referred to as real user monitoring or RUM): Set the header after the < head> tag. Set the footer at the end of < body> tag. resp.setContentType(\"text/html;charset=UTF-8\"); PrintWriter out = resp.getWriter(); out.println(\"<html>\"); out.println(\"<head>\"); // get the RUM JavaScript header for the current web transaction out.println(NewRelic.getBrowserTimingHeader()); out.println(\"<title>NewRelic API example servlet</title>\"); out.println(\"</head>\"); out.println(\"<body>\"); out.println(\"<h1>API example</h1>\"); // get the RUM JavaScript footer for the current web transaction out.println(NewRelic.getBrowserTimingFooter()); out.println(\"</body>\"); out.println(\"</html>\"); out.close(); } Copy Complete the HTTP response This part of the API call defines the remaining information to include in the HttpServletResponse response. protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { processRequest(req, resp); } protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { processRequest(req, resp); } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.81137,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> <em>API</em>: Custom instrumentation with annotation of an example app",
        "sections": "<em>Java</em> <em>agent</em> <em>API</em>: Custom instrumentation with annotation of an example app",
        "tags": "<em>API</em> <em>guides</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> <em>API</em> lets you set up custom instrumentation for your <em>Java</em> application. This document shows an example of using custom instrumentation with annotation in an imaginary application. Important For best results when using the <em>API</em>, ensure you have the latest <em>Java</em> <em>agent</em> release"
      },
      "id": "603eb76a64441f48424e886b"
    },
    {
      "sections": [
        "Java agent API: Instrument using annotation",
        "Important",
        "Configure your agent for annotations",
        "Tip",
        "Create a new transaction",
        "Add detail to your transactions",
        "Convert a transaction to a web request",
        "Define your own @Trace annotation class",
        "Properties for @Trace",
        "dispatcher",
        "async",
        "metricName",
        "excludeFromTransactionTrace",
        "leaf",
        "More API functions"
      ],
      "title": "Java agent API: Instrument using annotation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "4a373504c0682b36745d2283fdd902ead43510ec",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/java-agent-api-instrument-using-annotation/",
      "published_at": "2021-05-05T06:57:49Z",
      "updated_at": "2021-03-16T04:31:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent provides several options for custom instrumentation. One of those options is adding the Java agent API's @Trace annotations to your application code. This document describes how to use annotations. Important To use annotations, you must modify the source code. If you can't or don't want to modify your source code, see Custom instrumentation for other instrumentation options. Configure your agent for annotations By default, the configuration setting enable_custom_tracing is set to true in the Java agent, which is the setting required for @Trace annotations to function. This setting is not included in the newrelic.yml by default. The only time you need to incorporate this setting into your configuration file is if you want to disable @Trace annotations altogether. To do this, set enable_custom_tracing: false (prefaced with two spaces) in the common stanza of your newrelic.yml. To detect custom traces: Make sure that newrelic-api.jar appears in your classpath. Add @Trace annotations to your code. In each class containing a method you want to instrument, call: import com.newrelic.api.agent.Trace; Copy Place the @Trace annotation on each target method. Tip The annotation com.newrelic.api.agent.Trace is located in the newrelic-api.jar. Create a new transaction If transactions do not appear and you want to start a new transaction, include dispatcher=true with the @Trace annotation: @Trace (dispatcher=true) public void run() { // background task } Copy Add detail to your transactions If your transaction traces show large blocks of uninstrumented time and you want to include some more methods within the trace, you can use the @Trace annotation without parameters: @Trace protected void methodWithinTransaction() { // work } Copy Convert a transaction to a web request To make a background task report as a web browser transaction with a Java agent API call: In the method annotated with @Trace(dispatcher=true), call: NewRelic.setRequestAndResponse(Request request, Response response) Copy The arguments are implementations of the Request and Response interfaces in newrelic-api.jar. Important Even if your Request and Response objects already are present, you still need to add this API call. Define your own @Trace annotation class If you define your own @Trace annotation class, there is no dependency on the newrelic-api.jar. To define the class: package com.test; @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Trace { public static final String NULL = \"\"; String metricName() default NULL; boolean dispatcher() default false; String tracerFactoryName() default NULL; } Copy Then, configure the agent to use this annotation in the common section of the newrelic.yml: class_transformer: trace_annotation_class_name: com.test.Trace Copy Properties for @Trace The @Trace annotation supports the following properties. dispatcher Type: Boolean Default: false If true, the agent will start a transaction when it reaches a method with this @Trace annotation if a transaction is not already in progress. If a transaction is already in progress, the method with this annotation will be included in the ongoing transaction, rather than starting a new one. If false (default), no metrics will be recorded if the agent has not started a transaction before the @Trace annotation is reached. For example: @Trace(dispatcher=true) Copy async Type: Boolean Default: false If true, this method is marked as asynchronous and the agent will trace this method if it linked to an existing transaction. For example: @Trace(async=true) Copy If false (default), the method is not marked as asynchronous. If other @Trace annotations are present and the method is not executing asynchronously, it will still be traced. metricName Type: String Default: (none) This property affects transaction traces and error reporting. By default, the metric name will include the class name followed by the method name. If you do not want class followed by method, then you can use this property to change the metric name. If you set the metricName, as in @Trace(metricName=\"YourMessageHere\"), then the time spent in this method will appear as YourMessageHere in any transaction trace. If you set the metricName in addition to the dispatcher, as in @Trace(metricName=\"YourMessageHere\", dispatcher=true), then the transaction name will appear as YourMessageHere in the APM Transactions page but the time spent in this method will not appear as YourMessageHere in any transaction trace. Here is an example: @Trace(metricName=\"YourMetricName\") Copy Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. excludeFromTransactionTrace Type: Boolean Default: false If true, the method will be excluded from the transaction trace. The agent will still collect metrics for the method. Here is an example: @Trace(excludeFromTransactionTrace=true) Copy leaf Type: Boolean Default: false A leaf tracer has no child tracers. This is useful when you want all time attributed to the tracer, even if other trace points are encountered the tracer's execution. Database tracers often act as a leaf so that all time is attributed to database activity, even if instrumented external calls are made. Here is an example: @Trace(leaf=true) Copy If a leaf tracer does not participate in transaction traces, the agent can create a tracer with lower overhead. Here is an example: @Trace(excludeFromTransactionTrace=true, leaf=true) Copy More API functions For more about the Java agent API and its functionality, see the Java agent API introduction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.69845,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> <em>API</em>: Instrument using annotation",
        "sections": "<em>Java</em> <em>agent</em> <em>API</em>: Instrument using annotation",
        "tags": "<em>API</em> <em>guides</em>",
        "body": "New Relic&#x27;s <em>Java</em> <em>agent</em> provides several options for custom instrumentation. One of those options is adding the <em>Java</em> <em>agent</em> <em>API</em>&#x27;s @Trace annotations to your application code. This document describes how to use annotations. Important To use annotations, you must modify the source code. If you can&#x27;t"
      },
      "id": "603eb64a28ccbc9ca2eba79f"
    },
    {
      "sections": [
        "Java agent API: Instrument external calls, messaging, datastore, web frameworks",
        "External API",
        "External parameters builders",
        "Important",
        "Cross application tracing API",
        "Client wrappers",
        "OutbounderHeaders implementation",
        "InboundHeaders implementation",
        "Server wrappers",
        "Extend ExtendedRequest class",
        "Response interface implementation",
        "CAT implementation using wrappers",
        "Cross application tracing: Client-side",
        "Cross application tracing: Server-side",
        "Messaging API",
        "Messaging API implementation",
        "Message with CAT headers implementation",
        "Datastore API",
        "Datastore API implementation",
        "Datastore API: Slow query",
        "Datastore with slow query implementation",
        "WebFrameworks API",
        "Tip",
        "WebFrameworks API implementation",
        "For more help"
      ],
      "title": "Java agent API: Instrument external calls, messaging, datastore, web frameworks",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "714d226d7cc81508ecd006cb53c26c7525abfd4e",
      "image": "https://docs.newrelic.com/static/00e2b7a703330efa62b14e15dda69907/1ff84/CAT_diagram.png",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/java-agent-api-instrument-external-calls-messaging-datastore-web-frameworks/",
      "published_at": "2021-05-05T06:59:42Z",
      "updated_at": "2021-03-11T03:37:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent collects and reports information on web transactions and non-web transactions, such as background tasks. The agent should instrument supported frameworks automatically, without any need to modify your application code. However, in addition to custom code and frameworks or technology not listed in the Compatibility and requirements for the Java agent documentation, some implementations of supported frameworks may require custom instrumentation. This document describes how to use the Java agent API to instrument external calls, messaging frameworks, cross application tracing (CAT), datastores, and web frameworks. For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 3.36.0 or higher. External API The External API enables applications to report external service calls to New Relic. This information appears on the External services page in APM. To report HTTP external activity, simply create an instance of ExternalParameters using the HttpParameters builder, and call reportAsExternal(ExternalParameters parameters) on the traced method you want to report. External API String library = \"HttpClient\"; // a user-recognizable name for the library that is being used URI uri = request.getURI(); // the URI that is being requested String procedure = \"execute\"; // these are typically named after the method in the library that's being instrumented // construct external parameters ExternalParameters params = HttpParameters .library(library) .uri(uri) .procedure(procedure) .inboundHeaders(inboundHeaders) .build(); // report the current method as doing external activity NewRelic.getAgent().getTracedMethod().reportAsExternal(params); Copy External parameters builders There are several builders to create ExternalParameters: DatastoreParameters HttpParameters GenericParameters MessageConsumeParameters MessageProduceParameters These builders create the input parameter object for TracedMethod's reportAsExternal API call. These parameter objects are used for things like linking HTTP external calls via cross application tracing, tracing external calls to a datastore, tracing external calls to a datastore with additional slow query processing, as well as tracing calls between message producers and consumers. Important All of the methods of this class have the potential to expose sensitive private information. Use caution when creating the arguments, paying particular attention to URIs and string values. Cross application tracing API The cross application tracing (CAT) API allows the New Relic Java agent to link transactions across applications monitored by New Relic. The API uses client and server wrappers that allow the agent to read headers from requests, and add headers to responses. Client wrappers For the agent to write outbound request headers in the client initiating the request, use the OutboundHeaders interface. For example: OutbounderHeaders implementation class OutboundWrapper implements OutboundHeaders { private final HttpUriRequest delegate; // OutboundHeaders is implemented by delegating to the library's request object public OutboundWrapper(HttpUriRequest request) { this.delegate = request; } // This allows the agent to add the correct headers to the HTTP request @Override public void setHeader(String name, String value) { delegate.addHeader(name, value); } // New Relic CAT specifies different header names for HTTP and MESSAGE @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } } Copy For the agent to read inbound response headers in the client receiving the response, implement the InboundHeaders. For example: InboundHeaders implementation class InboundWrapper implements InboundHeaders { private final CloseableHttpResponse responseHeaders; // OutboundHeaders is implemented by delegating to the library's response object public InboundWrapper(CloseableHttpResponse responseHeaders) { this.responseHeaders = responseHeaders; } // New Relic CAT specifies different header names for HTTP and MESSAGE @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } // this allows the agent to read the correct headers from the HTTP response @Override public String getHeader(String name) { return responseHeaders.getFirstHeader(name).getValue(); } } Copy Server wrappers For the agent to get web request headers, you must extend the ExtendedRequest class: Extend ExtendedRequest class // Extend ExtendedRequest class to create a wrapper for the Request object class RequestWrapper extends ExtendedRequest { private IHTTPSession session; public RequestWrapper(IHTTPSession session) { super(); this.session = session; } @Override public String getRequestURI() { return session.getUri(); } @Override public String getHeader(String name) { return session.getHeaders().get(name); } @Override public String getRemoteUser() { return null; } @SuppressWarnings(\"rawtypes\") @Override public Enumeration getParameterNames() { return Collections.enumeration(session.getParms().keySet()); } @Override public String[] getParameterValues(String name) { return new String[]{session.getParms().get(name)}; } @Override public Object getAttribute(String name) { return null; } @Override public String getCookieValue(String name) { return null; } @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } @Override public String getMethod() { return session.getMethod().toString(); } } Copy For the agent to set the web response headers, implement the Response interface: Response interface implementation // Implement Response interface to create a wrapper for the outgoing Response object public class ResponseWrapper implements com.newrelic.api.agent.Response { private final Response httpResponse; public ResponseWrapper(Response httpResponse) { this.httpResponse = httpResponse; } @Override public int getStatus() throws Exception { return 200; } @Override public String getStatusMessage() throws Exception { return null; } @Override public void setHeader(String name, String value) { httpResponse.addHeader(name, value); } @Override public String getContentType() { return \"\"; } @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } } Copy CAT implementation using wrappers Using the wrapper objects described in the previous sections, you can enable the Java agent to do cross application tracing (CAT) on the client and server side. For example: Cross application tracing: Client-side @Trace public int makeExternalCall(URI uri) throws IOException { String library = \"HTTPClient\"; String procedure = \"Execute\"; HttpUriRequest request = RequestBuilder.get().setUri(uri).build(); // Wrap the outbound Request object OutboundWrapper outboundHeaders = new OutboundWrapper(request); // Obtain a reference to the method currently being traced TracedMethod tracedMethod = NewRelic.getAgent().getTracedMethod(); // Add headers for outbound external request tracedMethod.addOutboundRequestHeaders(outboundHeaders); CloseableHttpClient connection = HttpClientBuilder.create().build(); CloseableHttpResponse response = connection.execute(request); // Wrap the incoming Response object InboundWrapper inboundHeaders = new InboundWrapper(response); // Create an input parameter object for a call to an external HTTP service ExternalParameters params = HttpParameters .library(library) .uri(uri) .procedure(procedure) .inboundHeaders(inboundHeaders) .build(); // Report a call to an external HTTP service tracedMethod.reportAsExternal(params); return response.getStatusLine().getStatusCode(); } Copy In this sample code, the agent is configured to report an external call using CAT on the client that is initiating the request. These steps can be summarized as follows: Implement OutboundHeaders and InboundHeaders using framework classes on the client. Use addOutboundRequestHeaders(OutboundHeaders outboundHeaders) to have the agent add appropriate headers to the outbound request. Create ExternalParameters object using HttpParameters builder and provide inbound response headers. Report as an external request using reportAsExternal(ExternalParameters params). Cross application tracing: Server-side @Trace(dispatcher = true) @Override public Response serve(IHTTPSession session) { // Obtain a reference to the current Transaction Transaction tx = NewRelic.getAgent().getTransaction(); // Set the name of the current transaction NewRelic.setTransactionName(\"Custom\", \"ExternalHTTPServer\"); // Wrap the Request object ExtendedRequest req = new RequestWrapper(session); // Set the request for the current transaction and convert it into a web transaction tx.setWebRequest(req); queryDB(); Response res = newFixedLengthResponse(\"<html><body><h1>SuccessfulResponse</h1>\\n</body></html>\\n\"); // Set the response for the current transaction and convert it into a web transaction tx.setWebResponse(new ResponseWrapper(res)); // Instruct the transaction to write the outbound response headers tx.addOutboundResponseHeaders(); // Mark the time when the response left the server tx.markResponseSent(); return res; } Copy In this sample code, the agent is configured to report an external call using CAT on the server that is responding to the request. These steps can be summarized as follows: Implement Response and extend the ExtendedRequest class using framework classes on the server. Use setWebRequest(ExtendedRequest request) and setWebResponse(Response response) to convert the transaction into a web transaction and together provide the agent with the inbound request headers and a place to record the outbound headers. It's important to use both setWebRequest(ExtendedRequest request) and setWebResponse(Response response) together, because the transaction name depends on the request object, and the response code depends on the response object. Use addOutboundResponseHeaders() to have the agent add appropriate headers to the outbound response. Mark the end of the response with a call to markResponseSent(). Messaging API The messaging API allows applications to report interactions with message queue brokers. It builds on top of the External API by providing the MessageConsumerParametersMessage and MessageConsumerParameters. This API generates the necessary metrics to identify message broker interactions. The UI will use these metrics to display messaging data including segments in transactions with the appropriate action and count (message put, or message take), a dedicated messages tab in transaction traces, and more. Providing inbound and outbound headers to the API also allows the agent to add CAT headers, and record CAT metrics, which enables the UI to draw service maps that show connections between applications. Important The messaging API relies on two-way communication between producers and consumers. If your producer does not receive an acknowledgment from a consumer, like in a fire-and-forget pattern, the messaging API will not accurately reflect the interactions with message queue brokers. The following example demonstrates how to instrument a fictional JMS library. Messaging API implementation public class MessageProducer { // instrument the method that puts messages on a queue @Trace public void sendMessageToQueue(Message message) { ExternalParameters messageProduceParameters = MessageProduceParameters.library(\"JMS\") .destinationType(DestinationType.NAMED_QUEUE) .destinationName(message.getJMSDestination()) .outboundHeaders(new OutboundWrapper(message)) .build(); NewRelic.getAgent().getTracedMethod().reportAsExternal(messageProduceParameters); } } Copy To simplify things, the agent assumes that sendMessageToQueue always puts a message in a named queue. In reality, a message can be sent to different destination types, including named queues, temporary queues, topics, and temporary topics. The API provides an enum to report messages to different destination types: NAMED_QUEUE, TEMP_QUEUE, NAMED_TOPIC, TEMP_TOPIC. It's important to specify the appropriate destination type because the UI will display the names of named queues and named topics and will omit the names of temporary queues and temporary topics. If the library is capable of transmitting CAT headers, an OutboundHeaders object will be provided to the API so that the agent can add CAT headers. Message with CAT headers implementation public class MessageConsumer { @Trace public Message messageReceive() { ExternalParameters messageConsumeParameters = MessageConsumeParameters.library(\"JMS\") .destinationType(DestinationType.NAMED_QUEUE) .destinationName(message.getJMSDestination()) .inboundHeaders(new InboundWrapper(message)) .build(); NewRelic.getAgent().getTracedMethod().reportAsExternal(messageConsumeParameters); return message; } } Copy Datastore API When a traced method is reported as an external datastore call, the call is shown in the APM Databases page. Because datastores are external to the running application, the method is reported as datastore activity using the reportAsExternal(ExternalParameters params) method. The only difference is that a different builder, DatastoreParameters, is used to create the appropriate ExternalParameters object. Datastore API implementation TracedMethod tracedMethod = NewRelic.getAgent().getTracedMethod(); tracedMethod.reportAsExternal( DatastoreParameters .product(\"sqlite\") // the datastore vendor .collection(\"test.db\") // the name of the collection (or table for SQL databases) .operation(\"select\") // the operation being performed, e.g. \"SELECT\" or \"UPDATE\" for SQL databases .instance(\"localhost\", 8080) // the datastore instance information - generally can be found as part of the connection .databaseName(\"test.db\") // may be null, indicating no keyspace for the command .build()); Copy Datastore API: Slow query This API call provides the same behavior as the Datastore API call and extends it to allow slow query information to be tracked. The same reportAsExternal(ExternalParameters params) method and builder are used, but with an additional builder method. Datastore with slow query implementation Creating the appropriate ExternalParameters object is illustrated below: //Reporting a method as doing datastore activity TracedMethod tracedMethod = NewRelic.getAgent().getTracedMethod(); tracedMethod.reportAsExternal( DatastoreParameters .product(\"sqlite\") // the datastore vendor .collection(\"test.db\") // the name of the collection (or table for SQL databases) .operation(\"select\") // the operation being performed, e.g. \"SELECT\" or \"UPDATE\" for SQL databases .instance(\"localhost\", 8080) // the datastore instance information - generally can be found as part of the connection .databaseName(\"test.db\") // may be null, indicating no keyspace for the command .slowQuery(rawQuery,QUERY_CONVERTER) .build()); private static QueryConverter<String> QUERY_CONVERTER = new QueryConverter<String>() { @Override public String toRawQueryString(String statement) { // Do work to transform raw query object to string return statement; } @Override public String toObfuscatedQueryString(String statement) { // Do work to remove any sensitive information here return obfuscateQuery(statement); } }; Copy WebFrameworks API The WebFrameworks API allows the agent to report additional identifying information about the application. // Set the dispatcher name and version which is reported to APM. // The dispatcherName is intended to represent the type of server that this // application is running on such as: Tomcat, Jetty, Netty, etc. NewRelic.setServerInfo(String dispatcherName, String version) // Set the app server port which is reported to APM. NewRelic.setAppServerPort(int port) // Set the instance name in the environment. // A single host:port may support multiple JVM instances. // The instance name is intended to help identify a specific JVM instance. NewRelic.setInstanceName(String instanceName) Copy Tip These values can be set only once. Subsequent calls will have no effect. WebFrameworks API implementation public NewRelicApiClient() throws IOException, URISyntaxException { super(8080); // Set Dispatcher name and version. NewRelic.setServerInfo(\"NanoHttp\", \"2.3.1\"); // Set Appserver port for jvm identification NewRelic.setAppServerPort(8080); // Set JVM instance name NewRelic.setInstanceName(\"Client:8080\"); start(NanoHTTPD.SOCKET_READ_TIMEOUT, false); System.out.println(\"\\nRunning on http://localhost:8080/ \\n\"); } Copy For more help Additional documentation resources include: New Relic Java agent API Javadoc (detailed API documentation on GitHub) Java agent API example (example application using custom instrumentation for cross application tracing and external datastore calls) Java agent API guide (goal-driven guide to using the Java agent API) Java instrumentation by annotation (how to use annotations to instrument your application code)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.44667,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> <em>API</em>: Instrument external calls, messaging, datastore, web frameworks",
        "sections": "<em>Java</em> <em>agent</em> <em>API</em>: Instrument external calls, messaging, datastore, web frameworks",
        "tags": "<em>API</em> <em>guides</em>",
        "body": " or technology not listed in the Compatibility and requirements for the <em>Java</em> <em>agent</em> documentation, some implementations of supported frameworks may require custom instrumentation. This document describes how to use the <em>Java</em> <em>agent</em> <em>API</em> to instrument external calls, messaging frameworks, cross application"
      },
      "id": "6043c7f828ccbcef982c6077"
    }
  ],
  "/docs/agents/java-agent/async-instrumentation/disable-scala-netty-akka-play-2-instrumentation": [
    {
      "sections": [
        "Troubleshoot Java asynchronous instrumentation",
        "Verify your instrumentation",
        "Use logs to troubleshoot",
        "Problem: Transaction times are too long",
        "Problem: No transaction trace data",
        "Problem: Too few async calls",
        "Ensure that each activity you monitor is appropriately linked",
        "Check if you are missing required annotations"
      ],
      "title": "Troubleshoot Java asynchronous instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Async instrumentation"
      ],
      "external_id": "0f21da73ba02edc45ec0cbbbaa7e0fc45678404b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/async-instrumentation/troubleshoot-java-asynchronous-instrumentation/",
      "published_at": "2021-05-05T07:05:09Z",
      "updated_at": "2021-03-16T09:03:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you are having problems using the Java agent API for async tokens and segments, use these techniques to help you find answers and solve problems. Verify your instrumentation The API has a number of built-in safety mechanisms to prevent issues caused by incorrect API usage, but you can use these techniques to verify that your application’s instrumentation is correct: After instrumenting your code, verify that the logs show that an equal number of tokens have been created and expired. For more information on which log messages to look for, see Use logs to troubleshoot. Check the garbage collection statistics under APM's JVMs page to determine whether or not your changes have significantly altered garbage collection patterns. Check if any segments or tokens are timing out by reviewing your transaction traces for a timed_out attribute. If so, you can change the limit with token_timeout and segment_timeout. Use logs to troubleshoot To customize your Java agent logging, see Generating logs. Then, you can examine your logs for these common messages: To view created tokens, check logs at FINEST for: Transaction com.newrelic.agent.Transaction@5a7cc8e: created active token com.newrelic.agent.TokenImpl@7db8d0e8 Copy To view expired tokens and the time that they expired, check logs at FINEST for: Transaction com.newrelic.agent.Transaction@5a7cc8e: expired token com.newrelic.agent.TokenImpl@7db8d0e8 Copy To view created segments, check logs at FINEST for: Transaction com.newrelic.agent.Transaction@486b7f04: startSegment(): com.newrelic.agent.Segment@2b7fdad3 created and started with tracer com.newrelic.agent.tracers.OtherRootTracer@4df4a953 Copy To view ended segments and the time that they ended, check logs at FINEST for: com.newrelic.agent.Transaction@486b7f04--finish segment(): com.newrelic.agent.Segment@2b7fdad3 async finish with tracer com.newrelic.agent.tracers.OtherRootTracer@4df4a953 Copy Problem: Transaction times are too long Make sure to expire tokens and end or ignore segments; otherwise transactions may take longer to report to New Relic. The Java agent has a timeout mechanism for tokens and segments that are not ended correctly. For more information, see token_timeout and segment_timeout. Problem: No transaction trace data Inspect transaction traces to make sure expected asynchronous work is reported. If you do not see any transaction traces, make sure your transaction duration exceeds the transaction trace threshold set in transaction_threshold. Problem: Too few async calls If too few calls are being reported: Ensure that each activity you monitor is appropriately linked In the faulty example below, a parallel stream is being used, which means that the work done inside the lambda in the call to map() can be scheduled on a different thread than the thread handling the request. Without creating a token to link all this work together, you will not see any of the work that gets scheduled on a different thread inside of your transaction. @RequestMapping(\"parallel_stream_bad\") @Trace(dispatcher = true) public ResponseEntity parallelStreamBad(@RequestParam(\"ids\") List<long> ids) { List<item> results = ids .parallelStream() .map(i -> requestItem(i)) .filter(item -> item != null) .collect(Collectors.toList()); return formattedResponse(\"parallel_stream_bad\", results); } Copy Check if you are missing required annotations The example below will report only a subset of the calls to requestItem() because it is impossible to put @Trace(async = true) around blocks of anonymous work inside the call to map(). Instead, you should pass the token into requestItem() and link it, and then add @Trace(async=true) around it. Or use a helper function like requestItemAsync() to do this without changing your existing methods. @RequestMapping(\"parallel_stream_bad2\") @Trace(dispatcher = true) public ResponseEntity parallelStreamBad2(@RequestParam(\"ids\") List<long> ids) { final Token token = NewRelic.getAgent().getTransaction().getToken(); List<item> results = ids .parallelStream() .map(id -> { token.link(); return requestItem(id); }) .filter(item -> item != null) .collect(Collectors.toList()); return formattedResponse(\"parallel_stream_bad2\", results); } Copy Compare this to the correct example below, in which the lambda expression is wrapped by the wrapper class InstrumentedCallable. This class accepts a token and a lambda, then wraps asynchronous work in @Trace(async = true) and uses a token to link the work to the request thread. @RequestMapping(\"parallel_stream_wrap\") @Trace(dispatcher = true) public ResponseEntity parallelStreamWrap(@RequestParam(\"ids\") List<long> ids) { final Token token = NewRelic.getAgent().getTransaction().getToken(); List<item> results = ids .parallelStream() .map(id -> InstrumentedCallable.instrumentCallable(token, () -> requestItem(id))) .map(c -> c.call()) .filter(item -> item != null) .collect(Collectors.toList()); token.expire(); return formattedResponse(\"parallel_stream_wrap\", results); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.07826,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Troubleshoot <em>Java</em> <em>asynchronous</em> <em>instrumentation</em>",
        "sections": "Troubleshoot <em>Java</em> <em>asynchronous</em> <em>instrumentation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "If you are having problems using the <em>Java</em> <em>agent</em> API for <em>async</em> tokens and segments, use these techniques to help you find answers and solve problems. Verify your <em>instrumentation</em> The API has a number of built-in safety mechanisms to prevent issues caused by incorrect API usage, but you can use"
      },
      "id": "603eb55a196a67260aa83dac"
    },
    {
      "sections": [
        "Introduction to Java async instrumentation",
        "Asynchronous operations",
        "Async and thread-switching",
        "Async and response time",
        "Custom instrumentation with the async API"
      ],
      "title": "Introduction to Java async instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Async instrumentation"
      ],
      "external_id": "3b0a9e1f2f6b69a8ad101ec59c592ac4a574ae63",
      "image": "https://docs.newrelic.com/static/a38112969f7c8a3001651b65853a803b/39c09/sZ6-I4x5BDSDspRS_G7Hefg.png",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/async-instrumentation/introduction-java-async-instrumentation/",
      "published_at": "2021-05-05T07:06:37Z",
      "updated_at": "2021-03-16T09:00:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic for Java includes a set of API methods for custom instrumentation of asynchronous activity. This is most useful to instrument asynchronous activity in unsupported frameworks, but you can also use the API to add additional instrumentation to supported frameworks. This document explains how asynchronous activity occurs, and how New Relic monitors async work. Asynchronous operations With a synchronous programming model, programming tasks are usually executed in a specific order. One task must complete before the next task begins, and each task blocks the next task from completing. Asynchronous programming uses a non-blocking model, so that tasks can be run in parallel. Tasks executed asynchronously are completely independent of each other in their execution and initialization. Because asynchronous code doesn't execute in a specific order, the server's full processing power can be used more efficiently, and the app's throughput increases. Async and thread-switching For applications that use asynchronous processing, thread-switching is when a program or task switches from one thread to another. Understanding these asynchronous interleavings can help you decide which methods should be instrumented. Here is an example method with a controller that makes external requests in parallel. These requests execute asynchronously, so each request executes independently of each other and getScoreAsync() returns immediately after being called. This allows the requesting thread to continue making requests while getScoreAsync() makes an external call and sends a reply. @ResponseBody @RequestMapping(\"getScores\", method = RequestMethod.Get produces = “text/plain”) public String getCreditScores(@RequestParam(name = \"uids\") uids) { return Arrays.stream(uids.split(\",\")) .parallel() .map(Integer::valueOf) .map(uid -> getScoreAsync(uid)) .collect(Collectors.toList());} Copy Some of these requests will finish before others. Some might even finish after the requesting thread has moved on to other tasks: With New Relic's asynchronous instrumentation, the APM UI flags the work as Async. For example, if the above method were instrumented by New Relic (either automatically or via custom instrumentation), this is what the APM UI would show on the Trace details page: one.newrelic.com > APM > (select an app) > Transactions > Transaction trace > Trace details: When asynchronous activity in a Java application is detected by APM, it is indicated with the Async flag in the Drilldown column. Async and response time Response time is defined as the duration of a transaction from the perspective of the requester. For asynchronous applications, the response time is often less than the total transaction time. This is because the methods don't have to wait for all preceding methods to complete before returning. Because tasks can be deferred, the application can take advantage of its limited resources and process things more quickly. The chart's response time line gives you more insight into the perceived behavior and speed of your application than does the total web transaction time: one.newrelic.com > APM > (select an app) > Summary: On the APM Summary page, asynchronous activity in a Java app can result in the response time (the blue line) being less than the total transaction time. This is because the methods don't have to wait for all preceding methods to complete before returning. Custom instrumentation with the async API To implement custom instrumentation of async work, see the Java agent async API guide. For general information on how to use the Java agent API, see Java agent API guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.07755,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Java</em> <em>async</em> <em>instrumentation</em>",
        "sections": "Introduction to <em>Java</em> <em>async</em> <em>instrumentation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " transaction time. This is because the methods don&#x27;t have to wait for all preceding methods to complete before returning. Custom <em>instrumentation</em> with the <em>async</em> API To implement custom <em>instrumentation</em> of <em>async</em> work, see the <em>Java</em> <em>agent</em> <em>async</em> API guide. For general information on how to use the <em>Java</em> <em>agent</em> API, see <em>Java</em> <em>agent</em> API guide."
      },
      "id": "603eb491e7b9d282bd2a07ca"
    },
    {
      "sections": [
        "Java agent API for asynchronous applications",
        "Async tracking tools: Tokens and segments",
        "Tokens: Connect async threads",
        "1. Start a transaction, then create and expire a token",
        "2. Mark a transaction as async and link to request thread",
        "3. View your async trace in the New Relic UI",
        "Tip",
        "Segments: Time arbitrary async activity",
        "1. Create a transaction and call an external service",
        "2. Start a segment, report externals, and end the segment"
      ],
      "title": "Java agent API for asynchronous applications",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Async instrumentation"
      ],
      "external_id": "7b5f035809040487d96279fb318203b479a61b02",
      "image": "https://docs.newrelic.com/static/06c87505ee5c0d97e598d04258587f52/c1b63/Screen-Shot-2017-03-14-at-4.50.31-PM.png",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/async-instrumentation/java-agent-api-asynchronous-applications/",
      "published_at": "2021-05-05T07:08:16Z",
      "updated_at": "2021-03-16T09:00:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic for Java (agent version 3.37 or higher) includes an API to instrument asynchronous activity. For supported frameworks, the agent usually instruments async work automatically. However, the async API can still be useful to add detail. This document provides examples of using tokens and segments to instrument your app. For more information about how New Relic instruments and displays async work in the APM UI, see Monitoring considerations for asynchronous applications. For details on the actual classes and methods, see the Javadoc. For general information on the Java agent API, see the Java agent API guide. For troubleshooting common problems, see Troubleshooting Java asynchronous applications. Async tracking tools: Tokens and segments The Java agent API provides two ways to trace asynchronous activity: Tokens: Tokens are passed between threads to link asynchronous units of work to a specific transaction. They do not perform any timing directly. Segments: Segments are used to measure an arbitrary piece of asynchronous application code, not necessarily associated with a method or thread. Segments are typically used to track external calls that are completed by a callback mechanism. Tokens: Connect async threads Use tokens to link arbitrary units of work that are on separate threads. This section describes how to use the token-related calls together to instrument async work. For detailed information on classes and methods, see the Javadoc. To use tokens, you first need to create the token, then link another call to the originating transaction. You should link the token as soon as possible within the other call. If you do not link the token immediately, you risk losing any methods that contain an @Trace below the call you are trying to link. You can also expire the token in the original call. The Java agent will then link the work in the New Relic UI. These examples illustrate how to use the token-related calls together: 1. Start a transaction, then create and expire a token Consider the method parallelStream() in the code snippet below. Because some of the calls to requestItemAsync() will occur on a separate thread, a token is created and passed to link that asynchronous work back to the requesting thread. /** * Example showing multi-threaded implementation of requesting data using a parallel {@link Stream}. */ @RequestMapping(\"parallel_stream\") @Trace(dispatcher = true) // starts a transaction public ResponseEntity<String> parallelStream(@RequestParam(\"ids\") List<Long> ids) { final Token token = NewRelic.getAgent().getTransaction(). getToken() ; List<item> results = ids .parallelStream() .map(id -> requestItemAsync\\(id, token)) // note we're calling a different method than parallelStreamBad .filter(item -> item != null) .collect(Collectors.toList()); token.expire() ; return formattedResponse(\"parallel_stream\", results); } Copy The agent API calls in this sample are: @Trace(dispatcher = true): Tells the agent to start a transaction. For more on this method, see the Javadoc. getToken(): Creates the token which will link the work together. For more on this method, see the Javadoc. token.expire(): Expires the token. This allows the transaction to end. For more on this method, see the Javadoc. 2. Mark a transaction as async and link to request thread The following code example shows requestItemAsync, which might execute on a separate thread from the requesting thread. For this reason, the token that was created in the previous code example is linked to the Transaction in requestItemAsync. Note that requestItemAsync() has the @Trace(async=true) annotation, which tells the agent to trace this method if it's linked to an existing transaction. After parallelStream() collects all results, the token is expired. This is important because it makes sure the transaction doesn't stay open after parallelStream() completes. @Trace(async = true) private Item requestItemAsync(long id, Token token) { token.link() ; return requestItem(id); } Copy The agent API calls in this sample are: @Trace(async = true): Starts a transaction. For more on this method, see the Javadoc. token.link(): Links the work being done in requestItemAsync() (which is executing on a different thread) to the requesting thread. For more on this method, see the Javadoc. 3. View your async trace in the New Relic UI Here's an example of a transaction trace in the APM UI for this endpoint: one.newrelic.com > APM > (select an app) > Transactions > Transaction trace > Trace details: All asynchronous method calls linked with a token are indicated with an Async icon. All asynchronous method calls linked with a token are indicated with an Async icon in the Drilldown column. It's not necessary to link methods that are on the same thread, but doing so will have no negative effect. It's often the case that a single token can be shared, like in the parallelStream() example. Tip By default, a transaction can create a maximum of 3000 tokens and each token has a default timeout of 180s. You can change the former limit with the token_limit config option and the latter with the token_timeout config option. Traces for transactions that exceed the token_limit will contain a token_clamp attribute. Increasing either config option may increase agent memory usage. Segments: Time arbitrary async activity Segments are used to measure an arbitrary piece of asynchronous application code, not necessarily associated with a method or thread. This is most commonly used to time connections to external services. Use segments if you want to: Time code that completes via a callback Time an asynchronous call that spans many methods Measure the time between when work is created and when it executed (for example, in a thread pool) 1. Create a transaction and call an external service The method below makes a call to an external service (in this case a database) using the method storeItem(): /** * Example showing single threaded implementation of inserting data into a datasource. */ @RequestMapping(\"insert\") @Trace(dispatcher = true) //starts a transaction public ResponseEntity insert(@RequestParam(\"id\") Long id) { if (id != null) { storeItem(id); return new ResponseEntity<>(\"insert\", HttpStatus.OK); } else { return new ResponseEntity<>(\"insert\", HttpStatus.BAD_REQUEST); } } Copy The goal in this case it to find out how long the Callable in the Lambda statement is waiting in the thread pool before executing, rather than determining how long storeItem() runs. For this reason, a segment is used instead of a token, and @Trace(async = true) is not necessary like it was for a token. The agent API call in this sample is: @Trace(dispatcher = true): Starts a transaction. For more on this method, see the Javadoc. 2. Start a segment, report externals, and end the segment The following code example shows a segment starting in the storeItem method to measure how long the Lambda statement is waiting in the thread pool. To stop timing the segment, you must call either .end() or .ignore(). If you don't want to report the segment as part of its parent transaction, call .ignore(). Otherwise, to report the segment as part of its parent transaction, call .end(). private void storeItem(long id) { Segment segment = NewRelic.getAgent().getTransaction(). startSegment(\"storeItem\") ; segment. reportAsExternal (DatastoreParameters .product(\"H2\") .collection(null) .operation(\"insert\") .instance(\"localhost\", 8080) .databaseName(\"test\") .build()); // fire and forget DB_POOL.submit(() -> { segment.end(); insertData(id); }); } Copy The agent API calls in this sample are: startSegment(...): Begins the segment that will time the code. For more on this method, see the Javadoc. reportAsExternal(DatastoreParameters()): Associates the time with a datastore external call This will show up in APM with datastore data. For more information, see reportAsExternal API. segment.end(): Stops timing this segment. For more on this method, see the Javadoc. 3. View your async trace in the New Relic UI When the method completes, APM displays a transaction trace with one external call: one.newrelic.com > APM > (select an app) > Transactions > Transaction trace > Trace details: A single asynchronous segment is called out in the Drilldown column. Tip By default, the agent can track a maximum of 1000 segments during a given transaction. You can change this limit with the segment_timeout config option. Traces of transactions that exceed this limit will contain a segment_clamp attribute. Increasing this limit may increase agent memory usage.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.07755,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> API for <em>asynchronous</em> applications",
        "sections": "<em>Java</em> <em>agent</em> API for <em>asynchronous</em> applications",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "New Relic for <em>Java</em> (<em>agent</em> version 3.37 or higher) includes an API to <em>instrument</em> asynchronous activity. For supported frameworks, the <em>agent</em> usually instruments <em>async</em> work automatically. However, the <em>async</em> API can still be useful to add detail. This document provides examples of using tokens"
      },
      "id": "603eb4c9196a67dde5a83db7"
    }
  ],
  "/docs/agents/java-agent/async-instrumentation/introduction-java-async-instrumentation": [
    {
      "sections": [
        "Troubleshoot Java asynchronous instrumentation",
        "Verify your instrumentation",
        "Use logs to troubleshoot",
        "Problem: Transaction times are too long",
        "Problem: No transaction trace data",
        "Problem: Too few async calls",
        "Ensure that each activity you monitor is appropriately linked",
        "Check if you are missing required annotations"
      ],
      "title": "Troubleshoot Java asynchronous instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Async instrumentation"
      ],
      "external_id": "0f21da73ba02edc45ec0cbbbaa7e0fc45678404b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/async-instrumentation/troubleshoot-java-asynchronous-instrumentation/",
      "published_at": "2021-05-05T07:05:09Z",
      "updated_at": "2021-03-16T09:03:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you are having problems using the Java agent API for async tokens and segments, use these techniques to help you find answers and solve problems. Verify your instrumentation The API has a number of built-in safety mechanisms to prevent issues caused by incorrect API usage, but you can use these techniques to verify that your application’s instrumentation is correct: After instrumenting your code, verify that the logs show that an equal number of tokens have been created and expired. For more information on which log messages to look for, see Use logs to troubleshoot. Check the garbage collection statistics under APM's JVMs page to determine whether or not your changes have significantly altered garbage collection patterns. Check if any segments or tokens are timing out by reviewing your transaction traces for a timed_out attribute. If so, you can change the limit with token_timeout and segment_timeout. Use logs to troubleshoot To customize your Java agent logging, see Generating logs. Then, you can examine your logs for these common messages: To view created tokens, check logs at FINEST for: Transaction com.newrelic.agent.Transaction@5a7cc8e: created active token com.newrelic.agent.TokenImpl@7db8d0e8 Copy To view expired tokens and the time that they expired, check logs at FINEST for: Transaction com.newrelic.agent.Transaction@5a7cc8e: expired token com.newrelic.agent.TokenImpl@7db8d0e8 Copy To view created segments, check logs at FINEST for: Transaction com.newrelic.agent.Transaction@486b7f04: startSegment(): com.newrelic.agent.Segment@2b7fdad3 created and started with tracer com.newrelic.agent.tracers.OtherRootTracer@4df4a953 Copy To view ended segments and the time that they ended, check logs at FINEST for: com.newrelic.agent.Transaction@486b7f04--finish segment(): com.newrelic.agent.Segment@2b7fdad3 async finish with tracer com.newrelic.agent.tracers.OtherRootTracer@4df4a953 Copy Problem: Transaction times are too long Make sure to expire tokens and end or ignore segments; otherwise transactions may take longer to report to New Relic. The Java agent has a timeout mechanism for tokens and segments that are not ended correctly. For more information, see token_timeout and segment_timeout. Problem: No transaction trace data Inspect transaction traces to make sure expected asynchronous work is reported. If you do not see any transaction traces, make sure your transaction duration exceeds the transaction trace threshold set in transaction_threshold. Problem: Too few async calls If too few calls are being reported: Ensure that each activity you monitor is appropriately linked In the faulty example below, a parallel stream is being used, which means that the work done inside the lambda in the call to map() can be scheduled on a different thread than the thread handling the request. Without creating a token to link all this work together, you will not see any of the work that gets scheduled on a different thread inside of your transaction. @RequestMapping(\"parallel_stream_bad\") @Trace(dispatcher = true) public ResponseEntity parallelStreamBad(@RequestParam(\"ids\") List<long> ids) { List<item> results = ids .parallelStream() .map(i -> requestItem(i)) .filter(item -> item != null) .collect(Collectors.toList()); return formattedResponse(\"parallel_stream_bad\", results); } Copy Check if you are missing required annotations The example below will report only a subset of the calls to requestItem() because it is impossible to put @Trace(async = true) around blocks of anonymous work inside the call to map(). Instead, you should pass the token into requestItem() and link it, and then add @Trace(async=true) around it. Or use a helper function like requestItemAsync() to do this without changing your existing methods. @RequestMapping(\"parallel_stream_bad2\") @Trace(dispatcher = true) public ResponseEntity parallelStreamBad2(@RequestParam(\"ids\") List<long> ids) { final Token token = NewRelic.getAgent().getTransaction().getToken(); List<item> results = ids .parallelStream() .map(id -> { token.link(); return requestItem(id); }) .filter(item -> item != null) .collect(Collectors.toList()); return formattedResponse(\"parallel_stream_bad2\", results); } Copy Compare this to the correct example below, in which the lambda expression is wrapped by the wrapper class InstrumentedCallable. This class accepts a token and a lambda, then wraps asynchronous work in @Trace(async = true) and uses a token to link the work to the request thread. @RequestMapping(\"parallel_stream_wrap\") @Trace(dispatcher = true) public ResponseEntity parallelStreamWrap(@RequestParam(\"ids\") List<long> ids) { final Token token = NewRelic.getAgent().getTransaction().getToken(); List<item> results = ids .parallelStream() .map(id -> InstrumentedCallable.instrumentCallable(token, () -> requestItem(id))) .map(c -> c.call()) .filter(item -> item != null) .collect(Collectors.toList()); token.expire(); return formattedResponse(\"parallel_stream_wrap\", results); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.07826,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Troubleshoot <em>Java</em> <em>asynchronous</em> <em>instrumentation</em>",
        "sections": "Troubleshoot <em>Java</em> <em>asynchronous</em> <em>instrumentation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "If you are having problems using the <em>Java</em> <em>agent</em> API for <em>async</em> tokens and segments, use these techniques to help you find answers and solve problems. Verify your <em>instrumentation</em> The API has a number of built-in safety mechanisms to prevent issues caused by incorrect API usage, but you can use"
      },
      "id": "603eb55a196a67260aa83dac"
    },
    {
      "sections": [
        "Java agent API for asynchronous applications",
        "Async tracking tools: Tokens and segments",
        "Tokens: Connect async threads",
        "1. Start a transaction, then create and expire a token",
        "2. Mark a transaction as async and link to request thread",
        "3. View your async trace in the New Relic UI",
        "Tip",
        "Segments: Time arbitrary async activity",
        "1. Create a transaction and call an external service",
        "2. Start a segment, report externals, and end the segment"
      ],
      "title": "Java agent API for asynchronous applications",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Async instrumentation"
      ],
      "external_id": "7b5f035809040487d96279fb318203b479a61b02",
      "image": "https://docs.newrelic.com/static/06c87505ee5c0d97e598d04258587f52/c1b63/Screen-Shot-2017-03-14-at-4.50.31-PM.png",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/async-instrumentation/java-agent-api-asynchronous-applications/",
      "published_at": "2021-05-05T07:08:16Z",
      "updated_at": "2021-03-16T09:00:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic for Java (agent version 3.37 or higher) includes an API to instrument asynchronous activity. For supported frameworks, the agent usually instruments async work automatically. However, the async API can still be useful to add detail. This document provides examples of using tokens and segments to instrument your app. For more information about how New Relic instruments and displays async work in the APM UI, see Monitoring considerations for asynchronous applications. For details on the actual classes and methods, see the Javadoc. For general information on the Java agent API, see the Java agent API guide. For troubleshooting common problems, see Troubleshooting Java asynchronous applications. Async tracking tools: Tokens and segments The Java agent API provides two ways to trace asynchronous activity: Tokens: Tokens are passed between threads to link asynchronous units of work to a specific transaction. They do not perform any timing directly. Segments: Segments are used to measure an arbitrary piece of asynchronous application code, not necessarily associated with a method or thread. Segments are typically used to track external calls that are completed by a callback mechanism. Tokens: Connect async threads Use tokens to link arbitrary units of work that are on separate threads. This section describes how to use the token-related calls together to instrument async work. For detailed information on classes and methods, see the Javadoc. To use tokens, you first need to create the token, then link another call to the originating transaction. You should link the token as soon as possible within the other call. If you do not link the token immediately, you risk losing any methods that contain an @Trace below the call you are trying to link. You can also expire the token in the original call. The Java agent will then link the work in the New Relic UI. These examples illustrate how to use the token-related calls together: 1. Start a transaction, then create and expire a token Consider the method parallelStream() in the code snippet below. Because some of the calls to requestItemAsync() will occur on a separate thread, a token is created and passed to link that asynchronous work back to the requesting thread. /** * Example showing multi-threaded implementation of requesting data using a parallel {@link Stream}. */ @RequestMapping(\"parallel_stream\") @Trace(dispatcher = true) // starts a transaction public ResponseEntity<String> parallelStream(@RequestParam(\"ids\") List<Long> ids) { final Token token = NewRelic.getAgent().getTransaction(). getToken() ; List<item> results = ids .parallelStream() .map(id -> requestItemAsync\\(id, token)) // note we're calling a different method than parallelStreamBad .filter(item -> item != null) .collect(Collectors.toList()); token.expire() ; return formattedResponse(\"parallel_stream\", results); } Copy The agent API calls in this sample are: @Trace(dispatcher = true): Tells the agent to start a transaction. For more on this method, see the Javadoc. getToken(): Creates the token which will link the work together. For more on this method, see the Javadoc. token.expire(): Expires the token. This allows the transaction to end. For more on this method, see the Javadoc. 2. Mark a transaction as async and link to request thread The following code example shows requestItemAsync, which might execute on a separate thread from the requesting thread. For this reason, the token that was created in the previous code example is linked to the Transaction in requestItemAsync. Note that requestItemAsync() has the @Trace(async=true) annotation, which tells the agent to trace this method if it's linked to an existing transaction. After parallelStream() collects all results, the token is expired. This is important because it makes sure the transaction doesn't stay open after parallelStream() completes. @Trace(async = true) private Item requestItemAsync(long id, Token token) { token.link() ; return requestItem(id); } Copy The agent API calls in this sample are: @Trace(async = true): Starts a transaction. For more on this method, see the Javadoc. token.link(): Links the work being done in requestItemAsync() (which is executing on a different thread) to the requesting thread. For more on this method, see the Javadoc. 3. View your async trace in the New Relic UI Here's an example of a transaction trace in the APM UI for this endpoint: one.newrelic.com > APM > (select an app) > Transactions > Transaction trace > Trace details: All asynchronous method calls linked with a token are indicated with an Async icon. All asynchronous method calls linked with a token are indicated with an Async icon in the Drilldown column. It's not necessary to link methods that are on the same thread, but doing so will have no negative effect. It's often the case that a single token can be shared, like in the parallelStream() example. Tip By default, a transaction can create a maximum of 3000 tokens and each token has a default timeout of 180s. You can change the former limit with the token_limit config option and the latter with the token_timeout config option. Traces for transactions that exceed the token_limit will contain a token_clamp attribute. Increasing either config option may increase agent memory usage. Segments: Time arbitrary async activity Segments are used to measure an arbitrary piece of asynchronous application code, not necessarily associated with a method or thread. This is most commonly used to time connections to external services. Use segments if you want to: Time code that completes via a callback Time an asynchronous call that spans many methods Measure the time between when work is created and when it executed (for example, in a thread pool) 1. Create a transaction and call an external service The method below makes a call to an external service (in this case a database) using the method storeItem(): /** * Example showing single threaded implementation of inserting data into a datasource. */ @RequestMapping(\"insert\") @Trace(dispatcher = true) //starts a transaction public ResponseEntity insert(@RequestParam(\"id\") Long id) { if (id != null) { storeItem(id); return new ResponseEntity<>(\"insert\", HttpStatus.OK); } else { return new ResponseEntity<>(\"insert\", HttpStatus.BAD_REQUEST); } } Copy The goal in this case it to find out how long the Callable in the Lambda statement is waiting in the thread pool before executing, rather than determining how long storeItem() runs. For this reason, a segment is used instead of a token, and @Trace(async = true) is not necessary like it was for a token. The agent API call in this sample is: @Trace(dispatcher = true): Starts a transaction. For more on this method, see the Javadoc. 2. Start a segment, report externals, and end the segment The following code example shows a segment starting in the storeItem method to measure how long the Lambda statement is waiting in the thread pool. To stop timing the segment, you must call either .end() or .ignore(). If you don't want to report the segment as part of its parent transaction, call .ignore(). Otherwise, to report the segment as part of its parent transaction, call .end(). private void storeItem(long id) { Segment segment = NewRelic.getAgent().getTransaction(). startSegment(\"storeItem\") ; segment. reportAsExternal (DatastoreParameters .product(\"H2\") .collection(null) .operation(\"insert\") .instance(\"localhost\", 8080) .databaseName(\"test\") .build()); // fire and forget DB_POOL.submit(() -> { segment.end(); insertData(id); }); } Copy The agent API calls in this sample are: startSegment(...): Begins the segment that will time the code. For more on this method, see the Javadoc. reportAsExternal(DatastoreParameters()): Associates the time with a datastore external call This will show up in APM with datastore data. For more information, see reportAsExternal API. segment.end(): Stops timing this segment. For more on this method, see the Javadoc. 3. View your async trace in the New Relic UI When the method completes, APM displays a transaction trace with one external call: one.newrelic.com > APM > (select an app) > Transactions > Transaction trace > Trace details: A single asynchronous segment is called out in the Drilldown column. Tip By default, the agent can track a maximum of 1000 segments during a given transaction. You can change this limit with the segment_timeout config option. Traces of transactions that exceed this limit will contain a segment_clamp attribute. Increasing this limit may increase agent memory usage.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.07755,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> API for <em>asynchronous</em> applications",
        "sections": "<em>Java</em> <em>agent</em> API for <em>asynchronous</em> applications",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "New Relic for <em>Java</em> (<em>agent</em> version 3.37 or higher) includes an API to <em>instrument</em> asynchronous activity. For supported frameworks, the <em>agent</em> usually instruments <em>async</em> work automatically. However, the <em>async</em> API can still be useful to add detail. This document provides examples of using tokens"
      },
      "id": "603eb4c9196a67dde5a83db7"
    },
    {
      "sections": [
        "Disable Scala, Netty, Akka, and Play 2 Instrumentation",
        "Contents",
        "Java agent versions 3.21 or lower",
        "Java agent versions 3.22 or higher",
        "Check for deprecated configuration settings"
      ],
      "title": "Disable Scala, Netty, Akka, and Play 2 Instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Async instrumentation"
      ],
      "external_id": "7a6fa946f9f903c240099279d125807b89665668",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/async-instrumentation/disable-scala-netty-akka-play-2-instrumentation/",
      "published_at": "2021-05-05T07:06:38Z",
      "updated_at": "2021-03-13T02:45:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document describes how to disable Java agent instrumentation on these popular async frameworks: Scala Netty Akka Play 2 You may choose to disable some or all of this instrumentation if you find that the metrics reported aren't valuable to you, or if the instrumentation incurs more overhead than you would like. If you selectively disable some of the instrumentation, some segments of activity will not be reported and your total time will be understated. Contents Java agent versions 3.21 or lower If you are using Java agent version 3.22 or lower, add the following to the class_transformer section of your newrelic.yml settings: # This section is for settings common to all environments. # Do not add anything above this next line. common: &default_settings class_transformer: akka_instrumentation: enabled: false netty_instrumenation: enabled: false play2_instrumentation: enabled: false scala_instrumentation: enabled: false Copy Java agent versions 3.22 or higher The older Scala, Netty, Akka, and Play 2 Framework instrumentation configuration names have been deprecated as of Java Agent version 3.22. For those using Java Agent 3.22 or higher, add the following to the class_transformer section of your newrelic.yml settings: common: &default_settings class_transformer: # Disable all Akka instrumentations com.newrelic.instrumentation.akka-2.0: enabled: false com.newrelic.instrumentation.akka-2.1: enabled: false # Disabling 2.2 also disables higher versions com.newrelic.instrumentation.akka-2.2: enabled: false # Disable all Netty instrumentations com.newrelic.instrumentation.netty-3.4: enabled: false com.newrelic.instrumentation.netty-3.8: enabled: false com.newrelic.instrumentation.netty-4.0.0: enabled: false com.newrelic.instrumentation.netty-4.0.8: enabled: false # Disable all Play 2 instrumentations com.newrelic.instrumentation.play-2.1: enabled: false com.newrelic.instrumentation.play-2.2: enabled: false com.newrelic.instrumentation.play-2.3: enabled: false # New in Release 3.22, the Play 2.4 instrumentation does not respect # the older play2_instrumentation configuration setting com.newrelic.instrumentation.play-2.4: enabled: false # Disable all Scala-language instrumentations com.newrelic.instrumentation.scala-2.9.3: enabled: false Copy The pre-3.22 instrumentation names will be respected for a time, but they will be removed in future releases. If disabled by either the old or new instrumentation configuration, the instrumentation will be disabled. Check for deprecated configuration settings Any use of the pre-3.22 instrumentation names will be logged with messages similar to: INFO: Using deprecated configuration setting akka_instrumentation for instrumentation com.newrelic.instrumentation.akka-2.2 Copy OR INFO: The configuration setting akka_instrumentation is deprecated, please update the class_transformer config to use com.newrelic.instrumentation.akka-2.2 instead Copy Using the deprecated settings does not indicate the deprecated instrumentation has been loaded or is being used. These messages are hints to the user that it is time to update your configuration settings. Play 2.4 does not respect the older play2_instrumentation configuration settings, as it is a new instrumentation. In all cases, if you are using Java agent version 3.22 or higher, you should use the new instrumentation names for the Scala, Netty, Akka, and Play 2 framework in their newrelic.yml.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.95677,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Disable Scala, Netty, Akka, and Play 2 <em>Instrumentation</em>",
        "sections": "<em>Java</em> <em>agent</em> versions 3.21 or lower",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "This document describes how to disable <em>Java</em> <em>agent</em> <em>instrumentation</em> on these popular <em>async</em> frameworks: Scala Netty Akka Play 2 You may choose to disable some or all of this <em>instrumentation</em> if you find that the metrics reported aren&#x27;t valuable to you, or if the <em>instrumentation</em> incurs more overhead"
      },
      "id": "6043f28428ccbc13812c6062"
    }
  ],
  "/docs/agents/java-agent/async-instrumentation/java-agent-api-asynchronous-applications": [
    {
      "sections": [
        "Troubleshoot Java asynchronous instrumentation",
        "Verify your instrumentation",
        "Use logs to troubleshoot",
        "Problem: Transaction times are too long",
        "Problem: No transaction trace data",
        "Problem: Too few async calls",
        "Ensure that each activity you monitor is appropriately linked",
        "Check if you are missing required annotations"
      ],
      "title": "Troubleshoot Java asynchronous instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Async instrumentation"
      ],
      "external_id": "0f21da73ba02edc45ec0cbbbaa7e0fc45678404b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/async-instrumentation/troubleshoot-java-asynchronous-instrumentation/",
      "published_at": "2021-05-05T07:05:09Z",
      "updated_at": "2021-03-16T09:03:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you are having problems using the Java agent API for async tokens and segments, use these techniques to help you find answers and solve problems. Verify your instrumentation The API has a number of built-in safety mechanisms to prevent issues caused by incorrect API usage, but you can use these techniques to verify that your application’s instrumentation is correct: After instrumenting your code, verify that the logs show that an equal number of tokens have been created and expired. For more information on which log messages to look for, see Use logs to troubleshoot. Check the garbage collection statistics under APM's JVMs page to determine whether or not your changes have significantly altered garbage collection patterns. Check if any segments or tokens are timing out by reviewing your transaction traces for a timed_out attribute. If so, you can change the limit with token_timeout and segment_timeout. Use logs to troubleshoot To customize your Java agent logging, see Generating logs. Then, you can examine your logs for these common messages: To view created tokens, check logs at FINEST for: Transaction com.newrelic.agent.Transaction@5a7cc8e: created active token com.newrelic.agent.TokenImpl@7db8d0e8 Copy To view expired tokens and the time that they expired, check logs at FINEST for: Transaction com.newrelic.agent.Transaction@5a7cc8e: expired token com.newrelic.agent.TokenImpl@7db8d0e8 Copy To view created segments, check logs at FINEST for: Transaction com.newrelic.agent.Transaction@486b7f04: startSegment(): com.newrelic.agent.Segment@2b7fdad3 created and started with tracer com.newrelic.agent.tracers.OtherRootTracer@4df4a953 Copy To view ended segments and the time that they ended, check logs at FINEST for: com.newrelic.agent.Transaction@486b7f04--finish segment(): com.newrelic.agent.Segment@2b7fdad3 async finish with tracer com.newrelic.agent.tracers.OtherRootTracer@4df4a953 Copy Problem: Transaction times are too long Make sure to expire tokens and end or ignore segments; otherwise transactions may take longer to report to New Relic. The Java agent has a timeout mechanism for tokens and segments that are not ended correctly. For more information, see token_timeout and segment_timeout. Problem: No transaction trace data Inspect transaction traces to make sure expected asynchronous work is reported. If you do not see any transaction traces, make sure your transaction duration exceeds the transaction trace threshold set in transaction_threshold. Problem: Too few async calls If too few calls are being reported: Ensure that each activity you monitor is appropriately linked In the faulty example below, a parallel stream is being used, which means that the work done inside the lambda in the call to map() can be scheduled on a different thread than the thread handling the request. Without creating a token to link all this work together, you will not see any of the work that gets scheduled on a different thread inside of your transaction. @RequestMapping(\"parallel_stream_bad\") @Trace(dispatcher = true) public ResponseEntity parallelStreamBad(@RequestParam(\"ids\") List<long> ids) { List<item> results = ids .parallelStream() .map(i -> requestItem(i)) .filter(item -> item != null) .collect(Collectors.toList()); return formattedResponse(\"parallel_stream_bad\", results); } Copy Check if you are missing required annotations The example below will report only a subset of the calls to requestItem() because it is impossible to put @Trace(async = true) around blocks of anonymous work inside the call to map(). Instead, you should pass the token into requestItem() and link it, and then add @Trace(async=true) around it. Or use a helper function like requestItemAsync() to do this without changing your existing methods. @RequestMapping(\"parallel_stream_bad2\") @Trace(dispatcher = true) public ResponseEntity parallelStreamBad2(@RequestParam(\"ids\") List<long> ids) { final Token token = NewRelic.getAgent().getTransaction().getToken(); List<item> results = ids .parallelStream() .map(id -> { token.link(); return requestItem(id); }) .filter(item -> item != null) .collect(Collectors.toList()); return formattedResponse(\"parallel_stream_bad2\", results); } Copy Compare this to the correct example below, in which the lambda expression is wrapped by the wrapper class InstrumentedCallable. This class accepts a token and a lambda, then wraps asynchronous work in @Trace(async = true) and uses a token to link the work to the request thread. @RequestMapping(\"parallel_stream_wrap\") @Trace(dispatcher = true) public ResponseEntity parallelStreamWrap(@RequestParam(\"ids\") List<long> ids) { final Token token = NewRelic.getAgent().getTransaction().getToken(); List<item> results = ids .parallelStream() .map(id -> InstrumentedCallable.instrumentCallable(token, () -> requestItem(id))) .map(c -> c.call()) .filter(item -> item != null) .collect(Collectors.toList()); token.expire(); return formattedResponse(\"parallel_stream_wrap\", results); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.07826,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Troubleshoot <em>Java</em> <em>asynchronous</em> <em>instrumentation</em>",
        "sections": "Troubleshoot <em>Java</em> <em>asynchronous</em> <em>instrumentation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "If you are having problems using the <em>Java</em> <em>agent</em> API for <em>async</em> tokens and segments, use these techniques to help you find answers and solve problems. Verify your <em>instrumentation</em> The API has a number of built-in safety mechanisms to prevent issues caused by incorrect API usage, but you can use"
      },
      "id": "603eb55a196a67260aa83dac"
    },
    {
      "sections": [
        "Introduction to Java async instrumentation",
        "Asynchronous operations",
        "Async and thread-switching",
        "Async and response time",
        "Custom instrumentation with the async API"
      ],
      "title": "Introduction to Java async instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Async instrumentation"
      ],
      "external_id": "3b0a9e1f2f6b69a8ad101ec59c592ac4a574ae63",
      "image": "https://docs.newrelic.com/static/a38112969f7c8a3001651b65853a803b/39c09/sZ6-I4x5BDSDspRS_G7Hefg.png",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/async-instrumentation/introduction-java-async-instrumentation/",
      "published_at": "2021-05-05T07:06:37Z",
      "updated_at": "2021-03-16T09:00:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic for Java includes a set of API methods for custom instrumentation of asynchronous activity. This is most useful to instrument asynchronous activity in unsupported frameworks, but you can also use the API to add additional instrumentation to supported frameworks. This document explains how asynchronous activity occurs, and how New Relic monitors async work. Asynchronous operations With a synchronous programming model, programming tasks are usually executed in a specific order. One task must complete before the next task begins, and each task blocks the next task from completing. Asynchronous programming uses a non-blocking model, so that tasks can be run in parallel. Tasks executed asynchronously are completely independent of each other in their execution and initialization. Because asynchronous code doesn't execute in a specific order, the server's full processing power can be used more efficiently, and the app's throughput increases. Async and thread-switching For applications that use asynchronous processing, thread-switching is when a program or task switches from one thread to another. Understanding these asynchronous interleavings can help you decide which methods should be instrumented. Here is an example method with a controller that makes external requests in parallel. These requests execute asynchronously, so each request executes independently of each other and getScoreAsync() returns immediately after being called. This allows the requesting thread to continue making requests while getScoreAsync() makes an external call and sends a reply. @ResponseBody @RequestMapping(\"getScores\", method = RequestMethod.Get produces = “text/plain”) public String getCreditScores(@RequestParam(name = \"uids\") uids) { return Arrays.stream(uids.split(\",\")) .parallel() .map(Integer::valueOf) .map(uid -> getScoreAsync(uid)) .collect(Collectors.toList());} Copy Some of these requests will finish before others. Some might even finish after the requesting thread has moved on to other tasks: With New Relic's asynchronous instrumentation, the APM UI flags the work as Async. For example, if the above method were instrumented by New Relic (either automatically or via custom instrumentation), this is what the APM UI would show on the Trace details page: one.newrelic.com > APM > (select an app) > Transactions > Transaction trace > Trace details: When asynchronous activity in a Java application is detected by APM, it is indicated with the Async flag in the Drilldown column. Async and response time Response time is defined as the duration of a transaction from the perspective of the requester. For asynchronous applications, the response time is often less than the total transaction time. This is because the methods don't have to wait for all preceding methods to complete before returning. Because tasks can be deferred, the application can take advantage of its limited resources and process things more quickly. The chart's response time line gives you more insight into the perceived behavior and speed of your application than does the total web transaction time: one.newrelic.com > APM > (select an app) > Summary: On the APM Summary page, asynchronous activity in a Java app can result in the response time (the blue line) being less than the total transaction time. This is because the methods don't have to wait for all preceding methods to complete before returning. Custom instrumentation with the async API To implement custom instrumentation of async work, see the Java agent async API guide. For general information on how to use the Java agent API, see Java agent API guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.07755,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Java</em> <em>async</em> <em>instrumentation</em>",
        "sections": "Introduction to <em>Java</em> <em>async</em> <em>instrumentation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " transaction time. This is because the methods don&#x27;t have to wait for all preceding methods to complete before returning. Custom <em>instrumentation</em> with the <em>async</em> API To implement custom <em>instrumentation</em> of <em>async</em> work, see the <em>Java</em> <em>agent</em> <em>async</em> API guide. For general information on how to use the <em>Java</em> <em>agent</em> API, see <em>Java</em> <em>agent</em> API guide."
      },
      "id": "603eb491e7b9d282bd2a07ca"
    },
    {
      "sections": [
        "Disable Scala, Netty, Akka, and Play 2 Instrumentation",
        "Contents",
        "Java agent versions 3.21 or lower",
        "Java agent versions 3.22 or higher",
        "Check for deprecated configuration settings"
      ],
      "title": "Disable Scala, Netty, Akka, and Play 2 Instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Async instrumentation"
      ],
      "external_id": "7a6fa946f9f903c240099279d125807b89665668",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/async-instrumentation/disable-scala-netty-akka-play-2-instrumentation/",
      "published_at": "2021-05-05T07:06:38Z",
      "updated_at": "2021-03-13T02:45:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document describes how to disable Java agent instrumentation on these popular async frameworks: Scala Netty Akka Play 2 You may choose to disable some or all of this instrumentation if you find that the metrics reported aren't valuable to you, or if the instrumentation incurs more overhead than you would like. If you selectively disable some of the instrumentation, some segments of activity will not be reported and your total time will be understated. Contents Java agent versions 3.21 or lower If you are using Java agent version 3.22 or lower, add the following to the class_transformer section of your newrelic.yml settings: # This section is for settings common to all environments. # Do not add anything above this next line. common: &default_settings class_transformer: akka_instrumentation: enabled: false netty_instrumenation: enabled: false play2_instrumentation: enabled: false scala_instrumentation: enabled: false Copy Java agent versions 3.22 or higher The older Scala, Netty, Akka, and Play 2 Framework instrumentation configuration names have been deprecated as of Java Agent version 3.22. For those using Java Agent 3.22 or higher, add the following to the class_transformer section of your newrelic.yml settings: common: &default_settings class_transformer: # Disable all Akka instrumentations com.newrelic.instrumentation.akka-2.0: enabled: false com.newrelic.instrumentation.akka-2.1: enabled: false # Disabling 2.2 also disables higher versions com.newrelic.instrumentation.akka-2.2: enabled: false # Disable all Netty instrumentations com.newrelic.instrumentation.netty-3.4: enabled: false com.newrelic.instrumentation.netty-3.8: enabled: false com.newrelic.instrumentation.netty-4.0.0: enabled: false com.newrelic.instrumentation.netty-4.0.8: enabled: false # Disable all Play 2 instrumentations com.newrelic.instrumentation.play-2.1: enabled: false com.newrelic.instrumentation.play-2.2: enabled: false com.newrelic.instrumentation.play-2.3: enabled: false # New in Release 3.22, the Play 2.4 instrumentation does not respect # the older play2_instrumentation configuration setting com.newrelic.instrumentation.play-2.4: enabled: false # Disable all Scala-language instrumentations com.newrelic.instrumentation.scala-2.9.3: enabled: false Copy The pre-3.22 instrumentation names will be respected for a time, but they will be removed in future releases. If disabled by either the old or new instrumentation configuration, the instrumentation will be disabled. Check for deprecated configuration settings Any use of the pre-3.22 instrumentation names will be logged with messages similar to: INFO: Using deprecated configuration setting akka_instrumentation for instrumentation com.newrelic.instrumentation.akka-2.2 Copy OR INFO: The configuration setting akka_instrumentation is deprecated, please update the class_transformer config to use com.newrelic.instrumentation.akka-2.2 instead Copy Using the deprecated settings does not indicate the deprecated instrumentation has been loaded or is being used. These messages are hints to the user that it is time to update your configuration settings. Play 2.4 does not respect the older play2_instrumentation configuration settings, as it is a new instrumentation. In all cases, if you are using Java agent version 3.22 or higher, you should use the new instrumentation names for the Scala, Netty, Akka, and Play 2 framework in their newrelic.yml.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.95676,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Disable Scala, Netty, Akka, and Play 2 <em>Instrumentation</em>",
        "sections": "<em>Java</em> <em>agent</em> versions 3.21 or lower",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "This document describes how to disable <em>Java</em> <em>agent</em> <em>instrumentation</em> on these popular <em>async</em> frameworks: Scala Netty Akka Play 2 You may choose to disable some or all of this <em>instrumentation</em> if you find that the metrics reported aren&#x27;t valuable to you, or if the <em>instrumentation</em> incurs more overhead"
      },
      "id": "6043f28428ccbc13812c6062"
    }
  ],
  "/docs/agents/java-agent/async-instrumentation/troubleshoot-java-asynchronous-instrumentation": [
    {
      "sections": [
        "Introduction to Java async instrumentation",
        "Asynchronous operations",
        "Async and thread-switching",
        "Async and response time",
        "Custom instrumentation with the async API"
      ],
      "title": "Introduction to Java async instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Async instrumentation"
      ],
      "external_id": "3b0a9e1f2f6b69a8ad101ec59c592ac4a574ae63",
      "image": "https://docs.newrelic.com/static/a38112969f7c8a3001651b65853a803b/39c09/sZ6-I4x5BDSDspRS_G7Hefg.png",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/async-instrumentation/introduction-java-async-instrumentation/",
      "published_at": "2021-05-05T07:06:37Z",
      "updated_at": "2021-03-16T09:00:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic for Java includes a set of API methods for custom instrumentation of asynchronous activity. This is most useful to instrument asynchronous activity in unsupported frameworks, but you can also use the API to add additional instrumentation to supported frameworks. This document explains how asynchronous activity occurs, and how New Relic monitors async work. Asynchronous operations With a synchronous programming model, programming tasks are usually executed in a specific order. One task must complete before the next task begins, and each task blocks the next task from completing. Asynchronous programming uses a non-blocking model, so that tasks can be run in parallel. Tasks executed asynchronously are completely independent of each other in their execution and initialization. Because asynchronous code doesn't execute in a specific order, the server's full processing power can be used more efficiently, and the app's throughput increases. Async and thread-switching For applications that use asynchronous processing, thread-switching is when a program or task switches from one thread to another. Understanding these asynchronous interleavings can help you decide which methods should be instrumented. Here is an example method with a controller that makes external requests in parallel. These requests execute asynchronously, so each request executes independently of each other and getScoreAsync() returns immediately after being called. This allows the requesting thread to continue making requests while getScoreAsync() makes an external call and sends a reply. @ResponseBody @RequestMapping(\"getScores\", method = RequestMethod.Get produces = “text/plain”) public String getCreditScores(@RequestParam(name = \"uids\") uids) { return Arrays.stream(uids.split(\",\")) .parallel() .map(Integer::valueOf) .map(uid -> getScoreAsync(uid)) .collect(Collectors.toList());} Copy Some of these requests will finish before others. Some might even finish after the requesting thread has moved on to other tasks: With New Relic's asynchronous instrumentation, the APM UI flags the work as Async. For example, if the above method were instrumented by New Relic (either automatically or via custom instrumentation), this is what the APM UI would show on the Trace details page: one.newrelic.com > APM > (select an app) > Transactions > Transaction trace > Trace details: When asynchronous activity in a Java application is detected by APM, it is indicated with the Async flag in the Drilldown column. Async and response time Response time is defined as the duration of a transaction from the perspective of the requester. For asynchronous applications, the response time is often less than the total transaction time. This is because the methods don't have to wait for all preceding methods to complete before returning. Because tasks can be deferred, the application can take advantage of its limited resources and process things more quickly. The chart's response time line gives you more insight into the perceived behavior and speed of your application than does the total web transaction time: one.newrelic.com > APM > (select an app) > Summary: On the APM Summary page, asynchronous activity in a Java app can result in the response time (the blue line) being less than the total transaction time. This is because the methods don't have to wait for all preceding methods to complete before returning. Custom instrumentation with the async API To implement custom instrumentation of async work, see the Java agent async API guide. For general information on how to use the Java agent API, see Java agent API guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.07755,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Java</em> <em>async</em> <em>instrumentation</em>",
        "sections": "Introduction to <em>Java</em> <em>async</em> <em>instrumentation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " transaction time. This is because the methods don&#x27;t have to wait for all preceding methods to complete before returning. Custom <em>instrumentation</em> with the <em>async</em> API To implement custom <em>instrumentation</em> of <em>async</em> work, see the <em>Java</em> <em>agent</em> <em>async</em> API guide. For general information on how to use the <em>Java</em> <em>agent</em> API, see <em>Java</em> <em>agent</em> API guide."
      },
      "id": "603eb491e7b9d282bd2a07ca"
    },
    {
      "sections": [
        "Java agent API for asynchronous applications",
        "Async tracking tools: Tokens and segments",
        "Tokens: Connect async threads",
        "1. Start a transaction, then create and expire a token",
        "2. Mark a transaction as async and link to request thread",
        "3. View your async trace in the New Relic UI",
        "Tip",
        "Segments: Time arbitrary async activity",
        "1. Create a transaction and call an external service",
        "2. Start a segment, report externals, and end the segment"
      ],
      "title": "Java agent API for asynchronous applications",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Async instrumentation"
      ],
      "external_id": "7b5f035809040487d96279fb318203b479a61b02",
      "image": "https://docs.newrelic.com/static/06c87505ee5c0d97e598d04258587f52/c1b63/Screen-Shot-2017-03-14-at-4.50.31-PM.png",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/async-instrumentation/java-agent-api-asynchronous-applications/",
      "published_at": "2021-05-05T07:08:16Z",
      "updated_at": "2021-03-16T09:00:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic for Java (agent version 3.37 or higher) includes an API to instrument asynchronous activity. For supported frameworks, the agent usually instruments async work automatically. However, the async API can still be useful to add detail. This document provides examples of using tokens and segments to instrument your app. For more information about how New Relic instruments and displays async work in the APM UI, see Monitoring considerations for asynchronous applications. For details on the actual classes and methods, see the Javadoc. For general information on the Java agent API, see the Java agent API guide. For troubleshooting common problems, see Troubleshooting Java asynchronous applications. Async tracking tools: Tokens and segments The Java agent API provides two ways to trace asynchronous activity: Tokens: Tokens are passed between threads to link asynchronous units of work to a specific transaction. They do not perform any timing directly. Segments: Segments are used to measure an arbitrary piece of asynchronous application code, not necessarily associated with a method or thread. Segments are typically used to track external calls that are completed by a callback mechanism. Tokens: Connect async threads Use tokens to link arbitrary units of work that are on separate threads. This section describes how to use the token-related calls together to instrument async work. For detailed information on classes and methods, see the Javadoc. To use tokens, you first need to create the token, then link another call to the originating transaction. You should link the token as soon as possible within the other call. If you do not link the token immediately, you risk losing any methods that contain an @Trace below the call you are trying to link. You can also expire the token in the original call. The Java agent will then link the work in the New Relic UI. These examples illustrate how to use the token-related calls together: 1. Start a transaction, then create and expire a token Consider the method parallelStream() in the code snippet below. Because some of the calls to requestItemAsync() will occur on a separate thread, a token is created and passed to link that asynchronous work back to the requesting thread. /** * Example showing multi-threaded implementation of requesting data using a parallel {@link Stream}. */ @RequestMapping(\"parallel_stream\") @Trace(dispatcher = true) // starts a transaction public ResponseEntity<String> parallelStream(@RequestParam(\"ids\") List<Long> ids) { final Token token = NewRelic.getAgent().getTransaction(). getToken() ; List<item> results = ids .parallelStream() .map(id -> requestItemAsync\\(id, token)) // note we're calling a different method than parallelStreamBad .filter(item -> item != null) .collect(Collectors.toList()); token.expire() ; return formattedResponse(\"parallel_stream\", results); } Copy The agent API calls in this sample are: @Trace(dispatcher = true): Tells the agent to start a transaction. For more on this method, see the Javadoc. getToken(): Creates the token which will link the work together. For more on this method, see the Javadoc. token.expire(): Expires the token. This allows the transaction to end. For more on this method, see the Javadoc. 2. Mark a transaction as async and link to request thread The following code example shows requestItemAsync, which might execute on a separate thread from the requesting thread. For this reason, the token that was created in the previous code example is linked to the Transaction in requestItemAsync. Note that requestItemAsync() has the @Trace(async=true) annotation, which tells the agent to trace this method if it's linked to an existing transaction. After parallelStream() collects all results, the token is expired. This is important because it makes sure the transaction doesn't stay open after parallelStream() completes. @Trace(async = true) private Item requestItemAsync(long id, Token token) { token.link() ; return requestItem(id); } Copy The agent API calls in this sample are: @Trace(async = true): Starts a transaction. For more on this method, see the Javadoc. token.link(): Links the work being done in requestItemAsync() (which is executing on a different thread) to the requesting thread. For more on this method, see the Javadoc. 3. View your async trace in the New Relic UI Here's an example of a transaction trace in the APM UI for this endpoint: one.newrelic.com > APM > (select an app) > Transactions > Transaction trace > Trace details: All asynchronous method calls linked with a token are indicated with an Async icon. All asynchronous method calls linked with a token are indicated with an Async icon in the Drilldown column. It's not necessary to link methods that are on the same thread, but doing so will have no negative effect. It's often the case that a single token can be shared, like in the parallelStream() example. Tip By default, a transaction can create a maximum of 3000 tokens and each token has a default timeout of 180s. You can change the former limit with the token_limit config option and the latter with the token_timeout config option. Traces for transactions that exceed the token_limit will contain a token_clamp attribute. Increasing either config option may increase agent memory usage. Segments: Time arbitrary async activity Segments are used to measure an arbitrary piece of asynchronous application code, not necessarily associated with a method or thread. This is most commonly used to time connections to external services. Use segments if you want to: Time code that completes via a callback Time an asynchronous call that spans many methods Measure the time between when work is created and when it executed (for example, in a thread pool) 1. Create a transaction and call an external service The method below makes a call to an external service (in this case a database) using the method storeItem(): /** * Example showing single threaded implementation of inserting data into a datasource. */ @RequestMapping(\"insert\") @Trace(dispatcher = true) //starts a transaction public ResponseEntity insert(@RequestParam(\"id\") Long id) { if (id != null) { storeItem(id); return new ResponseEntity<>(\"insert\", HttpStatus.OK); } else { return new ResponseEntity<>(\"insert\", HttpStatus.BAD_REQUEST); } } Copy The goal in this case it to find out how long the Callable in the Lambda statement is waiting in the thread pool before executing, rather than determining how long storeItem() runs. For this reason, a segment is used instead of a token, and @Trace(async = true) is not necessary like it was for a token. The agent API call in this sample is: @Trace(dispatcher = true): Starts a transaction. For more on this method, see the Javadoc. 2. Start a segment, report externals, and end the segment The following code example shows a segment starting in the storeItem method to measure how long the Lambda statement is waiting in the thread pool. To stop timing the segment, you must call either .end() or .ignore(). If you don't want to report the segment as part of its parent transaction, call .ignore(). Otherwise, to report the segment as part of its parent transaction, call .end(). private void storeItem(long id) { Segment segment = NewRelic.getAgent().getTransaction(). startSegment(\"storeItem\") ; segment. reportAsExternal (DatastoreParameters .product(\"H2\") .collection(null) .operation(\"insert\") .instance(\"localhost\", 8080) .databaseName(\"test\") .build()); // fire and forget DB_POOL.submit(() -> { segment.end(); insertData(id); }); } Copy The agent API calls in this sample are: startSegment(...): Begins the segment that will time the code. For more on this method, see the Javadoc. reportAsExternal(DatastoreParameters()): Associates the time with a datastore external call This will show up in APM with datastore data. For more information, see reportAsExternal API. segment.end(): Stops timing this segment. For more on this method, see the Javadoc. 3. View your async trace in the New Relic UI When the method completes, APM displays a transaction trace with one external call: one.newrelic.com > APM > (select an app) > Transactions > Transaction trace > Trace details: A single asynchronous segment is called out in the Drilldown column. Tip By default, the agent can track a maximum of 1000 segments during a given transaction. You can change this limit with the segment_timeout config option. Traces of transactions that exceed this limit will contain a segment_clamp attribute. Increasing this limit may increase agent memory usage.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.07755,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> API for <em>asynchronous</em> applications",
        "sections": "<em>Java</em> <em>agent</em> API for <em>asynchronous</em> applications",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "New Relic for <em>Java</em> (<em>agent</em> version 3.37 or higher) includes an API to <em>instrument</em> asynchronous activity. For supported frameworks, the <em>agent</em> usually instruments <em>async</em> work automatically. However, the <em>async</em> API can still be useful to add detail. This document provides examples of using tokens"
      },
      "id": "603eb4c9196a67dde5a83db7"
    },
    {
      "sections": [
        "Disable Scala, Netty, Akka, and Play 2 Instrumentation",
        "Contents",
        "Java agent versions 3.21 or lower",
        "Java agent versions 3.22 or higher",
        "Check for deprecated configuration settings"
      ],
      "title": "Disable Scala, Netty, Akka, and Play 2 Instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Async instrumentation"
      ],
      "external_id": "7a6fa946f9f903c240099279d125807b89665668",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/async-instrumentation/disable-scala-netty-akka-play-2-instrumentation/",
      "published_at": "2021-05-05T07:06:38Z",
      "updated_at": "2021-03-13T02:45:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document describes how to disable Java agent instrumentation on these popular async frameworks: Scala Netty Akka Play 2 You may choose to disable some or all of this instrumentation if you find that the metrics reported aren't valuable to you, or if the instrumentation incurs more overhead than you would like. If you selectively disable some of the instrumentation, some segments of activity will not be reported and your total time will be understated. Contents Java agent versions 3.21 or lower If you are using Java agent version 3.22 or lower, add the following to the class_transformer section of your newrelic.yml settings: # This section is for settings common to all environments. # Do not add anything above this next line. common: &default_settings class_transformer: akka_instrumentation: enabled: false netty_instrumenation: enabled: false play2_instrumentation: enabled: false scala_instrumentation: enabled: false Copy Java agent versions 3.22 or higher The older Scala, Netty, Akka, and Play 2 Framework instrumentation configuration names have been deprecated as of Java Agent version 3.22. For those using Java Agent 3.22 or higher, add the following to the class_transformer section of your newrelic.yml settings: common: &default_settings class_transformer: # Disable all Akka instrumentations com.newrelic.instrumentation.akka-2.0: enabled: false com.newrelic.instrumentation.akka-2.1: enabled: false # Disabling 2.2 also disables higher versions com.newrelic.instrumentation.akka-2.2: enabled: false # Disable all Netty instrumentations com.newrelic.instrumentation.netty-3.4: enabled: false com.newrelic.instrumentation.netty-3.8: enabled: false com.newrelic.instrumentation.netty-4.0.0: enabled: false com.newrelic.instrumentation.netty-4.0.8: enabled: false # Disable all Play 2 instrumentations com.newrelic.instrumentation.play-2.1: enabled: false com.newrelic.instrumentation.play-2.2: enabled: false com.newrelic.instrumentation.play-2.3: enabled: false # New in Release 3.22, the Play 2.4 instrumentation does not respect # the older play2_instrumentation configuration setting com.newrelic.instrumentation.play-2.4: enabled: false # Disable all Scala-language instrumentations com.newrelic.instrumentation.scala-2.9.3: enabled: false Copy The pre-3.22 instrumentation names will be respected for a time, but they will be removed in future releases. If disabled by either the old or new instrumentation configuration, the instrumentation will be disabled. Check for deprecated configuration settings Any use of the pre-3.22 instrumentation names will be logged with messages similar to: INFO: Using deprecated configuration setting akka_instrumentation for instrumentation com.newrelic.instrumentation.akka-2.2 Copy OR INFO: The configuration setting akka_instrumentation is deprecated, please update the class_transformer config to use com.newrelic.instrumentation.akka-2.2 instead Copy Using the deprecated settings does not indicate the deprecated instrumentation has been loaded or is being used. These messages are hints to the user that it is time to update your configuration settings. Play 2.4 does not respect the older play2_instrumentation configuration settings, as it is a new instrumentation. In all cases, if you are using Java agent version 3.22 or higher, you should use the new instrumentation names for the Scala, Netty, Akka, and Play 2 framework in their newrelic.yml.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.95676,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Disable Scala, Netty, Akka, and Play 2 <em>Instrumentation</em>",
        "sections": "<em>Java</em> <em>agent</em> versions 3.21 or lower",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "This document describes how to disable <em>Java</em> <em>agent</em> <em>instrumentation</em> on these popular <em>async</em> frameworks: Scala Netty Akka Play 2 You may choose to disable some or all of this <em>instrumentation</em> if you find that the metrics reported aren&#x27;t valuable to you, or if the <em>instrumentation</em> incurs more overhead"
      },
      "id": "6043f28428ccbc13812c6062"
    }
  ],
  "/docs/agents/java-agent/attributes/java-agent-attributes": [
    {
      "sections": [
        "Update Java config for legacy agent versions",
        "Problem",
        "Solution"
      ],
      "title": "Update Java config for legacy agent versions",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "6123f5a7ab0baa2929c54780a4b9307612c636a7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/update-java-config-legacy-agent-versions/",
      "published_at": "2021-05-05T07:05:11Z",
      "updated_at": "2021-03-16T14:30:45Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem You use Java agent version 3.16.1 or lower and need to upgrade to the latest version, but you use deprecated configuration options to configure agent attributes. Solution In newrelic.yml, edit the configuration properties you use for compatiblity with the latest versions: Deprecated property New property analytics_events transaction_events The stanza in the newrelic.yml configuration file called analytics_events has been deprecated. Use the transaction_events stanza instead. capture_params attributes.include: request.parameters.* By default, request parameters are not sent to New Relic. Add request.parameters.* to the attributes.include list to turn on all request parameters. The capture_params property has been deprecated. ignored_params attributes.exclude: request.parameters.{name} Add each request parameter key to the attributes.exclude list. Be sure to prepend the key with request.parameters. The ignored_params property has been deprecated. capture_messaging_params attributes.include: message.parameters.* By default, message queue parameters are not sent to New Relic. Previously, setting capture_messaging_params to true would enable message queue parameters. Now you must add message.parameters.* to the attributes.include list. ignored_messaging_params attributes.exclude: message.parameters.{name} Previously, you could set ignored_messaging_params to a list of message queue parameter keys to exclude. Now you must add each message queue parameter key to the attributes.exclude list. Be sure to prepend the key with message.parameters. capture_attributes attributes.enabled The old capture_attributes flag would turn off user attribute collection. This has been deprecated. Use attributes.enabled instead. In this example, the Java agent collects request parameters and records them to the transaction tracer and error collector destinations. This emulates enabling the legacy server-side configuration options for Capture attributes or Capture parameters. To customize the attributes element in your Java agent configuration file: attributes.enabled: true attributes.include: request.parameters.* Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 95.27211,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Update <em>Java</em> config for legacy <em>agent</em> versions",
        "sections": "Update <em>Java</em> config for legacy <em>agent</em> versions",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Problem You use <em>Java</em> <em>agent</em> version 3.16.1 or lower and need to upgrade to the latest version, but you use deprecated configuration options to configure <em>agent</em> <em>attributes</em>. Solution In newrelic.yml, edit the configuration properties you use for compatiblity with the latest versions: Deprecated"
      },
      "id": "603e8774196a6715c3a83dd3"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/",
      "sections": [
        "Collect data",
        "Guides to collect data",
        "Add custom attributes",
        "Collect data - any source",
        "Create custom events",
        "Build queries with NerdGraph",
        "Query data with NRQL"
      ],
      "published_at": "2021-05-07T01:40:09Z",
      "title": "Collect data",
      "updated_at": "2021-05-06T01:38:02Z",
      "type": "developer",
      "external_id": "fb5d6f75b61858b09e3e8c63f3b2af97813f47b6",
      "document_type": "page",
      "popularity": 1,
      "body": "Through our opensource agents or APIs, New Relic makes it easy to collect data from any source. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data Add custom attributes   Use custom attributes for deeper analysis Collect data - any source 15 min APIs, agents, OS emitters - get any data Create custom events 5 min Define, visualize, and get alerts on the data you want using custom events Build queries with NerdGraph 25 min Try NerdGraph and build the queries you need Query data with NRQL 10 min Query default data, custom events, and attributes",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.81351,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add custom <em>attributes</em>",
        "body": " custom <em>attributes</em>   Use custom <em>attributes</em> for deeper analysis Collect data - any source 15 min APIs, <em>agents</em>, OS emitters - get any data Create custom events 5 min Define, visualize, and get alerts on the data you want using custom events Build queries with NerdGraph 25 min Try NerdGraph and build the queries you need Query data with NRQL 10 min Query default data, custom events, and <em>attributes</em>"
      },
      "id": "6091fa38196a67a932d52a29"
    },
    {
      "sections": [
        "Java agent configuration: Config file",
        "Configuration file structure",
        "Tip",
        "Configuration settings precedence",
        "Configuring the Java extensions directory",
        "Create an extensions directory",
        "Specify an existing extensions directory",
        "General configuration settings",
        "license_key (REQUIRED)",
        "app_name (REQUIRED)",
        "agent_enabled",
        "apdex_t (DEPRECATED)",
        "appserver_port",
        "Important",
        "audit_mode",
        "ca_bundle_path",
        "use_private_ssl",
        "enable_auto_app_naming",
        "enable_auto_transaction_naming",
        "Caution",
        "enable_custom_tracing",
        "extensions.dir",
        "high_security",
        "insert_api_key",
        "labels",
        "max_stack_trace_lines",
        "proxy_host",
        "proxy_password",
        "proxy_port",
        "proxy_user",
        "proxy_scheme",
        "reactor-netty.errors.enabled",
        "send_data_on_exit",
        "send_data_on_exit_threshold",
        "send_environment_info",
        "send_jvm_props",
        "ssl (DEPRECATED)",
        "sync_startup",
        "scala_futures_as_segments",
        "Logging configuration",
        "log_daily",
        "log_file_count",
        "log_file_name",
        "log_file_path",
        "log_level",
        "log_limit_in_kbytes",
        "JMX",
        "enabled",
        "linkingMetadataMBean",
        "Attributes",
        "include",
        "exclude",
        "Transaction tracer",
        "explain_enabled",
        "explain_threshold",
        "insert_sql_max_length",
        "log_sql",
        "record_sql",
        "stack_based_naming (Play 2.x+ only)",
        "stack_trace_threshold",
        "top_n",
        "transaction_threshold",
        "slow_query_whitelist (DEPRECATED)",
        "collect_slow_queries_from",
        "attributes.enabled",
        "attributes.include",
        "attributes.exclude",
        "token_limit",
        "segment_limit",
        "Transaction segments",
        "Browser monitoring",
        "auto_instrument",
        "disabled_auto_pages",
        "External tracer",
        "exclude_request_uri",
        "Cross application tracer",
        "Error collector",
        "ignore_classes",
        "ignore_messages",
        "ignore_status_codes",
        "expected_classes",
        "expected_messages",
        "expected_status_codes",
        "ignore_errors (DEPRECATED)",
        "Strip exceptions",
        "whitelist (DEPRECATED)",
        "allowed_classes",
        "Thread profiler",
        "Transaction events",
        "max_samples_stored",
        "custom_request_headers",
        "Custom events",
        "Hostname configuration",
        "display_name",
        "ipv_preference",
        "Custom instrumentation",
        "trace_annotation_class_name",
        "com.newrelic.instrumentation.servlet-user",
        "System properties",
        "newrelic.config.process_host.display_name",
        "newrelic.config.file",
        "newrelic.debug",
        "newrelic.environment",
        "newrelic.home",
        "newrelic.logfile",
        "Environment variables",
        "NEW_RELIC_APP_NAME (REQUIRED)",
        "NEW_RELIC_DISTRIBUTED_TRACING_ENABLED",
        "NEW_RELIC_PROCESS_HOST_DISPLAY_NAME",
        "NEW_RELIC_LICENSE_KEY (REQUIRED)",
        "NEW_RELIC_LOG",
        "Cloud platform utilization",
        "detect_aws",
        "detect_docker",
        "Async instrumentation",
        "token_timeout",
        "segment_timeout",
        "Circuit breaker",
        "memory_threshold",
        "gc_cpu_threshold",
        "Message tracer",
        "segment_parameters.enabled",
        "Distributed tracing",
        "exclude_newrelic_header",
        "Infinite Tracing",
        "trace_observer.host",
        "Span events",
        "Jar collector",
        "skip_temp_jars",
        "jars_per_second"
      ],
      "title": "Java agent configuration: Config file",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "1d61f848fa192438225eae269421b8d384915c8b",
      "image": "https://docs.newrelic.com/static/60ca967eab99ca225186310913ae2de6/8c557/java-config-cascade.png",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-configuration-config-file/",
      "published_at": "2021-05-04T17:01:42Z",
      "updated_at": "2021-03-16T15:52:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent reads its configuration from the newrelic.yml file. By default the agent looks for this file in the directory that contains newrelic.jar. You can override the config file's location by setting the newrelic.config.file system property to a fully qualified file name. Configuration file structure The newrelic.yml file is split into stanzas corresponding to different environments: Test Development Staging Production (default) New Relic applies settings in the common stanza to each of these environments. You can select other environments as the default by setting the newrelic.environment system property to the environment name. Tip A newrelic.yml template is available. If you edit newrelic.yml, be careful to conform to the YAML format. Use a YAML validator to ensure the syntax is accurate before using the file with New Relic's Java agent, and follow these rules: Java agent newrelic.yml Requirements Format YML files are case sensitive. Indentations All indentations must be in increments of two characters. Other indentations will result in an Unable to parse configuration file error upon agent startup. Use the same level of indentation for data in the same stanza of the file. Indent any sub-stanzas by an additional two spaces. Changes to file You must restart your JVM host process for changes to take effect. Exception: Property changes to log_level and audit_mode do not require a restart. Property changes under circuit breaker don't require a restart. Configuration settings precedence To override any setting in the config file, use a system property override. In certain environments, environment variables can also be used to override both the config file and the system properties. The environment variables primarily exist to support Heroku. When used, server-side configuration overrides all other configuration settings. With the Java agent, server-side configuration overrides all other settings. Environment variables override Java system properties. Java properties override user configuration settings in your newrelic.yml file. User settings override the newrelic.yml default settings. Configuring the Java extensions directory The Java agent reads the configuration files on process startup. To identify the directory where the files are located, either create a new or specify an existing extensions directory: Create an extensions directory To create the extensions directory: Navigate to the directory where newrelic.jar and newrelic.yml are located. Create a directory named extensions. In newrelic.yml, check that the property extensions.dir is not set. Specify an existing extensions directory To use an existing Java extensions directory: In your newrelic.yml file, locate the common section. Use the property extensions.dir to specify the location of the file. General configuration settings Set these options in the common stanza. To override any of these options, use a newrelic.config prefixed system property. license_key (REQUIRED) Type String Default (none) This setting is required. You must specify the license key associated with your New Relic account. This key binds your agent's data to your account in the New Relic service. app_name (REQUIRED) Type String Default (none) This setting is required. Defines the application name used to report data to New Relic. If enable_auto_app_naming is false, the agent reports all data to this application. Otherwise, the agent reports only background tasks (transactions for non-web applications) to this application. To report data to more than one application, separate the application names with a semicolon. For example, to report data to My Application and My Application 2 use this: app_name: My Application;My Application 2 Copy For more methods of naming your application, see Name your Java application. agent_enabled Type Boolean Default true Flag to enable the agent. Use this setting to force the agent to run or not run. apdex_t (DEPRECATED) Type Float Default 1.0 The apdex_t threshold in seconds for the application's Apdex score. For Java agent versions 1.2.008 or higher, the apdex_t value is set in the UI and the value in newrelic.yml is ignored. appserver_port Type Integer Default (none) Number to differentiate JVMs for the same app on the same machine. New Relic uses host/port for uniqueness, so you can distinguish the JVMs by putting a switch like this into the startup arguments for each JVM: -Dnewrelic.config.appserver_port=8081 Copy Once you have used appserver_port to name the JVMs and restart them, you should be able to see them individually in the dropdown and in the profiling interface. Important This is only a change for New Relic; it doesn't actually affect the port on which the host communicates in any way. audit_mode Type Boolean Default false Enables plain text logging of all data sent to New Relic to the agent logfile. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. ca_bundle_path Type String Value Format /path/to/ca/cert/bundle.pem Specifies a path to a custom SSL certificate bundle that will be used by the agent to establish a secure connection to New Relic. If your custom SSL certificate bundle doesn't include certificates that are sufficient to connect to New Relic then you'll need to merge the required certs into your custom certificate bundle. use_private_ssl Type Boolean Default false The following SSL certificates are bundled into the agent jar: META-INF/certs/eu-newrelic-com.pem META-INF/certs/eu01-nr-data-net.pem META-INF/certs/newrelic-com.pem Copy By default (use_private_ssl: false) the agent will use the SSL certificates bundled into the JDK to establish a secure connection to New Relic or the custom SSL certificates bundle specified by ca_bundle_path. If you want to use the SSL certificates bundled with the agent, set use_private_ssl: true. Note: use_private_ssl will be ignored if ca_bundle_path is set. enable_auto_app_naming Type Boolean Default false Enables the reporting of data separately for each web app. Set to true to enable support for auto app naming. The name of each web app is detected automatically and the agent reports data separately for each one. This provides a finer-grained performance breakdown for web apps in New Relic. For more information, see Automatic application naming. For more methods of naming your application, see Name your Java application. enable_auto_transaction_naming Type Boolean Default true Enables component-based transaction naming. Set to true to enable component-based transaction naming. Set to false to use the URI of a web request as the name of the transaction. For more information, see Naming web transactions. Caution Unless you implement API calls to name your transactions, disabling auto-transaction naming is very likely to cause Metric grouping issues. enable_custom_tracing Type Boolean Default true Enables all instrumentation using an @Trace annotation. Disabling this causes @Trace annotations to be ignored. extensions.dir Type String Default (none) Defines the location of the optional extensions directory. If this property is not set, the agent will look for a subdirectory named extensions in the same directory as newrelic.jar and newrelic.yml. high_security Type Boolean Default false In order for high security to be enabled, this property must be set to true and the high security property in the New Relic user interface must be enabled. Enabling high security means SSL is turned on, request and message queue parameters are not collected, and queries cannot be sent to New Relic in their raw form. Important As of Java agent 3.48.0, SSL is enabled by default and the config option to disable it has been deprecated. As of Java agent 4.0.0, the ability to disable SSL has been removed. insert_api_key Type String Default (none) A valid Insert API Key for your account. This is only required for Real-time Java profiling using JFR metrics. labels Type String Default \"\" Attach tags to this app. Note that this option now enables tags, which replaced the label feature. You can still query your historical labels. max_stack_trace_lines Type Integer Default 30 Limits the number of lines the agent collects from each stack trace. Increasing this value may impact performance, because it increases the amount of memory the agent uses and the amount of data sent to New Relic. proxy_host Type String Default (none) The proxy host through which to connect to the New Relic collector. If a proxy is used, the host setting is required. Other proxy settings are optional. proxy_password Type String Default (none) The password for proxy authentication. If a proxy is used, the host setting is required. Other proxy settings are optional. The username and password settings will be used to authenticate to Basic Auth challenges from a proxy server. Important The Java agent supports Basic (clear text) authentication. proxy_port Type String Default 8080 The proxy host port number. If a proxy is used, the host setting is required. Other proxy settings are optional. proxy_user Type String Default (none) The username for proxy authentication, such as Basic (clear text) authentication. If a proxy is used, the host setting is required. Other proxy settings are optional. The username and password settings will be used to authenticate to Basic Auth challenges from a proxy server. proxy_scheme Type String Default (none) The proxy scheme used. Setting proxy_scheme: \"https\" will allow the agent to connect through proxies using the HTTPS scheme. reactor-netty.errors.enabled Type Boolean Default true Whether errors are reported for reactor netty. If set to false, errors will be ignored. Important Only available in Java agent 6.3.0 and above. send_data_on_exit Type Boolean Default false Enable delayed JVM shutdown to give the agent a chance to send latest metric data to New Relic before JVM shutdown. send_data_on_exit_threshold Type Integer Default 60 The number of seconds after which the agent will use the send_data_on_exit setting. send_environment_info Type Boolean Default true Enable reporting of JVM settings to New Relic. send_jvm_props Type Boolean Default true When set to true, JVM properties will be sent to New Relic. ssl (DEPRECATED) Type Boolean Default true Requires connections to the New Relic collector to go over SSL. The agent communicates with New Relic via HTTPS by default, and New Relic requires HTTPS for all traffic to APM and the New Relic REST API. This work is done asynchronously to the threads that process your application code, so response times will not be directly affected by this change. Important As of Java agent 3.48.0, SSL is enabled by default and the config option to disable it has been deprecated. As of Java agent 4.0.0, the ability to disable SSL has been removed. sync_startup Type Boolean Default false Enable the agent to connect the New Relic collector immediately upon app startup. scala_futures_as_segments Important This applies to Java agent version 3.44.0 or higher. Type Boolean Default false For more concise transaction trace details, the agent does not report Scala Futures as transaction segments, and those Futures do not contribute to the transaction’s total time. Enabling scala_futures_as_segments increases your overhead. If you want Scala Futures to report as transaction segments so you can view them in a transaction trace, you can enable it: scala_futures_as_segments: enabled: true Copy Logging configuration These are part of the general configuration variables. They are broken out here because they are frequently tweaked for debugging. Some of the logging configuration variables are dynamic and do not need a host restart for them to take effect. For instance, if log files are growing too quickly, log_level can be set to a less verbose setting to reduce the reporting rate. Here is the order of precedence for configuration variables affecting log rotation. If log_daily is true, other log rotation settings are ignored. If log_file_count is 1 or 0, the size limit is ignored. Finally, the agent applies log_limit_in_kbytes. Depending on the growth rate, it is possible for the log file size to exceed the configured value by a small amount. log_daily Type Boolean Default false Set to true to roll the logs daily. Overrides the other configuration variables that affect log rotation. log_file_count Type Integer Default 1 The maximum number of log files to keep when using log rotation. log_file_name Type String Default newrelic_agent.log The unqualified log file name or the string STDOUT which will log to standard out. log_file_path Type String Default logs subdirectory where newrelic.jar is located The log file path. Tip If log_file_path is specified, the directory must already exist. If the default value is used, the agent will attempt to create the directory. log_level Type String Default info The log verbosity level. The agent uses its own log file to keep its logging separate from that of your application. Valid options, in order of verboseness, are: off severe warning info fine finer finest This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. log_limit_in_kbytes Type Integer Default 0 The log file size in kilobytes at which log files are rotated. Set to 0 for no limit. JMX To set these options, use the jmx stanza. To override them, use a newrelic.config.jmx prefixed system property. The Java agent uses JMX to collect JVM data as well as to communicate with the JFR (Java Flight Recorder) daemon for Real-time Java profiling. enabled Type Boolean Default true This setting can be used to turn on or off all JMX functionality. linkingMetadataMBean Type Boolean Default false This setting can be enabled to allow the Java agent to expose linking metadata to the JFR daemon. Doing so allows the JFR daemon to obtain the entity GUID generated by the Java agent and link JFR data with the same APM application that is being monitored by the agent instead of as a separate entity. Important This applies to Java agent version 6.1.0 or higher. Attributes To set these options, use the attributes stanza. To override them, use a newrelic.config.attributes prefixed system property. Attributes are key-value pairs that provide information for transaction traces, traced errors, browser monitoring, and transaction events. There is also an attribute stanza under each destination. For more information, see Java agent attributes, Enabling and disabling attributes and Attribute examples. enabled Type Boolean Default true This setting can be used to turn on or off all attributes. Important For security reasons, capturing custom attributes using the Custom Instrumentation Editor is set to false by default. include Type List of Strings Default (none) If attributes are enabled, attribute keys found in this list will be sent to New Relic. Separate the keys in the list with a comma; for example: key1, key2, key3 Copy Also refer to the agent attribute rules. exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic. Separate the keys in the list with a comma; for example: key1, key2, key3 Copy Also refer to the agent attribute rules. Transaction tracer These options are set in the transaction_tracer stanza and can be overridden by using a newrelic.config.transaction_tracer prefixed system property. Transaction tracing captures deep information about slow transactions and sends this to the New Relic service. The transaction includes the exact call sequence of the transactions, including any query statements issued. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. enabled Type Boolean Default true The transaction tracer is enabled by default. Set this to false to turn it off. explain_enabled Type Boolean Default true Determines whether the agent will capture the EXPLAIN plan for slow queries. Only supported for MySQL and PostgreSQL. explain_threshold Type Float Default 0.5 Threshold in seconds for query execution time below which the slow query and the EXPLAIN plan (if supported) will not be captured. Relevant to slow queries only when record_sql is set to raw or obfuscated. Relevant to EXPLAIN plans only when explain_enabled is set to true. insert_sql_max_length Type Integer Default 2000 The character limit for the SQL query string. If you have many slow SQL queries with large chunks of information, this could negatively affect performance or how quickly you see your data in New Relic. Increase the value gradually until you find the right balance of information and performance. log_sql Type Boolean Default false Set to true to enable logging of queries to the agent log file instead of uploading to New Relic. Queries are logged using the record_sql mode. record_sql Type String Default obfuscated When the transaction tracer is on, query statements can optionally be recorded. The recorder has three modes: off: Send no queries. raw: Send the query statement in its original form. obfuscated: Strips out numeric and string literals. stack_based_naming (Play 2.x+ only) Type Boolean Default False Defaulted to true until Java agent version 3.12.1, when it was changed to false. This option is for Play 2.x+ only. Play/Scala instrumentation can use Thread.getStackTrace() to improve tracer naming, but at the cost of increased overhead. stack_trace_threshold Type Integer Default 0.5 Defines a threshold (in seconds) for collecting stack traces from an SQL call. When SQL statements exceed this threshold, the agent will capture the current stack trace. This is useful for pinpointing where long SQL calls originate from. top_n Type Integer Default 20 Use this setting to control the variety of your transaction traces. top_n is an integer that represents the number of unique, slow transactions that traces will be created for. If you want transaction traces to more accurately reflect the actual slowest transactions in your app, make this value lower. If you want to sample a more diverse array of transactions, make the value higher. A value of 0 would mean that only the slowest transaction is always traced. This is considered not to be optimal, though, because you may have one or two transactions that are always the slowest, and repeatedly seeing those same transaction traces will probably not give you much value. If the same transaction is often the slowest, the top_n setting allows the Java agent (over time) to sample the slowest n transactions. This gives you greater variety and more insight into your application. transaction_threshold Type String (float) Default apdex_f The time threshold used to determine when a transaction is eligible to be traced. When the transaction's response time exceeds this threshold, a transaction trace will be recorded and sent to New Relic. The default is apdex_f (default), which sets the threshold to be the \"Frustrated\" Apdex level (four times the apdex_t value). You can also set a specific time threshold by entering a float value that represents a number of seconds. slow_query_whitelist (DEPRECATED) Type String Default (none) Important This config has been deprecated as of agent version 5.10.0 and will be removed in a future agent version. Instead use collect_slow_queries_from. By default, high security mode does not allow the agent to collect slow queries. Enable this option to collect Cassandra queries from the DataStax driver, even with high security enabled. If you don't use high security, the agent collects slow queries automatically. For DataStax driver 2.1.2, add this rule to your allow list: transaction_tracer: slow_query_whitelist: 'com.newrelic.instrumentation.cassandra-datastax-2.1.2' Copy For DataStax driver 3.0.0, add this rule to your allow list: transaction_tracer: slow_query_whitelist: 'com.newrelic.instrumentation.cassandra-datastax-3.0.0' Copy collect_slow_queries_from Type String Default (none) By default, high security mode does not allow the agent to collect slow queries. Enable this option to collect Cassandra queries from the DataStax driver, even with high security enabled. If you don't use high security, the agent collects slow queries automatically. For DataStax driver 2.1.2, add this rule to your allow list: transaction_tracer: collect_slow_queries_from: 'com.newrelic.instrumentation.cassandra-datastax-2.1.2' Copy For DataStax driver 3.0.0, add this rule to your allow list: transaction_tracer: collect_slow_queries_from: 'com.newrelic.instrumentation.cassandra-datastax-3.0.0' Copy attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for transaction traces. If attributes.enabled at the root level is false, no attributes will be sent to transaction traces regardless on how this property (transaction_tracer.attributes.enabled) is set. attributes.include Type List of strings Default (none) If attributes are enabled for transaction traces, all attribute keys found in this list will be sent to New Relic in transaction traces. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in transaction traces. For more information, see the agent attribute rules. token_limit Type Integer Default 3000 Limits the number of Tokens that can be created per Transaction. Increasing this value may impact performance, because it increases the amount of memory the agent uses and the amount of data sent to New Relic. segment_limit Type Integer Default 3000 Limits the number of segments that can be created per transaction. Increasing this value may impact performance, because it increases the amount of memory the agent uses and the amount of data sent to New Relic. Transaction segments These options are set in the transaction_segments stanza and can be overridden by using a newrelic.config.transaction_segments prefixed system property. Transaction segments represent discrete pieces of work (generally method calls) and are displayed within transaction traces. Important Transaction segment attribute filtering requires Java agent version 4.10.0 or higher. attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for transaction segments. If attributes.enabled at the root level is false, no attributes will be sent to transaction segments regardless on how this property (transaction_segments.attributes.enabled) is set. attributes.include Type List of strings Default (none) If attributes are enabled for transaction segments, all attribute keys found in this list will be sent to New Relic in transaction segments. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in transaction segments. For more information, see the agent attribute rules. Browser monitoring These options are set in the browser_monitoring stanza and can be overridden by using a newrelic.config.browser_monitoring prefixed system property. Browser monitoring gives you insight into the performance real users are experiencing with your website. This is accomplished by measuring the time it takes for your users' browsers to download and render your web pages by injecting a small amount of JavaScript code into the header and footer of each page. auto_instrument Type Boolean Default true By default the agent automatically inserts API calls in compiled JSPs to inject the monitoring JavaScript into web pages. Set this attribute to false to turn off this behavior. disabled_auto_pages Type Comma-separated list of strings Default (none) When auto_instrument is true, by default all pages are instrumented. List all pages that you want the auto instrumentation to skip here. You can still use manual instrumentation on these pages. For example: browser_monitoring: disabled_auto_pages: /WEB-INF/jsp/testpage_1.jsp, /WEB-INF/jsp/testpage_2.jsp Copy attributes.enabled Type Boolean Default false This setting can be used to turn on or off all attributes for browser monitoring. This is the data you can query. If attributes.enabled is false at the root level, no attributes will be sent up in browser monitoring regardless on how this property under browser_monitoring is set. attributes.include Type List of Strings Default (none) If attributes are enabled for browser_monitoring, all attribute keys found in this list will be sent to New Relic in page views. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in page views. For more information, see the agent attribute rules. External tracer The external tracing options are set in the external_tracer stanza and can be overridden by using a newrelic.config.external_tracer prefixed system property. exclude_request_uri Type Boolean Default false This setting can be used to control the collection of outgoing request URIs for errors and transaction traces. Set this to true to disable collecting this information. Cross application tracer The cross application tracing options are set in the cross_application_tracer stanza and can be overridden by using a newrelic.config.cross_application_tracer prefixed system property. Cross application tracing adds request and response headers to external calls using the Apache HttpClient libraries. This provides better performance data when calling applications monitored by other New Relic Agents. enabled Type Boolean Default true Cross application tracing is enabled by default. Set this to false to turn it off. Error collector These options are set in the error_collector stanza and unless noted otherwise can be overridden by using a newrelic.config.error_collector prefixed system property. The error collector captures information about uncaught exceptions and sends them to New Relic for viewing. Tip For how to configure errors for the Java agent, including how to configure errors via the UI, see Java agent error configuration. enabled Type Boolean Default true Enable error collection. ignore_classes Type Stanza containing a list of fully qualified class_name strings Default (none) Specified exception class names will be ignored and will not affect error rate or Apdex score, or be reported to APM. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: ignore_classes: - \"com.example.MyException\" - \"com.example.DifferentException\" Copy ignore_messages Type Stanza containing a fully qualified class_name and a list of messages per error class Default (none) Specify exception class names the agent should ignore. Ignored messages will not affect error rate or Apdex score, or be reported to APM. Contains yaml pairs consisting of: A fully qualified exception class name that should not be reported to APM AND A list of exception messages to match against (at least one is required) If the exception class name matches an error but the message does not, then that error will not be ignored. Message strings use contains for matching. A message cannot be provided on its own and must always be paired with a fully qualified class name. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: ignore_messages: com.example.MyException: - \"Some error message to ignore\" - \"Some other error message to ignore\" com.example.DifferentException: - \"Some different error message to ignore\" Copy ignore_status_codes Type Comma-separated list of strings and ranges Default 404 A comma-separated list comprised of individual and dashed ranges of HTTP status codes that should not be treated as errors. If this property is commented out in the newrelic.yml configuration file, then the 404 status code will automatically be ignored. When using server-side configuration, the status code 404 must be specified in order for it to be ignored. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: ignore_status_codes: 404,507-511 Copy expected_classes Type Stanza containing a List of fully qualified class_name strings Default (none) Prevents specified exception classes from affecting error rate or Apdex score while still reporting the errors to APM. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: expected_classes: - \"com.example.MyException\" - \"com.example.DifferentException\" Copy expected_messages Type Stanza containing a fully qualified class_name and a List of messages per error class Default (none) Contains yaml pairs consisting of a fully qualified exception class name that should be marked as expected and thus prevented from affecting error rate or Apdex score and a List of exception messages to match against, the latter of which at least one is required. If the exception class name matches an error but the message does not, then that error will not be marked as expected and therefore will affect error rate and Apdex score. Message strings use contains for matching. A message cannot be provided on its own and must always be paired with a fully qualified class name. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: expected_messages: com.example.MyException: - \"Some expected error message\" - \"Some other expected error message\" com.example.DifferentException: - \"Some different expected error message\"​ Copy expected_status_codes Type Comma-separated list of strings and ranges Default (none) A comma-separated list comprised of individual and dashed ranges of HTTP status codes to be marked as expected and thus prevented from affecting error rate or Apdex score. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: expected_status_codes: 415,500-506 Copy attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for traced errors. If attributes.enabled is false at the root level, then no attributes will be sent to traced errors regardless of how this property is set under error_collector. attributes.include Type List of strings Default (none) If attributes are enabled for traced errors, all attribute keys found in this list will be sent to New Relic in traced errors. For more information, see the agent attribute rules. attributes.exclude Type List of strings Default (none) Attribute keys found in this list will not be sent to New Relic in traced errors. For more information, see the agent attribute rules. ignore_errors (DEPRECATED) Type Comma-separated list of Strings Default (none) All specified exception class names specified will not be treated as errors. Deprecated as of Java agent 3.40.0 and replaced by ignore_classes. For example: error_collector: ignore_errors: some.other.MyException Copy Strip exceptions These options are set in the strip_exception_messages stanza and unless noted otherwise can be overridden by using a newrelic.config.strip_exception_messages​prefixed system property. This configuration can be enabled to control whether Java exception messages are reported to New Relic. enabled Type Boolean Default false By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you set this to true, the agent strips the messages from exceptions in order to prevent it from inadvertently capturing sensitive information. If you enable high security mode, this is automatically set to true. If you set enabled to true but you want the agent to capture messages from specific exceptions, add the exceptions to your allow list. whitelist (DEPRECATED) Type String Default (none) Important This config has been deprecated as of agent version 5.10.0 and will be removed in a future agent version. Instead use allowed_classes. If you set enabled to true but you want the agent to capture messages for specific exceptions, add each exception to the whitelist, separated by a comma. allowed_classes Type String Default (none) If you set enabled to true but you want the agent to capture messages for specific exceptions, add each exception to allowed_classes, separated by a comma. Thread profiler These options are set in the thread_profiler stanza and can be overridden by using a newrelic.config.thread_profiler prefixed system property. Thread profiler measures wall clock time, CPU time, and method call counts in your application's threads as they run. enabled Type Boolean Default true Enable the thread profiler. Transaction events These options are set in the transaction_events stanza and can be overridden by using a newrelic.config.transaction_events prefixed system property. Transaction events provide the data for displaying histograms and percentiles in the UI. Important Previously this stanza was called analytics_events. If your configuration file still uses analytics_events, update your agent to use transaction_events. enabled Type Boolean Default true Enable the transaction events service. max_samples_stored Type Integer Default 2000 Max 10000 The maximum number of sampled transaction events reported every 60 seconds. custom_request_headers Type List of maps Default None Important Unlike other settings, custom_request_headers have to be paired together and must be set in the newrelic.yml file. They can't be overwritten by Java virtual machine arguments (system property) or environment variables. A list of maps with the paired keys header_name and the optional header_alias. Choose one or more custom HTTP request headers to add as transaction attributes. You can list multiple header configurations: transaction_events: custom_request_headers: - header_name: \"X-Custom-Header-1\" - header_name: \"X-Custom-Header-2\" header_alias: \"CustomHeader2alias\" Copy In the first map set, X-Custom-Header-1 is captured and reported by the agent as the header name for a corresponding value from the request object. The header_name will also be the name of the attribute sent to New Relic. In the second map set, the request header is X-Custom-Header-2, but the CustomHeader2alias is the name sent to New Relic. attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for transaction events. If attributes.enabled is false at the root level, then no attributes will be sent to transaction events regardless of how this property is set under transaction_events. attributes.include Type List of Strings Default (none) If attributes are enabled for transaction events, all attribute keys found in this list will be sent to New Relic in transaction events. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in transaction events. For more information, see the agent attribute rules. Custom events Custom events are set in the custom_insights_events stanza and can be overridden by using a newrelic.config.custom_insights_events prefixed system property. APM lets you record custom event data via the New Relic language agent APIs, which you can then query. Important For Java agent versions prior to 4.1.0, the following YAML configuration is recognized: custom_insights_events.enabled: true custom_insights_events.max_samples_stored: 5000 Copy For agent versions 4.1.0 and above, the YAML configuration uses the nested stanza formatting: custom_insights_events: enabled: false max_samples_stored: 5000 Copy enabled Type Boolean Default true This enables the custom event service. max_samples_stored Type Integer Default/Max 10000 The maximum number of sampled custom events reported every 60 seconds. Hostname configuration These options are set in the process_host stanza and can be overridden by using a newrelic.config.process_host prefixed system property. These properties are used for configuring the hostname displayed in the UI: display_name Type String Default (none) Set a display name to decorate the \"host:port\" label in the New Relic UI. ipv_preference Type String Default 4 If the hostname cannot be determined, then the IP address of the host will be used. This property determines whether the IPv4 or IPv6 address should be used. The default is IPv4. Custom instrumentation These options set in the class_transformer stanza and can be overridden by using a newrelic.config.class_transformer prefixed system property. trace_annotation_class_name Type String Default (none) String containing the full class name of the annotation class the agent uses to determine which user-specified methods to instrument. For more information about custom annotations, see Java custom metric collection. com.newrelic.instrumentation.servlet-user Type Boolean Default false Enable this option to capture the userPrincipal name. This name is included as a transaction trace attribute, and can be queried. System properties You can override any setting in the newrelic.yml file by setting a system property. The system property corresponding to a given setting in the config file is the setting name prefixed by newrelic.config. For example, the system property for the log_level setting is newrelic.config.log_level. For settings nested in stanzas, prepend the stanza name to the setting name. For example, the system property for the enabled setting in the transaction_tracer stanza is newrelic.config.transaction_tracer.enabled. In addition to overriding configuration settings, the following system properties are recognized by the agent: newrelic.config.process_host.display_name Type String Default (none) Set a display name to decorate the \"host:port\" label in the New Relic UI. Requires Java agent 3.17 or higher. newrelic.config.file Type String Default (none) String containing a fully qualified path to the newrelic configuration file. If empty, the agent assumes newrelic.yml is in the same directory as newrelic.jar. newrelic.debug Type Boolean Default (none) Enable debug logging. newrelic.environment Type String Default (none) String containing the environment configuration for the agent to use. newrelic.home Type String Default (none) String containing the home directory of agent. This defaults to the same directory as the agent jarfile. newrelic.logfile Type String Default newrelic_agent.log String containing the name of the agent log file. Environment variables Environment variables take the highest precedence and override the system properties and yml config settings. To set environment variables, use the export VARNAME=value command. To permanently set environment variables, add the export line to a file such as ~/.bashrc or ~/.bash_profile. You can override any setting from a system property or in the newrelic.yml by setting an environment variable. The environment variable corresponding to a given setting in the config file is the setting name prefixed by NEW_RELIC with all dots (.) and dashes (-) replaced by underscores (_). For example, the environment variable for the log_level setting is NEW_RELIC_LOG_LEVEL. For settings nested in stanzas, prepend the stanza name to the setting name. For example, the environment variable for the enabled setting in the transaction_tracer stanza is NEW_RELIC_TRANSACTION_TRACER_ENABLED. Important Agent configuration via environment variables requires Java agent version 4.10.0 or higher. For agent versions older than 4.10.0 the following environment variables are available: NEW_RELIC_APP_NAME (REQUIRED) Type String Default (none) This setting is required. Contains the application name under which to report data to New Relic. Set the name of your application as you want it to appear in New Relic. If enable_auto_app_naming is false, the agent reports all data to this application. Otherwise, the agent reports only background tasks (transactions for non-web applications) to this application. To report data to more than one application, separate the application names with a semicolon ;. For example, to report data to My Application and My Application 2: app_name: My Application;My Application 2 Copy For more methods of naming your application, see Name your Java application. NEW_RELIC_DISTRIBUTED_TRACING_ENABLED Type String Default false Enables distributed tracing. Case sensitive: use true or false. For more information, see the distributed tracing section. NEW_RELIC_PROCESS_HOST_DISPLAY_NAME Type String Default (none) Set a display name to decorate the \"host:port\" label in the New Relic UI. NEW_RELIC_LICENSE_KEY (REQUIRED) Type String Default (none) This setting is required. Contains your New Relic account license. You must specify the license key associated with your New Relic account. This key binds your agent's data to your account in the New Relic service. NEW_RELIC_LOG Type String Default newrelic_agent.log The unqualified log file name or the string STDOUT which will log to standard out. Cloud platform utilization These options are set in the utilization stanza and can be overridden by using a newrelic.config.utilization prefixed system property. The agent collects utilization information and sends it to the New Relic service. The agent can collect information from Amazon Web Services (AWS) EC2 instances and Docker containers. detect_aws Type Boolean Default true Determines whether the agent polls AWS metadata API. detect_docker Type Boolean Default true Determines whether the agent reads Docker information from the file system. Async instrumentation These options are set directly in the common stanza and can be overridden by using a prefixed system property. token_timeout Type Integer Default (seconds) 180 The number of seconds after which the agent will automatically expire an async token that has not been explicitly expired with token.expire(). For usage instructions, see Tokens: Connect async threads. Important Increasing this value may impact performance, because it increases the amount of memory the agent uses and prevents transactions from being reported due to unexpired tokens. segment_timeout Type Integer Default (seconds) 600 The number of seconds after which the agent will automatically end a segment that has not been explicitly ended with segment.end() or segment.ignore(). For usage instructions, see Segments: Time arbitrary async activity. Important Increasing this value may impact performance, because it increases the amount of memory the agent uses and prevents transactions from being reported due to un-ended segments. Circuit breaker These settings customize the behavior of the Java circuit breaker. These settings are not included in newrelic.yml by default. You do not need to restart your JVM after changing them. If you want to customize the circuit breaker, add the stanza under the common stanza: common: &default_settings​ ​ OTHER_CONFIG_SETTINGS circuitbreaker: enabled: true memory_threshold: 20 gc_cpu_threshold: 10 Copy enabled Type Boolean Default true If your application is behaving as expected, you may want to disable the circuit breaker. memory_threshold Type Integer (0 to 100) Default 20 Customize the precentage of free heap memory below which the circuit breaker should trip. When the percentage of free heap memory is less than memory_threshold, and the CPU time spent doing garbage collection is greater than gc_cpu_threshold, the circuit breaker trips. In order to make the circuit breaker less likely to trip, decrease memory_threshold and/or increase gc_cpu_threshold. Adjust these values as needed, based on your application's operating performance and behavior. gc_cpu_threshold Type Integer (0 to 100) Default 10 Customize the precentage of garbage collection CPU time above which the circuit breaker should trip. When the percentage of free heap memory is less than memory_threshold, and the CPU time spent doing garbage collection is greater than gc_cpu_threshold, the circuit breaker trips. In order to make the circuit breaker less likely to trip, decrease memory_threshold and/or increase gc_cpu_threshold. Adjust these values as needed, based on your application's operating performance and behavior. Message tracer These options are set in the message_tracer stanza and can be overridden by using a newrelic.config.message_tracer prefixed system property. segment_parameters.enabled Type Boolean Default true Adds message properties to tracer attributes. Set this to false to turn it off. Distributed tracing Important Enabling distributed tracing disables cross application tracing, and has other effects on APM features. Before enabling, read the transition guide. Requires Java agent version 4.3.0 or higher. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. In the config file, it can be set in the distributed_tracing stanza. It can be overridden using a newrelic.config.distributed_tracing prefixed system property. enabled Type Boolean Default false Set this to true to enable distributed tracing. For example, to enable this in the config file, you would use: distributed_tracing: enabled: true Copy To enable this using a system property, you would use: -Dnewrelic.config.distributed_tracing.enabled=true Copy exclude_newrelic_header Type Boolean Default false By default, supported versions of the agent utilize both the newrelic header and W3C Trace Context headers for distributed tracing. The newrelic distributed tracing header allows interoperability with older agents that don't support W3C Trace Context headers. Agent versions that support W3C Trace Context headers will prioritize them over newrelic headers for distributed tracing. If you do not want to utilize the newrelic header, setting this to true will result in the agent excluding the newrelic header and only using W3C Trace Context headers for distributed tracing. For example, to exclude newrelic headers in the config file, you would use: distributed_tracing: exclude_newrelic_header: true Copy To exclude newrelic headers using a system property, you would use: -Dnewrelic.config.distributed_tracing.exclude_newrelic_header=true Copy Infinite Tracing Important Requirements: Java Agent 5.12.1 or higher. Infinite Tracing does not work if enable_auto_app_naming is enabled. To turn on Infinite Tracing, enable distributed tracing and add the additional setting below. For an example, see Language Agents: Configure Distributed Tracing. trace_observer.host Type String Default None For help getting a valid Infinite Tracing trace observer host entry, see find or create a Trace Observer. You can configure this via YAML: infinite_tracing: trace_observer: host: YOUR_TRACE_OBSERVER_HOST Copy You can also use the system property newrelic.config.infinite_tracing.trace_observer.host or the environment variable NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_HOST. Span events Span events are reported for distributed tracing. Distributed tracing must be enabled to report span events. Span configuration is set in the span_events stanza and can be overridden by using a newrelic.config.span_events prefixed system property. Options include: enabled Type Boolean Default true Used to enable/disable span event reporting. attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for span events. If attributes.enabled at the root level is false, no attributes will be sent to span events regardless on how this property (span_events.attributes.enabled) is set. attributes.include Type List of strings Default (none) If attributes are enabled for span events, all attribute keys found in this list will be sent to New Relic in span_events. For more information, see the agent attribute rules. attributes.exclude Type List of strings Default (none) All attribute keys found in this list will not be sent to New Relic in span events. For more information, see the agent attribute rules. Important Span event attribute filtering requires Java agent version 4.10.0 or higher. Jar collector The Java agent collects and information about jars and their versions on the application classpath. Jar collection configuration is set in the jar_collector stanza and can be overridden by using a newrelic.config.jar_collector prefixed system property. Options include: enabled Type Boolean Default true Used to enable/disable jar collection and reporting. skip_temp_jars Type Boolean Default true Used to enable/disable collection of temporary jars. Temporary jars are those residing in the directory specified by the system property java.io.tmpdir. jars_per_second Type Integer Default 10 The maximum number of jars to process per second. Must be positive.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 89.311325,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> configuration: Config file",
        "sections": "<em>Java</em> <em>agent</em> configuration: Config file",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": ". There is also an attribute stanza under each destination. For more information, see <em>Java</em> <em>agent</em> <em>attributes</em>, Enabling and disabling <em>attributes</em> and Attribute examples. enabled Type Boolean Default true This setting can be used to turn on or off all <em>attributes</em>. Important For security reasons, capturing custom"
      },
      "id": "603eb739e7b9d2a2432a07e0"
    }
  ],
  "/docs/agents/java-agent/configuration/automatic-application-naming": [
    {
      "sections": [
        "Configuring your SSL certificates",
        "Notice of expired SSL certificates and certificate removal",
        "Caution",
        "Important",
        "Java Agent versions 6.2.0 - 6.4.2",
        "Java Agent versions 6.0.0/6.1.0",
        "Using YAML-based configuration",
        "Java Agent versions prior to 6.0.0 (Deprecated)",
        "For more help"
      ],
      "title": "Configuring your SSL certificates",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "af154f250e87f571db157972e22dbb1f907a8fde",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/configuring-your-ssl-certificates/",
      "published_at": "2021-05-05T06:44:59Z",
      "updated_at": "2021-04-28T23:01:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To communicate with the New Relic collector over HTTPS, you need to have the proper certificates for trusted signers in the trust store on your app server. By default, most JREs contain a valid root certificate that allows the agent to connect to newrelic.com. For SSL connection issues, please visit SSL or connection errors (Java). Notice of expired SSL certificates and certificate removal Caution The SSL certificates that were bundled with Java agent versions 6.1.0 to 6.4.2 have expired and are no longer valid. This means that Java agent versions 6.1.0 to 6.4.2 can no longer use the certificates bundled with the agent to establish a connection with New Relic and that you must provide your own SSL certificates. Please see this community forum post for additional details. Important Java agent versions higher than 6.4.2 no longer ship with SSL certificates bundled into the agent. You must provide your own SSL truststore to the agent by explicitly using the ca_bundle_path configuration option, or by using the default truststore provided by the JDK/JRE (the agent will look to use the latter by default). Additionally the use_private_ssl configuration option has been removed from Java agent versions higher than 6.4.2. Users wishing to add the global certificate to their local trust store can download the DigiCert Global Root CA from DigiCert. Java Agent versions 6.2.0 - 6.4.2 Starting with Java agent version 6.2.0, the use_private_ssl configuration option has been reintroduced so you can use the SSL certificates that are bundled into the agent jar. The following bundled SSL certificates are valid for up to a year after release. META-INF/certs/eu-newrelic-com.pem META-INF/certs/eu01-nr-data-net.pem META-INF/certs/newrelic-com.pem Copy Important The Java agent will begin logging a warning message upon application startup when there are less than three months before the bundled certificate expires. When the bundled certificates expire, the Java agent will no longer be able to connect to New Relic and you must either update to the latest agent version or provide a valid certificate using the ca_bundle_path configuration. Users wishing to add the global certificate to their local trust store can download the DigiCert Global Root CA from DigiCert. Using YAML-based configuration common: default_settings ca_bundle_path: /path/to/digicert.pem use_private_ssl: false # # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic ... Copy Summary There are two configuration settings that determine what certs are used by the agent to establish a secure connection to New Relic. They are: use_private_ssl and ca_bundle_path. Here's how they work together: DEFAULT: Neither configuration option (ca_bundle_path/use_private_ssl) is provided, because both are using default values. The agent will use the default SSL certificates bundled into the Java Development Kit (JDK). If these certificates aren't present or don't include certificates that trust New Relic, then the agent will not connect. You'll need to merge valid certificates into your JDK certificate bundle. Only use_private_ssl is configured. The agent will use the SSL certificates that are bundled with it. Only ca_bundle_path is configured. The agent will try to connect using the custom SSL certificates bundle at the configured path. If the configured custom certificate bundle doesn’t include certificates that trust New Relic, then the agent will not connect. You'll need to merge valid certificates into your custom certificate bundle. Both use_private_ssl and ca_bundle_path are configured. The ca_bundle_path configuration setting takes precedence and the use_private_ssl config is ignored. This behavior is the same as only specifying ca_bundle_path. Java Agent versions 6.0.0/6.1.0 Starting in 6.0.0, the Java agent no longer includes the nrcert global certificate chain. Users wishing to add the global certificate to their local trust store must download the DigiCert Global Root CA from DigiCert. Note: In versions 6.1.0+, the Java agent will use a bundled New Relic certificate that is valid for up to a year after release. Before the certificate expires, you must either update the agent to the latest version or provide a valid certificate using the ca_bundle_path configuration. Important The Java agent will begin logging a warning message upon application startup when there are less than three months before the bundled certificate expires. Using YAML-based configuration common: default_settings ca_bundle_path: /path/to/digicert.pem # # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic ... Copy Java Agent versions prior to 6.0.0 (Deprecated) For Java agent versions prior to 6.0.0, applications that require valid certificates may add them in one of the following two ways: Use YAML-based configuration. Add the bundled list of New Relic trusted signers to the local store. Using YAML-based configuration The New Relic Java agent bundles the list of trusted signers in the agent newrelic.jar file. If you do not want to change the local trust store, you can activate them by setting use_private_ssl to true in the newrelic.yml agent configuration file: common: default_settings use_private_ssl: true # # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic ... Copy For more help Additional documentation resources include New Relic for Java (compatibility and requirements, installation, and configuration.)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 133.55939,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Configuring</em> your SSL certificates",
        "sections": "<em>Java</em> <em>Agent</em> versions 6.2.0 - 6.4.2",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " provide your own SSL truststore to the <em>agent</em> by explicitly using the ca_bundle_path <em>configuration</em> option, or by using the default truststore provided by the JDK&#x2F;JRE (the <em>agent</em> will look to use the latter by default). Additionally the use_private_ssl <em>configuration</em> option has been removed from <em>Java</em>"
      },
      "id": "603eb7a2e7b9d247c02a080d"
    },
    {
      "sections": [
        "Java agent configuration: Config file",
        "Configuration file structure",
        "Tip",
        "Configuration settings precedence",
        "Configuring the Java extensions directory",
        "Create an extensions directory",
        "Specify an existing extensions directory",
        "General configuration settings",
        "license_key (REQUIRED)",
        "app_name (REQUIRED)",
        "agent_enabled",
        "apdex_t (DEPRECATED)",
        "appserver_port",
        "Important",
        "audit_mode",
        "ca_bundle_path",
        "use_private_ssl",
        "enable_auto_app_naming",
        "enable_auto_transaction_naming",
        "Caution",
        "enable_custom_tracing",
        "extensions.dir",
        "high_security",
        "insert_api_key",
        "labels",
        "max_stack_trace_lines",
        "proxy_host",
        "proxy_password",
        "proxy_port",
        "proxy_user",
        "proxy_scheme",
        "reactor-netty.errors.enabled",
        "send_data_on_exit",
        "send_data_on_exit_threshold",
        "send_environment_info",
        "send_jvm_props",
        "ssl (DEPRECATED)",
        "sync_startup",
        "scala_futures_as_segments",
        "Logging configuration",
        "log_daily",
        "log_file_count",
        "log_file_name",
        "log_file_path",
        "log_level",
        "log_limit_in_kbytes",
        "JMX",
        "enabled",
        "linkingMetadataMBean",
        "Attributes",
        "include",
        "exclude",
        "Transaction tracer",
        "explain_enabled",
        "explain_threshold",
        "insert_sql_max_length",
        "log_sql",
        "record_sql",
        "stack_based_naming (Play 2.x+ only)",
        "stack_trace_threshold",
        "top_n",
        "transaction_threshold",
        "slow_query_whitelist (DEPRECATED)",
        "collect_slow_queries_from",
        "attributes.enabled",
        "attributes.include",
        "attributes.exclude",
        "token_limit",
        "segment_limit",
        "Transaction segments",
        "Browser monitoring",
        "auto_instrument",
        "disabled_auto_pages",
        "External tracer",
        "exclude_request_uri",
        "Cross application tracer",
        "Error collector",
        "ignore_classes",
        "ignore_messages",
        "ignore_status_codes",
        "expected_classes",
        "expected_messages",
        "expected_status_codes",
        "ignore_errors (DEPRECATED)",
        "Strip exceptions",
        "whitelist (DEPRECATED)",
        "allowed_classes",
        "Thread profiler",
        "Transaction events",
        "max_samples_stored",
        "custom_request_headers",
        "Custom events",
        "Hostname configuration",
        "display_name",
        "ipv_preference",
        "Custom instrumentation",
        "trace_annotation_class_name",
        "com.newrelic.instrumentation.servlet-user",
        "System properties",
        "newrelic.config.process_host.display_name",
        "newrelic.config.file",
        "newrelic.debug",
        "newrelic.environment",
        "newrelic.home",
        "newrelic.logfile",
        "Environment variables",
        "NEW_RELIC_APP_NAME (REQUIRED)",
        "NEW_RELIC_DISTRIBUTED_TRACING_ENABLED",
        "NEW_RELIC_PROCESS_HOST_DISPLAY_NAME",
        "NEW_RELIC_LICENSE_KEY (REQUIRED)",
        "NEW_RELIC_LOG",
        "Cloud platform utilization",
        "detect_aws",
        "detect_docker",
        "Async instrumentation",
        "token_timeout",
        "segment_timeout",
        "Circuit breaker",
        "memory_threshold",
        "gc_cpu_threshold",
        "Message tracer",
        "segment_parameters.enabled",
        "Distributed tracing",
        "exclude_newrelic_header",
        "Infinite Tracing",
        "trace_observer.host",
        "Span events",
        "Jar collector",
        "skip_temp_jars",
        "jars_per_second"
      ],
      "title": "Java agent configuration: Config file",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "1d61f848fa192438225eae269421b8d384915c8b",
      "image": "https://docs.newrelic.com/static/60ca967eab99ca225186310913ae2de6/8c557/java-config-cascade.png",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-configuration-config-file/",
      "published_at": "2021-05-04T17:01:42Z",
      "updated_at": "2021-03-16T15:52:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent reads its configuration from the newrelic.yml file. By default the agent looks for this file in the directory that contains newrelic.jar. You can override the config file's location by setting the newrelic.config.file system property to a fully qualified file name. Configuration file structure The newrelic.yml file is split into stanzas corresponding to different environments: Test Development Staging Production (default) New Relic applies settings in the common stanza to each of these environments. You can select other environments as the default by setting the newrelic.environment system property to the environment name. Tip A newrelic.yml template is available. If you edit newrelic.yml, be careful to conform to the YAML format. Use a YAML validator to ensure the syntax is accurate before using the file with New Relic's Java agent, and follow these rules: Java agent newrelic.yml Requirements Format YML files are case sensitive. Indentations All indentations must be in increments of two characters. Other indentations will result in an Unable to parse configuration file error upon agent startup. Use the same level of indentation for data in the same stanza of the file. Indent any sub-stanzas by an additional two spaces. Changes to file You must restart your JVM host process for changes to take effect. Exception: Property changes to log_level and audit_mode do not require a restart. Property changes under circuit breaker don't require a restart. Configuration settings precedence To override any setting in the config file, use a system property override. In certain environments, environment variables can also be used to override both the config file and the system properties. The environment variables primarily exist to support Heroku. When used, server-side configuration overrides all other configuration settings. With the Java agent, server-side configuration overrides all other settings. Environment variables override Java system properties. Java properties override user configuration settings in your newrelic.yml file. User settings override the newrelic.yml default settings. Configuring the Java extensions directory The Java agent reads the configuration files on process startup. To identify the directory where the files are located, either create a new or specify an existing extensions directory: Create an extensions directory To create the extensions directory: Navigate to the directory where newrelic.jar and newrelic.yml are located. Create a directory named extensions. In newrelic.yml, check that the property extensions.dir is not set. Specify an existing extensions directory To use an existing Java extensions directory: In your newrelic.yml file, locate the common section. Use the property extensions.dir to specify the location of the file. General configuration settings Set these options in the common stanza. To override any of these options, use a newrelic.config prefixed system property. license_key (REQUIRED) Type String Default (none) This setting is required. You must specify the license key associated with your New Relic account. This key binds your agent's data to your account in the New Relic service. app_name (REQUIRED) Type String Default (none) This setting is required. Defines the application name used to report data to New Relic. If enable_auto_app_naming is false, the agent reports all data to this application. Otherwise, the agent reports only background tasks (transactions for non-web applications) to this application. To report data to more than one application, separate the application names with a semicolon. For example, to report data to My Application and My Application 2 use this: app_name: My Application;My Application 2 Copy For more methods of naming your application, see Name your Java application. agent_enabled Type Boolean Default true Flag to enable the agent. Use this setting to force the agent to run or not run. apdex_t (DEPRECATED) Type Float Default 1.0 The apdex_t threshold in seconds for the application's Apdex score. For Java agent versions 1.2.008 or higher, the apdex_t value is set in the UI and the value in newrelic.yml is ignored. appserver_port Type Integer Default (none) Number to differentiate JVMs for the same app on the same machine. New Relic uses host/port for uniqueness, so you can distinguish the JVMs by putting a switch like this into the startup arguments for each JVM: -Dnewrelic.config.appserver_port=8081 Copy Once you have used appserver_port to name the JVMs and restart them, you should be able to see them individually in the dropdown and in the profiling interface. Important This is only a change for New Relic; it doesn't actually affect the port on which the host communicates in any way. audit_mode Type Boolean Default false Enables plain text logging of all data sent to New Relic to the agent logfile. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. ca_bundle_path Type String Value Format /path/to/ca/cert/bundle.pem Specifies a path to a custom SSL certificate bundle that will be used by the agent to establish a secure connection to New Relic. If your custom SSL certificate bundle doesn't include certificates that are sufficient to connect to New Relic then you'll need to merge the required certs into your custom certificate bundle. use_private_ssl Type Boolean Default false The following SSL certificates are bundled into the agent jar: META-INF/certs/eu-newrelic-com.pem META-INF/certs/eu01-nr-data-net.pem META-INF/certs/newrelic-com.pem Copy By default (use_private_ssl: false) the agent will use the SSL certificates bundled into the JDK to establish a secure connection to New Relic or the custom SSL certificates bundle specified by ca_bundle_path. If you want to use the SSL certificates bundled with the agent, set use_private_ssl: true. Note: use_private_ssl will be ignored if ca_bundle_path is set. enable_auto_app_naming Type Boolean Default false Enables the reporting of data separately for each web app. Set to true to enable support for auto app naming. The name of each web app is detected automatically and the agent reports data separately for each one. This provides a finer-grained performance breakdown for web apps in New Relic. For more information, see Automatic application naming. For more methods of naming your application, see Name your Java application. enable_auto_transaction_naming Type Boolean Default true Enables component-based transaction naming. Set to true to enable component-based transaction naming. Set to false to use the URI of a web request as the name of the transaction. For more information, see Naming web transactions. Caution Unless you implement API calls to name your transactions, disabling auto-transaction naming is very likely to cause Metric grouping issues. enable_custom_tracing Type Boolean Default true Enables all instrumentation using an @Trace annotation. Disabling this causes @Trace annotations to be ignored. extensions.dir Type String Default (none) Defines the location of the optional extensions directory. If this property is not set, the agent will look for a subdirectory named extensions in the same directory as newrelic.jar and newrelic.yml. high_security Type Boolean Default false In order for high security to be enabled, this property must be set to true and the high security property in the New Relic user interface must be enabled. Enabling high security means SSL is turned on, request and message queue parameters are not collected, and queries cannot be sent to New Relic in their raw form. Important As of Java agent 3.48.0, SSL is enabled by default and the config option to disable it has been deprecated. As of Java agent 4.0.0, the ability to disable SSL has been removed. insert_api_key Type String Default (none) A valid Insert API Key for your account. This is only required for Real-time Java profiling using JFR metrics. labels Type String Default \"\" Attach tags to this app. Note that this option now enables tags, which replaced the label feature. You can still query your historical labels. max_stack_trace_lines Type Integer Default 30 Limits the number of lines the agent collects from each stack trace. Increasing this value may impact performance, because it increases the amount of memory the agent uses and the amount of data sent to New Relic. proxy_host Type String Default (none) The proxy host through which to connect to the New Relic collector. If a proxy is used, the host setting is required. Other proxy settings are optional. proxy_password Type String Default (none) The password for proxy authentication. If a proxy is used, the host setting is required. Other proxy settings are optional. The username and password settings will be used to authenticate to Basic Auth challenges from a proxy server. Important The Java agent supports Basic (clear text) authentication. proxy_port Type String Default 8080 The proxy host port number. If a proxy is used, the host setting is required. Other proxy settings are optional. proxy_user Type String Default (none) The username for proxy authentication, such as Basic (clear text) authentication. If a proxy is used, the host setting is required. Other proxy settings are optional. The username and password settings will be used to authenticate to Basic Auth challenges from a proxy server. proxy_scheme Type String Default (none) The proxy scheme used. Setting proxy_scheme: \"https\" will allow the agent to connect through proxies using the HTTPS scheme. reactor-netty.errors.enabled Type Boolean Default true Whether errors are reported for reactor netty. If set to false, errors will be ignored. Important Only available in Java agent 6.3.0 and above. send_data_on_exit Type Boolean Default false Enable delayed JVM shutdown to give the agent a chance to send latest metric data to New Relic before JVM shutdown. send_data_on_exit_threshold Type Integer Default 60 The number of seconds after which the agent will use the send_data_on_exit setting. send_environment_info Type Boolean Default true Enable reporting of JVM settings to New Relic. send_jvm_props Type Boolean Default true When set to true, JVM properties will be sent to New Relic. ssl (DEPRECATED) Type Boolean Default true Requires connections to the New Relic collector to go over SSL. The agent communicates with New Relic via HTTPS by default, and New Relic requires HTTPS for all traffic to APM and the New Relic REST API. This work is done asynchronously to the threads that process your application code, so response times will not be directly affected by this change. Important As of Java agent 3.48.0, SSL is enabled by default and the config option to disable it has been deprecated. As of Java agent 4.0.0, the ability to disable SSL has been removed. sync_startup Type Boolean Default false Enable the agent to connect the New Relic collector immediately upon app startup. scala_futures_as_segments Important This applies to Java agent version 3.44.0 or higher. Type Boolean Default false For more concise transaction trace details, the agent does not report Scala Futures as transaction segments, and those Futures do not contribute to the transaction’s total time. Enabling scala_futures_as_segments increases your overhead. If you want Scala Futures to report as transaction segments so you can view them in a transaction trace, you can enable it: scala_futures_as_segments: enabled: true Copy Logging configuration These are part of the general configuration variables. They are broken out here because they are frequently tweaked for debugging. Some of the logging configuration variables are dynamic and do not need a host restart for them to take effect. For instance, if log files are growing too quickly, log_level can be set to a less verbose setting to reduce the reporting rate. Here is the order of precedence for configuration variables affecting log rotation. If log_daily is true, other log rotation settings are ignored. If log_file_count is 1 or 0, the size limit is ignored. Finally, the agent applies log_limit_in_kbytes. Depending on the growth rate, it is possible for the log file size to exceed the configured value by a small amount. log_daily Type Boolean Default false Set to true to roll the logs daily. Overrides the other configuration variables that affect log rotation. log_file_count Type Integer Default 1 The maximum number of log files to keep when using log rotation. log_file_name Type String Default newrelic_agent.log The unqualified log file name or the string STDOUT which will log to standard out. log_file_path Type String Default logs subdirectory where newrelic.jar is located The log file path. Tip If log_file_path is specified, the directory must already exist. If the default value is used, the agent will attempt to create the directory. log_level Type String Default info The log verbosity level. The agent uses its own log file to keep its logging separate from that of your application. Valid options, in order of verboseness, are: off severe warning info fine finer finest This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. log_limit_in_kbytes Type Integer Default 0 The log file size in kilobytes at which log files are rotated. Set to 0 for no limit. JMX To set these options, use the jmx stanza. To override them, use a newrelic.config.jmx prefixed system property. The Java agent uses JMX to collect JVM data as well as to communicate with the JFR (Java Flight Recorder) daemon for Real-time Java profiling. enabled Type Boolean Default true This setting can be used to turn on or off all JMX functionality. linkingMetadataMBean Type Boolean Default false This setting can be enabled to allow the Java agent to expose linking metadata to the JFR daemon. Doing so allows the JFR daemon to obtain the entity GUID generated by the Java agent and link JFR data with the same APM application that is being monitored by the agent instead of as a separate entity. Important This applies to Java agent version 6.1.0 or higher. Attributes To set these options, use the attributes stanza. To override them, use a newrelic.config.attributes prefixed system property. Attributes are key-value pairs that provide information for transaction traces, traced errors, browser monitoring, and transaction events. There is also an attribute stanza under each destination. For more information, see Java agent attributes, Enabling and disabling attributes and Attribute examples. enabled Type Boolean Default true This setting can be used to turn on or off all attributes. Important For security reasons, capturing custom attributes using the Custom Instrumentation Editor is set to false by default. include Type List of Strings Default (none) If attributes are enabled, attribute keys found in this list will be sent to New Relic. Separate the keys in the list with a comma; for example: key1, key2, key3 Copy Also refer to the agent attribute rules. exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic. Separate the keys in the list with a comma; for example: key1, key2, key3 Copy Also refer to the agent attribute rules. Transaction tracer These options are set in the transaction_tracer stanza and can be overridden by using a newrelic.config.transaction_tracer prefixed system property. Transaction tracing captures deep information about slow transactions and sends this to the New Relic service. The transaction includes the exact call sequence of the transactions, including any query statements issued. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. enabled Type Boolean Default true The transaction tracer is enabled by default. Set this to false to turn it off. explain_enabled Type Boolean Default true Determines whether the agent will capture the EXPLAIN plan for slow queries. Only supported for MySQL and PostgreSQL. explain_threshold Type Float Default 0.5 Threshold in seconds for query execution time below which the slow query and the EXPLAIN plan (if supported) will not be captured. Relevant to slow queries only when record_sql is set to raw or obfuscated. Relevant to EXPLAIN plans only when explain_enabled is set to true. insert_sql_max_length Type Integer Default 2000 The character limit for the SQL query string. If you have many slow SQL queries with large chunks of information, this could negatively affect performance or how quickly you see your data in New Relic. Increase the value gradually until you find the right balance of information and performance. log_sql Type Boolean Default false Set to true to enable logging of queries to the agent log file instead of uploading to New Relic. Queries are logged using the record_sql mode. record_sql Type String Default obfuscated When the transaction tracer is on, query statements can optionally be recorded. The recorder has three modes: off: Send no queries. raw: Send the query statement in its original form. obfuscated: Strips out numeric and string literals. stack_based_naming (Play 2.x+ only) Type Boolean Default False Defaulted to true until Java agent version 3.12.1, when it was changed to false. This option is for Play 2.x+ only. Play/Scala instrumentation can use Thread.getStackTrace() to improve tracer naming, but at the cost of increased overhead. stack_trace_threshold Type Integer Default 0.5 Defines a threshold (in seconds) for collecting stack traces from an SQL call. When SQL statements exceed this threshold, the agent will capture the current stack trace. This is useful for pinpointing where long SQL calls originate from. top_n Type Integer Default 20 Use this setting to control the variety of your transaction traces. top_n is an integer that represents the number of unique, slow transactions that traces will be created for. If you want transaction traces to more accurately reflect the actual slowest transactions in your app, make this value lower. If you want to sample a more diverse array of transactions, make the value higher. A value of 0 would mean that only the slowest transaction is always traced. This is considered not to be optimal, though, because you may have one or two transactions that are always the slowest, and repeatedly seeing those same transaction traces will probably not give you much value. If the same transaction is often the slowest, the top_n setting allows the Java agent (over time) to sample the slowest n transactions. This gives you greater variety and more insight into your application. transaction_threshold Type String (float) Default apdex_f The time threshold used to determine when a transaction is eligible to be traced. When the transaction's response time exceeds this threshold, a transaction trace will be recorded and sent to New Relic. The default is apdex_f (default), which sets the threshold to be the \"Frustrated\" Apdex level (four times the apdex_t value). You can also set a specific time threshold by entering a float value that represents a number of seconds. slow_query_whitelist (DEPRECATED) Type String Default (none) Important This config has been deprecated as of agent version 5.10.0 and will be removed in a future agent version. Instead use collect_slow_queries_from. By default, high security mode does not allow the agent to collect slow queries. Enable this option to collect Cassandra queries from the DataStax driver, even with high security enabled. If you don't use high security, the agent collects slow queries automatically. For DataStax driver 2.1.2, add this rule to your allow list: transaction_tracer: slow_query_whitelist: 'com.newrelic.instrumentation.cassandra-datastax-2.1.2' Copy For DataStax driver 3.0.0, add this rule to your allow list: transaction_tracer: slow_query_whitelist: 'com.newrelic.instrumentation.cassandra-datastax-3.0.0' Copy collect_slow_queries_from Type String Default (none) By default, high security mode does not allow the agent to collect slow queries. Enable this option to collect Cassandra queries from the DataStax driver, even with high security enabled. If you don't use high security, the agent collects slow queries automatically. For DataStax driver 2.1.2, add this rule to your allow list: transaction_tracer: collect_slow_queries_from: 'com.newrelic.instrumentation.cassandra-datastax-2.1.2' Copy For DataStax driver 3.0.0, add this rule to your allow list: transaction_tracer: collect_slow_queries_from: 'com.newrelic.instrumentation.cassandra-datastax-3.0.0' Copy attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for transaction traces. If attributes.enabled at the root level is false, no attributes will be sent to transaction traces regardless on how this property (transaction_tracer.attributes.enabled) is set. attributes.include Type List of strings Default (none) If attributes are enabled for transaction traces, all attribute keys found in this list will be sent to New Relic in transaction traces. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in transaction traces. For more information, see the agent attribute rules. token_limit Type Integer Default 3000 Limits the number of Tokens that can be created per Transaction. Increasing this value may impact performance, because it increases the amount of memory the agent uses and the amount of data sent to New Relic. segment_limit Type Integer Default 3000 Limits the number of segments that can be created per transaction. Increasing this value may impact performance, because it increases the amount of memory the agent uses and the amount of data sent to New Relic. Transaction segments These options are set in the transaction_segments stanza and can be overridden by using a newrelic.config.transaction_segments prefixed system property. Transaction segments represent discrete pieces of work (generally method calls) and are displayed within transaction traces. Important Transaction segment attribute filtering requires Java agent version 4.10.0 or higher. attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for transaction segments. If attributes.enabled at the root level is false, no attributes will be sent to transaction segments regardless on how this property (transaction_segments.attributes.enabled) is set. attributes.include Type List of strings Default (none) If attributes are enabled for transaction segments, all attribute keys found in this list will be sent to New Relic in transaction segments. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in transaction segments. For more information, see the agent attribute rules. Browser monitoring These options are set in the browser_monitoring stanza and can be overridden by using a newrelic.config.browser_monitoring prefixed system property. Browser monitoring gives you insight into the performance real users are experiencing with your website. This is accomplished by measuring the time it takes for your users' browsers to download and render your web pages by injecting a small amount of JavaScript code into the header and footer of each page. auto_instrument Type Boolean Default true By default the agent automatically inserts API calls in compiled JSPs to inject the monitoring JavaScript into web pages. Set this attribute to false to turn off this behavior. disabled_auto_pages Type Comma-separated list of strings Default (none) When auto_instrument is true, by default all pages are instrumented. List all pages that you want the auto instrumentation to skip here. You can still use manual instrumentation on these pages. For example: browser_monitoring: disabled_auto_pages: /WEB-INF/jsp/testpage_1.jsp, /WEB-INF/jsp/testpage_2.jsp Copy attributes.enabled Type Boolean Default false This setting can be used to turn on or off all attributes for browser monitoring. This is the data you can query. If attributes.enabled is false at the root level, no attributes will be sent up in browser monitoring regardless on how this property under browser_monitoring is set. attributes.include Type List of Strings Default (none) If attributes are enabled for browser_monitoring, all attribute keys found in this list will be sent to New Relic in page views. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in page views. For more information, see the agent attribute rules. External tracer The external tracing options are set in the external_tracer stanza and can be overridden by using a newrelic.config.external_tracer prefixed system property. exclude_request_uri Type Boolean Default false This setting can be used to control the collection of outgoing request URIs for errors and transaction traces. Set this to true to disable collecting this information. Cross application tracer The cross application tracing options are set in the cross_application_tracer stanza and can be overridden by using a newrelic.config.cross_application_tracer prefixed system property. Cross application tracing adds request and response headers to external calls using the Apache HttpClient libraries. This provides better performance data when calling applications monitored by other New Relic Agents. enabled Type Boolean Default true Cross application tracing is enabled by default. Set this to false to turn it off. Error collector These options are set in the error_collector stanza and unless noted otherwise can be overridden by using a newrelic.config.error_collector prefixed system property. The error collector captures information about uncaught exceptions and sends them to New Relic for viewing. Tip For how to configure errors for the Java agent, including how to configure errors via the UI, see Java agent error configuration. enabled Type Boolean Default true Enable error collection. ignore_classes Type Stanza containing a list of fully qualified class_name strings Default (none) Specified exception class names will be ignored and will not affect error rate or Apdex score, or be reported to APM. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: ignore_classes: - \"com.example.MyException\" - \"com.example.DifferentException\" Copy ignore_messages Type Stanza containing a fully qualified class_name and a list of messages per error class Default (none) Specify exception class names the agent should ignore. Ignored messages will not affect error rate or Apdex score, or be reported to APM. Contains yaml pairs consisting of: A fully qualified exception class name that should not be reported to APM AND A list of exception messages to match against (at least one is required) If the exception class name matches an error but the message does not, then that error will not be ignored. Message strings use contains for matching. A message cannot be provided on its own and must always be paired with a fully qualified class name. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: ignore_messages: com.example.MyException: - \"Some error message to ignore\" - \"Some other error message to ignore\" com.example.DifferentException: - \"Some different error message to ignore\" Copy ignore_status_codes Type Comma-separated list of strings and ranges Default 404 A comma-separated list comprised of individual and dashed ranges of HTTP status codes that should not be treated as errors. If this property is commented out in the newrelic.yml configuration file, then the 404 status code will automatically be ignored. When using server-side configuration, the status code 404 must be specified in order for it to be ignored. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: ignore_status_codes: 404,507-511 Copy expected_classes Type Stanza containing a List of fully qualified class_name strings Default (none) Prevents specified exception classes from affecting error rate or Apdex score while still reporting the errors to APM. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: expected_classes: - \"com.example.MyException\" - \"com.example.DifferentException\" Copy expected_messages Type Stanza containing a fully qualified class_name and a List of messages per error class Default (none) Contains yaml pairs consisting of a fully qualified exception class name that should be marked as expected and thus prevented from affecting error rate or Apdex score and a List of exception messages to match against, the latter of which at least one is required. If the exception class name matches an error but the message does not, then that error will not be marked as expected and therefore will affect error rate and Apdex score. Message strings use contains for matching. A message cannot be provided on its own and must always be paired with a fully qualified class name. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: expected_messages: com.example.MyException: - \"Some expected error message\" - \"Some other expected error message\" com.example.DifferentException: - \"Some different expected error message\"​ Copy expected_status_codes Type Comma-separated list of strings and ranges Default (none) A comma-separated list comprised of individual and dashed ranges of HTTP status codes to be marked as expected and thus prevented from affecting error rate or Apdex score. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: expected_status_codes: 415,500-506 Copy attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for traced errors. If attributes.enabled is false at the root level, then no attributes will be sent to traced errors regardless of how this property is set under error_collector. attributes.include Type List of strings Default (none) If attributes are enabled for traced errors, all attribute keys found in this list will be sent to New Relic in traced errors. For more information, see the agent attribute rules. attributes.exclude Type List of strings Default (none) Attribute keys found in this list will not be sent to New Relic in traced errors. For more information, see the agent attribute rules. ignore_errors (DEPRECATED) Type Comma-separated list of Strings Default (none) All specified exception class names specified will not be treated as errors. Deprecated as of Java agent 3.40.0 and replaced by ignore_classes. For example: error_collector: ignore_errors: some.other.MyException Copy Strip exceptions These options are set in the strip_exception_messages stanza and unless noted otherwise can be overridden by using a newrelic.config.strip_exception_messages​prefixed system property. This configuration can be enabled to control whether Java exception messages are reported to New Relic. enabled Type Boolean Default false By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you set this to true, the agent strips the messages from exceptions in order to prevent it from inadvertently capturing sensitive information. If you enable high security mode, this is automatically set to true. If you set enabled to true but you want the agent to capture messages from specific exceptions, add the exceptions to your allow list. whitelist (DEPRECATED) Type String Default (none) Important This config has been deprecated as of agent version 5.10.0 and will be removed in a future agent version. Instead use allowed_classes. If you set enabled to true but you want the agent to capture messages for specific exceptions, add each exception to the whitelist, separated by a comma. allowed_classes Type String Default (none) If you set enabled to true but you want the agent to capture messages for specific exceptions, add each exception to allowed_classes, separated by a comma. Thread profiler These options are set in the thread_profiler stanza and can be overridden by using a newrelic.config.thread_profiler prefixed system property. Thread profiler measures wall clock time, CPU time, and method call counts in your application's threads as they run. enabled Type Boolean Default true Enable the thread profiler. Transaction events These options are set in the transaction_events stanza and can be overridden by using a newrelic.config.transaction_events prefixed system property. Transaction events provide the data for displaying histograms and percentiles in the UI. Important Previously this stanza was called analytics_events. If your configuration file still uses analytics_events, update your agent to use transaction_events. enabled Type Boolean Default true Enable the transaction events service. max_samples_stored Type Integer Default 2000 Max 10000 The maximum number of sampled transaction events reported every 60 seconds. custom_request_headers Type List of maps Default None Important Unlike other settings, custom_request_headers have to be paired together and must be set in the newrelic.yml file. They can't be overwritten by Java virtual machine arguments (system property) or environment variables. A list of maps with the paired keys header_name and the optional header_alias. Choose one or more custom HTTP request headers to add as transaction attributes. You can list multiple header configurations: transaction_events: custom_request_headers: - header_name: \"X-Custom-Header-1\" - header_name: \"X-Custom-Header-2\" header_alias: \"CustomHeader2alias\" Copy In the first map set, X-Custom-Header-1 is captured and reported by the agent as the header name for a corresponding value from the request object. The header_name will also be the name of the attribute sent to New Relic. In the second map set, the request header is X-Custom-Header-2, but the CustomHeader2alias is the name sent to New Relic. attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for transaction events. If attributes.enabled is false at the root level, then no attributes will be sent to transaction events regardless of how this property is set under transaction_events. attributes.include Type List of Strings Default (none) If attributes are enabled for transaction events, all attribute keys found in this list will be sent to New Relic in transaction events. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in transaction events. For more information, see the agent attribute rules. Custom events Custom events are set in the custom_insights_events stanza and can be overridden by using a newrelic.config.custom_insights_events prefixed system property. APM lets you record custom event data via the New Relic language agent APIs, which you can then query. Important For Java agent versions prior to 4.1.0, the following YAML configuration is recognized: custom_insights_events.enabled: true custom_insights_events.max_samples_stored: 5000 Copy For agent versions 4.1.0 and above, the YAML configuration uses the nested stanza formatting: custom_insights_events: enabled: false max_samples_stored: 5000 Copy enabled Type Boolean Default true This enables the custom event service. max_samples_stored Type Integer Default/Max 10000 The maximum number of sampled custom events reported every 60 seconds. Hostname configuration These options are set in the process_host stanza and can be overridden by using a newrelic.config.process_host prefixed system property. These properties are used for configuring the hostname displayed in the UI: display_name Type String Default (none) Set a display name to decorate the \"host:port\" label in the New Relic UI. ipv_preference Type String Default 4 If the hostname cannot be determined, then the IP address of the host will be used. This property determines whether the IPv4 or IPv6 address should be used. The default is IPv4. Custom instrumentation These options set in the class_transformer stanza and can be overridden by using a newrelic.config.class_transformer prefixed system property. trace_annotation_class_name Type String Default (none) String containing the full class name of the annotation class the agent uses to determine which user-specified methods to instrument. For more information about custom annotations, see Java custom metric collection. com.newrelic.instrumentation.servlet-user Type Boolean Default false Enable this option to capture the userPrincipal name. This name is included as a transaction trace attribute, and can be queried. System properties You can override any setting in the newrelic.yml file by setting a system property. The system property corresponding to a given setting in the config file is the setting name prefixed by newrelic.config. For example, the system property for the log_level setting is newrelic.config.log_level. For settings nested in stanzas, prepend the stanza name to the setting name. For example, the system property for the enabled setting in the transaction_tracer stanza is newrelic.config.transaction_tracer.enabled. In addition to overriding configuration settings, the following system properties are recognized by the agent: newrelic.config.process_host.display_name Type String Default (none) Set a display name to decorate the \"host:port\" label in the New Relic UI. Requires Java agent 3.17 or higher. newrelic.config.file Type String Default (none) String containing a fully qualified path to the newrelic configuration file. If empty, the agent assumes newrelic.yml is in the same directory as newrelic.jar. newrelic.debug Type Boolean Default (none) Enable debug logging. newrelic.environment Type String Default (none) String containing the environment configuration for the agent to use. newrelic.home Type String Default (none) String containing the home directory of agent. This defaults to the same directory as the agent jarfile. newrelic.logfile Type String Default newrelic_agent.log String containing the name of the agent log file. Environment variables Environment variables take the highest precedence and override the system properties and yml config settings. To set environment variables, use the export VARNAME=value command. To permanently set environment variables, add the export line to a file such as ~/.bashrc or ~/.bash_profile. You can override any setting from a system property or in the newrelic.yml by setting an environment variable. The environment variable corresponding to a given setting in the config file is the setting name prefixed by NEW_RELIC with all dots (.) and dashes (-) replaced by underscores (_). For example, the environment variable for the log_level setting is NEW_RELIC_LOG_LEVEL. For settings nested in stanzas, prepend the stanza name to the setting name. For example, the environment variable for the enabled setting in the transaction_tracer stanza is NEW_RELIC_TRANSACTION_TRACER_ENABLED. Important Agent configuration via environment variables requires Java agent version 4.10.0 or higher. For agent versions older than 4.10.0 the following environment variables are available: NEW_RELIC_APP_NAME (REQUIRED) Type String Default (none) This setting is required. Contains the application name under which to report data to New Relic. Set the name of your application as you want it to appear in New Relic. If enable_auto_app_naming is false, the agent reports all data to this application. Otherwise, the agent reports only background tasks (transactions for non-web applications) to this application. To report data to more than one application, separate the application names with a semicolon ;. For example, to report data to My Application and My Application 2: app_name: My Application;My Application 2 Copy For more methods of naming your application, see Name your Java application. NEW_RELIC_DISTRIBUTED_TRACING_ENABLED Type String Default false Enables distributed tracing. Case sensitive: use true or false. For more information, see the distributed tracing section. NEW_RELIC_PROCESS_HOST_DISPLAY_NAME Type String Default (none) Set a display name to decorate the \"host:port\" label in the New Relic UI. NEW_RELIC_LICENSE_KEY (REQUIRED) Type String Default (none) This setting is required. Contains your New Relic account license. You must specify the license key associated with your New Relic account. This key binds your agent's data to your account in the New Relic service. NEW_RELIC_LOG Type String Default newrelic_agent.log The unqualified log file name or the string STDOUT which will log to standard out. Cloud platform utilization These options are set in the utilization stanza and can be overridden by using a newrelic.config.utilization prefixed system property. The agent collects utilization information and sends it to the New Relic service. The agent can collect information from Amazon Web Services (AWS) EC2 instances and Docker containers. detect_aws Type Boolean Default true Determines whether the agent polls AWS metadata API. detect_docker Type Boolean Default true Determines whether the agent reads Docker information from the file system. Async instrumentation These options are set directly in the common stanza and can be overridden by using a prefixed system property. token_timeout Type Integer Default (seconds) 180 The number of seconds after which the agent will automatically expire an async token that has not been explicitly expired with token.expire(). For usage instructions, see Tokens: Connect async threads. Important Increasing this value may impact performance, because it increases the amount of memory the agent uses and prevents transactions from being reported due to unexpired tokens. segment_timeout Type Integer Default (seconds) 600 The number of seconds after which the agent will automatically end a segment that has not been explicitly ended with segment.end() or segment.ignore(). For usage instructions, see Segments: Time arbitrary async activity. Important Increasing this value may impact performance, because it increases the amount of memory the agent uses and prevents transactions from being reported due to un-ended segments. Circuit breaker These settings customize the behavior of the Java circuit breaker. These settings are not included in newrelic.yml by default. You do not need to restart your JVM after changing them. If you want to customize the circuit breaker, add the stanza under the common stanza: common: &default_settings​ ​ OTHER_CONFIG_SETTINGS circuitbreaker: enabled: true memory_threshold: 20 gc_cpu_threshold: 10 Copy enabled Type Boolean Default true If your application is behaving as expected, you may want to disable the circuit breaker. memory_threshold Type Integer (0 to 100) Default 20 Customize the precentage of free heap memory below which the circuit breaker should trip. When the percentage of free heap memory is less than memory_threshold, and the CPU time spent doing garbage collection is greater than gc_cpu_threshold, the circuit breaker trips. In order to make the circuit breaker less likely to trip, decrease memory_threshold and/or increase gc_cpu_threshold. Adjust these values as needed, based on your application's operating performance and behavior. gc_cpu_threshold Type Integer (0 to 100) Default 10 Customize the precentage of garbage collection CPU time above which the circuit breaker should trip. When the percentage of free heap memory is less than memory_threshold, and the CPU time spent doing garbage collection is greater than gc_cpu_threshold, the circuit breaker trips. In order to make the circuit breaker less likely to trip, decrease memory_threshold and/or increase gc_cpu_threshold. Adjust these values as needed, based on your application's operating performance and behavior. Message tracer These options are set in the message_tracer stanza and can be overridden by using a newrelic.config.message_tracer prefixed system property. segment_parameters.enabled Type Boolean Default true Adds message properties to tracer attributes. Set this to false to turn it off. Distributed tracing Important Enabling distributed tracing disables cross application tracing, and has other effects on APM features. Before enabling, read the transition guide. Requires Java agent version 4.3.0 or higher. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. In the config file, it can be set in the distributed_tracing stanza. It can be overridden using a newrelic.config.distributed_tracing prefixed system property. enabled Type Boolean Default false Set this to true to enable distributed tracing. For example, to enable this in the config file, you would use: distributed_tracing: enabled: true Copy To enable this using a system property, you would use: -Dnewrelic.config.distributed_tracing.enabled=true Copy exclude_newrelic_header Type Boolean Default false By default, supported versions of the agent utilize both the newrelic header and W3C Trace Context headers for distributed tracing. The newrelic distributed tracing header allows interoperability with older agents that don't support W3C Trace Context headers. Agent versions that support W3C Trace Context headers will prioritize them over newrelic headers for distributed tracing. If you do not want to utilize the newrelic header, setting this to true will result in the agent excluding the newrelic header and only using W3C Trace Context headers for distributed tracing. For example, to exclude newrelic headers in the config file, you would use: distributed_tracing: exclude_newrelic_header: true Copy To exclude newrelic headers using a system property, you would use: -Dnewrelic.config.distributed_tracing.exclude_newrelic_header=true Copy Infinite Tracing Important Requirements: Java Agent 5.12.1 or higher. Infinite Tracing does not work if enable_auto_app_naming is enabled. To turn on Infinite Tracing, enable distributed tracing and add the additional setting below. For an example, see Language Agents: Configure Distributed Tracing. trace_observer.host Type String Default None For help getting a valid Infinite Tracing trace observer host entry, see find or create a Trace Observer. You can configure this via YAML: infinite_tracing: trace_observer: host: YOUR_TRACE_OBSERVER_HOST Copy You can also use the system property newrelic.config.infinite_tracing.trace_observer.host or the environment variable NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_HOST. Span events Span events are reported for distributed tracing. Distributed tracing must be enabled to report span events. Span configuration is set in the span_events stanza and can be overridden by using a newrelic.config.span_events prefixed system property. Options include: enabled Type Boolean Default true Used to enable/disable span event reporting. attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for span events. If attributes.enabled at the root level is false, no attributes will be sent to span events regardless on how this property (span_events.attributes.enabled) is set. attributes.include Type List of strings Default (none) If attributes are enabled for span events, all attribute keys found in this list will be sent to New Relic in span_events. For more information, see the agent attribute rules. attributes.exclude Type List of strings Default (none) All attribute keys found in this list will not be sent to New Relic in span events. For more information, see the agent attribute rules. Important Span event attribute filtering requires Java agent version 4.10.0 or higher. Jar collector The Java agent collects and information about jars and their versions on the application classpath. Jar collection configuration is set in the jar_collector stanza and can be overridden by using a newrelic.config.jar_collector prefixed system property. Options include: enabled Type Boolean Default true Used to enable/disable jar collection and reporting. skip_temp_jars Type Boolean Default true Used to enable/disable collection of temporary jars. Temporary jars are those residing in the directory specified by the system property java.io.tmpdir. jars_per_second Type Integer Default 10 The maximum number of jars to process per second. Must be positive.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 94.537,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> <em>configuration</em>: Config file",
        "sections": "<em>Java</em> <em>agent</em> <em>configuration</em>: Config file",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> reads its <em>configuration</em> from the newrelic.yml file. By default the <em>agent</em> looks for this file in the directory that contains newrelic.jar. You can override the config file&#x27;s location by setting the newrelic.config.file system property to a fully qualified file name"
      },
      "id": "603eb739e7b9d2a2432a07e0"
    },
    {
      "sections": [
        "Java agent config file template"
      ],
      "title": "Java agent config file template",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "cab129eda0df59e172b299574d8e44fbb3c04617",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-config-file-template/",
      "published_at": "2021-05-05T06:49:05Z",
      "updated_at": "2021-03-16T13:47:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains a templated version of the newrelic.yml file that the Java agent reads for configuration. The config file format is YAML. While no knowledge of YAML is necessary to edit the file, be careful to maintain the proper indentation. Learn more about YAML on Wikipedia. When making changes to the newrelic.yml file, use a YAML validator to ensure the syntax is accurate and follow these rules: YML files are case sensitive. All indentations are in increments of two characters. Data in the same stanza of the file must use the same level of indentation, and sub-stanzas should be indented by an additional two spaces. For more information about structure, directories, and settings, see Java agent configuration. # This file configures the New Relic Agent. New Relic monitors # Java applications with deep visibility and low overhead. For more details and additional # configuration options visit https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-configuration-config-file. # # <%= generated_for_user %> # # This section is for settings common to all environments. # Do not add anything above this next line. common: &default_settings # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic # account. For example, if your license key is 12345 use this: # license_key: '12345' # The key binds your Agent's data to your account in the New Relic service. license_key: '<%= license_key %>' # Agent Enabled # Use this setting to disable the agent instead of removing it from the startup command. # Default is true. agent_enabled: true # Set the name of your application as you'd like it show up in New Relic. # If enable_auto_app_naming is false, the agent reports all data to this application. # Otherwise, the agent reports only background tasks (transactions for non-web applications) # to this application. To report data to more than one application # (useful for rollup reporting), separate the application names with \";\". # For example, to report data to \"My Application\" and \"My Application 2\" use this: # app_name: My Application;My Application 2 # This setting is required. Up to 3 different application names can be specified. # The first application name must be unique. app_name: My Application # To enable high security, set this property to true. When in high # security mode, the agent will use SSL and obfuscated SQL. Additionally, # request parameters and message parameters will not be sent to New Relic. high_security: false # Set to true to enable support for auto app naming. # The name of each web app is detected automatically # and the agent reports data separately for each one. # This provides a finer-grained performance breakdown for # web apps in New Relic. # Default is false. enable_auto_app_naming: false # Set to true to enable component-based transaction naming. # Set to false to use the URI of a web request as the name of the transaction. # Default is true. enable_auto_transaction_naming: true # The agent uses its own log file to keep its logging # separate from that of your application. Specify the log level here. # This setting is dynamic, so changes do not require restarting your application. # The levels in increasing order of verboseness are: # off, severe, warning, info, fine, finer, finest # Default is info. log_level: info # Log all data sent to and from New Relic in plain text. # This setting is dynamic, so changes do not require restarting your application. # Default is false. audit_mode: false # The number of backup log files to save. # Default is 1. log_file_count: 1 # The maximum number of kbytes to write to any one log file. # The log_file_count must be set greater than 1. # Default is 0 (no limit). log_limit_in_kbytes: 0 # Override other log rolling configuration and roll the logs daily. # Default is false. log_daily: false # The name of the log file. # Default is newrelic_agent.log. log_file_name: newrelic_agent.log # The log file directory. # Default is the logs directory in the newrelic.jar parent directory. #log_file_path: # Proxy settings for connecting to the New Relic server: # If a proxy is used, the host setting is required. Other settings # are optional. Default port is 8080. The username and password # settings will be used to authenticate to Basic Auth challenges # from a proxy server. Proxy scheme will allow the agent to # connect through proxies using the HTTPS scheme. #proxy_host: hostname #proxy_port: 8080 #proxy_user: username #proxy_password: password #proxy_scheme: https # Limits the number of lines to capture for each stack trace. # Default is 30 max_stack_trace_lines: 30 # Provides the ability to configure the attributes sent to New Relic. These # attributes can be found in transaction traces, traced errors, Insight's # transaction events, and Insight's page views. attributes: # When true, attributes will be sent to New Relic. The default is true. enabled: true #A comma separated list of attribute keys whose values should # be sent to New Relic. #include: # A comma separated list of attribute keys whose values should # not be sent to New Relic. #exclude: # Transaction tracer captures deep information about slow # transactions and sends this to the New Relic service once a # minute. Included in the transaction is the exact call sequence of # the transactions including any SQL statements issued. transaction_tracer: # Transaction tracer is enabled by default. Set this to false to turn it off. # This feature is not available to Lite accounts and is automatically disabled. # Default is true. enabled: true # Threshold in seconds for when to collect a transaction # trace. When the response time of a controller action exceeds # this threshold, a transaction trace will be recorded and sent to # New Relic. Valid values are any float value, or (default) \"apdex_f\", # which will use the threshold for the \"Frustrated\" Apdex level # (greater than four times the apdex_t value). # Default is apdex_f. transaction_threshold: apdex_f # When transaction tracer is on, SQL statements can optionally be # recorded. The recorder has three modes, \"off\" which sends no # SQL, \"raw\" which sends the SQL statement in its original form, # and \"obfuscated\", which strips out numeric and string literals. # Default is obfuscated. record_sql: obfuscated # Set this to true to log SQL statements instead of recording them. # SQL is logged using the record_sql mode. # Default is false. log_sql: false # Threshold in seconds for when to collect stack trace for a SQL # call. In other words, when SQL statements exceed this threshold, # then capture and send to New Relic the current stack trace. This is # helpful for pinpointing where long SQL calls originate from. # Default is 0.5 seconds. stack_trace_threshold: 0.5 # Determines whether the agent will capture query plans for slow # SQL queries. Only supported for MySQL and PostgreSQL. # Default is true. explain_enabled: true # Threshold for query execution time below which query plans will not # not be captured. Relevant only when `explain_enabled` is true. # Default is 0.5 seconds. explain_threshold: 0.5 # Use this setting to control the variety of transaction traces. # The higher the setting, the greater the variety. # Set this to 0 to always report the slowest transaction trace. # Default is 20. top_n: 20 # Error collector captures information about uncaught exceptions and # sends them to New Relic for viewing. error_collector: # This property enables the collection of errors. If the property is not # set or the property is set to false, then errors will not be collected. # Default is true. enabled: true # Use this property to exclude specific exceptions from being reported as errors # by providing a comma separated list of full class names. # The default is to exclude akka.actor.ActorKilledException. If you want to override # this, you must provide any new value as an empty list is ignored. ignore_errors: akka.actor.ActorKilledException # Use this property to exclude specific http status codes from being reported as errors # by providing a comma separated list of status codes. # The default is to exclude 404s. If you want to override # this, you must provide any new value as an empty list is ignored. ignore_status_codes: 404 # Transaction Events are used for Histograms and Percentiles. Unaggregated data is collected # for each web transaction and sent to the server on harvest. transaction_events: # Set to false to disable transaction events. # Default is true. enabled: true # Events are collected up to the configured amount. Afterwards, events are sampled to # maintain an even distribution across the harvest cycle. # Default is 2000. Setting to 0 will disable. max_samples_stored: 2000 # Distributed tracing lets you see the path that a request takes through your distributed system. # Enabling distributed tracing changes the behavior of some New Relic features, so carefully consult the transition # guide before you enable this feature: https://docs.newrelic.com/docs/apm/distributed-tracing/getting-started/transition-guide-distributed-tracing # Default is false. distributed_tracing: enabled: false # Cross Application Tracing adds request and response headers to # external calls using supported HTTP libraries to provide better # performance data when calling applications monitored by other New Relic Agents. cross_application_tracer: # Set to false to disable cross application tracing. # Default is true. enabled: true # Thread profiler measures wall clock time, CPU time, and method call counts # in your application's threads as they run. # This feature is not available to Lite accounts and is automatically disabled. thread_profiler: # Set to false to disable the thread profiler. # Default is true. enabled: true # New Relic Real User Monitoring gives you insight into the performance real users are # experiencing with your website. This is accomplished by measuring the time it takes for # your users' browsers to download and render your web pages by injecting a small amount # of JavaScript code into the header and footer of each page. browser_monitoring: # By default the agent automatically inserts API calls in compiled JSPs to # inject the monitoring JavaScript into web pages. Not all rendering engines are supported. # See https://docs.newrelic.com/docs/agents/java-agent/instrumentation/new-relic-browser-java-agent#manual_instrumentation # for instructions to add these manually to your pages. # Set this attribute to false to turn off this behavior. auto_instrument: true class_transformer: # This instrumentation reports the name of the user principal returned from # HttpServletRequest.getUserPrincipal() when servlets and filters are invoked. com.newrelic.instrumentation.servlet-user: enabled: false com.newrelic.instrumentation.spring-aop-2: enabled: false # This instrumentation reports metrics for resultset operations. com.newrelic.instrumentation.jdbc-resultset: enabled: false # Classes loaded by classloaders in this list will not be instrumented. # This is a useful optimization for runtimes which use classloaders to # load dynamic classes which the agent would not instrument. classloader_excludes: groovy.lang.GroovyClassLoader$InnerLoader, org.codehaus.groovy.runtime.callsite.CallSiteClassLoader, com.collaxa.cube.engine.deployment.BPELClassLoader, org.springframework.data.convert.ClassGeneratingEntityInstantiator$ObjectInstantiatorClassGenerator, org.mvel2.optimizers.impl.asm.ASMAccessorOptimizer$ContextClassLoader, gw.internal.gosu.compiler.SingleServingGosuClassLoader, # User-configurable custom labels for this agent. Labels are name-value pairs. # There is a maximum of 64 labels per agent. Names and values are limited to 255 characters. # Names and values may not contain colons (:) or semicolons (;). labels: # An example label #label_name: label_value # Application Environments # ------------------------------------------ # Environment specific settings are in this section. # You can use the environment to override the default settings. # For example, to change the app_name setting. # Use -Dnewrelic.environment=<environment> on the Java startup command line # to set the environment. # The default environment is production. # NOTE if your application has other named environments, you should # provide configuration settings for these environments here. development: <<: *default_settings app_name: My Application (Development) test: <<: *default_settings app_name: My Application (Test) production: <<: *default_settings staging: <<: *default_settings app_name: My Application (Staging) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 94.51564,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> config file template",
        "sections": "<em>Java</em> <em>agent</em> config file template",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " options visit https:&#x2F;&#x2F;docs.newrelic.com&#x2F;docs&#x2F;<em>agents</em>&#x2F;<em>java</em>-<em>agent</em>&#x2F;<em>configuration</em>&#x2F;<em>java</em>-<em>agent</em>-<em>configuration</em>-config-file. # # &lt;%= generated_for_user %&gt; # # This section is for settings common to all environments. # Do not add anything above this next line. common: &amp;default_settings"
      },
      "id": "603eb738e7b9d242542a0815"
    }
  ],
  "/docs/agents/java-agent/configuration/configuring-your-ssl-certificates": [
    {
      "sections": [
        "Java agent configuration: Config file",
        "Configuration file structure",
        "Tip",
        "Configuration settings precedence",
        "Configuring the Java extensions directory",
        "Create an extensions directory",
        "Specify an existing extensions directory",
        "General configuration settings",
        "license_key (REQUIRED)",
        "app_name (REQUIRED)",
        "agent_enabled",
        "apdex_t (DEPRECATED)",
        "appserver_port",
        "Important",
        "audit_mode",
        "ca_bundle_path",
        "use_private_ssl",
        "enable_auto_app_naming",
        "enable_auto_transaction_naming",
        "Caution",
        "enable_custom_tracing",
        "extensions.dir",
        "high_security",
        "insert_api_key",
        "labels",
        "max_stack_trace_lines",
        "proxy_host",
        "proxy_password",
        "proxy_port",
        "proxy_user",
        "proxy_scheme",
        "reactor-netty.errors.enabled",
        "send_data_on_exit",
        "send_data_on_exit_threshold",
        "send_environment_info",
        "send_jvm_props",
        "ssl (DEPRECATED)",
        "sync_startup",
        "scala_futures_as_segments",
        "Logging configuration",
        "log_daily",
        "log_file_count",
        "log_file_name",
        "log_file_path",
        "log_level",
        "log_limit_in_kbytes",
        "JMX",
        "enabled",
        "linkingMetadataMBean",
        "Attributes",
        "include",
        "exclude",
        "Transaction tracer",
        "explain_enabled",
        "explain_threshold",
        "insert_sql_max_length",
        "log_sql",
        "record_sql",
        "stack_based_naming (Play 2.x+ only)",
        "stack_trace_threshold",
        "top_n",
        "transaction_threshold",
        "slow_query_whitelist (DEPRECATED)",
        "collect_slow_queries_from",
        "attributes.enabled",
        "attributes.include",
        "attributes.exclude",
        "token_limit",
        "segment_limit",
        "Transaction segments",
        "Browser monitoring",
        "auto_instrument",
        "disabled_auto_pages",
        "External tracer",
        "exclude_request_uri",
        "Cross application tracer",
        "Error collector",
        "ignore_classes",
        "ignore_messages",
        "ignore_status_codes",
        "expected_classes",
        "expected_messages",
        "expected_status_codes",
        "ignore_errors (DEPRECATED)",
        "Strip exceptions",
        "whitelist (DEPRECATED)",
        "allowed_classes",
        "Thread profiler",
        "Transaction events",
        "max_samples_stored",
        "custom_request_headers",
        "Custom events",
        "Hostname configuration",
        "display_name",
        "ipv_preference",
        "Custom instrumentation",
        "trace_annotation_class_name",
        "com.newrelic.instrumentation.servlet-user",
        "System properties",
        "newrelic.config.process_host.display_name",
        "newrelic.config.file",
        "newrelic.debug",
        "newrelic.environment",
        "newrelic.home",
        "newrelic.logfile",
        "Environment variables",
        "NEW_RELIC_APP_NAME (REQUIRED)",
        "NEW_RELIC_DISTRIBUTED_TRACING_ENABLED",
        "NEW_RELIC_PROCESS_HOST_DISPLAY_NAME",
        "NEW_RELIC_LICENSE_KEY (REQUIRED)",
        "NEW_RELIC_LOG",
        "Cloud platform utilization",
        "detect_aws",
        "detect_docker",
        "Async instrumentation",
        "token_timeout",
        "segment_timeout",
        "Circuit breaker",
        "memory_threshold",
        "gc_cpu_threshold",
        "Message tracer",
        "segment_parameters.enabled",
        "Distributed tracing",
        "exclude_newrelic_header",
        "Infinite Tracing",
        "trace_observer.host",
        "Span events",
        "Jar collector",
        "skip_temp_jars",
        "jars_per_second"
      ],
      "title": "Java agent configuration: Config file",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "1d61f848fa192438225eae269421b8d384915c8b",
      "image": "https://docs.newrelic.com/static/60ca967eab99ca225186310913ae2de6/8c557/java-config-cascade.png",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-configuration-config-file/",
      "published_at": "2021-05-04T17:01:42Z",
      "updated_at": "2021-03-16T15:52:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent reads its configuration from the newrelic.yml file. By default the agent looks for this file in the directory that contains newrelic.jar. You can override the config file's location by setting the newrelic.config.file system property to a fully qualified file name. Configuration file structure The newrelic.yml file is split into stanzas corresponding to different environments: Test Development Staging Production (default) New Relic applies settings in the common stanza to each of these environments. You can select other environments as the default by setting the newrelic.environment system property to the environment name. Tip A newrelic.yml template is available. If you edit newrelic.yml, be careful to conform to the YAML format. Use a YAML validator to ensure the syntax is accurate before using the file with New Relic's Java agent, and follow these rules: Java agent newrelic.yml Requirements Format YML files are case sensitive. Indentations All indentations must be in increments of two characters. Other indentations will result in an Unable to parse configuration file error upon agent startup. Use the same level of indentation for data in the same stanza of the file. Indent any sub-stanzas by an additional two spaces. Changes to file You must restart your JVM host process for changes to take effect. Exception: Property changes to log_level and audit_mode do not require a restart. Property changes under circuit breaker don't require a restart. Configuration settings precedence To override any setting in the config file, use a system property override. In certain environments, environment variables can also be used to override both the config file and the system properties. The environment variables primarily exist to support Heroku. When used, server-side configuration overrides all other configuration settings. With the Java agent, server-side configuration overrides all other settings. Environment variables override Java system properties. Java properties override user configuration settings in your newrelic.yml file. User settings override the newrelic.yml default settings. Configuring the Java extensions directory The Java agent reads the configuration files on process startup. To identify the directory where the files are located, either create a new or specify an existing extensions directory: Create an extensions directory To create the extensions directory: Navigate to the directory where newrelic.jar and newrelic.yml are located. Create a directory named extensions. In newrelic.yml, check that the property extensions.dir is not set. Specify an existing extensions directory To use an existing Java extensions directory: In your newrelic.yml file, locate the common section. Use the property extensions.dir to specify the location of the file. General configuration settings Set these options in the common stanza. To override any of these options, use a newrelic.config prefixed system property. license_key (REQUIRED) Type String Default (none) This setting is required. You must specify the license key associated with your New Relic account. This key binds your agent's data to your account in the New Relic service. app_name (REQUIRED) Type String Default (none) This setting is required. Defines the application name used to report data to New Relic. If enable_auto_app_naming is false, the agent reports all data to this application. Otherwise, the agent reports only background tasks (transactions for non-web applications) to this application. To report data to more than one application, separate the application names with a semicolon. For example, to report data to My Application and My Application 2 use this: app_name: My Application;My Application 2 Copy For more methods of naming your application, see Name your Java application. agent_enabled Type Boolean Default true Flag to enable the agent. Use this setting to force the agent to run or not run. apdex_t (DEPRECATED) Type Float Default 1.0 The apdex_t threshold in seconds for the application's Apdex score. For Java agent versions 1.2.008 or higher, the apdex_t value is set in the UI and the value in newrelic.yml is ignored. appserver_port Type Integer Default (none) Number to differentiate JVMs for the same app on the same machine. New Relic uses host/port for uniqueness, so you can distinguish the JVMs by putting a switch like this into the startup arguments for each JVM: -Dnewrelic.config.appserver_port=8081 Copy Once you have used appserver_port to name the JVMs and restart them, you should be able to see them individually in the dropdown and in the profiling interface. Important This is only a change for New Relic; it doesn't actually affect the port on which the host communicates in any way. audit_mode Type Boolean Default false Enables plain text logging of all data sent to New Relic to the agent logfile. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. ca_bundle_path Type String Value Format /path/to/ca/cert/bundle.pem Specifies a path to a custom SSL certificate bundle that will be used by the agent to establish a secure connection to New Relic. If your custom SSL certificate bundle doesn't include certificates that are sufficient to connect to New Relic then you'll need to merge the required certs into your custom certificate bundle. use_private_ssl Type Boolean Default false The following SSL certificates are bundled into the agent jar: META-INF/certs/eu-newrelic-com.pem META-INF/certs/eu01-nr-data-net.pem META-INF/certs/newrelic-com.pem Copy By default (use_private_ssl: false) the agent will use the SSL certificates bundled into the JDK to establish a secure connection to New Relic or the custom SSL certificates bundle specified by ca_bundle_path. If you want to use the SSL certificates bundled with the agent, set use_private_ssl: true. Note: use_private_ssl will be ignored if ca_bundle_path is set. enable_auto_app_naming Type Boolean Default false Enables the reporting of data separately for each web app. Set to true to enable support for auto app naming. The name of each web app is detected automatically and the agent reports data separately for each one. This provides a finer-grained performance breakdown for web apps in New Relic. For more information, see Automatic application naming. For more methods of naming your application, see Name your Java application. enable_auto_transaction_naming Type Boolean Default true Enables component-based transaction naming. Set to true to enable component-based transaction naming. Set to false to use the URI of a web request as the name of the transaction. For more information, see Naming web transactions. Caution Unless you implement API calls to name your transactions, disabling auto-transaction naming is very likely to cause Metric grouping issues. enable_custom_tracing Type Boolean Default true Enables all instrumentation using an @Trace annotation. Disabling this causes @Trace annotations to be ignored. extensions.dir Type String Default (none) Defines the location of the optional extensions directory. If this property is not set, the agent will look for a subdirectory named extensions in the same directory as newrelic.jar and newrelic.yml. high_security Type Boolean Default false In order for high security to be enabled, this property must be set to true and the high security property in the New Relic user interface must be enabled. Enabling high security means SSL is turned on, request and message queue parameters are not collected, and queries cannot be sent to New Relic in their raw form. Important As of Java agent 3.48.0, SSL is enabled by default and the config option to disable it has been deprecated. As of Java agent 4.0.0, the ability to disable SSL has been removed. insert_api_key Type String Default (none) A valid Insert API Key for your account. This is only required for Real-time Java profiling using JFR metrics. labels Type String Default \"\" Attach tags to this app. Note that this option now enables tags, which replaced the label feature. You can still query your historical labels. max_stack_trace_lines Type Integer Default 30 Limits the number of lines the agent collects from each stack trace. Increasing this value may impact performance, because it increases the amount of memory the agent uses and the amount of data sent to New Relic. proxy_host Type String Default (none) The proxy host through which to connect to the New Relic collector. If a proxy is used, the host setting is required. Other proxy settings are optional. proxy_password Type String Default (none) The password for proxy authentication. If a proxy is used, the host setting is required. Other proxy settings are optional. The username and password settings will be used to authenticate to Basic Auth challenges from a proxy server. Important The Java agent supports Basic (clear text) authentication. proxy_port Type String Default 8080 The proxy host port number. If a proxy is used, the host setting is required. Other proxy settings are optional. proxy_user Type String Default (none) The username for proxy authentication, such as Basic (clear text) authentication. If a proxy is used, the host setting is required. Other proxy settings are optional. The username and password settings will be used to authenticate to Basic Auth challenges from a proxy server. proxy_scheme Type String Default (none) The proxy scheme used. Setting proxy_scheme: \"https\" will allow the agent to connect through proxies using the HTTPS scheme. reactor-netty.errors.enabled Type Boolean Default true Whether errors are reported for reactor netty. If set to false, errors will be ignored. Important Only available in Java agent 6.3.0 and above. send_data_on_exit Type Boolean Default false Enable delayed JVM shutdown to give the agent a chance to send latest metric data to New Relic before JVM shutdown. send_data_on_exit_threshold Type Integer Default 60 The number of seconds after which the agent will use the send_data_on_exit setting. send_environment_info Type Boolean Default true Enable reporting of JVM settings to New Relic. send_jvm_props Type Boolean Default true When set to true, JVM properties will be sent to New Relic. ssl (DEPRECATED) Type Boolean Default true Requires connections to the New Relic collector to go over SSL. The agent communicates with New Relic via HTTPS by default, and New Relic requires HTTPS for all traffic to APM and the New Relic REST API. This work is done asynchronously to the threads that process your application code, so response times will not be directly affected by this change. Important As of Java agent 3.48.0, SSL is enabled by default and the config option to disable it has been deprecated. As of Java agent 4.0.0, the ability to disable SSL has been removed. sync_startup Type Boolean Default false Enable the agent to connect the New Relic collector immediately upon app startup. scala_futures_as_segments Important This applies to Java agent version 3.44.0 or higher. Type Boolean Default false For more concise transaction trace details, the agent does not report Scala Futures as transaction segments, and those Futures do not contribute to the transaction’s total time. Enabling scala_futures_as_segments increases your overhead. If you want Scala Futures to report as transaction segments so you can view them in a transaction trace, you can enable it: scala_futures_as_segments: enabled: true Copy Logging configuration These are part of the general configuration variables. They are broken out here because they are frequently tweaked for debugging. Some of the logging configuration variables are dynamic and do not need a host restart for them to take effect. For instance, if log files are growing too quickly, log_level can be set to a less verbose setting to reduce the reporting rate. Here is the order of precedence for configuration variables affecting log rotation. If log_daily is true, other log rotation settings are ignored. If log_file_count is 1 or 0, the size limit is ignored. Finally, the agent applies log_limit_in_kbytes. Depending on the growth rate, it is possible for the log file size to exceed the configured value by a small amount. log_daily Type Boolean Default false Set to true to roll the logs daily. Overrides the other configuration variables that affect log rotation. log_file_count Type Integer Default 1 The maximum number of log files to keep when using log rotation. log_file_name Type String Default newrelic_agent.log The unqualified log file name or the string STDOUT which will log to standard out. log_file_path Type String Default logs subdirectory where newrelic.jar is located The log file path. Tip If log_file_path is specified, the directory must already exist. If the default value is used, the agent will attempt to create the directory. log_level Type String Default info The log verbosity level. The agent uses its own log file to keep its logging separate from that of your application. Valid options, in order of verboseness, are: off severe warning info fine finer finest This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. log_limit_in_kbytes Type Integer Default 0 The log file size in kilobytes at which log files are rotated. Set to 0 for no limit. JMX To set these options, use the jmx stanza. To override them, use a newrelic.config.jmx prefixed system property. The Java agent uses JMX to collect JVM data as well as to communicate with the JFR (Java Flight Recorder) daemon for Real-time Java profiling. enabled Type Boolean Default true This setting can be used to turn on or off all JMX functionality. linkingMetadataMBean Type Boolean Default false This setting can be enabled to allow the Java agent to expose linking metadata to the JFR daemon. Doing so allows the JFR daemon to obtain the entity GUID generated by the Java agent and link JFR data with the same APM application that is being monitored by the agent instead of as a separate entity. Important This applies to Java agent version 6.1.0 or higher. Attributes To set these options, use the attributes stanza. To override them, use a newrelic.config.attributes prefixed system property. Attributes are key-value pairs that provide information for transaction traces, traced errors, browser monitoring, and transaction events. There is also an attribute stanza under each destination. For more information, see Java agent attributes, Enabling and disabling attributes and Attribute examples. enabled Type Boolean Default true This setting can be used to turn on or off all attributes. Important For security reasons, capturing custom attributes using the Custom Instrumentation Editor is set to false by default. include Type List of Strings Default (none) If attributes are enabled, attribute keys found in this list will be sent to New Relic. Separate the keys in the list with a comma; for example: key1, key2, key3 Copy Also refer to the agent attribute rules. exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic. Separate the keys in the list with a comma; for example: key1, key2, key3 Copy Also refer to the agent attribute rules. Transaction tracer These options are set in the transaction_tracer stanza and can be overridden by using a newrelic.config.transaction_tracer prefixed system property. Transaction tracing captures deep information about slow transactions and sends this to the New Relic service. The transaction includes the exact call sequence of the transactions, including any query statements issued. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. enabled Type Boolean Default true The transaction tracer is enabled by default. Set this to false to turn it off. explain_enabled Type Boolean Default true Determines whether the agent will capture the EXPLAIN plan for slow queries. Only supported for MySQL and PostgreSQL. explain_threshold Type Float Default 0.5 Threshold in seconds for query execution time below which the slow query and the EXPLAIN plan (if supported) will not be captured. Relevant to slow queries only when record_sql is set to raw or obfuscated. Relevant to EXPLAIN plans only when explain_enabled is set to true. insert_sql_max_length Type Integer Default 2000 The character limit for the SQL query string. If you have many slow SQL queries with large chunks of information, this could negatively affect performance or how quickly you see your data in New Relic. Increase the value gradually until you find the right balance of information and performance. log_sql Type Boolean Default false Set to true to enable logging of queries to the agent log file instead of uploading to New Relic. Queries are logged using the record_sql mode. record_sql Type String Default obfuscated When the transaction tracer is on, query statements can optionally be recorded. The recorder has three modes: off: Send no queries. raw: Send the query statement in its original form. obfuscated: Strips out numeric and string literals. stack_based_naming (Play 2.x+ only) Type Boolean Default False Defaulted to true until Java agent version 3.12.1, when it was changed to false. This option is for Play 2.x+ only. Play/Scala instrumentation can use Thread.getStackTrace() to improve tracer naming, but at the cost of increased overhead. stack_trace_threshold Type Integer Default 0.5 Defines a threshold (in seconds) for collecting stack traces from an SQL call. When SQL statements exceed this threshold, the agent will capture the current stack trace. This is useful for pinpointing where long SQL calls originate from. top_n Type Integer Default 20 Use this setting to control the variety of your transaction traces. top_n is an integer that represents the number of unique, slow transactions that traces will be created for. If you want transaction traces to more accurately reflect the actual slowest transactions in your app, make this value lower. If you want to sample a more diverse array of transactions, make the value higher. A value of 0 would mean that only the slowest transaction is always traced. This is considered not to be optimal, though, because you may have one or two transactions that are always the slowest, and repeatedly seeing those same transaction traces will probably not give you much value. If the same transaction is often the slowest, the top_n setting allows the Java agent (over time) to sample the slowest n transactions. This gives you greater variety and more insight into your application. transaction_threshold Type String (float) Default apdex_f The time threshold used to determine when a transaction is eligible to be traced. When the transaction's response time exceeds this threshold, a transaction trace will be recorded and sent to New Relic. The default is apdex_f (default), which sets the threshold to be the \"Frustrated\" Apdex level (four times the apdex_t value). You can also set a specific time threshold by entering a float value that represents a number of seconds. slow_query_whitelist (DEPRECATED) Type String Default (none) Important This config has been deprecated as of agent version 5.10.0 and will be removed in a future agent version. Instead use collect_slow_queries_from. By default, high security mode does not allow the agent to collect slow queries. Enable this option to collect Cassandra queries from the DataStax driver, even with high security enabled. If you don't use high security, the agent collects slow queries automatically. For DataStax driver 2.1.2, add this rule to your allow list: transaction_tracer: slow_query_whitelist: 'com.newrelic.instrumentation.cassandra-datastax-2.1.2' Copy For DataStax driver 3.0.0, add this rule to your allow list: transaction_tracer: slow_query_whitelist: 'com.newrelic.instrumentation.cassandra-datastax-3.0.0' Copy collect_slow_queries_from Type String Default (none) By default, high security mode does not allow the agent to collect slow queries. Enable this option to collect Cassandra queries from the DataStax driver, even with high security enabled. If you don't use high security, the agent collects slow queries automatically. For DataStax driver 2.1.2, add this rule to your allow list: transaction_tracer: collect_slow_queries_from: 'com.newrelic.instrumentation.cassandra-datastax-2.1.2' Copy For DataStax driver 3.0.0, add this rule to your allow list: transaction_tracer: collect_slow_queries_from: 'com.newrelic.instrumentation.cassandra-datastax-3.0.0' Copy attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for transaction traces. If attributes.enabled at the root level is false, no attributes will be sent to transaction traces regardless on how this property (transaction_tracer.attributes.enabled) is set. attributes.include Type List of strings Default (none) If attributes are enabled for transaction traces, all attribute keys found in this list will be sent to New Relic in transaction traces. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in transaction traces. For more information, see the agent attribute rules. token_limit Type Integer Default 3000 Limits the number of Tokens that can be created per Transaction. Increasing this value may impact performance, because it increases the amount of memory the agent uses and the amount of data sent to New Relic. segment_limit Type Integer Default 3000 Limits the number of segments that can be created per transaction. Increasing this value may impact performance, because it increases the amount of memory the agent uses and the amount of data sent to New Relic. Transaction segments These options are set in the transaction_segments stanza and can be overridden by using a newrelic.config.transaction_segments prefixed system property. Transaction segments represent discrete pieces of work (generally method calls) and are displayed within transaction traces. Important Transaction segment attribute filtering requires Java agent version 4.10.0 or higher. attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for transaction segments. If attributes.enabled at the root level is false, no attributes will be sent to transaction segments regardless on how this property (transaction_segments.attributes.enabled) is set. attributes.include Type List of strings Default (none) If attributes are enabled for transaction segments, all attribute keys found in this list will be sent to New Relic in transaction segments. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in transaction segments. For more information, see the agent attribute rules. Browser monitoring These options are set in the browser_monitoring stanza and can be overridden by using a newrelic.config.browser_monitoring prefixed system property. Browser monitoring gives you insight into the performance real users are experiencing with your website. This is accomplished by measuring the time it takes for your users' browsers to download and render your web pages by injecting a small amount of JavaScript code into the header and footer of each page. auto_instrument Type Boolean Default true By default the agent automatically inserts API calls in compiled JSPs to inject the monitoring JavaScript into web pages. Set this attribute to false to turn off this behavior. disabled_auto_pages Type Comma-separated list of strings Default (none) When auto_instrument is true, by default all pages are instrumented. List all pages that you want the auto instrumentation to skip here. You can still use manual instrumentation on these pages. For example: browser_monitoring: disabled_auto_pages: /WEB-INF/jsp/testpage_1.jsp, /WEB-INF/jsp/testpage_2.jsp Copy attributes.enabled Type Boolean Default false This setting can be used to turn on or off all attributes for browser monitoring. This is the data you can query. If attributes.enabled is false at the root level, no attributes will be sent up in browser monitoring regardless on how this property under browser_monitoring is set. attributes.include Type List of Strings Default (none) If attributes are enabled for browser_monitoring, all attribute keys found in this list will be sent to New Relic in page views. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in page views. For more information, see the agent attribute rules. External tracer The external tracing options are set in the external_tracer stanza and can be overridden by using a newrelic.config.external_tracer prefixed system property. exclude_request_uri Type Boolean Default false This setting can be used to control the collection of outgoing request URIs for errors and transaction traces. Set this to true to disable collecting this information. Cross application tracer The cross application tracing options are set in the cross_application_tracer stanza and can be overridden by using a newrelic.config.cross_application_tracer prefixed system property. Cross application tracing adds request and response headers to external calls using the Apache HttpClient libraries. This provides better performance data when calling applications monitored by other New Relic Agents. enabled Type Boolean Default true Cross application tracing is enabled by default. Set this to false to turn it off. Error collector These options are set in the error_collector stanza and unless noted otherwise can be overridden by using a newrelic.config.error_collector prefixed system property. The error collector captures information about uncaught exceptions and sends them to New Relic for viewing. Tip For how to configure errors for the Java agent, including how to configure errors via the UI, see Java agent error configuration. enabled Type Boolean Default true Enable error collection. ignore_classes Type Stanza containing a list of fully qualified class_name strings Default (none) Specified exception class names will be ignored and will not affect error rate or Apdex score, or be reported to APM. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: ignore_classes: - \"com.example.MyException\" - \"com.example.DifferentException\" Copy ignore_messages Type Stanza containing a fully qualified class_name and a list of messages per error class Default (none) Specify exception class names the agent should ignore. Ignored messages will not affect error rate or Apdex score, or be reported to APM. Contains yaml pairs consisting of: A fully qualified exception class name that should not be reported to APM AND A list of exception messages to match against (at least one is required) If the exception class name matches an error but the message does not, then that error will not be ignored. Message strings use contains for matching. A message cannot be provided on its own and must always be paired with a fully qualified class name. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: ignore_messages: com.example.MyException: - \"Some error message to ignore\" - \"Some other error message to ignore\" com.example.DifferentException: - \"Some different error message to ignore\" Copy ignore_status_codes Type Comma-separated list of strings and ranges Default 404 A comma-separated list comprised of individual and dashed ranges of HTTP status codes that should not be treated as errors. If this property is commented out in the newrelic.yml configuration file, then the 404 status code will automatically be ignored. When using server-side configuration, the status code 404 must be specified in order for it to be ignored. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: ignore_status_codes: 404,507-511 Copy expected_classes Type Stanza containing a List of fully qualified class_name strings Default (none) Prevents specified exception classes from affecting error rate or Apdex score while still reporting the errors to APM. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: expected_classes: - \"com.example.MyException\" - \"com.example.DifferentException\" Copy expected_messages Type Stanza containing a fully qualified class_name and a List of messages per error class Default (none) Contains yaml pairs consisting of a fully qualified exception class name that should be marked as expected and thus prevented from affecting error rate or Apdex score and a List of exception messages to match against, the latter of which at least one is required. If the exception class name matches an error but the message does not, then that error will not be marked as expected and therefore will affect error rate and Apdex score. Message strings use contains for matching. A message cannot be provided on its own and must always be paired with a fully qualified class name. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: expected_messages: com.example.MyException: - \"Some expected error message\" - \"Some other expected error message\" com.example.DifferentException: - \"Some different expected error message\"​ Copy expected_status_codes Type Comma-separated list of strings and ranges Default (none) A comma-separated list comprised of individual and dashed ranges of HTTP status codes to be marked as expected and thus prevented from affecting error rate or Apdex score. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: expected_status_codes: 415,500-506 Copy attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for traced errors. If attributes.enabled is false at the root level, then no attributes will be sent to traced errors regardless of how this property is set under error_collector. attributes.include Type List of strings Default (none) If attributes are enabled for traced errors, all attribute keys found in this list will be sent to New Relic in traced errors. For more information, see the agent attribute rules. attributes.exclude Type List of strings Default (none) Attribute keys found in this list will not be sent to New Relic in traced errors. For more information, see the agent attribute rules. ignore_errors (DEPRECATED) Type Comma-separated list of Strings Default (none) All specified exception class names specified will not be treated as errors. Deprecated as of Java agent 3.40.0 and replaced by ignore_classes. For example: error_collector: ignore_errors: some.other.MyException Copy Strip exceptions These options are set in the strip_exception_messages stanza and unless noted otherwise can be overridden by using a newrelic.config.strip_exception_messages​prefixed system property. This configuration can be enabled to control whether Java exception messages are reported to New Relic. enabled Type Boolean Default false By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you set this to true, the agent strips the messages from exceptions in order to prevent it from inadvertently capturing sensitive information. If you enable high security mode, this is automatically set to true. If you set enabled to true but you want the agent to capture messages from specific exceptions, add the exceptions to your allow list. whitelist (DEPRECATED) Type String Default (none) Important This config has been deprecated as of agent version 5.10.0 and will be removed in a future agent version. Instead use allowed_classes. If you set enabled to true but you want the agent to capture messages for specific exceptions, add each exception to the whitelist, separated by a comma. allowed_classes Type String Default (none) If you set enabled to true but you want the agent to capture messages for specific exceptions, add each exception to allowed_classes, separated by a comma. Thread profiler These options are set in the thread_profiler stanza and can be overridden by using a newrelic.config.thread_profiler prefixed system property. Thread profiler measures wall clock time, CPU time, and method call counts in your application's threads as they run. enabled Type Boolean Default true Enable the thread profiler. Transaction events These options are set in the transaction_events stanza and can be overridden by using a newrelic.config.transaction_events prefixed system property. Transaction events provide the data for displaying histograms and percentiles in the UI. Important Previously this stanza was called analytics_events. If your configuration file still uses analytics_events, update your agent to use transaction_events. enabled Type Boolean Default true Enable the transaction events service. max_samples_stored Type Integer Default 2000 Max 10000 The maximum number of sampled transaction events reported every 60 seconds. custom_request_headers Type List of maps Default None Important Unlike other settings, custom_request_headers have to be paired together and must be set in the newrelic.yml file. They can't be overwritten by Java virtual machine arguments (system property) or environment variables. A list of maps with the paired keys header_name and the optional header_alias. Choose one or more custom HTTP request headers to add as transaction attributes. You can list multiple header configurations: transaction_events: custom_request_headers: - header_name: \"X-Custom-Header-1\" - header_name: \"X-Custom-Header-2\" header_alias: \"CustomHeader2alias\" Copy In the first map set, X-Custom-Header-1 is captured and reported by the agent as the header name for a corresponding value from the request object. The header_name will also be the name of the attribute sent to New Relic. In the second map set, the request header is X-Custom-Header-2, but the CustomHeader2alias is the name sent to New Relic. attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for transaction events. If attributes.enabled is false at the root level, then no attributes will be sent to transaction events regardless of how this property is set under transaction_events. attributes.include Type List of Strings Default (none) If attributes are enabled for transaction events, all attribute keys found in this list will be sent to New Relic in transaction events. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in transaction events. For more information, see the agent attribute rules. Custom events Custom events are set in the custom_insights_events stanza and can be overridden by using a newrelic.config.custom_insights_events prefixed system property. APM lets you record custom event data via the New Relic language agent APIs, which you can then query. Important For Java agent versions prior to 4.1.0, the following YAML configuration is recognized: custom_insights_events.enabled: true custom_insights_events.max_samples_stored: 5000 Copy For agent versions 4.1.0 and above, the YAML configuration uses the nested stanza formatting: custom_insights_events: enabled: false max_samples_stored: 5000 Copy enabled Type Boolean Default true This enables the custom event service. max_samples_stored Type Integer Default/Max 10000 The maximum number of sampled custom events reported every 60 seconds. Hostname configuration These options are set in the process_host stanza and can be overridden by using a newrelic.config.process_host prefixed system property. These properties are used for configuring the hostname displayed in the UI: display_name Type String Default (none) Set a display name to decorate the \"host:port\" label in the New Relic UI. ipv_preference Type String Default 4 If the hostname cannot be determined, then the IP address of the host will be used. This property determines whether the IPv4 or IPv6 address should be used. The default is IPv4. Custom instrumentation These options set in the class_transformer stanza and can be overridden by using a newrelic.config.class_transformer prefixed system property. trace_annotation_class_name Type String Default (none) String containing the full class name of the annotation class the agent uses to determine which user-specified methods to instrument. For more information about custom annotations, see Java custom metric collection. com.newrelic.instrumentation.servlet-user Type Boolean Default false Enable this option to capture the userPrincipal name. This name is included as a transaction trace attribute, and can be queried. System properties You can override any setting in the newrelic.yml file by setting a system property. The system property corresponding to a given setting in the config file is the setting name prefixed by newrelic.config. For example, the system property for the log_level setting is newrelic.config.log_level. For settings nested in stanzas, prepend the stanza name to the setting name. For example, the system property for the enabled setting in the transaction_tracer stanza is newrelic.config.transaction_tracer.enabled. In addition to overriding configuration settings, the following system properties are recognized by the agent: newrelic.config.process_host.display_name Type String Default (none) Set a display name to decorate the \"host:port\" label in the New Relic UI. Requires Java agent 3.17 or higher. newrelic.config.file Type String Default (none) String containing a fully qualified path to the newrelic configuration file. If empty, the agent assumes newrelic.yml is in the same directory as newrelic.jar. newrelic.debug Type Boolean Default (none) Enable debug logging. newrelic.environment Type String Default (none) String containing the environment configuration for the agent to use. newrelic.home Type String Default (none) String containing the home directory of agent. This defaults to the same directory as the agent jarfile. newrelic.logfile Type String Default newrelic_agent.log String containing the name of the agent log file. Environment variables Environment variables take the highest precedence and override the system properties and yml config settings. To set environment variables, use the export VARNAME=value command. To permanently set environment variables, add the export line to a file such as ~/.bashrc or ~/.bash_profile. You can override any setting from a system property or in the newrelic.yml by setting an environment variable. The environment variable corresponding to a given setting in the config file is the setting name prefixed by NEW_RELIC with all dots (.) and dashes (-) replaced by underscores (_). For example, the environment variable for the log_level setting is NEW_RELIC_LOG_LEVEL. For settings nested in stanzas, prepend the stanza name to the setting name. For example, the environment variable for the enabled setting in the transaction_tracer stanza is NEW_RELIC_TRANSACTION_TRACER_ENABLED. Important Agent configuration via environment variables requires Java agent version 4.10.0 or higher. For agent versions older than 4.10.0 the following environment variables are available: NEW_RELIC_APP_NAME (REQUIRED) Type String Default (none) This setting is required. Contains the application name under which to report data to New Relic. Set the name of your application as you want it to appear in New Relic. If enable_auto_app_naming is false, the agent reports all data to this application. Otherwise, the agent reports only background tasks (transactions for non-web applications) to this application. To report data to more than one application, separate the application names with a semicolon ;. For example, to report data to My Application and My Application 2: app_name: My Application;My Application 2 Copy For more methods of naming your application, see Name your Java application. NEW_RELIC_DISTRIBUTED_TRACING_ENABLED Type String Default false Enables distributed tracing. Case sensitive: use true or false. For more information, see the distributed tracing section. NEW_RELIC_PROCESS_HOST_DISPLAY_NAME Type String Default (none) Set a display name to decorate the \"host:port\" label in the New Relic UI. NEW_RELIC_LICENSE_KEY (REQUIRED) Type String Default (none) This setting is required. Contains your New Relic account license. You must specify the license key associated with your New Relic account. This key binds your agent's data to your account in the New Relic service. NEW_RELIC_LOG Type String Default newrelic_agent.log The unqualified log file name or the string STDOUT which will log to standard out. Cloud platform utilization These options are set in the utilization stanza and can be overridden by using a newrelic.config.utilization prefixed system property. The agent collects utilization information and sends it to the New Relic service. The agent can collect information from Amazon Web Services (AWS) EC2 instances and Docker containers. detect_aws Type Boolean Default true Determines whether the agent polls AWS metadata API. detect_docker Type Boolean Default true Determines whether the agent reads Docker information from the file system. Async instrumentation These options are set directly in the common stanza and can be overridden by using a prefixed system property. token_timeout Type Integer Default (seconds) 180 The number of seconds after which the agent will automatically expire an async token that has not been explicitly expired with token.expire(). For usage instructions, see Tokens: Connect async threads. Important Increasing this value may impact performance, because it increases the amount of memory the agent uses and prevents transactions from being reported due to unexpired tokens. segment_timeout Type Integer Default (seconds) 600 The number of seconds after which the agent will automatically end a segment that has not been explicitly ended with segment.end() or segment.ignore(). For usage instructions, see Segments: Time arbitrary async activity. Important Increasing this value may impact performance, because it increases the amount of memory the agent uses and prevents transactions from being reported due to un-ended segments. Circuit breaker These settings customize the behavior of the Java circuit breaker. These settings are not included in newrelic.yml by default. You do not need to restart your JVM after changing them. If you want to customize the circuit breaker, add the stanza under the common stanza: common: &default_settings​ ​ OTHER_CONFIG_SETTINGS circuitbreaker: enabled: true memory_threshold: 20 gc_cpu_threshold: 10 Copy enabled Type Boolean Default true If your application is behaving as expected, you may want to disable the circuit breaker. memory_threshold Type Integer (0 to 100) Default 20 Customize the precentage of free heap memory below which the circuit breaker should trip. When the percentage of free heap memory is less than memory_threshold, and the CPU time spent doing garbage collection is greater than gc_cpu_threshold, the circuit breaker trips. In order to make the circuit breaker less likely to trip, decrease memory_threshold and/or increase gc_cpu_threshold. Adjust these values as needed, based on your application's operating performance and behavior. gc_cpu_threshold Type Integer (0 to 100) Default 10 Customize the precentage of garbage collection CPU time above which the circuit breaker should trip. When the percentage of free heap memory is less than memory_threshold, and the CPU time spent doing garbage collection is greater than gc_cpu_threshold, the circuit breaker trips. In order to make the circuit breaker less likely to trip, decrease memory_threshold and/or increase gc_cpu_threshold. Adjust these values as needed, based on your application's operating performance and behavior. Message tracer These options are set in the message_tracer stanza and can be overridden by using a newrelic.config.message_tracer prefixed system property. segment_parameters.enabled Type Boolean Default true Adds message properties to tracer attributes. Set this to false to turn it off. Distributed tracing Important Enabling distributed tracing disables cross application tracing, and has other effects on APM features. Before enabling, read the transition guide. Requires Java agent version 4.3.0 or higher. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. In the config file, it can be set in the distributed_tracing stanza. It can be overridden using a newrelic.config.distributed_tracing prefixed system property. enabled Type Boolean Default false Set this to true to enable distributed tracing. For example, to enable this in the config file, you would use: distributed_tracing: enabled: true Copy To enable this using a system property, you would use: -Dnewrelic.config.distributed_tracing.enabled=true Copy exclude_newrelic_header Type Boolean Default false By default, supported versions of the agent utilize both the newrelic header and W3C Trace Context headers for distributed tracing. The newrelic distributed tracing header allows interoperability with older agents that don't support W3C Trace Context headers. Agent versions that support W3C Trace Context headers will prioritize them over newrelic headers for distributed tracing. If you do not want to utilize the newrelic header, setting this to true will result in the agent excluding the newrelic header and only using W3C Trace Context headers for distributed tracing. For example, to exclude newrelic headers in the config file, you would use: distributed_tracing: exclude_newrelic_header: true Copy To exclude newrelic headers using a system property, you would use: -Dnewrelic.config.distributed_tracing.exclude_newrelic_header=true Copy Infinite Tracing Important Requirements: Java Agent 5.12.1 or higher. Infinite Tracing does not work if enable_auto_app_naming is enabled. To turn on Infinite Tracing, enable distributed tracing and add the additional setting below. For an example, see Language Agents: Configure Distributed Tracing. trace_observer.host Type String Default None For help getting a valid Infinite Tracing trace observer host entry, see find or create a Trace Observer. You can configure this via YAML: infinite_tracing: trace_observer: host: YOUR_TRACE_OBSERVER_HOST Copy You can also use the system property newrelic.config.infinite_tracing.trace_observer.host or the environment variable NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_HOST. Span events Span events are reported for distributed tracing. Distributed tracing must be enabled to report span events. Span configuration is set in the span_events stanza and can be overridden by using a newrelic.config.span_events prefixed system property. Options include: enabled Type Boolean Default true Used to enable/disable span event reporting. attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for span events. If attributes.enabled at the root level is false, no attributes will be sent to span events regardless on how this property (span_events.attributes.enabled) is set. attributes.include Type List of strings Default (none) If attributes are enabled for span events, all attribute keys found in this list will be sent to New Relic in span_events. For more information, see the agent attribute rules. attributes.exclude Type List of strings Default (none) All attribute keys found in this list will not be sent to New Relic in span events. For more information, see the agent attribute rules. Important Span event attribute filtering requires Java agent version 4.10.0 or higher. Jar collector The Java agent collects and information about jars and their versions on the application classpath. Jar collection configuration is set in the jar_collector stanza and can be overridden by using a newrelic.config.jar_collector prefixed system property. Options include: enabled Type Boolean Default true Used to enable/disable jar collection and reporting. skip_temp_jars Type Boolean Default true Used to enable/disable collection of temporary jars. Temporary jars are those residing in the directory specified by the system property java.io.tmpdir. jars_per_second Type Integer Default 10 The maximum number of jars to process per second. Must be positive.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 94.536995,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> <em>configuration</em>: Config file",
        "sections": "<em>Java</em> <em>agent</em> <em>configuration</em>: Config file",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> reads its <em>configuration</em> from the newrelic.yml file. By default the <em>agent</em> looks for this file in the directory that contains newrelic.jar. You can override the config file&#x27;s location by setting the newrelic.config.file system property to a fully qualified file name"
      },
      "id": "603eb739e7b9d2a2432a07e0"
    },
    {
      "sections": [
        "Java agent config file template"
      ],
      "title": "Java agent config file template",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "cab129eda0df59e172b299574d8e44fbb3c04617",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-config-file-template/",
      "published_at": "2021-05-05T06:49:05Z",
      "updated_at": "2021-03-16T13:47:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains a templated version of the newrelic.yml file that the Java agent reads for configuration. The config file format is YAML. While no knowledge of YAML is necessary to edit the file, be careful to maintain the proper indentation. Learn more about YAML on Wikipedia. When making changes to the newrelic.yml file, use a YAML validator to ensure the syntax is accurate and follow these rules: YML files are case sensitive. All indentations are in increments of two characters. Data in the same stanza of the file must use the same level of indentation, and sub-stanzas should be indented by an additional two spaces. For more information about structure, directories, and settings, see Java agent configuration. # This file configures the New Relic Agent. New Relic monitors # Java applications with deep visibility and low overhead. For more details and additional # configuration options visit https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-configuration-config-file. # # <%= generated_for_user %> # # This section is for settings common to all environments. # Do not add anything above this next line. common: &default_settings # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic # account. For example, if your license key is 12345 use this: # license_key: '12345' # The key binds your Agent's data to your account in the New Relic service. license_key: '<%= license_key %>' # Agent Enabled # Use this setting to disable the agent instead of removing it from the startup command. # Default is true. agent_enabled: true # Set the name of your application as you'd like it show up in New Relic. # If enable_auto_app_naming is false, the agent reports all data to this application. # Otherwise, the agent reports only background tasks (transactions for non-web applications) # to this application. To report data to more than one application # (useful for rollup reporting), separate the application names with \";\". # For example, to report data to \"My Application\" and \"My Application 2\" use this: # app_name: My Application;My Application 2 # This setting is required. Up to 3 different application names can be specified. # The first application name must be unique. app_name: My Application # To enable high security, set this property to true. When in high # security mode, the agent will use SSL and obfuscated SQL. Additionally, # request parameters and message parameters will not be sent to New Relic. high_security: false # Set to true to enable support for auto app naming. # The name of each web app is detected automatically # and the agent reports data separately for each one. # This provides a finer-grained performance breakdown for # web apps in New Relic. # Default is false. enable_auto_app_naming: false # Set to true to enable component-based transaction naming. # Set to false to use the URI of a web request as the name of the transaction. # Default is true. enable_auto_transaction_naming: true # The agent uses its own log file to keep its logging # separate from that of your application. Specify the log level here. # This setting is dynamic, so changes do not require restarting your application. # The levels in increasing order of verboseness are: # off, severe, warning, info, fine, finer, finest # Default is info. log_level: info # Log all data sent to and from New Relic in plain text. # This setting is dynamic, so changes do not require restarting your application. # Default is false. audit_mode: false # The number of backup log files to save. # Default is 1. log_file_count: 1 # The maximum number of kbytes to write to any one log file. # The log_file_count must be set greater than 1. # Default is 0 (no limit). log_limit_in_kbytes: 0 # Override other log rolling configuration and roll the logs daily. # Default is false. log_daily: false # The name of the log file. # Default is newrelic_agent.log. log_file_name: newrelic_agent.log # The log file directory. # Default is the logs directory in the newrelic.jar parent directory. #log_file_path: # Proxy settings for connecting to the New Relic server: # If a proxy is used, the host setting is required. Other settings # are optional. Default port is 8080. The username and password # settings will be used to authenticate to Basic Auth challenges # from a proxy server. Proxy scheme will allow the agent to # connect through proxies using the HTTPS scheme. #proxy_host: hostname #proxy_port: 8080 #proxy_user: username #proxy_password: password #proxy_scheme: https # Limits the number of lines to capture for each stack trace. # Default is 30 max_stack_trace_lines: 30 # Provides the ability to configure the attributes sent to New Relic. These # attributes can be found in transaction traces, traced errors, Insight's # transaction events, and Insight's page views. attributes: # When true, attributes will be sent to New Relic. The default is true. enabled: true #A comma separated list of attribute keys whose values should # be sent to New Relic. #include: # A comma separated list of attribute keys whose values should # not be sent to New Relic. #exclude: # Transaction tracer captures deep information about slow # transactions and sends this to the New Relic service once a # minute. Included in the transaction is the exact call sequence of # the transactions including any SQL statements issued. transaction_tracer: # Transaction tracer is enabled by default. Set this to false to turn it off. # This feature is not available to Lite accounts and is automatically disabled. # Default is true. enabled: true # Threshold in seconds for when to collect a transaction # trace. When the response time of a controller action exceeds # this threshold, a transaction trace will be recorded and sent to # New Relic. Valid values are any float value, or (default) \"apdex_f\", # which will use the threshold for the \"Frustrated\" Apdex level # (greater than four times the apdex_t value). # Default is apdex_f. transaction_threshold: apdex_f # When transaction tracer is on, SQL statements can optionally be # recorded. The recorder has three modes, \"off\" which sends no # SQL, \"raw\" which sends the SQL statement in its original form, # and \"obfuscated\", which strips out numeric and string literals. # Default is obfuscated. record_sql: obfuscated # Set this to true to log SQL statements instead of recording them. # SQL is logged using the record_sql mode. # Default is false. log_sql: false # Threshold in seconds for when to collect stack trace for a SQL # call. In other words, when SQL statements exceed this threshold, # then capture and send to New Relic the current stack trace. This is # helpful for pinpointing where long SQL calls originate from. # Default is 0.5 seconds. stack_trace_threshold: 0.5 # Determines whether the agent will capture query plans for slow # SQL queries. Only supported for MySQL and PostgreSQL. # Default is true. explain_enabled: true # Threshold for query execution time below which query plans will not # not be captured. Relevant only when `explain_enabled` is true. # Default is 0.5 seconds. explain_threshold: 0.5 # Use this setting to control the variety of transaction traces. # The higher the setting, the greater the variety. # Set this to 0 to always report the slowest transaction trace. # Default is 20. top_n: 20 # Error collector captures information about uncaught exceptions and # sends them to New Relic for viewing. error_collector: # This property enables the collection of errors. If the property is not # set or the property is set to false, then errors will not be collected. # Default is true. enabled: true # Use this property to exclude specific exceptions from being reported as errors # by providing a comma separated list of full class names. # The default is to exclude akka.actor.ActorKilledException. If you want to override # this, you must provide any new value as an empty list is ignored. ignore_errors: akka.actor.ActorKilledException # Use this property to exclude specific http status codes from being reported as errors # by providing a comma separated list of status codes. # The default is to exclude 404s. If you want to override # this, you must provide any new value as an empty list is ignored. ignore_status_codes: 404 # Transaction Events are used for Histograms and Percentiles. Unaggregated data is collected # for each web transaction and sent to the server on harvest. transaction_events: # Set to false to disable transaction events. # Default is true. enabled: true # Events are collected up to the configured amount. Afterwards, events are sampled to # maintain an even distribution across the harvest cycle. # Default is 2000. Setting to 0 will disable. max_samples_stored: 2000 # Distributed tracing lets you see the path that a request takes through your distributed system. # Enabling distributed tracing changes the behavior of some New Relic features, so carefully consult the transition # guide before you enable this feature: https://docs.newrelic.com/docs/apm/distributed-tracing/getting-started/transition-guide-distributed-tracing # Default is false. distributed_tracing: enabled: false # Cross Application Tracing adds request and response headers to # external calls using supported HTTP libraries to provide better # performance data when calling applications monitored by other New Relic Agents. cross_application_tracer: # Set to false to disable cross application tracing. # Default is true. enabled: true # Thread profiler measures wall clock time, CPU time, and method call counts # in your application's threads as they run. # This feature is not available to Lite accounts and is automatically disabled. thread_profiler: # Set to false to disable the thread profiler. # Default is true. enabled: true # New Relic Real User Monitoring gives you insight into the performance real users are # experiencing with your website. This is accomplished by measuring the time it takes for # your users' browsers to download and render your web pages by injecting a small amount # of JavaScript code into the header and footer of each page. browser_monitoring: # By default the agent automatically inserts API calls in compiled JSPs to # inject the monitoring JavaScript into web pages. Not all rendering engines are supported. # See https://docs.newrelic.com/docs/agents/java-agent/instrumentation/new-relic-browser-java-agent#manual_instrumentation # for instructions to add these manually to your pages. # Set this attribute to false to turn off this behavior. auto_instrument: true class_transformer: # This instrumentation reports the name of the user principal returned from # HttpServletRequest.getUserPrincipal() when servlets and filters are invoked. com.newrelic.instrumentation.servlet-user: enabled: false com.newrelic.instrumentation.spring-aop-2: enabled: false # This instrumentation reports metrics for resultset operations. com.newrelic.instrumentation.jdbc-resultset: enabled: false # Classes loaded by classloaders in this list will not be instrumented. # This is a useful optimization for runtimes which use classloaders to # load dynamic classes which the agent would not instrument. classloader_excludes: groovy.lang.GroovyClassLoader$InnerLoader, org.codehaus.groovy.runtime.callsite.CallSiteClassLoader, com.collaxa.cube.engine.deployment.BPELClassLoader, org.springframework.data.convert.ClassGeneratingEntityInstantiator$ObjectInstantiatorClassGenerator, org.mvel2.optimizers.impl.asm.ASMAccessorOptimizer$ContextClassLoader, gw.internal.gosu.compiler.SingleServingGosuClassLoader, # User-configurable custom labels for this agent. Labels are name-value pairs. # There is a maximum of 64 labels per agent. Names and values are limited to 255 characters. # Names and values may not contain colons (:) or semicolons (;). labels: # An example label #label_name: label_value # Application Environments # ------------------------------------------ # Environment specific settings are in this section. # You can use the environment to override the default settings. # For example, to change the app_name setting. # Use -Dnewrelic.environment=<environment> on the Java startup command line # to set the environment. # The default environment is production. # NOTE if your application has other named environments, you should # provide configuration settings for these environments here. development: <<: *default_settings app_name: My Application (Development) test: <<: *default_settings app_name: My Application (Test) production: <<: *default_settings staging: <<: *default_settings app_name: My Application (Staging) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 94.51563,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> config file template",
        "sections": "<em>Java</em> <em>agent</em> config file template",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " options visit https:&#x2F;&#x2F;docs.newrelic.com&#x2F;docs&#x2F;<em>agents</em>&#x2F;<em>java</em>-<em>agent</em>&#x2F;<em>configuration</em>&#x2F;<em>java</em>-<em>agent</em>-<em>configuration</em>-config-file. # # &lt;%= generated_for_user %&gt; # # This section is for settings common to all environments. # Do not add anything above this next line. common: &amp;default_settings"
      },
      "id": "603eb738e7b9d242542a0815"
    },
    {
      "sections": [
        "Name your Java application",
        "Set or change app name",
        "Tip",
        "Use multiple app names",
        "Java config file",
        "Java environment variable",
        "System properties",
        "Important"
      ],
      "title": "Name your Java application",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "72db22e0ea6a9f8062f65ad8d7fc3e22608f90a2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/name-your-java-application/",
      "published_at": "2021-05-05T06:50:12Z",
      "updated_at": "2021-03-16T13:13:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent gives you several ways to change the application name that is reported and displayed in APM. This document gives you an overview of those naming options. For a general overview of APM app naming (not Java-specific), see Name your application. Set or change app name APM differentiates applications by the name they report as. Data continuity breaks when you change the application name. To change an application's name without breaking data continuity, use the UI alias-change option. Here are the ways to change your Java application's name: Naming method Description Recommended: Configure app_name in newrelic.yml Configure your newrelic.yml file to set your app name. This is the recommended and most commonly used option: app_name: My Application Copy Configure app_name using JVM arguments Set a system property with JVM arguments to set unique app names for multiple applications that report to the same Java agent: -Dnewrelic.config.app_name=\"My App\" Copy Set app name using environment variables Set an environment variable to easily set app names during the deployment of containers, or to ensure an app name stays the same through multiple iterations of a newrelic.yml file: export NEW_RELIC_APP_NAME=\"My App\" Copy Automatic application naming Enable automatic application naming in your newrelic.yml file if you want applications named for their context, filter, servlet, or request attribute: enable_auto_app_naming: true Copy Change alias via UI Change an application's alias to change only the displayed name in the UI. This does not change the name the application reports as. This does not break data continuity, unlike all other options. Tip Note that some methods take precedence over others. Use multiple app names You can use multiple app names to aggregate data from several applications under the same name in APM (sometimes referred to as \"rolling up\" your data). For more about how multiple app names work, see Use multiple app names. In Java, you can set up to three app names. The primary app name is first, while the second and third names are used for the more general data aggregation categories. Java config file Here is an example of setting multiple names in the newrelic.yml file: app_name: My Application;My Application 2;My application 3 Copy Java environment variable Here is an example of setting multiple names as environment variable: export NEW_RELIC_APP_NAME=\"My Application;My Application 2;My application 3\" Copy System properties Important If you set multiple application names using system properties on the Java command line, remember to quote the command-line parameter because of the ; character. Here is an example of setting multiple names as a system property: -Dnewrelic.config.app_name=\"My Application;My Application 2;My application 3\" Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 94.50982,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Name your <em>Java</em> application",
        "sections": "Name your <em>Java</em> application",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "New Relic&#x27;s <em>Java</em> <em>agent</em> gives you several ways to change the application name that is reported and displayed in APM. This document gives you an overview of those naming options. For a general overview of APM app naming (not <em>Java</em>-specific), see Name your application. Set or change app name APM"
      },
      "id": "603ea329196a675e06a83dd4"
    }
  ],
  "/docs/agents/java-agent/configuration/hostname-logic-java": [
    {
      "sections": [
        "Configuring your SSL certificates",
        "Notice of expired SSL certificates and certificate removal",
        "Caution",
        "Important",
        "Java Agent versions 6.2.0 - 6.4.2",
        "Java Agent versions 6.0.0/6.1.0",
        "Using YAML-based configuration",
        "Java Agent versions prior to 6.0.0 (Deprecated)",
        "For more help"
      ],
      "title": "Configuring your SSL certificates",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "af154f250e87f571db157972e22dbb1f907a8fde",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/configuring-your-ssl-certificates/",
      "published_at": "2021-05-05T06:44:59Z",
      "updated_at": "2021-04-28T23:01:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To communicate with the New Relic collector over HTTPS, you need to have the proper certificates for trusted signers in the trust store on your app server. By default, most JREs contain a valid root certificate that allows the agent to connect to newrelic.com. For SSL connection issues, please visit SSL or connection errors (Java). Notice of expired SSL certificates and certificate removal Caution The SSL certificates that were bundled with Java agent versions 6.1.0 to 6.4.2 have expired and are no longer valid. This means that Java agent versions 6.1.0 to 6.4.2 can no longer use the certificates bundled with the agent to establish a connection with New Relic and that you must provide your own SSL certificates. Please see this community forum post for additional details. Important Java agent versions higher than 6.4.2 no longer ship with SSL certificates bundled into the agent. You must provide your own SSL truststore to the agent by explicitly using the ca_bundle_path configuration option, or by using the default truststore provided by the JDK/JRE (the agent will look to use the latter by default). Additionally the use_private_ssl configuration option has been removed from Java agent versions higher than 6.4.2. Users wishing to add the global certificate to their local trust store can download the DigiCert Global Root CA from DigiCert. Java Agent versions 6.2.0 - 6.4.2 Starting with Java agent version 6.2.0, the use_private_ssl configuration option has been reintroduced so you can use the SSL certificates that are bundled into the agent jar. The following bundled SSL certificates are valid for up to a year after release. META-INF/certs/eu-newrelic-com.pem META-INF/certs/eu01-nr-data-net.pem META-INF/certs/newrelic-com.pem Copy Important The Java agent will begin logging a warning message upon application startup when there are less than three months before the bundled certificate expires. When the bundled certificates expire, the Java agent will no longer be able to connect to New Relic and you must either update to the latest agent version or provide a valid certificate using the ca_bundle_path configuration. Users wishing to add the global certificate to their local trust store can download the DigiCert Global Root CA from DigiCert. Using YAML-based configuration common: default_settings ca_bundle_path: /path/to/digicert.pem use_private_ssl: false # # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic ... Copy Summary There are two configuration settings that determine what certs are used by the agent to establish a secure connection to New Relic. They are: use_private_ssl and ca_bundle_path. Here's how they work together: DEFAULT: Neither configuration option (ca_bundle_path/use_private_ssl) is provided, because both are using default values. The agent will use the default SSL certificates bundled into the Java Development Kit (JDK). If these certificates aren't present or don't include certificates that trust New Relic, then the agent will not connect. You'll need to merge valid certificates into your JDK certificate bundle. Only use_private_ssl is configured. The agent will use the SSL certificates that are bundled with it. Only ca_bundle_path is configured. The agent will try to connect using the custom SSL certificates bundle at the configured path. If the configured custom certificate bundle doesn’t include certificates that trust New Relic, then the agent will not connect. You'll need to merge valid certificates into your custom certificate bundle. Both use_private_ssl and ca_bundle_path are configured. The ca_bundle_path configuration setting takes precedence and the use_private_ssl config is ignored. This behavior is the same as only specifying ca_bundle_path. Java Agent versions 6.0.0/6.1.0 Starting in 6.0.0, the Java agent no longer includes the nrcert global certificate chain. Users wishing to add the global certificate to their local trust store must download the DigiCert Global Root CA from DigiCert. Note: In versions 6.1.0+, the Java agent will use a bundled New Relic certificate that is valid for up to a year after release. Before the certificate expires, you must either update the agent to the latest version or provide a valid certificate using the ca_bundle_path configuration. Important The Java agent will begin logging a warning message upon application startup when there are less than three months before the bundled certificate expires. Using YAML-based configuration common: default_settings ca_bundle_path: /path/to/digicert.pem # # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic ... Copy Java Agent versions prior to 6.0.0 (Deprecated) For Java agent versions prior to 6.0.0, applications that require valid certificates may add them in one of the following two ways: Use YAML-based configuration. Add the bundled list of New Relic trusted signers to the local store. Using YAML-based configuration The New Relic Java agent bundles the list of trusted signers in the agent newrelic.jar file. If you do not want to change the local trust store, you can activate them by setting use_private_ssl to true in the newrelic.yml agent configuration file: common: default_settings use_private_ssl: true # # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic ... Copy For more help Additional documentation resources include New Relic for Java (compatibility and requirements, installation, and configuration.)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 133.55931,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Configuring</em> your SSL certificates",
        "sections": "<em>Java</em> <em>Agent</em> versions 6.2.0 - 6.4.2",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " provide your own SSL truststore to the <em>agent</em> by explicitly using the ca_bundle_path <em>configuration</em> option, or by using the default truststore provided by the JDK&#x2F;JRE (the <em>agent</em> will look to use the latter by default). Additionally the use_private_ssl <em>configuration</em> option has been removed from <em>Java</em>"
      },
      "id": "603eb7a2e7b9d247c02a080d"
    },
    {
      "sections": [
        "Java agent configuration: Config file",
        "Configuration file structure",
        "Tip",
        "Configuration settings precedence",
        "Configuring the Java extensions directory",
        "Create an extensions directory",
        "Specify an existing extensions directory",
        "General configuration settings",
        "license_key (REQUIRED)",
        "app_name (REQUIRED)",
        "agent_enabled",
        "apdex_t (DEPRECATED)",
        "appserver_port",
        "Important",
        "audit_mode",
        "ca_bundle_path",
        "use_private_ssl",
        "enable_auto_app_naming",
        "enable_auto_transaction_naming",
        "Caution",
        "enable_custom_tracing",
        "extensions.dir",
        "high_security",
        "insert_api_key",
        "labels",
        "max_stack_trace_lines",
        "proxy_host",
        "proxy_password",
        "proxy_port",
        "proxy_user",
        "proxy_scheme",
        "reactor-netty.errors.enabled",
        "send_data_on_exit",
        "send_data_on_exit_threshold",
        "send_environment_info",
        "send_jvm_props",
        "ssl (DEPRECATED)",
        "sync_startup",
        "scala_futures_as_segments",
        "Logging configuration",
        "log_daily",
        "log_file_count",
        "log_file_name",
        "log_file_path",
        "log_level",
        "log_limit_in_kbytes",
        "JMX",
        "enabled",
        "linkingMetadataMBean",
        "Attributes",
        "include",
        "exclude",
        "Transaction tracer",
        "explain_enabled",
        "explain_threshold",
        "insert_sql_max_length",
        "log_sql",
        "record_sql",
        "stack_based_naming (Play 2.x+ only)",
        "stack_trace_threshold",
        "top_n",
        "transaction_threshold",
        "slow_query_whitelist (DEPRECATED)",
        "collect_slow_queries_from",
        "attributes.enabled",
        "attributes.include",
        "attributes.exclude",
        "token_limit",
        "segment_limit",
        "Transaction segments",
        "Browser monitoring",
        "auto_instrument",
        "disabled_auto_pages",
        "External tracer",
        "exclude_request_uri",
        "Cross application tracer",
        "Error collector",
        "ignore_classes",
        "ignore_messages",
        "ignore_status_codes",
        "expected_classes",
        "expected_messages",
        "expected_status_codes",
        "ignore_errors (DEPRECATED)",
        "Strip exceptions",
        "whitelist (DEPRECATED)",
        "allowed_classes",
        "Thread profiler",
        "Transaction events",
        "max_samples_stored",
        "custom_request_headers",
        "Custom events",
        "Hostname configuration",
        "display_name",
        "ipv_preference",
        "Custom instrumentation",
        "trace_annotation_class_name",
        "com.newrelic.instrumentation.servlet-user",
        "System properties",
        "newrelic.config.process_host.display_name",
        "newrelic.config.file",
        "newrelic.debug",
        "newrelic.environment",
        "newrelic.home",
        "newrelic.logfile",
        "Environment variables",
        "NEW_RELIC_APP_NAME (REQUIRED)",
        "NEW_RELIC_DISTRIBUTED_TRACING_ENABLED",
        "NEW_RELIC_PROCESS_HOST_DISPLAY_NAME",
        "NEW_RELIC_LICENSE_KEY (REQUIRED)",
        "NEW_RELIC_LOG",
        "Cloud platform utilization",
        "detect_aws",
        "detect_docker",
        "Async instrumentation",
        "token_timeout",
        "segment_timeout",
        "Circuit breaker",
        "memory_threshold",
        "gc_cpu_threshold",
        "Message tracer",
        "segment_parameters.enabled",
        "Distributed tracing",
        "exclude_newrelic_header",
        "Infinite Tracing",
        "trace_observer.host",
        "Span events",
        "Jar collector",
        "skip_temp_jars",
        "jars_per_second"
      ],
      "title": "Java agent configuration: Config file",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "1d61f848fa192438225eae269421b8d384915c8b",
      "image": "https://docs.newrelic.com/static/60ca967eab99ca225186310913ae2de6/8c557/java-config-cascade.png",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-configuration-config-file/",
      "published_at": "2021-05-04T17:01:42Z",
      "updated_at": "2021-03-16T15:52:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent reads its configuration from the newrelic.yml file. By default the agent looks for this file in the directory that contains newrelic.jar. You can override the config file's location by setting the newrelic.config.file system property to a fully qualified file name. Configuration file structure The newrelic.yml file is split into stanzas corresponding to different environments: Test Development Staging Production (default) New Relic applies settings in the common stanza to each of these environments. You can select other environments as the default by setting the newrelic.environment system property to the environment name. Tip A newrelic.yml template is available. If you edit newrelic.yml, be careful to conform to the YAML format. Use a YAML validator to ensure the syntax is accurate before using the file with New Relic's Java agent, and follow these rules: Java agent newrelic.yml Requirements Format YML files are case sensitive. Indentations All indentations must be in increments of two characters. Other indentations will result in an Unable to parse configuration file error upon agent startup. Use the same level of indentation for data in the same stanza of the file. Indent any sub-stanzas by an additional two spaces. Changes to file You must restart your JVM host process for changes to take effect. Exception: Property changes to log_level and audit_mode do not require a restart. Property changes under circuit breaker don't require a restart. Configuration settings precedence To override any setting in the config file, use a system property override. In certain environments, environment variables can also be used to override both the config file and the system properties. The environment variables primarily exist to support Heroku. When used, server-side configuration overrides all other configuration settings. With the Java agent, server-side configuration overrides all other settings. Environment variables override Java system properties. Java properties override user configuration settings in your newrelic.yml file. User settings override the newrelic.yml default settings. Configuring the Java extensions directory The Java agent reads the configuration files on process startup. To identify the directory where the files are located, either create a new or specify an existing extensions directory: Create an extensions directory To create the extensions directory: Navigate to the directory where newrelic.jar and newrelic.yml are located. Create a directory named extensions. In newrelic.yml, check that the property extensions.dir is not set. Specify an existing extensions directory To use an existing Java extensions directory: In your newrelic.yml file, locate the common section. Use the property extensions.dir to specify the location of the file. General configuration settings Set these options in the common stanza. To override any of these options, use a newrelic.config prefixed system property. license_key (REQUIRED) Type String Default (none) This setting is required. You must specify the license key associated with your New Relic account. This key binds your agent's data to your account in the New Relic service. app_name (REQUIRED) Type String Default (none) This setting is required. Defines the application name used to report data to New Relic. If enable_auto_app_naming is false, the agent reports all data to this application. Otherwise, the agent reports only background tasks (transactions for non-web applications) to this application. To report data to more than one application, separate the application names with a semicolon. For example, to report data to My Application and My Application 2 use this: app_name: My Application;My Application 2 Copy For more methods of naming your application, see Name your Java application. agent_enabled Type Boolean Default true Flag to enable the agent. Use this setting to force the agent to run or not run. apdex_t (DEPRECATED) Type Float Default 1.0 The apdex_t threshold in seconds for the application's Apdex score. For Java agent versions 1.2.008 or higher, the apdex_t value is set in the UI and the value in newrelic.yml is ignored. appserver_port Type Integer Default (none) Number to differentiate JVMs for the same app on the same machine. New Relic uses host/port for uniqueness, so you can distinguish the JVMs by putting a switch like this into the startup arguments for each JVM: -Dnewrelic.config.appserver_port=8081 Copy Once you have used appserver_port to name the JVMs and restart them, you should be able to see them individually in the dropdown and in the profiling interface. Important This is only a change for New Relic; it doesn't actually affect the port on which the host communicates in any way. audit_mode Type Boolean Default false Enables plain text logging of all data sent to New Relic to the agent logfile. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. ca_bundle_path Type String Value Format /path/to/ca/cert/bundle.pem Specifies a path to a custom SSL certificate bundle that will be used by the agent to establish a secure connection to New Relic. If your custom SSL certificate bundle doesn't include certificates that are sufficient to connect to New Relic then you'll need to merge the required certs into your custom certificate bundle. use_private_ssl Type Boolean Default false The following SSL certificates are bundled into the agent jar: META-INF/certs/eu-newrelic-com.pem META-INF/certs/eu01-nr-data-net.pem META-INF/certs/newrelic-com.pem Copy By default (use_private_ssl: false) the agent will use the SSL certificates bundled into the JDK to establish a secure connection to New Relic or the custom SSL certificates bundle specified by ca_bundle_path. If you want to use the SSL certificates bundled with the agent, set use_private_ssl: true. Note: use_private_ssl will be ignored if ca_bundle_path is set. enable_auto_app_naming Type Boolean Default false Enables the reporting of data separately for each web app. Set to true to enable support for auto app naming. The name of each web app is detected automatically and the agent reports data separately for each one. This provides a finer-grained performance breakdown for web apps in New Relic. For more information, see Automatic application naming. For more methods of naming your application, see Name your Java application. enable_auto_transaction_naming Type Boolean Default true Enables component-based transaction naming. Set to true to enable component-based transaction naming. Set to false to use the URI of a web request as the name of the transaction. For more information, see Naming web transactions. Caution Unless you implement API calls to name your transactions, disabling auto-transaction naming is very likely to cause Metric grouping issues. enable_custom_tracing Type Boolean Default true Enables all instrumentation using an @Trace annotation. Disabling this causes @Trace annotations to be ignored. extensions.dir Type String Default (none) Defines the location of the optional extensions directory. If this property is not set, the agent will look for a subdirectory named extensions in the same directory as newrelic.jar and newrelic.yml. high_security Type Boolean Default false In order for high security to be enabled, this property must be set to true and the high security property in the New Relic user interface must be enabled. Enabling high security means SSL is turned on, request and message queue parameters are not collected, and queries cannot be sent to New Relic in their raw form. Important As of Java agent 3.48.0, SSL is enabled by default and the config option to disable it has been deprecated. As of Java agent 4.0.0, the ability to disable SSL has been removed. insert_api_key Type String Default (none) A valid Insert API Key for your account. This is only required for Real-time Java profiling using JFR metrics. labels Type String Default \"\" Attach tags to this app. Note that this option now enables tags, which replaced the label feature. You can still query your historical labels. max_stack_trace_lines Type Integer Default 30 Limits the number of lines the agent collects from each stack trace. Increasing this value may impact performance, because it increases the amount of memory the agent uses and the amount of data sent to New Relic. proxy_host Type String Default (none) The proxy host through which to connect to the New Relic collector. If a proxy is used, the host setting is required. Other proxy settings are optional. proxy_password Type String Default (none) The password for proxy authentication. If a proxy is used, the host setting is required. Other proxy settings are optional. The username and password settings will be used to authenticate to Basic Auth challenges from a proxy server. Important The Java agent supports Basic (clear text) authentication. proxy_port Type String Default 8080 The proxy host port number. If a proxy is used, the host setting is required. Other proxy settings are optional. proxy_user Type String Default (none) The username for proxy authentication, such as Basic (clear text) authentication. If a proxy is used, the host setting is required. Other proxy settings are optional. The username and password settings will be used to authenticate to Basic Auth challenges from a proxy server. proxy_scheme Type String Default (none) The proxy scheme used. Setting proxy_scheme: \"https\" will allow the agent to connect through proxies using the HTTPS scheme. reactor-netty.errors.enabled Type Boolean Default true Whether errors are reported for reactor netty. If set to false, errors will be ignored. Important Only available in Java agent 6.3.0 and above. send_data_on_exit Type Boolean Default false Enable delayed JVM shutdown to give the agent a chance to send latest metric data to New Relic before JVM shutdown. send_data_on_exit_threshold Type Integer Default 60 The number of seconds after which the agent will use the send_data_on_exit setting. send_environment_info Type Boolean Default true Enable reporting of JVM settings to New Relic. send_jvm_props Type Boolean Default true When set to true, JVM properties will be sent to New Relic. ssl (DEPRECATED) Type Boolean Default true Requires connections to the New Relic collector to go over SSL. The agent communicates with New Relic via HTTPS by default, and New Relic requires HTTPS for all traffic to APM and the New Relic REST API. This work is done asynchronously to the threads that process your application code, so response times will not be directly affected by this change. Important As of Java agent 3.48.0, SSL is enabled by default and the config option to disable it has been deprecated. As of Java agent 4.0.0, the ability to disable SSL has been removed. sync_startup Type Boolean Default false Enable the agent to connect the New Relic collector immediately upon app startup. scala_futures_as_segments Important This applies to Java agent version 3.44.0 or higher. Type Boolean Default false For more concise transaction trace details, the agent does not report Scala Futures as transaction segments, and those Futures do not contribute to the transaction’s total time. Enabling scala_futures_as_segments increases your overhead. If you want Scala Futures to report as transaction segments so you can view them in a transaction trace, you can enable it: scala_futures_as_segments: enabled: true Copy Logging configuration These are part of the general configuration variables. They are broken out here because they are frequently tweaked for debugging. Some of the logging configuration variables are dynamic and do not need a host restart for them to take effect. For instance, if log files are growing too quickly, log_level can be set to a less verbose setting to reduce the reporting rate. Here is the order of precedence for configuration variables affecting log rotation. If log_daily is true, other log rotation settings are ignored. If log_file_count is 1 or 0, the size limit is ignored. Finally, the agent applies log_limit_in_kbytes. Depending on the growth rate, it is possible for the log file size to exceed the configured value by a small amount. log_daily Type Boolean Default false Set to true to roll the logs daily. Overrides the other configuration variables that affect log rotation. log_file_count Type Integer Default 1 The maximum number of log files to keep when using log rotation. log_file_name Type String Default newrelic_agent.log The unqualified log file name or the string STDOUT which will log to standard out. log_file_path Type String Default logs subdirectory where newrelic.jar is located The log file path. Tip If log_file_path is specified, the directory must already exist. If the default value is used, the agent will attempt to create the directory. log_level Type String Default info The log verbosity level. The agent uses its own log file to keep its logging separate from that of your application. Valid options, in order of verboseness, are: off severe warning info fine finer finest This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. log_limit_in_kbytes Type Integer Default 0 The log file size in kilobytes at which log files are rotated. Set to 0 for no limit. JMX To set these options, use the jmx stanza. To override them, use a newrelic.config.jmx prefixed system property. The Java agent uses JMX to collect JVM data as well as to communicate with the JFR (Java Flight Recorder) daemon for Real-time Java profiling. enabled Type Boolean Default true This setting can be used to turn on or off all JMX functionality. linkingMetadataMBean Type Boolean Default false This setting can be enabled to allow the Java agent to expose linking metadata to the JFR daemon. Doing so allows the JFR daemon to obtain the entity GUID generated by the Java agent and link JFR data with the same APM application that is being monitored by the agent instead of as a separate entity. Important This applies to Java agent version 6.1.0 or higher. Attributes To set these options, use the attributes stanza. To override them, use a newrelic.config.attributes prefixed system property. Attributes are key-value pairs that provide information for transaction traces, traced errors, browser monitoring, and transaction events. There is also an attribute stanza under each destination. For more information, see Java agent attributes, Enabling and disabling attributes and Attribute examples. enabled Type Boolean Default true This setting can be used to turn on or off all attributes. Important For security reasons, capturing custom attributes using the Custom Instrumentation Editor is set to false by default. include Type List of Strings Default (none) If attributes are enabled, attribute keys found in this list will be sent to New Relic. Separate the keys in the list with a comma; for example: key1, key2, key3 Copy Also refer to the agent attribute rules. exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic. Separate the keys in the list with a comma; for example: key1, key2, key3 Copy Also refer to the agent attribute rules. Transaction tracer These options are set in the transaction_tracer stanza and can be overridden by using a newrelic.config.transaction_tracer prefixed system property. Transaction tracing captures deep information about slow transactions and sends this to the New Relic service. The transaction includes the exact call sequence of the transactions, including any query statements issued. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. enabled Type Boolean Default true The transaction tracer is enabled by default. Set this to false to turn it off. explain_enabled Type Boolean Default true Determines whether the agent will capture the EXPLAIN plan for slow queries. Only supported for MySQL and PostgreSQL. explain_threshold Type Float Default 0.5 Threshold in seconds for query execution time below which the slow query and the EXPLAIN plan (if supported) will not be captured. Relevant to slow queries only when record_sql is set to raw or obfuscated. Relevant to EXPLAIN plans only when explain_enabled is set to true. insert_sql_max_length Type Integer Default 2000 The character limit for the SQL query string. If you have many slow SQL queries with large chunks of information, this could negatively affect performance or how quickly you see your data in New Relic. Increase the value gradually until you find the right balance of information and performance. log_sql Type Boolean Default false Set to true to enable logging of queries to the agent log file instead of uploading to New Relic. Queries are logged using the record_sql mode. record_sql Type String Default obfuscated When the transaction tracer is on, query statements can optionally be recorded. The recorder has three modes: off: Send no queries. raw: Send the query statement in its original form. obfuscated: Strips out numeric and string literals. stack_based_naming (Play 2.x+ only) Type Boolean Default False Defaulted to true until Java agent version 3.12.1, when it was changed to false. This option is for Play 2.x+ only. Play/Scala instrumentation can use Thread.getStackTrace() to improve tracer naming, but at the cost of increased overhead. stack_trace_threshold Type Integer Default 0.5 Defines a threshold (in seconds) for collecting stack traces from an SQL call. When SQL statements exceed this threshold, the agent will capture the current stack trace. This is useful for pinpointing where long SQL calls originate from. top_n Type Integer Default 20 Use this setting to control the variety of your transaction traces. top_n is an integer that represents the number of unique, slow transactions that traces will be created for. If you want transaction traces to more accurately reflect the actual slowest transactions in your app, make this value lower. If you want to sample a more diverse array of transactions, make the value higher. A value of 0 would mean that only the slowest transaction is always traced. This is considered not to be optimal, though, because you may have one or two transactions that are always the slowest, and repeatedly seeing those same transaction traces will probably not give you much value. If the same transaction is often the slowest, the top_n setting allows the Java agent (over time) to sample the slowest n transactions. This gives you greater variety and more insight into your application. transaction_threshold Type String (float) Default apdex_f The time threshold used to determine when a transaction is eligible to be traced. When the transaction's response time exceeds this threshold, a transaction trace will be recorded and sent to New Relic. The default is apdex_f (default), which sets the threshold to be the \"Frustrated\" Apdex level (four times the apdex_t value). You can also set a specific time threshold by entering a float value that represents a number of seconds. slow_query_whitelist (DEPRECATED) Type String Default (none) Important This config has been deprecated as of agent version 5.10.0 and will be removed in a future agent version. Instead use collect_slow_queries_from. By default, high security mode does not allow the agent to collect slow queries. Enable this option to collect Cassandra queries from the DataStax driver, even with high security enabled. If you don't use high security, the agent collects slow queries automatically. For DataStax driver 2.1.2, add this rule to your allow list: transaction_tracer: slow_query_whitelist: 'com.newrelic.instrumentation.cassandra-datastax-2.1.2' Copy For DataStax driver 3.0.0, add this rule to your allow list: transaction_tracer: slow_query_whitelist: 'com.newrelic.instrumentation.cassandra-datastax-3.0.0' Copy collect_slow_queries_from Type String Default (none) By default, high security mode does not allow the agent to collect slow queries. Enable this option to collect Cassandra queries from the DataStax driver, even with high security enabled. If you don't use high security, the agent collects slow queries automatically. For DataStax driver 2.1.2, add this rule to your allow list: transaction_tracer: collect_slow_queries_from: 'com.newrelic.instrumentation.cassandra-datastax-2.1.2' Copy For DataStax driver 3.0.0, add this rule to your allow list: transaction_tracer: collect_slow_queries_from: 'com.newrelic.instrumentation.cassandra-datastax-3.0.0' Copy attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for transaction traces. If attributes.enabled at the root level is false, no attributes will be sent to transaction traces regardless on how this property (transaction_tracer.attributes.enabled) is set. attributes.include Type List of strings Default (none) If attributes are enabled for transaction traces, all attribute keys found in this list will be sent to New Relic in transaction traces. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in transaction traces. For more information, see the agent attribute rules. token_limit Type Integer Default 3000 Limits the number of Tokens that can be created per Transaction. Increasing this value may impact performance, because it increases the amount of memory the agent uses and the amount of data sent to New Relic. segment_limit Type Integer Default 3000 Limits the number of segments that can be created per transaction. Increasing this value may impact performance, because it increases the amount of memory the agent uses and the amount of data sent to New Relic. Transaction segments These options are set in the transaction_segments stanza and can be overridden by using a newrelic.config.transaction_segments prefixed system property. Transaction segments represent discrete pieces of work (generally method calls) and are displayed within transaction traces. Important Transaction segment attribute filtering requires Java agent version 4.10.0 or higher. attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for transaction segments. If attributes.enabled at the root level is false, no attributes will be sent to transaction segments regardless on how this property (transaction_segments.attributes.enabled) is set. attributes.include Type List of strings Default (none) If attributes are enabled for transaction segments, all attribute keys found in this list will be sent to New Relic in transaction segments. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in transaction segments. For more information, see the agent attribute rules. Browser monitoring These options are set in the browser_monitoring stanza and can be overridden by using a newrelic.config.browser_monitoring prefixed system property. Browser monitoring gives you insight into the performance real users are experiencing with your website. This is accomplished by measuring the time it takes for your users' browsers to download and render your web pages by injecting a small amount of JavaScript code into the header and footer of each page. auto_instrument Type Boolean Default true By default the agent automatically inserts API calls in compiled JSPs to inject the monitoring JavaScript into web pages. Set this attribute to false to turn off this behavior. disabled_auto_pages Type Comma-separated list of strings Default (none) When auto_instrument is true, by default all pages are instrumented. List all pages that you want the auto instrumentation to skip here. You can still use manual instrumentation on these pages. For example: browser_monitoring: disabled_auto_pages: /WEB-INF/jsp/testpage_1.jsp, /WEB-INF/jsp/testpage_2.jsp Copy attributes.enabled Type Boolean Default false This setting can be used to turn on or off all attributes for browser monitoring. This is the data you can query. If attributes.enabled is false at the root level, no attributes will be sent up in browser monitoring regardless on how this property under browser_monitoring is set. attributes.include Type List of Strings Default (none) If attributes are enabled for browser_monitoring, all attribute keys found in this list will be sent to New Relic in page views. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in page views. For more information, see the agent attribute rules. External tracer The external tracing options are set in the external_tracer stanza and can be overridden by using a newrelic.config.external_tracer prefixed system property. exclude_request_uri Type Boolean Default false This setting can be used to control the collection of outgoing request URIs for errors and transaction traces. Set this to true to disable collecting this information. Cross application tracer The cross application tracing options are set in the cross_application_tracer stanza and can be overridden by using a newrelic.config.cross_application_tracer prefixed system property. Cross application tracing adds request and response headers to external calls using the Apache HttpClient libraries. This provides better performance data when calling applications monitored by other New Relic Agents. enabled Type Boolean Default true Cross application tracing is enabled by default. Set this to false to turn it off. Error collector These options are set in the error_collector stanza and unless noted otherwise can be overridden by using a newrelic.config.error_collector prefixed system property. The error collector captures information about uncaught exceptions and sends them to New Relic for viewing. Tip For how to configure errors for the Java agent, including how to configure errors via the UI, see Java agent error configuration. enabled Type Boolean Default true Enable error collection. ignore_classes Type Stanza containing a list of fully qualified class_name strings Default (none) Specified exception class names will be ignored and will not affect error rate or Apdex score, or be reported to APM. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: ignore_classes: - \"com.example.MyException\" - \"com.example.DifferentException\" Copy ignore_messages Type Stanza containing a fully qualified class_name and a list of messages per error class Default (none) Specify exception class names the agent should ignore. Ignored messages will not affect error rate or Apdex score, or be reported to APM. Contains yaml pairs consisting of: A fully qualified exception class name that should not be reported to APM AND A list of exception messages to match against (at least one is required) If the exception class name matches an error but the message does not, then that error will not be ignored. Message strings use contains for matching. A message cannot be provided on its own and must always be paired with a fully qualified class name. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: ignore_messages: com.example.MyException: - \"Some error message to ignore\" - \"Some other error message to ignore\" com.example.DifferentException: - \"Some different error message to ignore\" Copy ignore_status_codes Type Comma-separated list of strings and ranges Default 404 A comma-separated list comprised of individual and dashed ranges of HTTP status codes that should not be treated as errors. If this property is commented out in the newrelic.yml configuration file, then the 404 status code will automatically be ignored. When using server-side configuration, the status code 404 must be specified in order for it to be ignored. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: ignore_status_codes: 404,507-511 Copy expected_classes Type Stanza containing a List of fully qualified class_name strings Default (none) Prevents specified exception classes from affecting error rate or Apdex score while still reporting the errors to APM. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: expected_classes: - \"com.example.MyException\" - \"com.example.DifferentException\" Copy expected_messages Type Stanza containing a fully qualified class_name and a List of messages per error class Default (none) Contains yaml pairs consisting of a fully qualified exception class name that should be marked as expected and thus prevented from affecting error rate or Apdex score and a List of exception messages to match against, the latter of which at least one is required. If the exception class name matches an error but the message does not, then that error will not be marked as expected and therefore will affect error rate and Apdex score. Message strings use contains for matching. A message cannot be provided on its own and must always be paired with a fully qualified class name. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: expected_messages: com.example.MyException: - \"Some expected error message\" - \"Some other expected error message\" com.example.DifferentException: - \"Some different expected error message\"​ Copy expected_status_codes Type Comma-separated list of strings and ranges Default (none) A comma-separated list comprised of individual and dashed ranges of HTTP status codes to be marked as expected and thus prevented from affecting error rate or Apdex score. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: expected_status_codes: 415,500-506 Copy attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for traced errors. If attributes.enabled is false at the root level, then no attributes will be sent to traced errors regardless of how this property is set under error_collector. attributes.include Type List of strings Default (none) If attributes are enabled for traced errors, all attribute keys found in this list will be sent to New Relic in traced errors. For more information, see the agent attribute rules. attributes.exclude Type List of strings Default (none) Attribute keys found in this list will not be sent to New Relic in traced errors. For more information, see the agent attribute rules. ignore_errors (DEPRECATED) Type Comma-separated list of Strings Default (none) All specified exception class names specified will not be treated as errors. Deprecated as of Java agent 3.40.0 and replaced by ignore_classes. For example: error_collector: ignore_errors: some.other.MyException Copy Strip exceptions These options are set in the strip_exception_messages stanza and unless noted otherwise can be overridden by using a newrelic.config.strip_exception_messages​prefixed system property. This configuration can be enabled to control whether Java exception messages are reported to New Relic. enabled Type Boolean Default false By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you set this to true, the agent strips the messages from exceptions in order to prevent it from inadvertently capturing sensitive information. If you enable high security mode, this is automatically set to true. If you set enabled to true but you want the agent to capture messages from specific exceptions, add the exceptions to your allow list. whitelist (DEPRECATED) Type String Default (none) Important This config has been deprecated as of agent version 5.10.0 and will be removed in a future agent version. Instead use allowed_classes. If you set enabled to true but you want the agent to capture messages for specific exceptions, add each exception to the whitelist, separated by a comma. allowed_classes Type String Default (none) If you set enabled to true but you want the agent to capture messages for specific exceptions, add each exception to allowed_classes, separated by a comma. Thread profiler These options are set in the thread_profiler stanza and can be overridden by using a newrelic.config.thread_profiler prefixed system property. Thread profiler measures wall clock time, CPU time, and method call counts in your application's threads as they run. enabled Type Boolean Default true Enable the thread profiler. Transaction events These options are set in the transaction_events stanza and can be overridden by using a newrelic.config.transaction_events prefixed system property. Transaction events provide the data for displaying histograms and percentiles in the UI. Important Previously this stanza was called analytics_events. If your configuration file still uses analytics_events, update your agent to use transaction_events. enabled Type Boolean Default true Enable the transaction events service. max_samples_stored Type Integer Default 2000 Max 10000 The maximum number of sampled transaction events reported every 60 seconds. custom_request_headers Type List of maps Default None Important Unlike other settings, custom_request_headers have to be paired together and must be set in the newrelic.yml file. They can't be overwritten by Java virtual machine arguments (system property) or environment variables. A list of maps with the paired keys header_name and the optional header_alias. Choose one or more custom HTTP request headers to add as transaction attributes. You can list multiple header configurations: transaction_events: custom_request_headers: - header_name: \"X-Custom-Header-1\" - header_name: \"X-Custom-Header-2\" header_alias: \"CustomHeader2alias\" Copy In the first map set, X-Custom-Header-1 is captured and reported by the agent as the header name for a corresponding value from the request object. The header_name will also be the name of the attribute sent to New Relic. In the second map set, the request header is X-Custom-Header-2, but the CustomHeader2alias is the name sent to New Relic. attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for transaction events. If attributes.enabled is false at the root level, then no attributes will be sent to transaction events regardless of how this property is set under transaction_events. attributes.include Type List of Strings Default (none) If attributes are enabled for transaction events, all attribute keys found in this list will be sent to New Relic in transaction events. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in transaction events. For more information, see the agent attribute rules. Custom events Custom events are set in the custom_insights_events stanza and can be overridden by using a newrelic.config.custom_insights_events prefixed system property. APM lets you record custom event data via the New Relic language agent APIs, which you can then query. Important For Java agent versions prior to 4.1.0, the following YAML configuration is recognized: custom_insights_events.enabled: true custom_insights_events.max_samples_stored: 5000 Copy For agent versions 4.1.0 and above, the YAML configuration uses the nested stanza formatting: custom_insights_events: enabled: false max_samples_stored: 5000 Copy enabled Type Boolean Default true This enables the custom event service. max_samples_stored Type Integer Default/Max 10000 The maximum number of sampled custom events reported every 60 seconds. Hostname configuration These options are set in the process_host stanza and can be overridden by using a newrelic.config.process_host prefixed system property. These properties are used for configuring the hostname displayed in the UI: display_name Type String Default (none) Set a display name to decorate the \"host:port\" label in the New Relic UI. ipv_preference Type String Default 4 If the hostname cannot be determined, then the IP address of the host will be used. This property determines whether the IPv4 or IPv6 address should be used. The default is IPv4. Custom instrumentation These options set in the class_transformer stanza and can be overridden by using a newrelic.config.class_transformer prefixed system property. trace_annotation_class_name Type String Default (none) String containing the full class name of the annotation class the agent uses to determine which user-specified methods to instrument. For more information about custom annotations, see Java custom metric collection. com.newrelic.instrumentation.servlet-user Type Boolean Default false Enable this option to capture the userPrincipal name. This name is included as a transaction trace attribute, and can be queried. System properties You can override any setting in the newrelic.yml file by setting a system property. The system property corresponding to a given setting in the config file is the setting name prefixed by newrelic.config. For example, the system property for the log_level setting is newrelic.config.log_level. For settings nested in stanzas, prepend the stanza name to the setting name. For example, the system property for the enabled setting in the transaction_tracer stanza is newrelic.config.transaction_tracer.enabled. In addition to overriding configuration settings, the following system properties are recognized by the agent: newrelic.config.process_host.display_name Type String Default (none) Set a display name to decorate the \"host:port\" label in the New Relic UI. Requires Java agent 3.17 or higher. newrelic.config.file Type String Default (none) String containing a fully qualified path to the newrelic configuration file. If empty, the agent assumes newrelic.yml is in the same directory as newrelic.jar. newrelic.debug Type Boolean Default (none) Enable debug logging. newrelic.environment Type String Default (none) String containing the environment configuration for the agent to use. newrelic.home Type String Default (none) String containing the home directory of agent. This defaults to the same directory as the agent jarfile. newrelic.logfile Type String Default newrelic_agent.log String containing the name of the agent log file. Environment variables Environment variables take the highest precedence and override the system properties and yml config settings. To set environment variables, use the export VARNAME=value command. To permanently set environment variables, add the export line to a file such as ~/.bashrc or ~/.bash_profile. You can override any setting from a system property or in the newrelic.yml by setting an environment variable. The environment variable corresponding to a given setting in the config file is the setting name prefixed by NEW_RELIC with all dots (.) and dashes (-) replaced by underscores (_). For example, the environment variable for the log_level setting is NEW_RELIC_LOG_LEVEL. For settings nested in stanzas, prepend the stanza name to the setting name. For example, the environment variable for the enabled setting in the transaction_tracer stanza is NEW_RELIC_TRANSACTION_TRACER_ENABLED. Important Agent configuration via environment variables requires Java agent version 4.10.0 or higher. For agent versions older than 4.10.0 the following environment variables are available: NEW_RELIC_APP_NAME (REQUIRED) Type String Default (none) This setting is required. Contains the application name under which to report data to New Relic. Set the name of your application as you want it to appear in New Relic. If enable_auto_app_naming is false, the agent reports all data to this application. Otherwise, the agent reports only background tasks (transactions for non-web applications) to this application. To report data to more than one application, separate the application names with a semicolon ;. For example, to report data to My Application and My Application 2: app_name: My Application;My Application 2 Copy For more methods of naming your application, see Name your Java application. NEW_RELIC_DISTRIBUTED_TRACING_ENABLED Type String Default false Enables distributed tracing. Case sensitive: use true or false. For more information, see the distributed tracing section. NEW_RELIC_PROCESS_HOST_DISPLAY_NAME Type String Default (none) Set a display name to decorate the \"host:port\" label in the New Relic UI. NEW_RELIC_LICENSE_KEY (REQUIRED) Type String Default (none) This setting is required. Contains your New Relic account license. You must specify the license key associated with your New Relic account. This key binds your agent's data to your account in the New Relic service. NEW_RELIC_LOG Type String Default newrelic_agent.log The unqualified log file name or the string STDOUT which will log to standard out. Cloud platform utilization These options are set in the utilization stanza and can be overridden by using a newrelic.config.utilization prefixed system property. The agent collects utilization information and sends it to the New Relic service. The agent can collect information from Amazon Web Services (AWS) EC2 instances and Docker containers. detect_aws Type Boolean Default true Determines whether the agent polls AWS metadata API. detect_docker Type Boolean Default true Determines whether the agent reads Docker information from the file system. Async instrumentation These options are set directly in the common stanza and can be overridden by using a prefixed system property. token_timeout Type Integer Default (seconds) 180 The number of seconds after which the agent will automatically expire an async token that has not been explicitly expired with token.expire(). For usage instructions, see Tokens: Connect async threads. Important Increasing this value may impact performance, because it increases the amount of memory the agent uses and prevents transactions from being reported due to unexpired tokens. segment_timeout Type Integer Default (seconds) 600 The number of seconds after which the agent will automatically end a segment that has not been explicitly ended with segment.end() or segment.ignore(). For usage instructions, see Segments: Time arbitrary async activity. Important Increasing this value may impact performance, because it increases the amount of memory the agent uses and prevents transactions from being reported due to un-ended segments. Circuit breaker These settings customize the behavior of the Java circuit breaker. These settings are not included in newrelic.yml by default. You do not need to restart your JVM after changing them. If you want to customize the circuit breaker, add the stanza under the common stanza: common: &default_settings​ ​ OTHER_CONFIG_SETTINGS circuitbreaker: enabled: true memory_threshold: 20 gc_cpu_threshold: 10 Copy enabled Type Boolean Default true If your application is behaving as expected, you may want to disable the circuit breaker. memory_threshold Type Integer (0 to 100) Default 20 Customize the precentage of free heap memory below which the circuit breaker should trip. When the percentage of free heap memory is less than memory_threshold, and the CPU time spent doing garbage collection is greater than gc_cpu_threshold, the circuit breaker trips. In order to make the circuit breaker less likely to trip, decrease memory_threshold and/or increase gc_cpu_threshold. Adjust these values as needed, based on your application's operating performance and behavior. gc_cpu_threshold Type Integer (0 to 100) Default 10 Customize the precentage of garbage collection CPU time above which the circuit breaker should trip. When the percentage of free heap memory is less than memory_threshold, and the CPU time spent doing garbage collection is greater than gc_cpu_threshold, the circuit breaker trips. In order to make the circuit breaker less likely to trip, decrease memory_threshold and/or increase gc_cpu_threshold. Adjust these values as needed, based on your application's operating performance and behavior. Message tracer These options are set in the message_tracer stanza and can be overridden by using a newrelic.config.message_tracer prefixed system property. segment_parameters.enabled Type Boolean Default true Adds message properties to tracer attributes. Set this to false to turn it off. Distributed tracing Important Enabling distributed tracing disables cross application tracing, and has other effects on APM features. Before enabling, read the transition guide. Requires Java agent version 4.3.0 or higher. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. In the config file, it can be set in the distributed_tracing stanza. It can be overridden using a newrelic.config.distributed_tracing prefixed system property. enabled Type Boolean Default false Set this to true to enable distributed tracing. For example, to enable this in the config file, you would use: distributed_tracing: enabled: true Copy To enable this using a system property, you would use: -Dnewrelic.config.distributed_tracing.enabled=true Copy exclude_newrelic_header Type Boolean Default false By default, supported versions of the agent utilize both the newrelic header and W3C Trace Context headers for distributed tracing. The newrelic distributed tracing header allows interoperability with older agents that don't support W3C Trace Context headers. Agent versions that support W3C Trace Context headers will prioritize them over newrelic headers for distributed tracing. If you do not want to utilize the newrelic header, setting this to true will result in the agent excluding the newrelic header and only using W3C Trace Context headers for distributed tracing. For example, to exclude newrelic headers in the config file, you would use: distributed_tracing: exclude_newrelic_header: true Copy To exclude newrelic headers using a system property, you would use: -Dnewrelic.config.distributed_tracing.exclude_newrelic_header=true Copy Infinite Tracing Important Requirements: Java Agent 5.12.1 or higher. Infinite Tracing does not work if enable_auto_app_naming is enabled. To turn on Infinite Tracing, enable distributed tracing and add the additional setting below. For an example, see Language Agents: Configure Distributed Tracing. trace_observer.host Type String Default None For help getting a valid Infinite Tracing trace observer host entry, see find or create a Trace Observer. You can configure this via YAML: infinite_tracing: trace_observer: host: YOUR_TRACE_OBSERVER_HOST Copy You can also use the system property newrelic.config.infinite_tracing.trace_observer.host or the environment variable NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_HOST. Span events Span events are reported for distributed tracing. Distributed tracing must be enabled to report span events. Span configuration is set in the span_events stanza and can be overridden by using a newrelic.config.span_events prefixed system property. Options include: enabled Type Boolean Default true Used to enable/disable span event reporting. attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for span events. If attributes.enabled at the root level is false, no attributes will be sent to span events regardless on how this property (span_events.attributes.enabled) is set. attributes.include Type List of strings Default (none) If attributes are enabled for span events, all attribute keys found in this list will be sent to New Relic in span_events. For more information, see the agent attribute rules. attributes.exclude Type List of strings Default (none) All attribute keys found in this list will not be sent to New Relic in span events. For more information, see the agent attribute rules. Important Span event attribute filtering requires Java agent version 4.10.0 or higher. Jar collector The Java agent collects and information about jars and their versions on the application classpath. Jar collection configuration is set in the jar_collector stanza and can be overridden by using a newrelic.config.jar_collector prefixed system property. Options include: enabled Type Boolean Default true Used to enable/disable jar collection and reporting. skip_temp_jars Type Boolean Default true Used to enable/disable collection of temporary jars. Temporary jars are those residing in the directory specified by the system property java.io.tmpdir. jars_per_second Type Integer Default 10 The maximum number of jars to process per second. Must be positive.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 94.536995,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> <em>configuration</em>: Config file",
        "sections": "<em>Java</em> <em>agent</em> <em>configuration</em>: Config file",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> reads its <em>configuration</em> from the newrelic.yml file. By default the <em>agent</em> looks for this file in the directory that contains newrelic.jar. You can override the config file&#x27;s location by setting the newrelic.config.file system property to a fully qualified file name"
      },
      "id": "603eb739e7b9d2a2432a07e0"
    },
    {
      "sections": [
        "Java agent config file template"
      ],
      "title": "Java agent config file template",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "cab129eda0df59e172b299574d8e44fbb3c04617",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-config-file-template/",
      "published_at": "2021-05-05T06:49:05Z",
      "updated_at": "2021-03-16T13:47:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains a templated version of the newrelic.yml file that the Java agent reads for configuration. The config file format is YAML. While no knowledge of YAML is necessary to edit the file, be careful to maintain the proper indentation. Learn more about YAML on Wikipedia. When making changes to the newrelic.yml file, use a YAML validator to ensure the syntax is accurate and follow these rules: YML files are case sensitive. All indentations are in increments of two characters. Data in the same stanza of the file must use the same level of indentation, and sub-stanzas should be indented by an additional two spaces. For more information about structure, directories, and settings, see Java agent configuration. # This file configures the New Relic Agent. New Relic monitors # Java applications with deep visibility and low overhead. For more details and additional # configuration options visit https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-configuration-config-file. # # <%= generated_for_user %> # # This section is for settings common to all environments. # Do not add anything above this next line. common: &default_settings # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic # account. For example, if your license key is 12345 use this: # license_key: '12345' # The key binds your Agent's data to your account in the New Relic service. license_key: '<%= license_key %>' # Agent Enabled # Use this setting to disable the agent instead of removing it from the startup command. # Default is true. agent_enabled: true # Set the name of your application as you'd like it show up in New Relic. # If enable_auto_app_naming is false, the agent reports all data to this application. # Otherwise, the agent reports only background tasks (transactions for non-web applications) # to this application. To report data to more than one application # (useful for rollup reporting), separate the application names with \";\". # For example, to report data to \"My Application\" and \"My Application 2\" use this: # app_name: My Application;My Application 2 # This setting is required. Up to 3 different application names can be specified. # The first application name must be unique. app_name: My Application # To enable high security, set this property to true. When in high # security mode, the agent will use SSL and obfuscated SQL. Additionally, # request parameters and message parameters will not be sent to New Relic. high_security: false # Set to true to enable support for auto app naming. # The name of each web app is detected automatically # and the agent reports data separately for each one. # This provides a finer-grained performance breakdown for # web apps in New Relic. # Default is false. enable_auto_app_naming: false # Set to true to enable component-based transaction naming. # Set to false to use the URI of a web request as the name of the transaction. # Default is true. enable_auto_transaction_naming: true # The agent uses its own log file to keep its logging # separate from that of your application. Specify the log level here. # This setting is dynamic, so changes do not require restarting your application. # The levels in increasing order of verboseness are: # off, severe, warning, info, fine, finer, finest # Default is info. log_level: info # Log all data sent to and from New Relic in plain text. # This setting is dynamic, so changes do not require restarting your application. # Default is false. audit_mode: false # The number of backup log files to save. # Default is 1. log_file_count: 1 # The maximum number of kbytes to write to any one log file. # The log_file_count must be set greater than 1. # Default is 0 (no limit). log_limit_in_kbytes: 0 # Override other log rolling configuration and roll the logs daily. # Default is false. log_daily: false # The name of the log file. # Default is newrelic_agent.log. log_file_name: newrelic_agent.log # The log file directory. # Default is the logs directory in the newrelic.jar parent directory. #log_file_path: # Proxy settings for connecting to the New Relic server: # If a proxy is used, the host setting is required. Other settings # are optional. Default port is 8080. The username and password # settings will be used to authenticate to Basic Auth challenges # from a proxy server. Proxy scheme will allow the agent to # connect through proxies using the HTTPS scheme. #proxy_host: hostname #proxy_port: 8080 #proxy_user: username #proxy_password: password #proxy_scheme: https # Limits the number of lines to capture for each stack trace. # Default is 30 max_stack_trace_lines: 30 # Provides the ability to configure the attributes sent to New Relic. These # attributes can be found in transaction traces, traced errors, Insight's # transaction events, and Insight's page views. attributes: # When true, attributes will be sent to New Relic. The default is true. enabled: true #A comma separated list of attribute keys whose values should # be sent to New Relic. #include: # A comma separated list of attribute keys whose values should # not be sent to New Relic. #exclude: # Transaction tracer captures deep information about slow # transactions and sends this to the New Relic service once a # minute. Included in the transaction is the exact call sequence of # the transactions including any SQL statements issued. transaction_tracer: # Transaction tracer is enabled by default. Set this to false to turn it off. # This feature is not available to Lite accounts and is automatically disabled. # Default is true. enabled: true # Threshold in seconds for when to collect a transaction # trace. When the response time of a controller action exceeds # this threshold, a transaction trace will be recorded and sent to # New Relic. Valid values are any float value, or (default) \"apdex_f\", # which will use the threshold for the \"Frustrated\" Apdex level # (greater than four times the apdex_t value). # Default is apdex_f. transaction_threshold: apdex_f # When transaction tracer is on, SQL statements can optionally be # recorded. The recorder has three modes, \"off\" which sends no # SQL, \"raw\" which sends the SQL statement in its original form, # and \"obfuscated\", which strips out numeric and string literals. # Default is obfuscated. record_sql: obfuscated # Set this to true to log SQL statements instead of recording them. # SQL is logged using the record_sql mode. # Default is false. log_sql: false # Threshold in seconds for when to collect stack trace for a SQL # call. In other words, when SQL statements exceed this threshold, # then capture and send to New Relic the current stack trace. This is # helpful for pinpointing where long SQL calls originate from. # Default is 0.5 seconds. stack_trace_threshold: 0.5 # Determines whether the agent will capture query plans for slow # SQL queries. Only supported for MySQL and PostgreSQL. # Default is true. explain_enabled: true # Threshold for query execution time below which query plans will not # not be captured. Relevant only when `explain_enabled` is true. # Default is 0.5 seconds. explain_threshold: 0.5 # Use this setting to control the variety of transaction traces. # The higher the setting, the greater the variety. # Set this to 0 to always report the slowest transaction trace. # Default is 20. top_n: 20 # Error collector captures information about uncaught exceptions and # sends them to New Relic for viewing. error_collector: # This property enables the collection of errors. If the property is not # set or the property is set to false, then errors will not be collected. # Default is true. enabled: true # Use this property to exclude specific exceptions from being reported as errors # by providing a comma separated list of full class names. # The default is to exclude akka.actor.ActorKilledException. If you want to override # this, you must provide any new value as an empty list is ignored. ignore_errors: akka.actor.ActorKilledException # Use this property to exclude specific http status codes from being reported as errors # by providing a comma separated list of status codes. # The default is to exclude 404s. If you want to override # this, you must provide any new value as an empty list is ignored. ignore_status_codes: 404 # Transaction Events are used for Histograms and Percentiles. Unaggregated data is collected # for each web transaction and sent to the server on harvest. transaction_events: # Set to false to disable transaction events. # Default is true. enabled: true # Events are collected up to the configured amount. Afterwards, events are sampled to # maintain an even distribution across the harvest cycle. # Default is 2000. Setting to 0 will disable. max_samples_stored: 2000 # Distributed tracing lets you see the path that a request takes through your distributed system. # Enabling distributed tracing changes the behavior of some New Relic features, so carefully consult the transition # guide before you enable this feature: https://docs.newrelic.com/docs/apm/distributed-tracing/getting-started/transition-guide-distributed-tracing # Default is false. distributed_tracing: enabled: false # Cross Application Tracing adds request and response headers to # external calls using supported HTTP libraries to provide better # performance data when calling applications monitored by other New Relic Agents. cross_application_tracer: # Set to false to disable cross application tracing. # Default is true. enabled: true # Thread profiler measures wall clock time, CPU time, and method call counts # in your application's threads as they run. # This feature is not available to Lite accounts and is automatically disabled. thread_profiler: # Set to false to disable the thread profiler. # Default is true. enabled: true # New Relic Real User Monitoring gives you insight into the performance real users are # experiencing with your website. This is accomplished by measuring the time it takes for # your users' browsers to download and render your web pages by injecting a small amount # of JavaScript code into the header and footer of each page. browser_monitoring: # By default the agent automatically inserts API calls in compiled JSPs to # inject the monitoring JavaScript into web pages. Not all rendering engines are supported. # See https://docs.newrelic.com/docs/agents/java-agent/instrumentation/new-relic-browser-java-agent#manual_instrumentation # for instructions to add these manually to your pages. # Set this attribute to false to turn off this behavior. auto_instrument: true class_transformer: # This instrumentation reports the name of the user principal returned from # HttpServletRequest.getUserPrincipal() when servlets and filters are invoked. com.newrelic.instrumentation.servlet-user: enabled: false com.newrelic.instrumentation.spring-aop-2: enabled: false # This instrumentation reports metrics for resultset operations. com.newrelic.instrumentation.jdbc-resultset: enabled: false # Classes loaded by classloaders in this list will not be instrumented. # This is a useful optimization for runtimes which use classloaders to # load dynamic classes which the agent would not instrument. classloader_excludes: groovy.lang.GroovyClassLoader$InnerLoader, org.codehaus.groovy.runtime.callsite.CallSiteClassLoader, com.collaxa.cube.engine.deployment.BPELClassLoader, org.springframework.data.convert.ClassGeneratingEntityInstantiator$ObjectInstantiatorClassGenerator, org.mvel2.optimizers.impl.asm.ASMAccessorOptimizer$ContextClassLoader, gw.internal.gosu.compiler.SingleServingGosuClassLoader, # User-configurable custom labels for this agent. Labels are name-value pairs. # There is a maximum of 64 labels per agent. Names and values are limited to 255 characters. # Names and values may not contain colons (:) or semicolons (;). labels: # An example label #label_name: label_value # Application Environments # ------------------------------------------ # Environment specific settings are in this section. # You can use the environment to override the default settings. # For example, to change the app_name setting. # Use -Dnewrelic.environment=<environment> on the Java startup command line # to set the environment. # The default environment is production. # NOTE if your application has other named environments, you should # provide configuration settings for these environments here. development: <<: *default_settings app_name: My Application (Development) test: <<: *default_settings app_name: My Application (Test) production: <<: *default_settings staging: <<: *default_settings app_name: My Application (Staging) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 94.51563,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> config file template",
        "sections": "<em>Java</em> <em>agent</em> config file template",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " options visit https:&#x2F;&#x2F;docs.newrelic.com&#x2F;docs&#x2F;<em>agents</em>&#x2F;<em>java</em>-<em>agent</em>&#x2F;<em>configuration</em>&#x2F;<em>java</em>-<em>agent</em>-<em>configuration</em>-config-file. # # &lt;%= generated_for_user %&gt; # # This section is for settings common to all environments. # Do not add anything above this next line. common: &amp;default_settings"
      },
      "id": "603eb738e7b9d242542a0815"
    }
  ],
  "/docs/agents/java-agent/configuration/java-agent-config-file-template": [
    {
      "sections": [
        "Configuring your SSL certificates",
        "Notice of expired SSL certificates and certificate removal",
        "Caution",
        "Important",
        "Java Agent versions 6.2.0 - 6.4.2",
        "Java Agent versions 6.0.0/6.1.0",
        "Using YAML-based configuration",
        "Java Agent versions prior to 6.0.0 (Deprecated)",
        "For more help"
      ],
      "title": "Configuring your SSL certificates",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "af154f250e87f571db157972e22dbb1f907a8fde",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/configuring-your-ssl-certificates/",
      "published_at": "2021-05-05T06:44:59Z",
      "updated_at": "2021-04-28T23:01:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To communicate with the New Relic collector over HTTPS, you need to have the proper certificates for trusted signers in the trust store on your app server. By default, most JREs contain a valid root certificate that allows the agent to connect to newrelic.com. For SSL connection issues, please visit SSL or connection errors (Java). Notice of expired SSL certificates and certificate removal Caution The SSL certificates that were bundled with Java agent versions 6.1.0 to 6.4.2 have expired and are no longer valid. This means that Java agent versions 6.1.0 to 6.4.2 can no longer use the certificates bundled with the agent to establish a connection with New Relic and that you must provide your own SSL certificates. Please see this community forum post for additional details. Important Java agent versions higher than 6.4.2 no longer ship with SSL certificates bundled into the agent. You must provide your own SSL truststore to the agent by explicitly using the ca_bundle_path configuration option, or by using the default truststore provided by the JDK/JRE (the agent will look to use the latter by default). Additionally the use_private_ssl configuration option has been removed from Java agent versions higher than 6.4.2. Users wishing to add the global certificate to their local trust store can download the DigiCert Global Root CA from DigiCert. Java Agent versions 6.2.0 - 6.4.2 Starting with Java agent version 6.2.0, the use_private_ssl configuration option has been reintroduced so you can use the SSL certificates that are bundled into the agent jar. The following bundled SSL certificates are valid for up to a year after release. META-INF/certs/eu-newrelic-com.pem META-INF/certs/eu01-nr-data-net.pem META-INF/certs/newrelic-com.pem Copy Important The Java agent will begin logging a warning message upon application startup when there are less than three months before the bundled certificate expires. When the bundled certificates expire, the Java agent will no longer be able to connect to New Relic and you must either update to the latest agent version or provide a valid certificate using the ca_bundle_path configuration. Users wishing to add the global certificate to their local trust store can download the DigiCert Global Root CA from DigiCert. Using YAML-based configuration common: default_settings ca_bundle_path: /path/to/digicert.pem use_private_ssl: false # # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic ... Copy Summary There are two configuration settings that determine what certs are used by the agent to establish a secure connection to New Relic. They are: use_private_ssl and ca_bundle_path. Here's how they work together: DEFAULT: Neither configuration option (ca_bundle_path/use_private_ssl) is provided, because both are using default values. The agent will use the default SSL certificates bundled into the Java Development Kit (JDK). If these certificates aren't present or don't include certificates that trust New Relic, then the agent will not connect. You'll need to merge valid certificates into your JDK certificate bundle. Only use_private_ssl is configured. The agent will use the SSL certificates that are bundled with it. Only ca_bundle_path is configured. The agent will try to connect using the custom SSL certificates bundle at the configured path. If the configured custom certificate bundle doesn’t include certificates that trust New Relic, then the agent will not connect. You'll need to merge valid certificates into your custom certificate bundle. Both use_private_ssl and ca_bundle_path are configured. The ca_bundle_path configuration setting takes precedence and the use_private_ssl config is ignored. This behavior is the same as only specifying ca_bundle_path. Java Agent versions 6.0.0/6.1.0 Starting in 6.0.0, the Java agent no longer includes the nrcert global certificate chain. Users wishing to add the global certificate to their local trust store must download the DigiCert Global Root CA from DigiCert. Note: In versions 6.1.0+, the Java agent will use a bundled New Relic certificate that is valid for up to a year after release. Before the certificate expires, you must either update the agent to the latest version or provide a valid certificate using the ca_bundle_path configuration. Important The Java agent will begin logging a warning message upon application startup when there are less than three months before the bundled certificate expires. Using YAML-based configuration common: default_settings ca_bundle_path: /path/to/digicert.pem # # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic ... Copy Java Agent versions prior to 6.0.0 (Deprecated) For Java agent versions prior to 6.0.0, applications that require valid certificates may add them in one of the following two ways: Use YAML-based configuration. Add the bundled list of New Relic trusted signers to the local store. Using YAML-based configuration The New Relic Java agent bundles the list of trusted signers in the agent newrelic.jar file. If you do not want to change the local trust store, you can activate them by setting use_private_ssl to true in the newrelic.yml agent configuration file: common: default_settings use_private_ssl: true # # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic ... Copy For more help Additional documentation resources include New Relic for Java (compatibility and requirements, installation, and configuration.)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 133.55931,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Configuring</em> your SSL certificates",
        "sections": "<em>Java</em> <em>Agent</em> versions 6.2.0 - 6.4.2",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " provide your own SSL truststore to the <em>agent</em> by explicitly using the ca_bundle_path <em>configuration</em> option, or by using the default truststore provided by the JDK&#x2F;JRE (the <em>agent</em> will look to use the latter by default). Additionally the use_private_ssl <em>configuration</em> option has been removed from <em>Java</em>"
      },
      "id": "603eb7a2e7b9d247c02a080d"
    },
    {
      "sections": [
        "Java agent configuration: Config file",
        "Configuration file structure",
        "Tip",
        "Configuration settings precedence",
        "Configuring the Java extensions directory",
        "Create an extensions directory",
        "Specify an existing extensions directory",
        "General configuration settings",
        "license_key (REQUIRED)",
        "app_name (REQUIRED)",
        "agent_enabled",
        "apdex_t (DEPRECATED)",
        "appserver_port",
        "Important",
        "audit_mode",
        "ca_bundle_path",
        "use_private_ssl",
        "enable_auto_app_naming",
        "enable_auto_transaction_naming",
        "Caution",
        "enable_custom_tracing",
        "extensions.dir",
        "high_security",
        "insert_api_key",
        "labels",
        "max_stack_trace_lines",
        "proxy_host",
        "proxy_password",
        "proxy_port",
        "proxy_user",
        "proxy_scheme",
        "reactor-netty.errors.enabled",
        "send_data_on_exit",
        "send_data_on_exit_threshold",
        "send_environment_info",
        "send_jvm_props",
        "ssl (DEPRECATED)",
        "sync_startup",
        "scala_futures_as_segments",
        "Logging configuration",
        "log_daily",
        "log_file_count",
        "log_file_name",
        "log_file_path",
        "log_level",
        "log_limit_in_kbytes",
        "JMX",
        "enabled",
        "linkingMetadataMBean",
        "Attributes",
        "include",
        "exclude",
        "Transaction tracer",
        "explain_enabled",
        "explain_threshold",
        "insert_sql_max_length",
        "log_sql",
        "record_sql",
        "stack_based_naming (Play 2.x+ only)",
        "stack_trace_threshold",
        "top_n",
        "transaction_threshold",
        "slow_query_whitelist (DEPRECATED)",
        "collect_slow_queries_from",
        "attributes.enabled",
        "attributes.include",
        "attributes.exclude",
        "token_limit",
        "segment_limit",
        "Transaction segments",
        "Browser monitoring",
        "auto_instrument",
        "disabled_auto_pages",
        "External tracer",
        "exclude_request_uri",
        "Cross application tracer",
        "Error collector",
        "ignore_classes",
        "ignore_messages",
        "ignore_status_codes",
        "expected_classes",
        "expected_messages",
        "expected_status_codes",
        "ignore_errors (DEPRECATED)",
        "Strip exceptions",
        "whitelist (DEPRECATED)",
        "allowed_classes",
        "Thread profiler",
        "Transaction events",
        "max_samples_stored",
        "custom_request_headers",
        "Custom events",
        "Hostname configuration",
        "display_name",
        "ipv_preference",
        "Custom instrumentation",
        "trace_annotation_class_name",
        "com.newrelic.instrumentation.servlet-user",
        "System properties",
        "newrelic.config.process_host.display_name",
        "newrelic.config.file",
        "newrelic.debug",
        "newrelic.environment",
        "newrelic.home",
        "newrelic.logfile",
        "Environment variables",
        "NEW_RELIC_APP_NAME (REQUIRED)",
        "NEW_RELIC_DISTRIBUTED_TRACING_ENABLED",
        "NEW_RELIC_PROCESS_HOST_DISPLAY_NAME",
        "NEW_RELIC_LICENSE_KEY (REQUIRED)",
        "NEW_RELIC_LOG",
        "Cloud platform utilization",
        "detect_aws",
        "detect_docker",
        "Async instrumentation",
        "token_timeout",
        "segment_timeout",
        "Circuit breaker",
        "memory_threshold",
        "gc_cpu_threshold",
        "Message tracer",
        "segment_parameters.enabled",
        "Distributed tracing",
        "exclude_newrelic_header",
        "Infinite Tracing",
        "trace_observer.host",
        "Span events",
        "Jar collector",
        "skip_temp_jars",
        "jars_per_second"
      ],
      "title": "Java agent configuration: Config file",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "1d61f848fa192438225eae269421b8d384915c8b",
      "image": "https://docs.newrelic.com/static/60ca967eab99ca225186310913ae2de6/8c557/java-config-cascade.png",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-configuration-config-file/",
      "published_at": "2021-05-04T17:01:42Z",
      "updated_at": "2021-03-16T15:52:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent reads its configuration from the newrelic.yml file. By default the agent looks for this file in the directory that contains newrelic.jar. You can override the config file's location by setting the newrelic.config.file system property to a fully qualified file name. Configuration file structure The newrelic.yml file is split into stanzas corresponding to different environments: Test Development Staging Production (default) New Relic applies settings in the common stanza to each of these environments. You can select other environments as the default by setting the newrelic.environment system property to the environment name. Tip A newrelic.yml template is available. If you edit newrelic.yml, be careful to conform to the YAML format. Use a YAML validator to ensure the syntax is accurate before using the file with New Relic's Java agent, and follow these rules: Java agent newrelic.yml Requirements Format YML files are case sensitive. Indentations All indentations must be in increments of two characters. Other indentations will result in an Unable to parse configuration file error upon agent startup. Use the same level of indentation for data in the same stanza of the file. Indent any sub-stanzas by an additional two spaces. Changes to file You must restart your JVM host process for changes to take effect. Exception: Property changes to log_level and audit_mode do not require a restart. Property changes under circuit breaker don't require a restart. Configuration settings precedence To override any setting in the config file, use a system property override. In certain environments, environment variables can also be used to override both the config file and the system properties. The environment variables primarily exist to support Heroku. When used, server-side configuration overrides all other configuration settings. With the Java agent, server-side configuration overrides all other settings. Environment variables override Java system properties. Java properties override user configuration settings in your newrelic.yml file. User settings override the newrelic.yml default settings. Configuring the Java extensions directory The Java agent reads the configuration files on process startup. To identify the directory where the files are located, either create a new or specify an existing extensions directory: Create an extensions directory To create the extensions directory: Navigate to the directory where newrelic.jar and newrelic.yml are located. Create a directory named extensions. In newrelic.yml, check that the property extensions.dir is not set. Specify an existing extensions directory To use an existing Java extensions directory: In your newrelic.yml file, locate the common section. Use the property extensions.dir to specify the location of the file. General configuration settings Set these options in the common stanza. To override any of these options, use a newrelic.config prefixed system property. license_key (REQUIRED) Type String Default (none) This setting is required. You must specify the license key associated with your New Relic account. This key binds your agent's data to your account in the New Relic service. app_name (REQUIRED) Type String Default (none) This setting is required. Defines the application name used to report data to New Relic. If enable_auto_app_naming is false, the agent reports all data to this application. Otherwise, the agent reports only background tasks (transactions for non-web applications) to this application. To report data to more than one application, separate the application names with a semicolon. For example, to report data to My Application and My Application 2 use this: app_name: My Application;My Application 2 Copy For more methods of naming your application, see Name your Java application. agent_enabled Type Boolean Default true Flag to enable the agent. Use this setting to force the agent to run or not run. apdex_t (DEPRECATED) Type Float Default 1.0 The apdex_t threshold in seconds for the application's Apdex score. For Java agent versions 1.2.008 or higher, the apdex_t value is set in the UI and the value in newrelic.yml is ignored. appserver_port Type Integer Default (none) Number to differentiate JVMs for the same app on the same machine. New Relic uses host/port for uniqueness, so you can distinguish the JVMs by putting a switch like this into the startup arguments for each JVM: -Dnewrelic.config.appserver_port=8081 Copy Once you have used appserver_port to name the JVMs and restart them, you should be able to see them individually in the dropdown and in the profiling interface. Important This is only a change for New Relic; it doesn't actually affect the port on which the host communicates in any way. audit_mode Type Boolean Default false Enables plain text logging of all data sent to New Relic to the agent logfile. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. ca_bundle_path Type String Value Format /path/to/ca/cert/bundle.pem Specifies a path to a custom SSL certificate bundle that will be used by the agent to establish a secure connection to New Relic. If your custom SSL certificate bundle doesn't include certificates that are sufficient to connect to New Relic then you'll need to merge the required certs into your custom certificate bundle. use_private_ssl Type Boolean Default false The following SSL certificates are bundled into the agent jar: META-INF/certs/eu-newrelic-com.pem META-INF/certs/eu01-nr-data-net.pem META-INF/certs/newrelic-com.pem Copy By default (use_private_ssl: false) the agent will use the SSL certificates bundled into the JDK to establish a secure connection to New Relic or the custom SSL certificates bundle specified by ca_bundle_path. If you want to use the SSL certificates bundled with the agent, set use_private_ssl: true. Note: use_private_ssl will be ignored if ca_bundle_path is set. enable_auto_app_naming Type Boolean Default false Enables the reporting of data separately for each web app. Set to true to enable support for auto app naming. The name of each web app is detected automatically and the agent reports data separately for each one. This provides a finer-grained performance breakdown for web apps in New Relic. For more information, see Automatic application naming. For more methods of naming your application, see Name your Java application. enable_auto_transaction_naming Type Boolean Default true Enables component-based transaction naming. Set to true to enable component-based transaction naming. Set to false to use the URI of a web request as the name of the transaction. For more information, see Naming web transactions. Caution Unless you implement API calls to name your transactions, disabling auto-transaction naming is very likely to cause Metric grouping issues. enable_custom_tracing Type Boolean Default true Enables all instrumentation using an @Trace annotation. Disabling this causes @Trace annotations to be ignored. extensions.dir Type String Default (none) Defines the location of the optional extensions directory. If this property is not set, the agent will look for a subdirectory named extensions in the same directory as newrelic.jar and newrelic.yml. high_security Type Boolean Default false In order for high security to be enabled, this property must be set to true and the high security property in the New Relic user interface must be enabled. Enabling high security means SSL is turned on, request and message queue parameters are not collected, and queries cannot be sent to New Relic in their raw form. Important As of Java agent 3.48.0, SSL is enabled by default and the config option to disable it has been deprecated. As of Java agent 4.0.0, the ability to disable SSL has been removed. insert_api_key Type String Default (none) A valid Insert API Key for your account. This is only required for Real-time Java profiling using JFR metrics. labels Type String Default \"\" Attach tags to this app. Note that this option now enables tags, which replaced the label feature. You can still query your historical labels. max_stack_trace_lines Type Integer Default 30 Limits the number of lines the agent collects from each stack trace. Increasing this value may impact performance, because it increases the amount of memory the agent uses and the amount of data sent to New Relic. proxy_host Type String Default (none) The proxy host through which to connect to the New Relic collector. If a proxy is used, the host setting is required. Other proxy settings are optional. proxy_password Type String Default (none) The password for proxy authentication. If a proxy is used, the host setting is required. Other proxy settings are optional. The username and password settings will be used to authenticate to Basic Auth challenges from a proxy server. Important The Java agent supports Basic (clear text) authentication. proxy_port Type String Default 8080 The proxy host port number. If a proxy is used, the host setting is required. Other proxy settings are optional. proxy_user Type String Default (none) The username for proxy authentication, such as Basic (clear text) authentication. If a proxy is used, the host setting is required. Other proxy settings are optional. The username and password settings will be used to authenticate to Basic Auth challenges from a proxy server. proxy_scheme Type String Default (none) The proxy scheme used. Setting proxy_scheme: \"https\" will allow the agent to connect through proxies using the HTTPS scheme. reactor-netty.errors.enabled Type Boolean Default true Whether errors are reported for reactor netty. If set to false, errors will be ignored. Important Only available in Java agent 6.3.0 and above. send_data_on_exit Type Boolean Default false Enable delayed JVM shutdown to give the agent a chance to send latest metric data to New Relic before JVM shutdown. send_data_on_exit_threshold Type Integer Default 60 The number of seconds after which the agent will use the send_data_on_exit setting. send_environment_info Type Boolean Default true Enable reporting of JVM settings to New Relic. send_jvm_props Type Boolean Default true When set to true, JVM properties will be sent to New Relic. ssl (DEPRECATED) Type Boolean Default true Requires connections to the New Relic collector to go over SSL. The agent communicates with New Relic via HTTPS by default, and New Relic requires HTTPS for all traffic to APM and the New Relic REST API. This work is done asynchronously to the threads that process your application code, so response times will not be directly affected by this change. Important As of Java agent 3.48.0, SSL is enabled by default and the config option to disable it has been deprecated. As of Java agent 4.0.0, the ability to disable SSL has been removed. sync_startup Type Boolean Default false Enable the agent to connect the New Relic collector immediately upon app startup. scala_futures_as_segments Important This applies to Java agent version 3.44.0 or higher. Type Boolean Default false For more concise transaction trace details, the agent does not report Scala Futures as transaction segments, and those Futures do not contribute to the transaction’s total time. Enabling scala_futures_as_segments increases your overhead. If you want Scala Futures to report as transaction segments so you can view them in a transaction trace, you can enable it: scala_futures_as_segments: enabled: true Copy Logging configuration These are part of the general configuration variables. They are broken out here because they are frequently tweaked for debugging. Some of the logging configuration variables are dynamic and do not need a host restart for them to take effect. For instance, if log files are growing too quickly, log_level can be set to a less verbose setting to reduce the reporting rate. Here is the order of precedence for configuration variables affecting log rotation. If log_daily is true, other log rotation settings are ignored. If log_file_count is 1 or 0, the size limit is ignored. Finally, the agent applies log_limit_in_kbytes. Depending on the growth rate, it is possible for the log file size to exceed the configured value by a small amount. log_daily Type Boolean Default false Set to true to roll the logs daily. Overrides the other configuration variables that affect log rotation. log_file_count Type Integer Default 1 The maximum number of log files to keep when using log rotation. log_file_name Type String Default newrelic_agent.log The unqualified log file name or the string STDOUT which will log to standard out. log_file_path Type String Default logs subdirectory where newrelic.jar is located The log file path. Tip If log_file_path is specified, the directory must already exist. If the default value is used, the agent will attempt to create the directory. log_level Type String Default info The log verbosity level. The agent uses its own log file to keep its logging separate from that of your application. Valid options, in order of verboseness, are: off severe warning info fine finer finest This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. log_limit_in_kbytes Type Integer Default 0 The log file size in kilobytes at which log files are rotated. Set to 0 for no limit. JMX To set these options, use the jmx stanza. To override them, use a newrelic.config.jmx prefixed system property. The Java agent uses JMX to collect JVM data as well as to communicate with the JFR (Java Flight Recorder) daemon for Real-time Java profiling. enabled Type Boolean Default true This setting can be used to turn on or off all JMX functionality. linkingMetadataMBean Type Boolean Default false This setting can be enabled to allow the Java agent to expose linking metadata to the JFR daemon. Doing so allows the JFR daemon to obtain the entity GUID generated by the Java agent and link JFR data with the same APM application that is being monitored by the agent instead of as a separate entity. Important This applies to Java agent version 6.1.0 or higher. Attributes To set these options, use the attributes stanza. To override them, use a newrelic.config.attributes prefixed system property. Attributes are key-value pairs that provide information for transaction traces, traced errors, browser monitoring, and transaction events. There is also an attribute stanza under each destination. For more information, see Java agent attributes, Enabling and disabling attributes and Attribute examples. enabled Type Boolean Default true This setting can be used to turn on or off all attributes. Important For security reasons, capturing custom attributes using the Custom Instrumentation Editor is set to false by default. include Type List of Strings Default (none) If attributes are enabled, attribute keys found in this list will be sent to New Relic. Separate the keys in the list with a comma; for example: key1, key2, key3 Copy Also refer to the agent attribute rules. exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic. Separate the keys in the list with a comma; for example: key1, key2, key3 Copy Also refer to the agent attribute rules. Transaction tracer These options are set in the transaction_tracer stanza and can be overridden by using a newrelic.config.transaction_tracer prefixed system property. Transaction tracing captures deep information about slow transactions and sends this to the New Relic service. The transaction includes the exact call sequence of the transactions, including any query statements issued. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. enabled Type Boolean Default true The transaction tracer is enabled by default. Set this to false to turn it off. explain_enabled Type Boolean Default true Determines whether the agent will capture the EXPLAIN plan for slow queries. Only supported for MySQL and PostgreSQL. explain_threshold Type Float Default 0.5 Threshold in seconds for query execution time below which the slow query and the EXPLAIN plan (if supported) will not be captured. Relevant to slow queries only when record_sql is set to raw or obfuscated. Relevant to EXPLAIN plans only when explain_enabled is set to true. insert_sql_max_length Type Integer Default 2000 The character limit for the SQL query string. If you have many slow SQL queries with large chunks of information, this could negatively affect performance or how quickly you see your data in New Relic. Increase the value gradually until you find the right balance of information and performance. log_sql Type Boolean Default false Set to true to enable logging of queries to the agent log file instead of uploading to New Relic. Queries are logged using the record_sql mode. record_sql Type String Default obfuscated When the transaction tracer is on, query statements can optionally be recorded. The recorder has three modes: off: Send no queries. raw: Send the query statement in its original form. obfuscated: Strips out numeric and string literals. stack_based_naming (Play 2.x+ only) Type Boolean Default False Defaulted to true until Java agent version 3.12.1, when it was changed to false. This option is for Play 2.x+ only. Play/Scala instrumentation can use Thread.getStackTrace() to improve tracer naming, but at the cost of increased overhead. stack_trace_threshold Type Integer Default 0.5 Defines a threshold (in seconds) for collecting stack traces from an SQL call. When SQL statements exceed this threshold, the agent will capture the current stack trace. This is useful for pinpointing where long SQL calls originate from. top_n Type Integer Default 20 Use this setting to control the variety of your transaction traces. top_n is an integer that represents the number of unique, slow transactions that traces will be created for. If you want transaction traces to more accurately reflect the actual slowest transactions in your app, make this value lower. If you want to sample a more diverse array of transactions, make the value higher. A value of 0 would mean that only the slowest transaction is always traced. This is considered not to be optimal, though, because you may have one or two transactions that are always the slowest, and repeatedly seeing those same transaction traces will probably not give you much value. If the same transaction is often the slowest, the top_n setting allows the Java agent (over time) to sample the slowest n transactions. This gives you greater variety and more insight into your application. transaction_threshold Type String (float) Default apdex_f The time threshold used to determine when a transaction is eligible to be traced. When the transaction's response time exceeds this threshold, a transaction trace will be recorded and sent to New Relic. The default is apdex_f (default), which sets the threshold to be the \"Frustrated\" Apdex level (four times the apdex_t value). You can also set a specific time threshold by entering a float value that represents a number of seconds. slow_query_whitelist (DEPRECATED) Type String Default (none) Important This config has been deprecated as of agent version 5.10.0 and will be removed in a future agent version. Instead use collect_slow_queries_from. By default, high security mode does not allow the agent to collect slow queries. Enable this option to collect Cassandra queries from the DataStax driver, even with high security enabled. If you don't use high security, the agent collects slow queries automatically. For DataStax driver 2.1.2, add this rule to your allow list: transaction_tracer: slow_query_whitelist: 'com.newrelic.instrumentation.cassandra-datastax-2.1.2' Copy For DataStax driver 3.0.0, add this rule to your allow list: transaction_tracer: slow_query_whitelist: 'com.newrelic.instrumentation.cassandra-datastax-3.0.0' Copy collect_slow_queries_from Type String Default (none) By default, high security mode does not allow the agent to collect slow queries. Enable this option to collect Cassandra queries from the DataStax driver, even with high security enabled. If you don't use high security, the agent collects slow queries automatically. For DataStax driver 2.1.2, add this rule to your allow list: transaction_tracer: collect_slow_queries_from: 'com.newrelic.instrumentation.cassandra-datastax-2.1.2' Copy For DataStax driver 3.0.0, add this rule to your allow list: transaction_tracer: collect_slow_queries_from: 'com.newrelic.instrumentation.cassandra-datastax-3.0.0' Copy attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for transaction traces. If attributes.enabled at the root level is false, no attributes will be sent to transaction traces regardless on how this property (transaction_tracer.attributes.enabled) is set. attributes.include Type List of strings Default (none) If attributes are enabled for transaction traces, all attribute keys found in this list will be sent to New Relic in transaction traces. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in transaction traces. For more information, see the agent attribute rules. token_limit Type Integer Default 3000 Limits the number of Tokens that can be created per Transaction. Increasing this value may impact performance, because it increases the amount of memory the agent uses and the amount of data sent to New Relic. segment_limit Type Integer Default 3000 Limits the number of segments that can be created per transaction. Increasing this value may impact performance, because it increases the amount of memory the agent uses and the amount of data sent to New Relic. Transaction segments These options are set in the transaction_segments stanza and can be overridden by using a newrelic.config.transaction_segments prefixed system property. Transaction segments represent discrete pieces of work (generally method calls) and are displayed within transaction traces. Important Transaction segment attribute filtering requires Java agent version 4.10.0 or higher. attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for transaction segments. If attributes.enabled at the root level is false, no attributes will be sent to transaction segments regardless on how this property (transaction_segments.attributes.enabled) is set. attributes.include Type List of strings Default (none) If attributes are enabled for transaction segments, all attribute keys found in this list will be sent to New Relic in transaction segments. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in transaction segments. For more information, see the agent attribute rules. Browser monitoring These options are set in the browser_monitoring stanza and can be overridden by using a newrelic.config.browser_monitoring prefixed system property. Browser monitoring gives you insight into the performance real users are experiencing with your website. This is accomplished by measuring the time it takes for your users' browsers to download and render your web pages by injecting a small amount of JavaScript code into the header and footer of each page. auto_instrument Type Boolean Default true By default the agent automatically inserts API calls in compiled JSPs to inject the monitoring JavaScript into web pages. Set this attribute to false to turn off this behavior. disabled_auto_pages Type Comma-separated list of strings Default (none) When auto_instrument is true, by default all pages are instrumented. List all pages that you want the auto instrumentation to skip here. You can still use manual instrumentation on these pages. For example: browser_monitoring: disabled_auto_pages: /WEB-INF/jsp/testpage_1.jsp, /WEB-INF/jsp/testpage_2.jsp Copy attributes.enabled Type Boolean Default false This setting can be used to turn on or off all attributes for browser monitoring. This is the data you can query. If attributes.enabled is false at the root level, no attributes will be sent up in browser monitoring regardless on how this property under browser_monitoring is set. attributes.include Type List of Strings Default (none) If attributes are enabled for browser_monitoring, all attribute keys found in this list will be sent to New Relic in page views. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in page views. For more information, see the agent attribute rules. External tracer The external tracing options are set in the external_tracer stanza and can be overridden by using a newrelic.config.external_tracer prefixed system property. exclude_request_uri Type Boolean Default false This setting can be used to control the collection of outgoing request URIs for errors and transaction traces. Set this to true to disable collecting this information. Cross application tracer The cross application tracing options are set in the cross_application_tracer stanza and can be overridden by using a newrelic.config.cross_application_tracer prefixed system property. Cross application tracing adds request and response headers to external calls using the Apache HttpClient libraries. This provides better performance data when calling applications monitored by other New Relic Agents. enabled Type Boolean Default true Cross application tracing is enabled by default. Set this to false to turn it off. Error collector These options are set in the error_collector stanza and unless noted otherwise can be overridden by using a newrelic.config.error_collector prefixed system property. The error collector captures information about uncaught exceptions and sends them to New Relic for viewing. Tip For how to configure errors for the Java agent, including how to configure errors via the UI, see Java agent error configuration. enabled Type Boolean Default true Enable error collection. ignore_classes Type Stanza containing a list of fully qualified class_name strings Default (none) Specified exception class names will be ignored and will not affect error rate or Apdex score, or be reported to APM. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: ignore_classes: - \"com.example.MyException\" - \"com.example.DifferentException\" Copy ignore_messages Type Stanza containing a fully qualified class_name and a list of messages per error class Default (none) Specify exception class names the agent should ignore. Ignored messages will not affect error rate or Apdex score, or be reported to APM. Contains yaml pairs consisting of: A fully qualified exception class name that should not be reported to APM AND A list of exception messages to match against (at least one is required) If the exception class name matches an error but the message does not, then that error will not be ignored. Message strings use contains for matching. A message cannot be provided on its own and must always be paired with a fully qualified class name. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: ignore_messages: com.example.MyException: - \"Some error message to ignore\" - \"Some other error message to ignore\" com.example.DifferentException: - \"Some different error message to ignore\" Copy ignore_status_codes Type Comma-separated list of strings and ranges Default 404 A comma-separated list comprised of individual and dashed ranges of HTTP status codes that should not be treated as errors. If this property is commented out in the newrelic.yml configuration file, then the 404 status code will automatically be ignored. When using server-side configuration, the status code 404 must be specified in order for it to be ignored. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: ignore_status_codes: 404,507-511 Copy expected_classes Type Stanza containing a List of fully qualified class_name strings Default (none) Prevents specified exception classes from affecting error rate or Apdex score while still reporting the errors to APM. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: expected_classes: - \"com.example.MyException\" - \"com.example.DifferentException\" Copy expected_messages Type Stanza containing a fully qualified class_name and a List of messages per error class Default (none) Contains yaml pairs consisting of a fully qualified exception class name that should be marked as expected and thus prevented from affecting error rate or Apdex score and a List of exception messages to match against, the latter of which at least one is required. If the exception class name matches an error but the message does not, then that error will not be marked as expected and therefore will affect error rate and Apdex score. Message strings use contains for matching. A message cannot be provided on its own and must always be paired with a fully qualified class name. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: expected_messages: com.example.MyException: - \"Some expected error message\" - \"Some other expected error message\" com.example.DifferentException: - \"Some different expected error message\"​ Copy expected_status_codes Type Comma-separated list of strings and ranges Default (none) A comma-separated list comprised of individual and dashed ranges of HTTP status codes to be marked as expected and thus prevented from affecting error rate or Apdex score. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: expected_status_codes: 415,500-506 Copy attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for traced errors. If attributes.enabled is false at the root level, then no attributes will be sent to traced errors regardless of how this property is set under error_collector. attributes.include Type List of strings Default (none) If attributes are enabled for traced errors, all attribute keys found in this list will be sent to New Relic in traced errors. For more information, see the agent attribute rules. attributes.exclude Type List of strings Default (none) Attribute keys found in this list will not be sent to New Relic in traced errors. For more information, see the agent attribute rules. ignore_errors (DEPRECATED) Type Comma-separated list of Strings Default (none) All specified exception class names specified will not be treated as errors. Deprecated as of Java agent 3.40.0 and replaced by ignore_classes. For example: error_collector: ignore_errors: some.other.MyException Copy Strip exceptions These options are set in the strip_exception_messages stanza and unless noted otherwise can be overridden by using a newrelic.config.strip_exception_messages​prefixed system property. This configuration can be enabled to control whether Java exception messages are reported to New Relic. enabled Type Boolean Default false By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you set this to true, the agent strips the messages from exceptions in order to prevent it from inadvertently capturing sensitive information. If you enable high security mode, this is automatically set to true. If you set enabled to true but you want the agent to capture messages from specific exceptions, add the exceptions to your allow list. whitelist (DEPRECATED) Type String Default (none) Important This config has been deprecated as of agent version 5.10.0 and will be removed in a future agent version. Instead use allowed_classes. If you set enabled to true but you want the agent to capture messages for specific exceptions, add each exception to the whitelist, separated by a comma. allowed_classes Type String Default (none) If you set enabled to true but you want the agent to capture messages for specific exceptions, add each exception to allowed_classes, separated by a comma. Thread profiler These options are set in the thread_profiler stanza and can be overridden by using a newrelic.config.thread_profiler prefixed system property. Thread profiler measures wall clock time, CPU time, and method call counts in your application's threads as they run. enabled Type Boolean Default true Enable the thread profiler. Transaction events These options are set in the transaction_events stanza and can be overridden by using a newrelic.config.transaction_events prefixed system property. Transaction events provide the data for displaying histograms and percentiles in the UI. Important Previously this stanza was called analytics_events. If your configuration file still uses analytics_events, update your agent to use transaction_events. enabled Type Boolean Default true Enable the transaction events service. max_samples_stored Type Integer Default 2000 Max 10000 The maximum number of sampled transaction events reported every 60 seconds. custom_request_headers Type List of maps Default None Important Unlike other settings, custom_request_headers have to be paired together and must be set in the newrelic.yml file. They can't be overwritten by Java virtual machine arguments (system property) or environment variables. A list of maps with the paired keys header_name and the optional header_alias. Choose one or more custom HTTP request headers to add as transaction attributes. You can list multiple header configurations: transaction_events: custom_request_headers: - header_name: \"X-Custom-Header-1\" - header_name: \"X-Custom-Header-2\" header_alias: \"CustomHeader2alias\" Copy In the first map set, X-Custom-Header-1 is captured and reported by the agent as the header name for a corresponding value from the request object. The header_name will also be the name of the attribute sent to New Relic. In the second map set, the request header is X-Custom-Header-2, but the CustomHeader2alias is the name sent to New Relic. attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for transaction events. If attributes.enabled is false at the root level, then no attributes will be sent to transaction events regardless of how this property is set under transaction_events. attributes.include Type List of Strings Default (none) If attributes are enabled for transaction events, all attribute keys found in this list will be sent to New Relic in transaction events. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in transaction events. For more information, see the agent attribute rules. Custom events Custom events are set in the custom_insights_events stanza and can be overridden by using a newrelic.config.custom_insights_events prefixed system property. APM lets you record custom event data via the New Relic language agent APIs, which you can then query. Important For Java agent versions prior to 4.1.0, the following YAML configuration is recognized: custom_insights_events.enabled: true custom_insights_events.max_samples_stored: 5000 Copy For agent versions 4.1.0 and above, the YAML configuration uses the nested stanza formatting: custom_insights_events: enabled: false max_samples_stored: 5000 Copy enabled Type Boolean Default true This enables the custom event service. max_samples_stored Type Integer Default/Max 10000 The maximum number of sampled custom events reported every 60 seconds. Hostname configuration These options are set in the process_host stanza and can be overridden by using a newrelic.config.process_host prefixed system property. These properties are used for configuring the hostname displayed in the UI: display_name Type String Default (none) Set a display name to decorate the \"host:port\" label in the New Relic UI. ipv_preference Type String Default 4 If the hostname cannot be determined, then the IP address of the host will be used. This property determines whether the IPv4 or IPv6 address should be used. The default is IPv4. Custom instrumentation These options set in the class_transformer stanza and can be overridden by using a newrelic.config.class_transformer prefixed system property. trace_annotation_class_name Type String Default (none) String containing the full class name of the annotation class the agent uses to determine which user-specified methods to instrument. For more information about custom annotations, see Java custom metric collection. com.newrelic.instrumentation.servlet-user Type Boolean Default false Enable this option to capture the userPrincipal name. This name is included as a transaction trace attribute, and can be queried. System properties You can override any setting in the newrelic.yml file by setting a system property. The system property corresponding to a given setting in the config file is the setting name prefixed by newrelic.config. For example, the system property for the log_level setting is newrelic.config.log_level. For settings nested in stanzas, prepend the stanza name to the setting name. For example, the system property for the enabled setting in the transaction_tracer stanza is newrelic.config.transaction_tracer.enabled. In addition to overriding configuration settings, the following system properties are recognized by the agent: newrelic.config.process_host.display_name Type String Default (none) Set a display name to decorate the \"host:port\" label in the New Relic UI. Requires Java agent 3.17 or higher. newrelic.config.file Type String Default (none) String containing a fully qualified path to the newrelic configuration file. If empty, the agent assumes newrelic.yml is in the same directory as newrelic.jar. newrelic.debug Type Boolean Default (none) Enable debug logging. newrelic.environment Type String Default (none) String containing the environment configuration for the agent to use. newrelic.home Type String Default (none) String containing the home directory of agent. This defaults to the same directory as the agent jarfile. newrelic.logfile Type String Default newrelic_agent.log String containing the name of the agent log file. Environment variables Environment variables take the highest precedence and override the system properties and yml config settings. To set environment variables, use the export VARNAME=value command. To permanently set environment variables, add the export line to a file such as ~/.bashrc or ~/.bash_profile. You can override any setting from a system property or in the newrelic.yml by setting an environment variable. The environment variable corresponding to a given setting in the config file is the setting name prefixed by NEW_RELIC with all dots (.) and dashes (-) replaced by underscores (_). For example, the environment variable for the log_level setting is NEW_RELIC_LOG_LEVEL. For settings nested in stanzas, prepend the stanza name to the setting name. For example, the environment variable for the enabled setting in the transaction_tracer stanza is NEW_RELIC_TRANSACTION_TRACER_ENABLED. Important Agent configuration via environment variables requires Java agent version 4.10.0 or higher. For agent versions older than 4.10.0 the following environment variables are available: NEW_RELIC_APP_NAME (REQUIRED) Type String Default (none) This setting is required. Contains the application name under which to report data to New Relic. Set the name of your application as you want it to appear in New Relic. If enable_auto_app_naming is false, the agent reports all data to this application. Otherwise, the agent reports only background tasks (transactions for non-web applications) to this application. To report data to more than one application, separate the application names with a semicolon ;. For example, to report data to My Application and My Application 2: app_name: My Application;My Application 2 Copy For more methods of naming your application, see Name your Java application. NEW_RELIC_DISTRIBUTED_TRACING_ENABLED Type String Default false Enables distributed tracing. Case sensitive: use true or false. For more information, see the distributed tracing section. NEW_RELIC_PROCESS_HOST_DISPLAY_NAME Type String Default (none) Set a display name to decorate the \"host:port\" label in the New Relic UI. NEW_RELIC_LICENSE_KEY (REQUIRED) Type String Default (none) This setting is required. Contains your New Relic account license. You must specify the license key associated with your New Relic account. This key binds your agent's data to your account in the New Relic service. NEW_RELIC_LOG Type String Default newrelic_agent.log The unqualified log file name or the string STDOUT which will log to standard out. Cloud platform utilization These options are set in the utilization stanza and can be overridden by using a newrelic.config.utilization prefixed system property. The agent collects utilization information and sends it to the New Relic service. The agent can collect information from Amazon Web Services (AWS) EC2 instances and Docker containers. detect_aws Type Boolean Default true Determines whether the agent polls AWS metadata API. detect_docker Type Boolean Default true Determines whether the agent reads Docker information from the file system. Async instrumentation These options are set directly in the common stanza and can be overridden by using a prefixed system property. token_timeout Type Integer Default (seconds) 180 The number of seconds after which the agent will automatically expire an async token that has not been explicitly expired with token.expire(). For usage instructions, see Tokens: Connect async threads. Important Increasing this value may impact performance, because it increases the amount of memory the agent uses and prevents transactions from being reported due to unexpired tokens. segment_timeout Type Integer Default (seconds) 600 The number of seconds after which the agent will automatically end a segment that has not been explicitly ended with segment.end() or segment.ignore(). For usage instructions, see Segments: Time arbitrary async activity. Important Increasing this value may impact performance, because it increases the amount of memory the agent uses and prevents transactions from being reported due to un-ended segments. Circuit breaker These settings customize the behavior of the Java circuit breaker. These settings are not included in newrelic.yml by default. You do not need to restart your JVM after changing them. If you want to customize the circuit breaker, add the stanza under the common stanza: common: &default_settings​ ​ OTHER_CONFIG_SETTINGS circuitbreaker: enabled: true memory_threshold: 20 gc_cpu_threshold: 10 Copy enabled Type Boolean Default true If your application is behaving as expected, you may want to disable the circuit breaker. memory_threshold Type Integer (0 to 100) Default 20 Customize the precentage of free heap memory below which the circuit breaker should trip. When the percentage of free heap memory is less than memory_threshold, and the CPU time spent doing garbage collection is greater than gc_cpu_threshold, the circuit breaker trips. In order to make the circuit breaker less likely to trip, decrease memory_threshold and/or increase gc_cpu_threshold. Adjust these values as needed, based on your application's operating performance and behavior. gc_cpu_threshold Type Integer (0 to 100) Default 10 Customize the precentage of garbage collection CPU time above which the circuit breaker should trip. When the percentage of free heap memory is less than memory_threshold, and the CPU time spent doing garbage collection is greater than gc_cpu_threshold, the circuit breaker trips. In order to make the circuit breaker less likely to trip, decrease memory_threshold and/or increase gc_cpu_threshold. Adjust these values as needed, based on your application's operating performance and behavior. Message tracer These options are set in the message_tracer stanza and can be overridden by using a newrelic.config.message_tracer prefixed system property. segment_parameters.enabled Type Boolean Default true Adds message properties to tracer attributes. Set this to false to turn it off. Distributed tracing Important Enabling distributed tracing disables cross application tracing, and has other effects on APM features. Before enabling, read the transition guide. Requires Java agent version 4.3.0 or higher. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. In the config file, it can be set in the distributed_tracing stanza. It can be overridden using a newrelic.config.distributed_tracing prefixed system property. enabled Type Boolean Default false Set this to true to enable distributed tracing. For example, to enable this in the config file, you would use: distributed_tracing: enabled: true Copy To enable this using a system property, you would use: -Dnewrelic.config.distributed_tracing.enabled=true Copy exclude_newrelic_header Type Boolean Default false By default, supported versions of the agent utilize both the newrelic header and W3C Trace Context headers for distributed tracing. The newrelic distributed tracing header allows interoperability with older agents that don't support W3C Trace Context headers. Agent versions that support W3C Trace Context headers will prioritize them over newrelic headers for distributed tracing. If you do not want to utilize the newrelic header, setting this to true will result in the agent excluding the newrelic header and only using W3C Trace Context headers for distributed tracing. For example, to exclude newrelic headers in the config file, you would use: distributed_tracing: exclude_newrelic_header: true Copy To exclude newrelic headers using a system property, you would use: -Dnewrelic.config.distributed_tracing.exclude_newrelic_header=true Copy Infinite Tracing Important Requirements: Java Agent 5.12.1 or higher. Infinite Tracing does not work if enable_auto_app_naming is enabled. To turn on Infinite Tracing, enable distributed tracing and add the additional setting below. For an example, see Language Agents: Configure Distributed Tracing. trace_observer.host Type String Default None For help getting a valid Infinite Tracing trace observer host entry, see find or create a Trace Observer. You can configure this via YAML: infinite_tracing: trace_observer: host: YOUR_TRACE_OBSERVER_HOST Copy You can also use the system property newrelic.config.infinite_tracing.trace_observer.host or the environment variable NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_HOST. Span events Span events are reported for distributed tracing. Distributed tracing must be enabled to report span events. Span configuration is set in the span_events stanza and can be overridden by using a newrelic.config.span_events prefixed system property. Options include: enabled Type Boolean Default true Used to enable/disable span event reporting. attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for span events. If attributes.enabled at the root level is false, no attributes will be sent to span events regardless on how this property (span_events.attributes.enabled) is set. attributes.include Type List of strings Default (none) If attributes are enabled for span events, all attribute keys found in this list will be sent to New Relic in span_events. For more information, see the agent attribute rules. attributes.exclude Type List of strings Default (none) All attribute keys found in this list will not be sent to New Relic in span events. For more information, see the agent attribute rules. Important Span event attribute filtering requires Java agent version 4.10.0 or higher. Jar collector The Java agent collects and information about jars and their versions on the application classpath. Jar collection configuration is set in the jar_collector stanza and can be overridden by using a newrelic.config.jar_collector prefixed system property. Options include: enabled Type Boolean Default true Used to enable/disable jar collection and reporting. skip_temp_jars Type Boolean Default true Used to enable/disable collection of temporary jars. Temporary jars are those residing in the directory specified by the system property java.io.tmpdir. jars_per_second Type Integer Default 10 The maximum number of jars to process per second. Must be positive.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 94.536995,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> <em>configuration</em>: Config file",
        "sections": "<em>Java</em> <em>agent</em> <em>configuration</em>: Config file",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> reads its <em>configuration</em> from the newrelic.yml file. By default the <em>agent</em> looks for this file in the directory that contains newrelic.jar. You can override the config file&#x27;s location by setting the newrelic.config.file system property to a fully qualified file name"
      },
      "id": "603eb739e7b9d2a2432a07e0"
    },
    {
      "sections": [
        "Name your Java application",
        "Set or change app name",
        "Tip",
        "Use multiple app names",
        "Java config file",
        "Java environment variable",
        "System properties",
        "Important"
      ],
      "title": "Name your Java application",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "72db22e0ea6a9f8062f65ad8d7fc3e22608f90a2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/name-your-java-application/",
      "published_at": "2021-05-05T06:50:12Z",
      "updated_at": "2021-03-16T13:13:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent gives you several ways to change the application name that is reported and displayed in APM. This document gives you an overview of those naming options. For a general overview of APM app naming (not Java-specific), see Name your application. Set or change app name APM differentiates applications by the name they report as. Data continuity breaks when you change the application name. To change an application's name without breaking data continuity, use the UI alias-change option. Here are the ways to change your Java application's name: Naming method Description Recommended: Configure app_name in newrelic.yml Configure your newrelic.yml file to set your app name. This is the recommended and most commonly used option: app_name: My Application Copy Configure app_name using JVM arguments Set a system property with JVM arguments to set unique app names for multiple applications that report to the same Java agent: -Dnewrelic.config.app_name=\"My App\" Copy Set app name using environment variables Set an environment variable to easily set app names during the deployment of containers, or to ensure an app name stays the same through multiple iterations of a newrelic.yml file: export NEW_RELIC_APP_NAME=\"My App\" Copy Automatic application naming Enable automatic application naming in your newrelic.yml file if you want applications named for their context, filter, servlet, or request attribute: enable_auto_app_naming: true Copy Change alias via UI Change an application's alias to change only the displayed name in the UI. This does not change the name the application reports as. This does not break data continuity, unlike all other options. Tip Note that some methods take precedence over others. Use multiple app names You can use multiple app names to aggregate data from several applications under the same name in APM (sometimes referred to as \"rolling up\" your data). For more about how multiple app names work, see Use multiple app names. In Java, you can set up to three app names. The primary app name is first, while the second and third names are used for the more general data aggregation categories. Java config file Here is an example of setting multiple names in the newrelic.yml file: app_name: My Application;My Application 2;My application 3 Copy Java environment variable Here is an example of setting multiple names as environment variable: export NEW_RELIC_APP_NAME=\"My Application;My Application 2;My application 3\" Copy System properties Important If you set multiple application names using system properties on the Java command line, remember to quote the command-line parameter because of the ; character. Here is an example of setting multiple names as a system property: -Dnewrelic.config.app_name=\"My Application;My Application 2;My application 3\" Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 94.50982,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Name your <em>Java</em> application",
        "sections": "Name your <em>Java</em> application",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "New Relic&#x27;s <em>Java</em> <em>agent</em> gives you several ways to change the application name that is reported and displayed in APM. This document gives you an overview of those naming options. For a general overview of APM app naming (not <em>Java</em>-specific), see Name your application. Set or change app name APM"
      },
      "id": "603ea329196a675e06a83dd4"
    }
  ],
  "/docs/agents/java-agent/configuration/java-agent-configuration-config-file": [
    {
      "sections": [
        "Configuring your SSL certificates",
        "Notice of expired SSL certificates and certificate removal",
        "Caution",
        "Important",
        "Java Agent versions 6.2.0 - 6.4.2",
        "Java Agent versions 6.0.0/6.1.0",
        "Using YAML-based configuration",
        "Java Agent versions prior to 6.0.0 (Deprecated)",
        "For more help"
      ],
      "title": "Configuring your SSL certificates",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "af154f250e87f571db157972e22dbb1f907a8fde",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/configuring-your-ssl-certificates/",
      "published_at": "2021-05-05T06:44:59Z",
      "updated_at": "2021-04-28T23:01:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To communicate with the New Relic collector over HTTPS, you need to have the proper certificates for trusted signers in the trust store on your app server. By default, most JREs contain a valid root certificate that allows the agent to connect to newrelic.com. For SSL connection issues, please visit SSL or connection errors (Java). Notice of expired SSL certificates and certificate removal Caution The SSL certificates that were bundled with Java agent versions 6.1.0 to 6.4.2 have expired and are no longer valid. This means that Java agent versions 6.1.0 to 6.4.2 can no longer use the certificates bundled with the agent to establish a connection with New Relic and that you must provide your own SSL certificates. Please see this community forum post for additional details. Important Java agent versions higher than 6.4.2 no longer ship with SSL certificates bundled into the agent. You must provide your own SSL truststore to the agent by explicitly using the ca_bundle_path configuration option, or by using the default truststore provided by the JDK/JRE (the agent will look to use the latter by default). Additionally the use_private_ssl configuration option has been removed from Java agent versions higher than 6.4.2. Users wishing to add the global certificate to their local trust store can download the DigiCert Global Root CA from DigiCert. Java Agent versions 6.2.0 - 6.4.2 Starting with Java agent version 6.2.0, the use_private_ssl configuration option has been reintroduced so you can use the SSL certificates that are bundled into the agent jar. The following bundled SSL certificates are valid for up to a year after release. META-INF/certs/eu-newrelic-com.pem META-INF/certs/eu01-nr-data-net.pem META-INF/certs/newrelic-com.pem Copy Important The Java agent will begin logging a warning message upon application startup when there are less than three months before the bundled certificate expires. When the bundled certificates expire, the Java agent will no longer be able to connect to New Relic and you must either update to the latest agent version or provide a valid certificate using the ca_bundle_path configuration. Users wishing to add the global certificate to their local trust store can download the DigiCert Global Root CA from DigiCert. Using YAML-based configuration common: default_settings ca_bundle_path: /path/to/digicert.pem use_private_ssl: false # # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic ... Copy Summary There are two configuration settings that determine what certs are used by the agent to establish a secure connection to New Relic. They are: use_private_ssl and ca_bundle_path. Here's how they work together: DEFAULT: Neither configuration option (ca_bundle_path/use_private_ssl) is provided, because both are using default values. The agent will use the default SSL certificates bundled into the Java Development Kit (JDK). If these certificates aren't present or don't include certificates that trust New Relic, then the agent will not connect. You'll need to merge valid certificates into your JDK certificate bundle. Only use_private_ssl is configured. The agent will use the SSL certificates that are bundled with it. Only ca_bundle_path is configured. The agent will try to connect using the custom SSL certificates bundle at the configured path. If the configured custom certificate bundle doesn’t include certificates that trust New Relic, then the agent will not connect. You'll need to merge valid certificates into your custom certificate bundle. Both use_private_ssl and ca_bundle_path are configured. The ca_bundle_path configuration setting takes precedence and the use_private_ssl config is ignored. This behavior is the same as only specifying ca_bundle_path. Java Agent versions 6.0.0/6.1.0 Starting in 6.0.0, the Java agent no longer includes the nrcert global certificate chain. Users wishing to add the global certificate to their local trust store must download the DigiCert Global Root CA from DigiCert. Note: In versions 6.1.0+, the Java agent will use a bundled New Relic certificate that is valid for up to a year after release. Before the certificate expires, you must either update the agent to the latest version or provide a valid certificate using the ca_bundle_path configuration. Important The Java agent will begin logging a warning message upon application startup when there are less than three months before the bundled certificate expires. Using YAML-based configuration common: default_settings ca_bundle_path: /path/to/digicert.pem # # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic ... Copy Java Agent versions prior to 6.0.0 (Deprecated) For Java agent versions prior to 6.0.0, applications that require valid certificates may add them in one of the following two ways: Use YAML-based configuration. Add the bundled list of New Relic trusted signers to the local store. Using YAML-based configuration The New Relic Java agent bundles the list of trusted signers in the agent newrelic.jar file. If you do not want to change the local trust store, you can activate them by setting use_private_ssl to true in the newrelic.yml agent configuration file: common: default_settings use_private_ssl: true # # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic ... Copy For more help Additional documentation resources include New Relic for Java (compatibility and requirements, installation, and configuration.)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 133.55928,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Configuring</em> your SSL certificates",
        "sections": "<em>Java</em> <em>Agent</em> versions 6.2.0 - 6.4.2",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " provide your own SSL truststore to the <em>agent</em> by explicitly using the ca_bundle_path <em>configuration</em> option, or by using the default truststore provided by the JDK&#x2F;JRE (the <em>agent</em> will look to use the latter by default). Additionally the use_private_ssl <em>configuration</em> option has been removed from <em>Java</em>"
      },
      "id": "603eb7a2e7b9d247c02a080d"
    },
    {
      "sections": [
        "Java agent config file template"
      ],
      "title": "Java agent config file template",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "cab129eda0df59e172b299574d8e44fbb3c04617",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-config-file-template/",
      "published_at": "2021-05-05T06:49:05Z",
      "updated_at": "2021-03-16T13:47:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains a templated version of the newrelic.yml file that the Java agent reads for configuration. The config file format is YAML. While no knowledge of YAML is necessary to edit the file, be careful to maintain the proper indentation. Learn more about YAML on Wikipedia. When making changes to the newrelic.yml file, use a YAML validator to ensure the syntax is accurate and follow these rules: YML files are case sensitive. All indentations are in increments of two characters. Data in the same stanza of the file must use the same level of indentation, and sub-stanzas should be indented by an additional two spaces. For more information about structure, directories, and settings, see Java agent configuration. # This file configures the New Relic Agent. New Relic monitors # Java applications with deep visibility and low overhead. For more details and additional # configuration options visit https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-configuration-config-file. # # <%= generated_for_user %> # # This section is for settings common to all environments. # Do not add anything above this next line. common: &default_settings # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic # account. For example, if your license key is 12345 use this: # license_key: '12345' # The key binds your Agent's data to your account in the New Relic service. license_key: '<%= license_key %>' # Agent Enabled # Use this setting to disable the agent instead of removing it from the startup command. # Default is true. agent_enabled: true # Set the name of your application as you'd like it show up in New Relic. # If enable_auto_app_naming is false, the agent reports all data to this application. # Otherwise, the agent reports only background tasks (transactions for non-web applications) # to this application. To report data to more than one application # (useful for rollup reporting), separate the application names with \";\". # For example, to report data to \"My Application\" and \"My Application 2\" use this: # app_name: My Application;My Application 2 # This setting is required. Up to 3 different application names can be specified. # The first application name must be unique. app_name: My Application # To enable high security, set this property to true. When in high # security mode, the agent will use SSL and obfuscated SQL. Additionally, # request parameters and message parameters will not be sent to New Relic. high_security: false # Set to true to enable support for auto app naming. # The name of each web app is detected automatically # and the agent reports data separately for each one. # This provides a finer-grained performance breakdown for # web apps in New Relic. # Default is false. enable_auto_app_naming: false # Set to true to enable component-based transaction naming. # Set to false to use the URI of a web request as the name of the transaction. # Default is true. enable_auto_transaction_naming: true # The agent uses its own log file to keep its logging # separate from that of your application. Specify the log level here. # This setting is dynamic, so changes do not require restarting your application. # The levels in increasing order of verboseness are: # off, severe, warning, info, fine, finer, finest # Default is info. log_level: info # Log all data sent to and from New Relic in plain text. # This setting is dynamic, so changes do not require restarting your application. # Default is false. audit_mode: false # The number of backup log files to save. # Default is 1. log_file_count: 1 # The maximum number of kbytes to write to any one log file. # The log_file_count must be set greater than 1. # Default is 0 (no limit). log_limit_in_kbytes: 0 # Override other log rolling configuration and roll the logs daily. # Default is false. log_daily: false # The name of the log file. # Default is newrelic_agent.log. log_file_name: newrelic_agent.log # The log file directory. # Default is the logs directory in the newrelic.jar parent directory. #log_file_path: # Proxy settings for connecting to the New Relic server: # If a proxy is used, the host setting is required. Other settings # are optional. Default port is 8080. The username and password # settings will be used to authenticate to Basic Auth challenges # from a proxy server. Proxy scheme will allow the agent to # connect through proxies using the HTTPS scheme. #proxy_host: hostname #proxy_port: 8080 #proxy_user: username #proxy_password: password #proxy_scheme: https # Limits the number of lines to capture for each stack trace. # Default is 30 max_stack_trace_lines: 30 # Provides the ability to configure the attributes sent to New Relic. These # attributes can be found in transaction traces, traced errors, Insight's # transaction events, and Insight's page views. attributes: # When true, attributes will be sent to New Relic. The default is true. enabled: true #A comma separated list of attribute keys whose values should # be sent to New Relic. #include: # A comma separated list of attribute keys whose values should # not be sent to New Relic. #exclude: # Transaction tracer captures deep information about slow # transactions and sends this to the New Relic service once a # minute. Included in the transaction is the exact call sequence of # the transactions including any SQL statements issued. transaction_tracer: # Transaction tracer is enabled by default. Set this to false to turn it off. # This feature is not available to Lite accounts and is automatically disabled. # Default is true. enabled: true # Threshold in seconds for when to collect a transaction # trace. When the response time of a controller action exceeds # this threshold, a transaction trace will be recorded and sent to # New Relic. Valid values are any float value, or (default) \"apdex_f\", # which will use the threshold for the \"Frustrated\" Apdex level # (greater than four times the apdex_t value). # Default is apdex_f. transaction_threshold: apdex_f # When transaction tracer is on, SQL statements can optionally be # recorded. The recorder has three modes, \"off\" which sends no # SQL, \"raw\" which sends the SQL statement in its original form, # and \"obfuscated\", which strips out numeric and string literals. # Default is obfuscated. record_sql: obfuscated # Set this to true to log SQL statements instead of recording them. # SQL is logged using the record_sql mode. # Default is false. log_sql: false # Threshold in seconds for when to collect stack trace for a SQL # call. In other words, when SQL statements exceed this threshold, # then capture and send to New Relic the current stack trace. This is # helpful for pinpointing where long SQL calls originate from. # Default is 0.5 seconds. stack_trace_threshold: 0.5 # Determines whether the agent will capture query plans for slow # SQL queries. Only supported for MySQL and PostgreSQL. # Default is true. explain_enabled: true # Threshold for query execution time below which query plans will not # not be captured. Relevant only when `explain_enabled` is true. # Default is 0.5 seconds. explain_threshold: 0.5 # Use this setting to control the variety of transaction traces. # The higher the setting, the greater the variety. # Set this to 0 to always report the slowest transaction trace. # Default is 20. top_n: 20 # Error collector captures information about uncaught exceptions and # sends them to New Relic for viewing. error_collector: # This property enables the collection of errors. If the property is not # set or the property is set to false, then errors will not be collected. # Default is true. enabled: true # Use this property to exclude specific exceptions from being reported as errors # by providing a comma separated list of full class names. # The default is to exclude akka.actor.ActorKilledException. If you want to override # this, you must provide any new value as an empty list is ignored. ignore_errors: akka.actor.ActorKilledException # Use this property to exclude specific http status codes from being reported as errors # by providing a comma separated list of status codes. # The default is to exclude 404s. If you want to override # this, you must provide any new value as an empty list is ignored. ignore_status_codes: 404 # Transaction Events are used for Histograms and Percentiles. Unaggregated data is collected # for each web transaction and sent to the server on harvest. transaction_events: # Set to false to disable transaction events. # Default is true. enabled: true # Events are collected up to the configured amount. Afterwards, events are sampled to # maintain an even distribution across the harvest cycle. # Default is 2000. Setting to 0 will disable. max_samples_stored: 2000 # Distributed tracing lets you see the path that a request takes through your distributed system. # Enabling distributed tracing changes the behavior of some New Relic features, so carefully consult the transition # guide before you enable this feature: https://docs.newrelic.com/docs/apm/distributed-tracing/getting-started/transition-guide-distributed-tracing # Default is false. distributed_tracing: enabled: false # Cross Application Tracing adds request and response headers to # external calls using supported HTTP libraries to provide better # performance data when calling applications monitored by other New Relic Agents. cross_application_tracer: # Set to false to disable cross application tracing. # Default is true. enabled: true # Thread profiler measures wall clock time, CPU time, and method call counts # in your application's threads as they run. # This feature is not available to Lite accounts and is automatically disabled. thread_profiler: # Set to false to disable the thread profiler. # Default is true. enabled: true # New Relic Real User Monitoring gives you insight into the performance real users are # experiencing with your website. This is accomplished by measuring the time it takes for # your users' browsers to download and render your web pages by injecting a small amount # of JavaScript code into the header and footer of each page. browser_monitoring: # By default the agent automatically inserts API calls in compiled JSPs to # inject the monitoring JavaScript into web pages. Not all rendering engines are supported. # See https://docs.newrelic.com/docs/agents/java-agent/instrumentation/new-relic-browser-java-agent#manual_instrumentation # for instructions to add these manually to your pages. # Set this attribute to false to turn off this behavior. auto_instrument: true class_transformer: # This instrumentation reports the name of the user principal returned from # HttpServletRequest.getUserPrincipal() when servlets and filters are invoked. com.newrelic.instrumentation.servlet-user: enabled: false com.newrelic.instrumentation.spring-aop-2: enabled: false # This instrumentation reports metrics for resultset operations. com.newrelic.instrumentation.jdbc-resultset: enabled: false # Classes loaded by classloaders in this list will not be instrumented. # This is a useful optimization for runtimes which use classloaders to # load dynamic classes which the agent would not instrument. classloader_excludes: groovy.lang.GroovyClassLoader$InnerLoader, org.codehaus.groovy.runtime.callsite.CallSiteClassLoader, com.collaxa.cube.engine.deployment.BPELClassLoader, org.springframework.data.convert.ClassGeneratingEntityInstantiator$ObjectInstantiatorClassGenerator, org.mvel2.optimizers.impl.asm.ASMAccessorOptimizer$ContextClassLoader, gw.internal.gosu.compiler.SingleServingGosuClassLoader, # User-configurable custom labels for this agent. Labels are name-value pairs. # There is a maximum of 64 labels per agent. Names and values are limited to 255 characters. # Names and values may not contain colons (:) or semicolons (;). labels: # An example label #label_name: label_value # Application Environments # ------------------------------------------ # Environment specific settings are in this section. # You can use the environment to override the default settings. # For example, to change the app_name setting. # Use -Dnewrelic.environment=<environment> on the Java startup command line # to set the environment. # The default environment is production. # NOTE if your application has other named environments, you should # provide configuration settings for these environments here. development: <<: *default_settings app_name: My Application (Development) test: <<: *default_settings app_name: My Application (Test) production: <<: *default_settings staging: <<: *default_settings app_name: My Application (Staging) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 94.515625,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> config file template",
        "sections": "<em>Java</em> <em>agent</em> config file template",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " options visit https:&#x2F;&#x2F;docs.newrelic.com&#x2F;docs&#x2F;<em>agents</em>&#x2F;<em>java</em>-<em>agent</em>&#x2F;<em>configuration</em>&#x2F;<em>java</em>-<em>agent</em>-<em>configuration</em>-config-file. # # &lt;%= generated_for_user %&gt; # # This section is for settings common to all environments. # Do not add anything above this next line. common: &amp;default_settings"
      },
      "id": "603eb738e7b9d242542a0815"
    },
    {
      "sections": [
        "Name your Java application",
        "Set or change app name",
        "Tip",
        "Use multiple app names",
        "Java config file",
        "Java environment variable",
        "System properties",
        "Important"
      ],
      "title": "Name your Java application",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "72db22e0ea6a9f8062f65ad8d7fc3e22608f90a2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/name-your-java-application/",
      "published_at": "2021-05-05T06:50:12Z",
      "updated_at": "2021-03-16T13:13:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent gives you several ways to change the application name that is reported and displayed in APM. This document gives you an overview of those naming options. For a general overview of APM app naming (not Java-specific), see Name your application. Set or change app name APM differentiates applications by the name they report as. Data continuity breaks when you change the application name. To change an application's name without breaking data continuity, use the UI alias-change option. Here are the ways to change your Java application's name: Naming method Description Recommended: Configure app_name in newrelic.yml Configure your newrelic.yml file to set your app name. This is the recommended and most commonly used option: app_name: My Application Copy Configure app_name using JVM arguments Set a system property with JVM arguments to set unique app names for multiple applications that report to the same Java agent: -Dnewrelic.config.app_name=\"My App\" Copy Set app name using environment variables Set an environment variable to easily set app names during the deployment of containers, or to ensure an app name stays the same through multiple iterations of a newrelic.yml file: export NEW_RELIC_APP_NAME=\"My App\" Copy Automatic application naming Enable automatic application naming in your newrelic.yml file if you want applications named for their context, filter, servlet, or request attribute: enable_auto_app_naming: true Copy Change alias via UI Change an application's alias to change only the displayed name in the UI. This does not change the name the application reports as. This does not break data continuity, unlike all other options. Tip Note that some methods take precedence over others. Use multiple app names You can use multiple app names to aggregate data from several applications under the same name in APM (sometimes referred to as \"rolling up\" your data). For more about how multiple app names work, see Use multiple app names. In Java, you can set up to three app names. The primary app name is first, while the second and third names are used for the more general data aggregation categories. Java config file Here is an example of setting multiple names in the newrelic.yml file: app_name: My Application;My Application 2;My application 3 Copy Java environment variable Here is an example of setting multiple names as environment variable: export NEW_RELIC_APP_NAME=\"My Application;My Application 2;My application 3\" Copy System properties Important If you set multiple application names using system properties on the Java command line, remember to quote the command-line parameter because of the ; character. Here is an example of setting multiple names as a system property: -Dnewrelic.config.app_name=\"My Application;My Application 2;My application 3\" Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 94.50982,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Name your <em>Java</em> application",
        "sections": "Name your <em>Java</em> application",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "New Relic&#x27;s <em>Java</em> <em>agent</em> gives you several ways to change the application name that is reported and displayed in APM. This document gives you an overview of those naming options. For a general overview of APM app naming (not <em>Java</em>-specific), see Name your application. Set or change app name APM"
      },
      "id": "603ea329196a675e06a83dd4"
    }
  ],
  "/docs/agents/java-agent/configuration/java-agent-error-configuration": [
    {
      "sections": [
        "Configuring your SSL certificates",
        "Notice of expired SSL certificates and certificate removal",
        "Caution",
        "Important",
        "Java Agent versions 6.2.0 - 6.4.2",
        "Java Agent versions 6.0.0/6.1.0",
        "Using YAML-based configuration",
        "Java Agent versions prior to 6.0.0 (Deprecated)",
        "For more help"
      ],
      "title": "Configuring your SSL certificates",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "af154f250e87f571db157972e22dbb1f907a8fde",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/configuring-your-ssl-certificates/",
      "published_at": "2021-05-05T06:44:59Z",
      "updated_at": "2021-04-28T23:01:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To communicate with the New Relic collector over HTTPS, you need to have the proper certificates for trusted signers in the trust store on your app server. By default, most JREs contain a valid root certificate that allows the agent to connect to newrelic.com. For SSL connection issues, please visit SSL or connection errors (Java). Notice of expired SSL certificates and certificate removal Caution The SSL certificates that were bundled with Java agent versions 6.1.0 to 6.4.2 have expired and are no longer valid. This means that Java agent versions 6.1.0 to 6.4.2 can no longer use the certificates bundled with the agent to establish a connection with New Relic and that you must provide your own SSL certificates. Please see this community forum post for additional details. Important Java agent versions higher than 6.4.2 no longer ship with SSL certificates bundled into the agent. You must provide your own SSL truststore to the agent by explicitly using the ca_bundle_path configuration option, or by using the default truststore provided by the JDK/JRE (the agent will look to use the latter by default). Additionally the use_private_ssl configuration option has been removed from Java agent versions higher than 6.4.2. Users wishing to add the global certificate to their local trust store can download the DigiCert Global Root CA from DigiCert. Java Agent versions 6.2.0 - 6.4.2 Starting with Java agent version 6.2.0, the use_private_ssl configuration option has been reintroduced so you can use the SSL certificates that are bundled into the agent jar. The following bundled SSL certificates are valid for up to a year after release. META-INF/certs/eu-newrelic-com.pem META-INF/certs/eu01-nr-data-net.pem META-INF/certs/newrelic-com.pem Copy Important The Java agent will begin logging a warning message upon application startup when there are less than three months before the bundled certificate expires. When the bundled certificates expire, the Java agent will no longer be able to connect to New Relic and you must either update to the latest agent version or provide a valid certificate using the ca_bundle_path configuration. Users wishing to add the global certificate to their local trust store can download the DigiCert Global Root CA from DigiCert. Using YAML-based configuration common: default_settings ca_bundle_path: /path/to/digicert.pem use_private_ssl: false # # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic ... Copy Summary There are two configuration settings that determine what certs are used by the agent to establish a secure connection to New Relic. They are: use_private_ssl and ca_bundle_path. Here's how they work together: DEFAULT: Neither configuration option (ca_bundle_path/use_private_ssl) is provided, because both are using default values. The agent will use the default SSL certificates bundled into the Java Development Kit (JDK). If these certificates aren't present or don't include certificates that trust New Relic, then the agent will not connect. You'll need to merge valid certificates into your JDK certificate bundle. Only use_private_ssl is configured. The agent will use the SSL certificates that are bundled with it. Only ca_bundle_path is configured. The agent will try to connect using the custom SSL certificates bundle at the configured path. If the configured custom certificate bundle doesn’t include certificates that trust New Relic, then the agent will not connect. You'll need to merge valid certificates into your custom certificate bundle. Both use_private_ssl and ca_bundle_path are configured. The ca_bundle_path configuration setting takes precedence and the use_private_ssl config is ignored. This behavior is the same as only specifying ca_bundle_path. Java Agent versions 6.0.0/6.1.0 Starting in 6.0.0, the Java agent no longer includes the nrcert global certificate chain. Users wishing to add the global certificate to their local trust store must download the DigiCert Global Root CA from DigiCert. Note: In versions 6.1.0+, the Java agent will use a bundled New Relic certificate that is valid for up to a year after release. Before the certificate expires, you must either update the agent to the latest version or provide a valid certificate using the ca_bundle_path configuration. Important The Java agent will begin logging a warning message upon application startup when there are less than three months before the bundled certificate expires. Using YAML-based configuration common: default_settings ca_bundle_path: /path/to/digicert.pem # # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic ... Copy Java Agent versions prior to 6.0.0 (Deprecated) For Java agent versions prior to 6.0.0, applications that require valid certificates may add them in one of the following two ways: Use YAML-based configuration. Add the bundled list of New Relic trusted signers to the local store. Using YAML-based configuration The New Relic Java agent bundles the list of trusted signers in the agent newrelic.jar file. If you do not want to change the local trust store, you can activate them by setting use_private_ssl to true in the newrelic.yml agent configuration file: common: default_settings use_private_ssl: true # # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic ... Copy For more help Additional documentation resources include New Relic for Java (compatibility and requirements, installation, and configuration.)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 133.55928,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Configuring</em> your SSL certificates",
        "sections": "<em>Java</em> <em>Agent</em> versions 6.2.0 - 6.4.2",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " provide your own SSL truststore to the <em>agent</em> by explicitly using the ca_bundle_path <em>configuration</em> option, or by using the default truststore provided by the JDK&#x2F;JRE (the <em>agent</em> will look to use the latter by default). Additionally the use_private_ssl <em>configuration</em> option has been removed from <em>Java</em>"
      },
      "id": "603eb7a2e7b9d247c02a080d"
    },
    {
      "sections": [
        "Java agent configuration: Config file",
        "Configuration file structure",
        "Tip",
        "Configuration settings precedence",
        "Configuring the Java extensions directory",
        "Create an extensions directory",
        "Specify an existing extensions directory",
        "General configuration settings",
        "license_key (REQUIRED)",
        "app_name (REQUIRED)",
        "agent_enabled",
        "apdex_t (DEPRECATED)",
        "appserver_port",
        "Important",
        "audit_mode",
        "ca_bundle_path",
        "use_private_ssl",
        "enable_auto_app_naming",
        "enable_auto_transaction_naming",
        "Caution",
        "enable_custom_tracing",
        "extensions.dir",
        "high_security",
        "insert_api_key",
        "labels",
        "max_stack_trace_lines",
        "proxy_host",
        "proxy_password",
        "proxy_port",
        "proxy_user",
        "proxy_scheme",
        "reactor-netty.errors.enabled",
        "send_data_on_exit",
        "send_data_on_exit_threshold",
        "send_environment_info",
        "send_jvm_props",
        "ssl (DEPRECATED)",
        "sync_startup",
        "scala_futures_as_segments",
        "Logging configuration",
        "log_daily",
        "log_file_count",
        "log_file_name",
        "log_file_path",
        "log_level",
        "log_limit_in_kbytes",
        "JMX",
        "enabled",
        "linkingMetadataMBean",
        "Attributes",
        "include",
        "exclude",
        "Transaction tracer",
        "explain_enabled",
        "explain_threshold",
        "insert_sql_max_length",
        "log_sql",
        "record_sql",
        "stack_based_naming (Play 2.x+ only)",
        "stack_trace_threshold",
        "top_n",
        "transaction_threshold",
        "slow_query_whitelist (DEPRECATED)",
        "collect_slow_queries_from",
        "attributes.enabled",
        "attributes.include",
        "attributes.exclude",
        "token_limit",
        "segment_limit",
        "Transaction segments",
        "Browser monitoring",
        "auto_instrument",
        "disabled_auto_pages",
        "External tracer",
        "exclude_request_uri",
        "Cross application tracer",
        "Error collector",
        "ignore_classes",
        "ignore_messages",
        "ignore_status_codes",
        "expected_classes",
        "expected_messages",
        "expected_status_codes",
        "ignore_errors (DEPRECATED)",
        "Strip exceptions",
        "whitelist (DEPRECATED)",
        "allowed_classes",
        "Thread profiler",
        "Transaction events",
        "max_samples_stored",
        "custom_request_headers",
        "Custom events",
        "Hostname configuration",
        "display_name",
        "ipv_preference",
        "Custom instrumentation",
        "trace_annotation_class_name",
        "com.newrelic.instrumentation.servlet-user",
        "System properties",
        "newrelic.config.process_host.display_name",
        "newrelic.config.file",
        "newrelic.debug",
        "newrelic.environment",
        "newrelic.home",
        "newrelic.logfile",
        "Environment variables",
        "NEW_RELIC_APP_NAME (REQUIRED)",
        "NEW_RELIC_DISTRIBUTED_TRACING_ENABLED",
        "NEW_RELIC_PROCESS_HOST_DISPLAY_NAME",
        "NEW_RELIC_LICENSE_KEY (REQUIRED)",
        "NEW_RELIC_LOG",
        "Cloud platform utilization",
        "detect_aws",
        "detect_docker",
        "Async instrumentation",
        "token_timeout",
        "segment_timeout",
        "Circuit breaker",
        "memory_threshold",
        "gc_cpu_threshold",
        "Message tracer",
        "segment_parameters.enabled",
        "Distributed tracing",
        "exclude_newrelic_header",
        "Infinite Tracing",
        "trace_observer.host",
        "Span events",
        "Jar collector",
        "skip_temp_jars",
        "jars_per_second"
      ],
      "title": "Java agent configuration: Config file",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "1d61f848fa192438225eae269421b8d384915c8b",
      "image": "https://docs.newrelic.com/static/60ca967eab99ca225186310913ae2de6/8c557/java-config-cascade.png",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-configuration-config-file/",
      "published_at": "2021-05-04T17:01:42Z",
      "updated_at": "2021-03-16T15:52:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent reads its configuration from the newrelic.yml file. By default the agent looks for this file in the directory that contains newrelic.jar. You can override the config file's location by setting the newrelic.config.file system property to a fully qualified file name. Configuration file structure The newrelic.yml file is split into stanzas corresponding to different environments: Test Development Staging Production (default) New Relic applies settings in the common stanza to each of these environments. You can select other environments as the default by setting the newrelic.environment system property to the environment name. Tip A newrelic.yml template is available. If you edit newrelic.yml, be careful to conform to the YAML format. Use a YAML validator to ensure the syntax is accurate before using the file with New Relic's Java agent, and follow these rules: Java agent newrelic.yml Requirements Format YML files are case sensitive. Indentations All indentations must be in increments of two characters. Other indentations will result in an Unable to parse configuration file error upon agent startup. Use the same level of indentation for data in the same stanza of the file. Indent any sub-stanzas by an additional two spaces. Changes to file You must restart your JVM host process for changes to take effect. Exception: Property changes to log_level and audit_mode do not require a restart. Property changes under circuit breaker don't require a restart. Configuration settings precedence To override any setting in the config file, use a system property override. In certain environments, environment variables can also be used to override both the config file and the system properties. The environment variables primarily exist to support Heroku. When used, server-side configuration overrides all other configuration settings. With the Java agent, server-side configuration overrides all other settings. Environment variables override Java system properties. Java properties override user configuration settings in your newrelic.yml file. User settings override the newrelic.yml default settings. Configuring the Java extensions directory The Java agent reads the configuration files on process startup. To identify the directory where the files are located, either create a new or specify an existing extensions directory: Create an extensions directory To create the extensions directory: Navigate to the directory where newrelic.jar and newrelic.yml are located. Create a directory named extensions. In newrelic.yml, check that the property extensions.dir is not set. Specify an existing extensions directory To use an existing Java extensions directory: In your newrelic.yml file, locate the common section. Use the property extensions.dir to specify the location of the file. General configuration settings Set these options in the common stanza. To override any of these options, use a newrelic.config prefixed system property. license_key (REQUIRED) Type String Default (none) This setting is required. You must specify the license key associated with your New Relic account. This key binds your agent's data to your account in the New Relic service. app_name (REQUIRED) Type String Default (none) This setting is required. Defines the application name used to report data to New Relic. If enable_auto_app_naming is false, the agent reports all data to this application. Otherwise, the agent reports only background tasks (transactions for non-web applications) to this application. To report data to more than one application, separate the application names with a semicolon. For example, to report data to My Application and My Application 2 use this: app_name: My Application;My Application 2 Copy For more methods of naming your application, see Name your Java application. agent_enabled Type Boolean Default true Flag to enable the agent. Use this setting to force the agent to run or not run. apdex_t (DEPRECATED) Type Float Default 1.0 The apdex_t threshold in seconds for the application's Apdex score. For Java agent versions 1.2.008 or higher, the apdex_t value is set in the UI and the value in newrelic.yml is ignored. appserver_port Type Integer Default (none) Number to differentiate JVMs for the same app on the same machine. New Relic uses host/port for uniqueness, so you can distinguish the JVMs by putting a switch like this into the startup arguments for each JVM: -Dnewrelic.config.appserver_port=8081 Copy Once you have used appserver_port to name the JVMs and restart them, you should be able to see them individually in the dropdown and in the profiling interface. Important This is only a change for New Relic; it doesn't actually affect the port on which the host communicates in any way. audit_mode Type Boolean Default false Enables plain text logging of all data sent to New Relic to the agent logfile. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. ca_bundle_path Type String Value Format /path/to/ca/cert/bundle.pem Specifies a path to a custom SSL certificate bundle that will be used by the agent to establish a secure connection to New Relic. If your custom SSL certificate bundle doesn't include certificates that are sufficient to connect to New Relic then you'll need to merge the required certs into your custom certificate bundle. use_private_ssl Type Boolean Default false The following SSL certificates are bundled into the agent jar: META-INF/certs/eu-newrelic-com.pem META-INF/certs/eu01-nr-data-net.pem META-INF/certs/newrelic-com.pem Copy By default (use_private_ssl: false) the agent will use the SSL certificates bundled into the JDK to establish a secure connection to New Relic or the custom SSL certificates bundle specified by ca_bundle_path. If you want to use the SSL certificates bundled with the agent, set use_private_ssl: true. Note: use_private_ssl will be ignored if ca_bundle_path is set. enable_auto_app_naming Type Boolean Default false Enables the reporting of data separately for each web app. Set to true to enable support for auto app naming. The name of each web app is detected automatically and the agent reports data separately for each one. This provides a finer-grained performance breakdown for web apps in New Relic. For more information, see Automatic application naming. For more methods of naming your application, see Name your Java application. enable_auto_transaction_naming Type Boolean Default true Enables component-based transaction naming. Set to true to enable component-based transaction naming. Set to false to use the URI of a web request as the name of the transaction. For more information, see Naming web transactions. Caution Unless you implement API calls to name your transactions, disabling auto-transaction naming is very likely to cause Metric grouping issues. enable_custom_tracing Type Boolean Default true Enables all instrumentation using an @Trace annotation. Disabling this causes @Trace annotations to be ignored. extensions.dir Type String Default (none) Defines the location of the optional extensions directory. If this property is not set, the agent will look for a subdirectory named extensions in the same directory as newrelic.jar and newrelic.yml. high_security Type Boolean Default false In order for high security to be enabled, this property must be set to true and the high security property in the New Relic user interface must be enabled. Enabling high security means SSL is turned on, request and message queue parameters are not collected, and queries cannot be sent to New Relic in their raw form. Important As of Java agent 3.48.0, SSL is enabled by default and the config option to disable it has been deprecated. As of Java agent 4.0.0, the ability to disable SSL has been removed. insert_api_key Type String Default (none) A valid Insert API Key for your account. This is only required for Real-time Java profiling using JFR metrics. labels Type String Default \"\" Attach tags to this app. Note that this option now enables tags, which replaced the label feature. You can still query your historical labels. max_stack_trace_lines Type Integer Default 30 Limits the number of lines the agent collects from each stack trace. Increasing this value may impact performance, because it increases the amount of memory the agent uses and the amount of data sent to New Relic. proxy_host Type String Default (none) The proxy host through which to connect to the New Relic collector. If a proxy is used, the host setting is required. Other proxy settings are optional. proxy_password Type String Default (none) The password for proxy authentication. If a proxy is used, the host setting is required. Other proxy settings are optional. The username and password settings will be used to authenticate to Basic Auth challenges from a proxy server. Important The Java agent supports Basic (clear text) authentication. proxy_port Type String Default 8080 The proxy host port number. If a proxy is used, the host setting is required. Other proxy settings are optional. proxy_user Type String Default (none) The username for proxy authentication, such as Basic (clear text) authentication. If a proxy is used, the host setting is required. Other proxy settings are optional. The username and password settings will be used to authenticate to Basic Auth challenges from a proxy server. proxy_scheme Type String Default (none) The proxy scheme used. Setting proxy_scheme: \"https\" will allow the agent to connect through proxies using the HTTPS scheme. reactor-netty.errors.enabled Type Boolean Default true Whether errors are reported for reactor netty. If set to false, errors will be ignored. Important Only available in Java agent 6.3.0 and above. send_data_on_exit Type Boolean Default false Enable delayed JVM shutdown to give the agent a chance to send latest metric data to New Relic before JVM shutdown. send_data_on_exit_threshold Type Integer Default 60 The number of seconds after which the agent will use the send_data_on_exit setting. send_environment_info Type Boolean Default true Enable reporting of JVM settings to New Relic. send_jvm_props Type Boolean Default true When set to true, JVM properties will be sent to New Relic. ssl (DEPRECATED) Type Boolean Default true Requires connections to the New Relic collector to go over SSL. The agent communicates with New Relic via HTTPS by default, and New Relic requires HTTPS for all traffic to APM and the New Relic REST API. This work is done asynchronously to the threads that process your application code, so response times will not be directly affected by this change. Important As of Java agent 3.48.0, SSL is enabled by default and the config option to disable it has been deprecated. As of Java agent 4.0.0, the ability to disable SSL has been removed. sync_startup Type Boolean Default false Enable the agent to connect the New Relic collector immediately upon app startup. scala_futures_as_segments Important This applies to Java agent version 3.44.0 or higher. Type Boolean Default false For more concise transaction trace details, the agent does not report Scala Futures as transaction segments, and those Futures do not contribute to the transaction’s total time. Enabling scala_futures_as_segments increases your overhead. If you want Scala Futures to report as transaction segments so you can view them in a transaction trace, you can enable it: scala_futures_as_segments: enabled: true Copy Logging configuration These are part of the general configuration variables. They are broken out here because they are frequently tweaked for debugging. Some of the logging configuration variables are dynamic and do not need a host restart for them to take effect. For instance, if log files are growing too quickly, log_level can be set to a less verbose setting to reduce the reporting rate. Here is the order of precedence for configuration variables affecting log rotation. If log_daily is true, other log rotation settings are ignored. If log_file_count is 1 or 0, the size limit is ignored. Finally, the agent applies log_limit_in_kbytes. Depending on the growth rate, it is possible for the log file size to exceed the configured value by a small amount. log_daily Type Boolean Default false Set to true to roll the logs daily. Overrides the other configuration variables that affect log rotation. log_file_count Type Integer Default 1 The maximum number of log files to keep when using log rotation. log_file_name Type String Default newrelic_agent.log The unqualified log file name or the string STDOUT which will log to standard out. log_file_path Type String Default logs subdirectory where newrelic.jar is located The log file path. Tip If log_file_path is specified, the directory must already exist. If the default value is used, the agent will attempt to create the directory. log_level Type String Default info The log verbosity level. The agent uses its own log file to keep its logging separate from that of your application. Valid options, in order of verboseness, are: off severe warning info fine finer finest This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. log_limit_in_kbytes Type Integer Default 0 The log file size in kilobytes at which log files are rotated. Set to 0 for no limit. JMX To set these options, use the jmx stanza. To override them, use a newrelic.config.jmx prefixed system property. The Java agent uses JMX to collect JVM data as well as to communicate with the JFR (Java Flight Recorder) daemon for Real-time Java profiling. enabled Type Boolean Default true This setting can be used to turn on or off all JMX functionality. linkingMetadataMBean Type Boolean Default false This setting can be enabled to allow the Java agent to expose linking metadata to the JFR daemon. Doing so allows the JFR daemon to obtain the entity GUID generated by the Java agent and link JFR data with the same APM application that is being monitored by the agent instead of as a separate entity. Important This applies to Java agent version 6.1.0 or higher. Attributes To set these options, use the attributes stanza. To override them, use a newrelic.config.attributes prefixed system property. Attributes are key-value pairs that provide information for transaction traces, traced errors, browser monitoring, and transaction events. There is also an attribute stanza under each destination. For more information, see Java agent attributes, Enabling and disabling attributes and Attribute examples. enabled Type Boolean Default true This setting can be used to turn on or off all attributes. Important For security reasons, capturing custom attributes using the Custom Instrumentation Editor is set to false by default. include Type List of Strings Default (none) If attributes are enabled, attribute keys found in this list will be sent to New Relic. Separate the keys in the list with a comma; for example: key1, key2, key3 Copy Also refer to the agent attribute rules. exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic. Separate the keys in the list with a comma; for example: key1, key2, key3 Copy Also refer to the agent attribute rules. Transaction tracer These options are set in the transaction_tracer stanza and can be overridden by using a newrelic.config.transaction_tracer prefixed system property. Transaction tracing captures deep information about slow transactions and sends this to the New Relic service. The transaction includes the exact call sequence of the transactions, including any query statements issued. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. enabled Type Boolean Default true The transaction tracer is enabled by default. Set this to false to turn it off. explain_enabled Type Boolean Default true Determines whether the agent will capture the EXPLAIN plan for slow queries. Only supported for MySQL and PostgreSQL. explain_threshold Type Float Default 0.5 Threshold in seconds for query execution time below which the slow query and the EXPLAIN plan (if supported) will not be captured. Relevant to slow queries only when record_sql is set to raw or obfuscated. Relevant to EXPLAIN plans only when explain_enabled is set to true. insert_sql_max_length Type Integer Default 2000 The character limit for the SQL query string. If you have many slow SQL queries with large chunks of information, this could negatively affect performance or how quickly you see your data in New Relic. Increase the value gradually until you find the right balance of information and performance. log_sql Type Boolean Default false Set to true to enable logging of queries to the agent log file instead of uploading to New Relic. Queries are logged using the record_sql mode. record_sql Type String Default obfuscated When the transaction tracer is on, query statements can optionally be recorded. The recorder has three modes: off: Send no queries. raw: Send the query statement in its original form. obfuscated: Strips out numeric and string literals. stack_based_naming (Play 2.x+ only) Type Boolean Default False Defaulted to true until Java agent version 3.12.1, when it was changed to false. This option is for Play 2.x+ only. Play/Scala instrumentation can use Thread.getStackTrace() to improve tracer naming, but at the cost of increased overhead. stack_trace_threshold Type Integer Default 0.5 Defines a threshold (in seconds) for collecting stack traces from an SQL call. When SQL statements exceed this threshold, the agent will capture the current stack trace. This is useful for pinpointing where long SQL calls originate from. top_n Type Integer Default 20 Use this setting to control the variety of your transaction traces. top_n is an integer that represents the number of unique, slow transactions that traces will be created for. If you want transaction traces to more accurately reflect the actual slowest transactions in your app, make this value lower. If you want to sample a more diverse array of transactions, make the value higher. A value of 0 would mean that only the slowest transaction is always traced. This is considered not to be optimal, though, because you may have one or two transactions that are always the slowest, and repeatedly seeing those same transaction traces will probably not give you much value. If the same transaction is often the slowest, the top_n setting allows the Java agent (over time) to sample the slowest n transactions. This gives you greater variety and more insight into your application. transaction_threshold Type String (float) Default apdex_f The time threshold used to determine when a transaction is eligible to be traced. When the transaction's response time exceeds this threshold, a transaction trace will be recorded and sent to New Relic. The default is apdex_f (default), which sets the threshold to be the \"Frustrated\" Apdex level (four times the apdex_t value). You can also set a specific time threshold by entering a float value that represents a number of seconds. slow_query_whitelist (DEPRECATED) Type String Default (none) Important This config has been deprecated as of agent version 5.10.0 and will be removed in a future agent version. Instead use collect_slow_queries_from. By default, high security mode does not allow the agent to collect slow queries. Enable this option to collect Cassandra queries from the DataStax driver, even with high security enabled. If you don't use high security, the agent collects slow queries automatically. For DataStax driver 2.1.2, add this rule to your allow list: transaction_tracer: slow_query_whitelist: 'com.newrelic.instrumentation.cassandra-datastax-2.1.2' Copy For DataStax driver 3.0.0, add this rule to your allow list: transaction_tracer: slow_query_whitelist: 'com.newrelic.instrumentation.cassandra-datastax-3.0.0' Copy collect_slow_queries_from Type String Default (none) By default, high security mode does not allow the agent to collect slow queries. Enable this option to collect Cassandra queries from the DataStax driver, even with high security enabled. If you don't use high security, the agent collects slow queries automatically. For DataStax driver 2.1.2, add this rule to your allow list: transaction_tracer: collect_slow_queries_from: 'com.newrelic.instrumentation.cassandra-datastax-2.1.2' Copy For DataStax driver 3.0.0, add this rule to your allow list: transaction_tracer: collect_slow_queries_from: 'com.newrelic.instrumentation.cassandra-datastax-3.0.0' Copy attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for transaction traces. If attributes.enabled at the root level is false, no attributes will be sent to transaction traces regardless on how this property (transaction_tracer.attributes.enabled) is set. attributes.include Type List of strings Default (none) If attributes are enabled for transaction traces, all attribute keys found in this list will be sent to New Relic in transaction traces. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in transaction traces. For more information, see the agent attribute rules. token_limit Type Integer Default 3000 Limits the number of Tokens that can be created per Transaction. Increasing this value may impact performance, because it increases the amount of memory the agent uses and the amount of data sent to New Relic. segment_limit Type Integer Default 3000 Limits the number of segments that can be created per transaction. Increasing this value may impact performance, because it increases the amount of memory the agent uses and the amount of data sent to New Relic. Transaction segments These options are set in the transaction_segments stanza and can be overridden by using a newrelic.config.transaction_segments prefixed system property. Transaction segments represent discrete pieces of work (generally method calls) and are displayed within transaction traces. Important Transaction segment attribute filtering requires Java agent version 4.10.0 or higher. attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for transaction segments. If attributes.enabled at the root level is false, no attributes will be sent to transaction segments regardless on how this property (transaction_segments.attributes.enabled) is set. attributes.include Type List of strings Default (none) If attributes are enabled for transaction segments, all attribute keys found in this list will be sent to New Relic in transaction segments. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in transaction segments. For more information, see the agent attribute rules. Browser monitoring These options are set in the browser_monitoring stanza and can be overridden by using a newrelic.config.browser_monitoring prefixed system property. Browser monitoring gives you insight into the performance real users are experiencing with your website. This is accomplished by measuring the time it takes for your users' browsers to download and render your web pages by injecting a small amount of JavaScript code into the header and footer of each page. auto_instrument Type Boolean Default true By default the agent automatically inserts API calls in compiled JSPs to inject the monitoring JavaScript into web pages. Set this attribute to false to turn off this behavior. disabled_auto_pages Type Comma-separated list of strings Default (none) When auto_instrument is true, by default all pages are instrumented. List all pages that you want the auto instrumentation to skip here. You can still use manual instrumentation on these pages. For example: browser_monitoring: disabled_auto_pages: /WEB-INF/jsp/testpage_1.jsp, /WEB-INF/jsp/testpage_2.jsp Copy attributes.enabled Type Boolean Default false This setting can be used to turn on or off all attributes for browser monitoring. This is the data you can query. If attributes.enabled is false at the root level, no attributes will be sent up in browser monitoring regardless on how this property under browser_monitoring is set. attributes.include Type List of Strings Default (none) If attributes are enabled for browser_monitoring, all attribute keys found in this list will be sent to New Relic in page views. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in page views. For more information, see the agent attribute rules. External tracer The external tracing options are set in the external_tracer stanza and can be overridden by using a newrelic.config.external_tracer prefixed system property. exclude_request_uri Type Boolean Default false This setting can be used to control the collection of outgoing request URIs for errors and transaction traces. Set this to true to disable collecting this information. Cross application tracer The cross application tracing options are set in the cross_application_tracer stanza and can be overridden by using a newrelic.config.cross_application_tracer prefixed system property. Cross application tracing adds request and response headers to external calls using the Apache HttpClient libraries. This provides better performance data when calling applications monitored by other New Relic Agents. enabled Type Boolean Default true Cross application tracing is enabled by default. Set this to false to turn it off. Error collector These options are set in the error_collector stanza and unless noted otherwise can be overridden by using a newrelic.config.error_collector prefixed system property. The error collector captures information about uncaught exceptions and sends them to New Relic for viewing. Tip For how to configure errors for the Java agent, including how to configure errors via the UI, see Java agent error configuration. enabled Type Boolean Default true Enable error collection. ignore_classes Type Stanza containing a list of fully qualified class_name strings Default (none) Specified exception class names will be ignored and will not affect error rate or Apdex score, or be reported to APM. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: ignore_classes: - \"com.example.MyException\" - \"com.example.DifferentException\" Copy ignore_messages Type Stanza containing a fully qualified class_name and a list of messages per error class Default (none) Specify exception class names the agent should ignore. Ignored messages will not affect error rate or Apdex score, or be reported to APM. Contains yaml pairs consisting of: A fully qualified exception class name that should not be reported to APM AND A list of exception messages to match against (at least one is required) If the exception class name matches an error but the message does not, then that error will not be ignored. Message strings use contains for matching. A message cannot be provided on its own and must always be paired with a fully qualified class name. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: ignore_messages: com.example.MyException: - \"Some error message to ignore\" - \"Some other error message to ignore\" com.example.DifferentException: - \"Some different error message to ignore\" Copy ignore_status_codes Type Comma-separated list of strings and ranges Default 404 A comma-separated list comprised of individual and dashed ranges of HTTP status codes that should not be treated as errors. If this property is commented out in the newrelic.yml configuration file, then the 404 status code will automatically be ignored. When using server-side configuration, the status code 404 must be specified in order for it to be ignored. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: ignore_status_codes: 404,507-511 Copy expected_classes Type Stanza containing a List of fully qualified class_name strings Default (none) Prevents specified exception classes from affecting error rate or Apdex score while still reporting the errors to APM. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: expected_classes: - \"com.example.MyException\" - \"com.example.DifferentException\" Copy expected_messages Type Stanza containing a fully qualified class_name and a List of messages per error class Default (none) Contains yaml pairs consisting of a fully qualified exception class name that should be marked as expected and thus prevented from affecting error rate or Apdex score and a List of exception messages to match against, the latter of which at least one is required. If the exception class name matches an error but the message does not, then that error will not be marked as expected and therefore will affect error rate and Apdex score. Message strings use contains for matching. A message cannot be provided on its own and must always be paired with a fully qualified class name. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: expected_messages: com.example.MyException: - \"Some expected error message\" - \"Some other expected error message\" com.example.DifferentException: - \"Some different expected error message\"​ Copy expected_status_codes Type Comma-separated list of strings and ranges Default (none) A comma-separated list comprised of individual and dashed ranges of HTTP status codes to be marked as expected and thus prevented from affecting error rate or Apdex score. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: expected_status_codes: 415,500-506 Copy attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for traced errors. If attributes.enabled is false at the root level, then no attributes will be sent to traced errors regardless of how this property is set under error_collector. attributes.include Type List of strings Default (none) If attributes are enabled for traced errors, all attribute keys found in this list will be sent to New Relic in traced errors. For more information, see the agent attribute rules. attributes.exclude Type List of strings Default (none) Attribute keys found in this list will not be sent to New Relic in traced errors. For more information, see the agent attribute rules. ignore_errors (DEPRECATED) Type Comma-separated list of Strings Default (none) All specified exception class names specified will not be treated as errors. Deprecated as of Java agent 3.40.0 and replaced by ignore_classes. For example: error_collector: ignore_errors: some.other.MyException Copy Strip exceptions These options are set in the strip_exception_messages stanza and unless noted otherwise can be overridden by using a newrelic.config.strip_exception_messages​prefixed system property. This configuration can be enabled to control whether Java exception messages are reported to New Relic. enabled Type Boolean Default false By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you set this to true, the agent strips the messages from exceptions in order to prevent it from inadvertently capturing sensitive information. If you enable high security mode, this is automatically set to true. If you set enabled to true but you want the agent to capture messages from specific exceptions, add the exceptions to your allow list. whitelist (DEPRECATED) Type String Default (none) Important This config has been deprecated as of agent version 5.10.0 and will be removed in a future agent version. Instead use allowed_classes. If you set enabled to true but you want the agent to capture messages for specific exceptions, add each exception to the whitelist, separated by a comma. allowed_classes Type String Default (none) If you set enabled to true but you want the agent to capture messages for specific exceptions, add each exception to allowed_classes, separated by a comma. Thread profiler These options are set in the thread_profiler stanza and can be overridden by using a newrelic.config.thread_profiler prefixed system property. Thread profiler measures wall clock time, CPU time, and method call counts in your application's threads as they run. enabled Type Boolean Default true Enable the thread profiler. Transaction events These options are set in the transaction_events stanza and can be overridden by using a newrelic.config.transaction_events prefixed system property. Transaction events provide the data for displaying histograms and percentiles in the UI. Important Previously this stanza was called analytics_events. If your configuration file still uses analytics_events, update your agent to use transaction_events. enabled Type Boolean Default true Enable the transaction events service. max_samples_stored Type Integer Default 2000 Max 10000 The maximum number of sampled transaction events reported every 60 seconds. custom_request_headers Type List of maps Default None Important Unlike other settings, custom_request_headers have to be paired together and must be set in the newrelic.yml file. They can't be overwritten by Java virtual machine arguments (system property) or environment variables. A list of maps with the paired keys header_name and the optional header_alias. Choose one or more custom HTTP request headers to add as transaction attributes. You can list multiple header configurations: transaction_events: custom_request_headers: - header_name: \"X-Custom-Header-1\" - header_name: \"X-Custom-Header-2\" header_alias: \"CustomHeader2alias\" Copy In the first map set, X-Custom-Header-1 is captured and reported by the agent as the header name for a corresponding value from the request object. The header_name will also be the name of the attribute sent to New Relic. In the second map set, the request header is X-Custom-Header-2, but the CustomHeader2alias is the name sent to New Relic. attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for transaction events. If attributes.enabled is false at the root level, then no attributes will be sent to transaction events regardless of how this property is set under transaction_events. attributes.include Type List of Strings Default (none) If attributes are enabled for transaction events, all attribute keys found in this list will be sent to New Relic in transaction events. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in transaction events. For more information, see the agent attribute rules. Custom events Custom events are set in the custom_insights_events stanza and can be overridden by using a newrelic.config.custom_insights_events prefixed system property. APM lets you record custom event data via the New Relic language agent APIs, which you can then query. Important For Java agent versions prior to 4.1.0, the following YAML configuration is recognized: custom_insights_events.enabled: true custom_insights_events.max_samples_stored: 5000 Copy For agent versions 4.1.0 and above, the YAML configuration uses the nested stanza formatting: custom_insights_events: enabled: false max_samples_stored: 5000 Copy enabled Type Boolean Default true This enables the custom event service. max_samples_stored Type Integer Default/Max 10000 The maximum number of sampled custom events reported every 60 seconds. Hostname configuration These options are set in the process_host stanza and can be overridden by using a newrelic.config.process_host prefixed system property. These properties are used for configuring the hostname displayed in the UI: display_name Type String Default (none) Set a display name to decorate the \"host:port\" label in the New Relic UI. ipv_preference Type String Default 4 If the hostname cannot be determined, then the IP address of the host will be used. This property determines whether the IPv4 or IPv6 address should be used. The default is IPv4. Custom instrumentation These options set in the class_transformer stanza and can be overridden by using a newrelic.config.class_transformer prefixed system property. trace_annotation_class_name Type String Default (none) String containing the full class name of the annotation class the agent uses to determine which user-specified methods to instrument. For more information about custom annotations, see Java custom metric collection. com.newrelic.instrumentation.servlet-user Type Boolean Default false Enable this option to capture the userPrincipal name. This name is included as a transaction trace attribute, and can be queried. System properties You can override any setting in the newrelic.yml file by setting a system property. The system property corresponding to a given setting in the config file is the setting name prefixed by newrelic.config. For example, the system property for the log_level setting is newrelic.config.log_level. For settings nested in stanzas, prepend the stanza name to the setting name. For example, the system property for the enabled setting in the transaction_tracer stanza is newrelic.config.transaction_tracer.enabled. In addition to overriding configuration settings, the following system properties are recognized by the agent: newrelic.config.process_host.display_name Type String Default (none) Set a display name to decorate the \"host:port\" label in the New Relic UI. Requires Java agent 3.17 or higher. newrelic.config.file Type String Default (none) String containing a fully qualified path to the newrelic configuration file. If empty, the agent assumes newrelic.yml is in the same directory as newrelic.jar. newrelic.debug Type Boolean Default (none) Enable debug logging. newrelic.environment Type String Default (none) String containing the environment configuration for the agent to use. newrelic.home Type String Default (none) String containing the home directory of agent. This defaults to the same directory as the agent jarfile. newrelic.logfile Type String Default newrelic_agent.log String containing the name of the agent log file. Environment variables Environment variables take the highest precedence and override the system properties and yml config settings. To set environment variables, use the export VARNAME=value command. To permanently set environment variables, add the export line to a file such as ~/.bashrc or ~/.bash_profile. You can override any setting from a system property or in the newrelic.yml by setting an environment variable. The environment variable corresponding to a given setting in the config file is the setting name prefixed by NEW_RELIC with all dots (.) and dashes (-) replaced by underscores (_). For example, the environment variable for the log_level setting is NEW_RELIC_LOG_LEVEL. For settings nested in stanzas, prepend the stanza name to the setting name. For example, the environment variable for the enabled setting in the transaction_tracer stanza is NEW_RELIC_TRANSACTION_TRACER_ENABLED. Important Agent configuration via environment variables requires Java agent version 4.10.0 or higher. For agent versions older than 4.10.0 the following environment variables are available: NEW_RELIC_APP_NAME (REQUIRED) Type String Default (none) This setting is required. Contains the application name under which to report data to New Relic. Set the name of your application as you want it to appear in New Relic. If enable_auto_app_naming is false, the agent reports all data to this application. Otherwise, the agent reports only background tasks (transactions for non-web applications) to this application. To report data to more than one application, separate the application names with a semicolon ;. For example, to report data to My Application and My Application 2: app_name: My Application;My Application 2 Copy For more methods of naming your application, see Name your Java application. NEW_RELIC_DISTRIBUTED_TRACING_ENABLED Type String Default false Enables distributed tracing. Case sensitive: use true or false. For more information, see the distributed tracing section. NEW_RELIC_PROCESS_HOST_DISPLAY_NAME Type String Default (none) Set a display name to decorate the \"host:port\" label in the New Relic UI. NEW_RELIC_LICENSE_KEY (REQUIRED) Type String Default (none) This setting is required. Contains your New Relic account license. You must specify the license key associated with your New Relic account. This key binds your agent's data to your account in the New Relic service. NEW_RELIC_LOG Type String Default newrelic_agent.log The unqualified log file name or the string STDOUT which will log to standard out. Cloud platform utilization These options are set in the utilization stanza and can be overridden by using a newrelic.config.utilization prefixed system property. The agent collects utilization information and sends it to the New Relic service. The agent can collect information from Amazon Web Services (AWS) EC2 instances and Docker containers. detect_aws Type Boolean Default true Determines whether the agent polls AWS metadata API. detect_docker Type Boolean Default true Determines whether the agent reads Docker information from the file system. Async instrumentation These options are set directly in the common stanza and can be overridden by using a prefixed system property. token_timeout Type Integer Default (seconds) 180 The number of seconds after which the agent will automatically expire an async token that has not been explicitly expired with token.expire(). For usage instructions, see Tokens: Connect async threads. Important Increasing this value may impact performance, because it increases the amount of memory the agent uses and prevents transactions from being reported due to unexpired tokens. segment_timeout Type Integer Default (seconds) 600 The number of seconds after which the agent will automatically end a segment that has not been explicitly ended with segment.end() or segment.ignore(). For usage instructions, see Segments: Time arbitrary async activity. Important Increasing this value may impact performance, because it increases the amount of memory the agent uses and prevents transactions from being reported due to un-ended segments. Circuit breaker These settings customize the behavior of the Java circuit breaker. These settings are not included in newrelic.yml by default. You do not need to restart your JVM after changing them. If you want to customize the circuit breaker, add the stanza under the common stanza: common: &default_settings​ ​ OTHER_CONFIG_SETTINGS circuitbreaker: enabled: true memory_threshold: 20 gc_cpu_threshold: 10 Copy enabled Type Boolean Default true If your application is behaving as expected, you may want to disable the circuit breaker. memory_threshold Type Integer (0 to 100) Default 20 Customize the precentage of free heap memory below which the circuit breaker should trip. When the percentage of free heap memory is less than memory_threshold, and the CPU time spent doing garbage collection is greater than gc_cpu_threshold, the circuit breaker trips. In order to make the circuit breaker less likely to trip, decrease memory_threshold and/or increase gc_cpu_threshold. Adjust these values as needed, based on your application's operating performance and behavior. gc_cpu_threshold Type Integer (0 to 100) Default 10 Customize the precentage of garbage collection CPU time above which the circuit breaker should trip. When the percentage of free heap memory is less than memory_threshold, and the CPU time spent doing garbage collection is greater than gc_cpu_threshold, the circuit breaker trips. In order to make the circuit breaker less likely to trip, decrease memory_threshold and/or increase gc_cpu_threshold. Adjust these values as needed, based on your application's operating performance and behavior. Message tracer These options are set in the message_tracer stanza and can be overridden by using a newrelic.config.message_tracer prefixed system property. segment_parameters.enabled Type Boolean Default true Adds message properties to tracer attributes. Set this to false to turn it off. Distributed tracing Important Enabling distributed tracing disables cross application tracing, and has other effects on APM features. Before enabling, read the transition guide. Requires Java agent version 4.3.0 or higher. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. In the config file, it can be set in the distributed_tracing stanza. It can be overridden using a newrelic.config.distributed_tracing prefixed system property. enabled Type Boolean Default false Set this to true to enable distributed tracing. For example, to enable this in the config file, you would use: distributed_tracing: enabled: true Copy To enable this using a system property, you would use: -Dnewrelic.config.distributed_tracing.enabled=true Copy exclude_newrelic_header Type Boolean Default false By default, supported versions of the agent utilize both the newrelic header and W3C Trace Context headers for distributed tracing. The newrelic distributed tracing header allows interoperability with older agents that don't support W3C Trace Context headers. Agent versions that support W3C Trace Context headers will prioritize them over newrelic headers for distributed tracing. If you do not want to utilize the newrelic header, setting this to true will result in the agent excluding the newrelic header and only using W3C Trace Context headers for distributed tracing. For example, to exclude newrelic headers in the config file, you would use: distributed_tracing: exclude_newrelic_header: true Copy To exclude newrelic headers using a system property, you would use: -Dnewrelic.config.distributed_tracing.exclude_newrelic_header=true Copy Infinite Tracing Important Requirements: Java Agent 5.12.1 or higher. Infinite Tracing does not work if enable_auto_app_naming is enabled. To turn on Infinite Tracing, enable distributed tracing and add the additional setting below. For an example, see Language Agents: Configure Distributed Tracing. trace_observer.host Type String Default None For help getting a valid Infinite Tracing trace observer host entry, see find or create a Trace Observer. You can configure this via YAML: infinite_tracing: trace_observer: host: YOUR_TRACE_OBSERVER_HOST Copy You can also use the system property newrelic.config.infinite_tracing.trace_observer.host or the environment variable NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_HOST. Span events Span events are reported for distributed tracing. Distributed tracing must be enabled to report span events. Span configuration is set in the span_events stanza and can be overridden by using a newrelic.config.span_events prefixed system property. Options include: enabled Type Boolean Default true Used to enable/disable span event reporting. attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for span events. If attributes.enabled at the root level is false, no attributes will be sent to span events regardless on how this property (span_events.attributes.enabled) is set. attributes.include Type List of strings Default (none) If attributes are enabled for span events, all attribute keys found in this list will be sent to New Relic in span_events. For more information, see the agent attribute rules. attributes.exclude Type List of strings Default (none) All attribute keys found in this list will not be sent to New Relic in span events. For more information, see the agent attribute rules. Important Span event attribute filtering requires Java agent version 4.10.0 or higher. Jar collector The Java agent collects and information about jars and their versions on the application classpath. Jar collection configuration is set in the jar_collector stanza and can be overridden by using a newrelic.config.jar_collector prefixed system property. Options include: enabled Type Boolean Default true Used to enable/disable jar collection and reporting. skip_temp_jars Type Boolean Default true Used to enable/disable collection of temporary jars. Temporary jars are those residing in the directory specified by the system property java.io.tmpdir. jars_per_second Type Integer Default 10 The maximum number of jars to process per second. Must be positive.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 94.53699,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> <em>configuration</em>: Config file",
        "sections": "<em>Java</em> <em>agent</em> <em>configuration</em>: Config file",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> reads its <em>configuration</em> from the newrelic.yml file. By default the <em>agent</em> looks for this file in the directory that contains newrelic.jar. You can override the config file&#x27;s location by setting the newrelic.config.file system property to a fully qualified file name"
      },
      "id": "603eb739e7b9d2a2432a07e0"
    },
    {
      "sections": [
        "Java agent config file template"
      ],
      "title": "Java agent config file template",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "cab129eda0df59e172b299574d8e44fbb3c04617",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-config-file-template/",
      "published_at": "2021-05-05T06:49:05Z",
      "updated_at": "2021-03-16T13:47:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains a templated version of the newrelic.yml file that the Java agent reads for configuration. The config file format is YAML. While no knowledge of YAML is necessary to edit the file, be careful to maintain the proper indentation. Learn more about YAML on Wikipedia. When making changes to the newrelic.yml file, use a YAML validator to ensure the syntax is accurate and follow these rules: YML files are case sensitive. All indentations are in increments of two characters. Data in the same stanza of the file must use the same level of indentation, and sub-stanzas should be indented by an additional two spaces. For more information about structure, directories, and settings, see Java agent configuration. # This file configures the New Relic Agent. New Relic monitors # Java applications with deep visibility and low overhead. For more details and additional # configuration options visit https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-configuration-config-file. # # <%= generated_for_user %> # # This section is for settings common to all environments. # Do not add anything above this next line. common: &default_settings # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic # account. For example, if your license key is 12345 use this: # license_key: '12345' # The key binds your Agent's data to your account in the New Relic service. license_key: '<%= license_key %>' # Agent Enabled # Use this setting to disable the agent instead of removing it from the startup command. # Default is true. agent_enabled: true # Set the name of your application as you'd like it show up in New Relic. # If enable_auto_app_naming is false, the agent reports all data to this application. # Otherwise, the agent reports only background tasks (transactions for non-web applications) # to this application. To report data to more than one application # (useful for rollup reporting), separate the application names with \";\". # For example, to report data to \"My Application\" and \"My Application 2\" use this: # app_name: My Application;My Application 2 # This setting is required. Up to 3 different application names can be specified. # The first application name must be unique. app_name: My Application # To enable high security, set this property to true. When in high # security mode, the agent will use SSL and obfuscated SQL. Additionally, # request parameters and message parameters will not be sent to New Relic. high_security: false # Set to true to enable support for auto app naming. # The name of each web app is detected automatically # and the agent reports data separately for each one. # This provides a finer-grained performance breakdown for # web apps in New Relic. # Default is false. enable_auto_app_naming: false # Set to true to enable component-based transaction naming. # Set to false to use the URI of a web request as the name of the transaction. # Default is true. enable_auto_transaction_naming: true # The agent uses its own log file to keep its logging # separate from that of your application. Specify the log level here. # This setting is dynamic, so changes do not require restarting your application. # The levels in increasing order of verboseness are: # off, severe, warning, info, fine, finer, finest # Default is info. log_level: info # Log all data sent to and from New Relic in plain text. # This setting is dynamic, so changes do not require restarting your application. # Default is false. audit_mode: false # The number of backup log files to save. # Default is 1. log_file_count: 1 # The maximum number of kbytes to write to any one log file. # The log_file_count must be set greater than 1. # Default is 0 (no limit). log_limit_in_kbytes: 0 # Override other log rolling configuration and roll the logs daily. # Default is false. log_daily: false # The name of the log file. # Default is newrelic_agent.log. log_file_name: newrelic_agent.log # The log file directory. # Default is the logs directory in the newrelic.jar parent directory. #log_file_path: # Proxy settings for connecting to the New Relic server: # If a proxy is used, the host setting is required. Other settings # are optional. Default port is 8080. The username and password # settings will be used to authenticate to Basic Auth challenges # from a proxy server. Proxy scheme will allow the agent to # connect through proxies using the HTTPS scheme. #proxy_host: hostname #proxy_port: 8080 #proxy_user: username #proxy_password: password #proxy_scheme: https # Limits the number of lines to capture for each stack trace. # Default is 30 max_stack_trace_lines: 30 # Provides the ability to configure the attributes sent to New Relic. These # attributes can be found in transaction traces, traced errors, Insight's # transaction events, and Insight's page views. attributes: # When true, attributes will be sent to New Relic. The default is true. enabled: true #A comma separated list of attribute keys whose values should # be sent to New Relic. #include: # A comma separated list of attribute keys whose values should # not be sent to New Relic. #exclude: # Transaction tracer captures deep information about slow # transactions and sends this to the New Relic service once a # minute. Included in the transaction is the exact call sequence of # the transactions including any SQL statements issued. transaction_tracer: # Transaction tracer is enabled by default. Set this to false to turn it off. # This feature is not available to Lite accounts and is automatically disabled. # Default is true. enabled: true # Threshold in seconds for when to collect a transaction # trace. When the response time of a controller action exceeds # this threshold, a transaction trace will be recorded and sent to # New Relic. Valid values are any float value, or (default) \"apdex_f\", # which will use the threshold for the \"Frustrated\" Apdex level # (greater than four times the apdex_t value). # Default is apdex_f. transaction_threshold: apdex_f # When transaction tracer is on, SQL statements can optionally be # recorded. The recorder has three modes, \"off\" which sends no # SQL, \"raw\" which sends the SQL statement in its original form, # and \"obfuscated\", which strips out numeric and string literals. # Default is obfuscated. record_sql: obfuscated # Set this to true to log SQL statements instead of recording them. # SQL is logged using the record_sql mode. # Default is false. log_sql: false # Threshold in seconds for when to collect stack trace for a SQL # call. In other words, when SQL statements exceed this threshold, # then capture and send to New Relic the current stack trace. This is # helpful for pinpointing where long SQL calls originate from. # Default is 0.5 seconds. stack_trace_threshold: 0.5 # Determines whether the agent will capture query plans for slow # SQL queries. Only supported for MySQL and PostgreSQL. # Default is true. explain_enabled: true # Threshold for query execution time below which query plans will not # not be captured. Relevant only when `explain_enabled` is true. # Default is 0.5 seconds. explain_threshold: 0.5 # Use this setting to control the variety of transaction traces. # The higher the setting, the greater the variety. # Set this to 0 to always report the slowest transaction trace. # Default is 20. top_n: 20 # Error collector captures information about uncaught exceptions and # sends them to New Relic for viewing. error_collector: # This property enables the collection of errors. If the property is not # set or the property is set to false, then errors will not be collected. # Default is true. enabled: true # Use this property to exclude specific exceptions from being reported as errors # by providing a comma separated list of full class names. # The default is to exclude akka.actor.ActorKilledException. If you want to override # this, you must provide any new value as an empty list is ignored. ignore_errors: akka.actor.ActorKilledException # Use this property to exclude specific http status codes from being reported as errors # by providing a comma separated list of status codes. # The default is to exclude 404s. If you want to override # this, you must provide any new value as an empty list is ignored. ignore_status_codes: 404 # Transaction Events are used for Histograms and Percentiles. Unaggregated data is collected # for each web transaction and sent to the server on harvest. transaction_events: # Set to false to disable transaction events. # Default is true. enabled: true # Events are collected up to the configured amount. Afterwards, events are sampled to # maintain an even distribution across the harvest cycle. # Default is 2000. Setting to 0 will disable. max_samples_stored: 2000 # Distributed tracing lets you see the path that a request takes through your distributed system. # Enabling distributed tracing changes the behavior of some New Relic features, so carefully consult the transition # guide before you enable this feature: https://docs.newrelic.com/docs/apm/distributed-tracing/getting-started/transition-guide-distributed-tracing # Default is false. distributed_tracing: enabled: false # Cross Application Tracing adds request and response headers to # external calls using supported HTTP libraries to provide better # performance data when calling applications monitored by other New Relic Agents. cross_application_tracer: # Set to false to disable cross application tracing. # Default is true. enabled: true # Thread profiler measures wall clock time, CPU time, and method call counts # in your application's threads as they run. # This feature is not available to Lite accounts and is automatically disabled. thread_profiler: # Set to false to disable the thread profiler. # Default is true. enabled: true # New Relic Real User Monitoring gives you insight into the performance real users are # experiencing with your website. This is accomplished by measuring the time it takes for # your users' browsers to download and render your web pages by injecting a small amount # of JavaScript code into the header and footer of each page. browser_monitoring: # By default the agent automatically inserts API calls in compiled JSPs to # inject the monitoring JavaScript into web pages. Not all rendering engines are supported. # See https://docs.newrelic.com/docs/agents/java-agent/instrumentation/new-relic-browser-java-agent#manual_instrumentation # for instructions to add these manually to your pages. # Set this attribute to false to turn off this behavior. auto_instrument: true class_transformer: # This instrumentation reports the name of the user principal returned from # HttpServletRequest.getUserPrincipal() when servlets and filters are invoked. com.newrelic.instrumentation.servlet-user: enabled: false com.newrelic.instrumentation.spring-aop-2: enabled: false # This instrumentation reports metrics for resultset operations. com.newrelic.instrumentation.jdbc-resultset: enabled: false # Classes loaded by classloaders in this list will not be instrumented. # This is a useful optimization for runtimes which use classloaders to # load dynamic classes which the agent would not instrument. classloader_excludes: groovy.lang.GroovyClassLoader$InnerLoader, org.codehaus.groovy.runtime.callsite.CallSiteClassLoader, com.collaxa.cube.engine.deployment.BPELClassLoader, org.springframework.data.convert.ClassGeneratingEntityInstantiator$ObjectInstantiatorClassGenerator, org.mvel2.optimizers.impl.asm.ASMAccessorOptimizer$ContextClassLoader, gw.internal.gosu.compiler.SingleServingGosuClassLoader, # User-configurable custom labels for this agent. Labels are name-value pairs. # There is a maximum of 64 labels per agent. Names and values are limited to 255 characters. # Names and values may not contain colons (:) or semicolons (;). labels: # An example label #label_name: label_value # Application Environments # ------------------------------------------ # Environment specific settings are in this section. # You can use the environment to override the default settings. # For example, to change the app_name setting. # Use -Dnewrelic.environment=<environment> on the Java startup command line # to set the environment. # The default environment is production. # NOTE if your application has other named environments, you should # provide configuration settings for these environments here. development: <<: *default_settings app_name: My Application (Development) test: <<: *default_settings app_name: My Application (Test) production: <<: *default_settings staging: <<: *default_settings app_name: My Application (Staging) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 94.515625,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> config file template",
        "sections": "<em>Java</em> <em>agent</em> config file template",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " options visit https:&#x2F;&#x2F;docs.newrelic.com&#x2F;docs&#x2F;<em>agents</em>&#x2F;<em>java</em>-<em>agent</em>&#x2F;<em>configuration</em>&#x2F;<em>java</em>-<em>agent</em>-<em>configuration</em>-config-file. # # &lt;%= generated_for_user %&gt; # # This section is for settings common to all environments. # Do not add anything above this next line. common: &amp;default_settings"
      },
      "id": "603eb738e7b9d242542a0815"
    }
  ],
  "/docs/agents/java-agent/configuration/name-your-java-application": [
    {
      "sections": [
        "Configuring your SSL certificates",
        "Notice of expired SSL certificates and certificate removal",
        "Caution",
        "Important",
        "Java Agent versions 6.2.0 - 6.4.2",
        "Java Agent versions 6.0.0/6.1.0",
        "Using YAML-based configuration",
        "Java Agent versions prior to 6.0.0 (Deprecated)",
        "For more help"
      ],
      "title": "Configuring your SSL certificates",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "af154f250e87f571db157972e22dbb1f907a8fde",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/configuring-your-ssl-certificates/",
      "published_at": "2021-05-05T06:44:59Z",
      "updated_at": "2021-04-28T23:01:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To communicate with the New Relic collector over HTTPS, you need to have the proper certificates for trusted signers in the trust store on your app server. By default, most JREs contain a valid root certificate that allows the agent to connect to newrelic.com. For SSL connection issues, please visit SSL or connection errors (Java). Notice of expired SSL certificates and certificate removal Caution The SSL certificates that were bundled with Java agent versions 6.1.0 to 6.4.2 have expired and are no longer valid. This means that Java agent versions 6.1.0 to 6.4.2 can no longer use the certificates bundled with the agent to establish a connection with New Relic and that you must provide your own SSL certificates. Please see this community forum post for additional details. Important Java agent versions higher than 6.4.2 no longer ship with SSL certificates bundled into the agent. You must provide your own SSL truststore to the agent by explicitly using the ca_bundle_path configuration option, or by using the default truststore provided by the JDK/JRE (the agent will look to use the latter by default). Additionally the use_private_ssl configuration option has been removed from Java agent versions higher than 6.4.2. Users wishing to add the global certificate to their local trust store can download the DigiCert Global Root CA from DigiCert. Java Agent versions 6.2.0 - 6.4.2 Starting with Java agent version 6.2.0, the use_private_ssl configuration option has been reintroduced so you can use the SSL certificates that are bundled into the agent jar. The following bundled SSL certificates are valid for up to a year after release. META-INF/certs/eu-newrelic-com.pem META-INF/certs/eu01-nr-data-net.pem META-INF/certs/newrelic-com.pem Copy Important The Java agent will begin logging a warning message upon application startup when there are less than three months before the bundled certificate expires. When the bundled certificates expire, the Java agent will no longer be able to connect to New Relic and you must either update to the latest agent version or provide a valid certificate using the ca_bundle_path configuration. Users wishing to add the global certificate to their local trust store can download the DigiCert Global Root CA from DigiCert. Using YAML-based configuration common: default_settings ca_bundle_path: /path/to/digicert.pem use_private_ssl: false # # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic ... Copy Summary There are two configuration settings that determine what certs are used by the agent to establish a secure connection to New Relic. They are: use_private_ssl and ca_bundle_path. Here's how they work together: DEFAULT: Neither configuration option (ca_bundle_path/use_private_ssl) is provided, because both are using default values. The agent will use the default SSL certificates bundled into the Java Development Kit (JDK). If these certificates aren't present or don't include certificates that trust New Relic, then the agent will not connect. You'll need to merge valid certificates into your JDK certificate bundle. Only use_private_ssl is configured. The agent will use the SSL certificates that are bundled with it. Only ca_bundle_path is configured. The agent will try to connect using the custom SSL certificates bundle at the configured path. If the configured custom certificate bundle doesn’t include certificates that trust New Relic, then the agent will not connect. You'll need to merge valid certificates into your custom certificate bundle. Both use_private_ssl and ca_bundle_path are configured. The ca_bundle_path configuration setting takes precedence and the use_private_ssl config is ignored. This behavior is the same as only specifying ca_bundle_path. Java Agent versions 6.0.0/6.1.0 Starting in 6.0.0, the Java agent no longer includes the nrcert global certificate chain. Users wishing to add the global certificate to their local trust store must download the DigiCert Global Root CA from DigiCert. Note: In versions 6.1.0+, the Java agent will use a bundled New Relic certificate that is valid for up to a year after release. Before the certificate expires, you must either update the agent to the latest version or provide a valid certificate using the ca_bundle_path configuration. Important The Java agent will begin logging a warning message upon application startup when there are less than three months before the bundled certificate expires. Using YAML-based configuration common: default_settings ca_bundle_path: /path/to/digicert.pem # # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic ... Copy Java Agent versions prior to 6.0.0 (Deprecated) For Java agent versions prior to 6.0.0, applications that require valid certificates may add them in one of the following two ways: Use YAML-based configuration. Add the bundled list of New Relic trusted signers to the local store. Using YAML-based configuration The New Relic Java agent bundles the list of trusted signers in the agent newrelic.jar file. If you do not want to change the local trust store, you can activate them by setting use_private_ssl to true in the newrelic.yml agent configuration file: common: default_settings use_private_ssl: true # # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic ... Copy For more help Additional documentation resources include New Relic for Java (compatibility and requirements, installation, and configuration.)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 133.55923,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Configuring</em> your SSL certificates",
        "sections": "<em>Java</em> <em>Agent</em> versions 6.2.0 - 6.4.2",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " provide your own SSL truststore to the <em>agent</em> by explicitly using the ca_bundle_path <em>configuration</em> option, or by using the default truststore provided by the JDK&#x2F;JRE (the <em>agent</em> will look to use the latter by default). Additionally the use_private_ssl <em>configuration</em> option has been removed from <em>Java</em>"
      },
      "id": "603eb7a2e7b9d247c02a080d"
    },
    {
      "sections": [
        "Java agent configuration: Config file",
        "Configuration file structure",
        "Tip",
        "Configuration settings precedence",
        "Configuring the Java extensions directory",
        "Create an extensions directory",
        "Specify an existing extensions directory",
        "General configuration settings",
        "license_key (REQUIRED)",
        "app_name (REQUIRED)",
        "agent_enabled",
        "apdex_t (DEPRECATED)",
        "appserver_port",
        "Important",
        "audit_mode",
        "ca_bundle_path",
        "use_private_ssl",
        "enable_auto_app_naming",
        "enable_auto_transaction_naming",
        "Caution",
        "enable_custom_tracing",
        "extensions.dir",
        "high_security",
        "insert_api_key",
        "labels",
        "max_stack_trace_lines",
        "proxy_host",
        "proxy_password",
        "proxy_port",
        "proxy_user",
        "proxy_scheme",
        "reactor-netty.errors.enabled",
        "send_data_on_exit",
        "send_data_on_exit_threshold",
        "send_environment_info",
        "send_jvm_props",
        "ssl (DEPRECATED)",
        "sync_startup",
        "scala_futures_as_segments",
        "Logging configuration",
        "log_daily",
        "log_file_count",
        "log_file_name",
        "log_file_path",
        "log_level",
        "log_limit_in_kbytes",
        "JMX",
        "enabled",
        "linkingMetadataMBean",
        "Attributes",
        "include",
        "exclude",
        "Transaction tracer",
        "explain_enabled",
        "explain_threshold",
        "insert_sql_max_length",
        "log_sql",
        "record_sql",
        "stack_based_naming (Play 2.x+ only)",
        "stack_trace_threshold",
        "top_n",
        "transaction_threshold",
        "slow_query_whitelist (DEPRECATED)",
        "collect_slow_queries_from",
        "attributes.enabled",
        "attributes.include",
        "attributes.exclude",
        "token_limit",
        "segment_limit",
        "Transaction segments",
        "Browser monitoring",
        "auto_instrument",
        "disabled_auto_pages",
        "External tracer",
        "exclude_request_uri",
        "Cross application tracer",
        "Error collector",
        "ignore_classes",
        "ignore_messages",
        "ignore_status_codes",
        "expected_classes",
        "expected_messages",
        "expected_status_codes",
        "ignore_errors (DEPRECATED)",
        "Strip exceptions",
        "whitelist (DEPRECATED)",
        "allowed_classes",
        "Thread profiler",
        "Transaction events",
        "max_samples_stored",
        "custom_request_headers",
        "Custom events",
        "Hostname configuration",
        "display_name",
        "ipv_preference",
        "Custom instrumentation",
        "trace_annotation_class_name",
        "com.newrelic.instrumentation.servlet-user",
        "System properties",
        "newrelic.config.process_host.display_name",
        "newrelic.config.file",
        "newrelic.debug",
        "newrelic.environment",
        "newrelic.home",
        "newrelic.logfile",
        "Environment variables",
        "NEW_RELIC_APP_NAME (REQUIRED)",
        "NEW_RELIC_DISTRIBUTED_TRACING_ENABLED",
        "NEW_RELIC_PROCESS_HOST_DISPLAY_NAME",
        "NEW_RELIC_LICENSE_KEY (REQUIRED)",
        "NEW_RELIC_LOG",
        "Cloud platform utilization",
        "detect_aws",
        "detect_docker",
        "Async instrumentation",
        "token_timeout",
        "segment_timeout",
        "Circuit breaker",
        "memory_threshold",
        "gc_cpu_threshold",
        "Message tracer",
        "segment_parameters.enabled",
        "Distributed tracing",
        "exclude_newrelic_header",
        "Infinite Tracing",
        "trace_observer.host",
        "Span events",
        "Jar collector",
        "skip_temp_jars",
        "jars_per_second"
      ],
      "title": "Java agent configuration: Config file",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "1d61f848fa192438225eae269421b8d384915c8b",
      "image": "https://docs.newrelic.com/static/60ca967eab99ca225186310913ae2de6/8c557/java-config-cascade.png",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-configuration-config-file/",
      "published_at": "2021-05-04T17:01:42Z",
      "updated_at": "2021-03-16T15:52:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent reads its configuration from the newrelic.yml file. By default the agent looks for this file in the directory that contains newrelic.jar. You can override the config file's location by setting the newrelic.config.file system property to a fully qualified file name. Configuration file structure The newrelic.yml file is split into stanzas corresponding to different environments: Test Development Staging Production (default) New Relic applies settings in the common stanza to each of these environments. You can select other environments as the default by setting the newrelic.environment system property to the environment name. Tip A newrelic.yml template is available. If you edit newrelic.yml, be careful to conform to the YAML format. Use a YAML validator to ensure the syntax is accurate before using the file with New Relic's Java agent, and follow these rules: Java agent newrelic.yml Requirements Format YML files are case sensitive. Indentations All indentations must be in increments of two characters. Other indentations will result in an Unable to parse configuration file error upon agent startup. Use the same level of indentation for data in the same stanza of the file. Indent any sub-stanzas by an additional two spaces. Changes to file You must restart your JVM host process for changes to take effect. Exception: Property changes to log_level and audit_mode do not require a restart. Property changes under circuit breaker don't require a restart. Configuration settings precedence To override any setting in the config file, use a system property override. In certain environments, environment variables can also be used to override both the config file and the system properties. The environment variables primarily exist to support Heroku. When used, server-side configuration overrides all other configuration settings. With the Java agent, server-side configuration overrides all other settings. Environment variables override Java system properties. Java properties override user configuration settings in your newrelic.yml file. User settings override the newrelic.yml default settings. Configuring the Java extensions directory The Java agent reads the configuration files on process startup. To identify the directory where the files are located, either create a new or specify an existing extensions directory: Create an extensions directory To create the extensions directory: Navigate to the directory where newrelic.jar and newrelic.yml are located. Create a directory named extensions. In newrelic.yml, check that the property extensions.dir is not set. Specify an existing extensions directory To use an existing Java extensions directory: In your newrelic.yml file, locate the common section. Use the property extensions.dir to specify the location of the file. General configuration settings Set these options in the common stanza. To override any of these options, use a newrelic.config prefixed system property. license_key (REQUIRED) Type String Default (none) This setting is required. You must specify the license key associated with your New Relic account. This key binds your agent's data to your account in the New Relic service. app_name (REQUIRED) Type String Default (none) This setting is required. Defines the application name used to report data to New Relic. If enable_auto_app_naming is false, the agent reports all data to this application. Otherwise, the agent reports only background tasks (transactions for non-web applications) to this application. To report data to more than one application, separate the application names with a semicolon. For example, to report data to My Application and My Application 2 use this: app_name: My Application;My Application 2 Copy For more methods of naming your application, see Name your Java application. agent_enabled Type Boolean Default true Flag to enable the agent. Use this setting to force the agent to run or not run. apdex_t (DEPRECATED) Type Float Default 1.0 The apdex_t threshold in seconds for the application's Apdex score. For Java agent versions 1.2.008 or higher, the apdex_t value is set in the UI and the value in newrelic.yml is ignored. appserver_port Type Integer Default (none) Number to differentiate JVMs for the same app on the same machine. New Relic uses host/port for uniqueness, so you can distinguish the JVMs by putting a switch like this into the startup arguments for each JVM: -Dnewrelic.config.appserver_port=8081 Copy Once you have used appserver_port to name the JVMs and restart them, you should be able to see them individually in the dropdown and in the profiling interface. Important This is only a change for New Relic; it doesn't actually affect the port on which the host communicates in any way. audit_mode Type Boolean Default false Enables plain text logging of all data sent to New Relic to the agent logfile. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. ca_bundle_path Type String Value Format /path/to/ca/cert/bundle.pem Specifies a path to a custom SSL certificate bundle that will be used by the agent to establish a secure connection to New Relic. If your custom SSL certificate bundle doesn't include certificates that are sufficient to connect to New Relic then you'll need to merge the required certs into your custom certificate bundle. use_private_ssl Type Boolean Default false The following SSL certificates are bundled into the agent jar: META-INF/certs/eu-newrelic-com.pem META-INF/certs/eu01-nr-data-net.pem META-INF/certs/newrelic-com.pem Copy By default (use_private_ssl: false) the agent will use the SSL certificates bundled into the JDK to establish a secure connection to New Relic or the custom SSL certificates bundle specified by ca_bundle_path. If you want to use the SSL certificates bundled with the agent, set use_private_ssl: true. Note: use_private_ssl will be ignored if ca_bundle_path is set. enable_auto_app_naming Type Boolean Default false Enables the reporting of data separately for each web app. Set to true to enable support for auto app naming. The name of each web app is detected automatically and the agent reports data separately for each one. This provides a finer-grained performance breakdown for web apps in New Relic. For more information, see Automatic application naming. For more methods of naming your application, see Name your Java application. enable_auto_transaction_naming Type Boolean Default true Enables component-based transaction naming. Set to true to enable component-based transaction naming. Set to false to use the URI of a web request as the name of the transaction. For more information, see Naming web transactions. Caution Unless you implement API calls to name your transactions, disabling auto-transaction naming is very likely to cause Metric grouping issues. enable_custom_tracing Type Boolean Default true Enables all instrumentation using an @Trace annotation. Disabling this causes @Trace annotations to be ignored. extensions.dir Type String Default (none) Defines the location of the optional extensions directory. If this property is not set, the agent will look for a subdirectory named extensions in the same directory as newrelic.jar and newrelic.yml. high_security Type Boolean Default false In order for high security to be enabled, this property must be set to true and the high security property in the New Relic user interface must be enabled. Enabling high security means SSL is turned on, request and message queue parameters are not collected, and queries cannot be sent to New Relic in their raw form. Important As of Java agent 3.48.0, SSL is enabled by default and the config option to disable it has been deprecated. As of Java agent 4.0.0, the ability to disable SSL has been removed. insert_api_key Type String Default (none) A valid Insert API Key for your account. This is only required for Real-time Java profiling using JFR metrics. labels Type String Default \"\" Attach tags to this app. Note that this option now enables tags, which replaced the label feature. You can still query your historical labels. max_stack_trace_lines Type Integer Default 30 Limits the number of lines the agent collects from each stack trace. Increasing this value may impact performance, because it increases the amount of memory the agent uses and the amount of data sent to New Relic. proxy_host Type String Default (none) The proxy host through which to connect to the New Relic collector. If a proxy is used, the host setting is required. Other proxy settings are optional. proxy_password Type String Default (none) The password for proxy authentication. If a proxy is used, the host setting is required. Other proxy settings are optional. The username and password settings will be used to authenticate to Basic Auth challenges from a proxy server. Important The Java agent supports Basic (clear text) authentication. proxy_port Type String Default 8080 The proxy host port number. If a proxy is used, the host setting is required. Other proxy settings are optional. proxy_user Type String Default (none) The username for proxy authentication, such as Basic (clear text) authentication. If a proxy is used, the host setting is required. Other proxy settings are optional. The username and password settings will be used to authenticate to Basic Auth challenges from a proxy server. proxy_scheme Type String Default (none) The proxy scheme used. Setting proxy_scheme: \"https\" will allow the agent to connect through proxies using the HTTPS scheme. reactor-netty.errors.enabled Type Boolean Default true Whether errors are reported for reactor netty. If set to false, errors will be ignored. Important Only available in Java agent 6.3.0 and above. send_data_on_exit Type Boolean Default false Enable delayed JVM shutdown to give the agent a chance to send latest metric data to New Relic before JVM shutdown. send_data_on_exit_threshold Type Integer Default 60 The number of seconds after which the agent will use the send_data_on_exit setting. send_environment_info Type Boolean Default true Enable reporting of JVM settings to New Relic. send_jvm_props Type Boolean Default true When set to true, JVM properties will be sent to New Relic. ssl (DEPRECATED) Type Boolean Default true Requires connections to the New Relic collector to go over SSL. The agent communicates with New Relic via HTTPS by default, and New Relic requires HTTPS for all traffic to APM and the New Relic REST API. This work is done asynchronously to the threads that process your application code, so response times will not be directly affected by this change. Important As of Java agent 3.48.0, SSL is enabled by default and the config option to disable it has been deprecated. As of Java agent 4.0.0, the ability to disable SSL has been removed. sync_startup Type Boolean Default false Enable the agent to connect the New Relic collector immediately upon app startup. scala_futures_as_segments Important This applies to Java agent version 3.44.0 or higher. Type Boolean Default false For more concise transaction trace details, the agent does not report Scala Futures as transaction segments, and those Futures do not contribute to the transaction’s total time. Enabling scala_futures_as_segments increases your overhead. If you want Scala Futures to report as transaction segments so you can view them in a transaction trace, you can enable it: scala_futures_as_segments: enabled: true Copy Logging configuration These are part of the general configuration variables. They are broken out here because they are frequently tweaked for debugging. Some of the logging configuration variables are dynamic and do not need a host restart for them to take effect. For instance, if log files are growing too quickly, log_level can be set to a less verbose setting to reduce the reporting rate. Here is the order of precedence for configuration variables affecting log rotation. If log_daily is true, other log rotation settings are ignored. If log_file_count is 1 or 0, the size limit is ignored. Finally, the agent applies log_limit_in_kbytes. Depending on the growth rate, it is possible for the log file size to exceed the configured value by a small amount. log_daily Type Boolean Default false Set to true to roll the logs daily. Overrides the other configuration variables that affect log rotation. log_file_count Type Integer Default 1 The maximum number of log files to keep when using log rotation. log_file_name Type String Default newrelic_agent.log The unqualified log file name or the string STDOUT which will log to standard out. log_file_path Type String Default logs subdirectory where newrelic.jar is located The log file path. Tip If log_file_path is specified, the directory must already exist. If the default value is used, the agent will attempt to create the directory. log_level Type String Default info The log verbosity level. The agent uses its own log file to keep its logging separate from that of your application. Valid options, in order of verboseness, are: off severe warning info fine finer finest This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. log_limit_in_kbytes Type Integer Default 0 The log file size in kilobytes at which log files are rotated. Set to 0 for no limit. JMX To set these options, use the jmx stanza. To override them, use a newrelic.config.jmx prefixed system property. The Java agent uses JMX to collect JVM data as well as to communicate with the JFR (Java Flight Recorder) daemon for Real-time Java profiling. enabled Type Boolean Default true This setting can be used to turn on or off all JMX functionality. linkingMetadataMBean Type Boolean Default false This setting can be enabled to allow the Java agent to expose linking metadata to the JFR daemon. Doing so allows the JFR daemon to obtain the entity GUID generated by the Java agent and link JFR data with the same APM application that is being monitored by the agent instead of as a separate entity. Important This applies to Java agent version 6.1.0 or higher. Attributes To set these options, use the attributes stanza. To override them, use a newrelic.config.attributes prefixed system property. Attributes are key-value pairs that provide information for transaction traces, traced errors, browser monitoring, and transaction events. There is also an attribute stanza under each destination. For more information, see Java agent attributes, Enabling and disabling attributes and Attribute examples. enabled Type Boolean Default true This setting can be used to turn on or off all attributes. Important For security reasons, capturing custom attributes using the Custom Instrumentation Editor is set to false by default. include Type List of Strings Default (none) If attributes are enabled, attribute keys found in this list will be sent to New Relic. Separate the keys in the list with a comma; for example: key1, key2, key3 Copy Also refer to the agent attribute rules. exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic. Separate the keys in the list with a comma; for example: key1, key2, key3 Copy Also refer to the agent attribute rules. Transaction tracer These options are set in the transaction_tracer stanza and can be overridden by using a newrelic.config.transaction_tracer prefixed system property. Transaction tracing captures deep information about slow transactions and sends this to the New Relic service. The transaction includes the exact call sequence of the transactions, including any query statements issued. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. enabled Type Boolean Default true The transaction tracer is enabled by default. Set this to false to turn it off. explain_enabled Type Boolean Default true Determines whether the agent will capture the EXPLAIN plan for slow queries. Only supported for MySQL and PostgreSQL. explain_threshold Type Float Default 0.5 Threshold in seconds for query execution time below which the slow query and the EXPLAIN plan (if supported) will not be captured. Relevant to slow queries only when record_sql is set to raw or obfuscated. Relevant to EXPLAIN plans only when explain_enabled is set to true. insert_sql_max_length Type Integer Default 2000 The character limit for the SQL query string. If you have many slow SQL queries with large chunks of information, this could negatively affect performance or how quickly you see your data in New Relic. Increase the value gradually until you find the right balance of information and performance. log_sql Type Boolean Default false Set to true to enable logging of queries to the agent log file instead of uploading to New Relic. Queries are logged using the record_sql mode. record_sql Type String Default obfuscated When the transaction tracer is on, query statements can optionally be recorded. The recorder has three modes: off: Send no queries. raw: Send the query statement in its original form. obfuscated: Strips out numeric and string literals. stack_based_naming (Play 2.x+ only) Type Boolean Default False Defaulted to true until Java agent version 3.12.1, when it was changed to false. This option is for Play 2.x+ only. Play/Scala instrumentation can use Thread.getStackTrace() to improve tracer naming, but at the cost of increased overhead. stack_trace_threshold Type Integer Default 0.5 Defines a threshold (in seconds) for collecting stack traces from an SQL call. When SQL statements exceed this threshold, the agent will capture the current stack trace. This is useful for pinpointing where long SQL calls originate from. top_n Type Integer Default 20 Use this setting to control the variety of your transaction traces. top_n is an integer that represents the number of unique, slow transactions that traces will be created for. If you want transaction traces to more accurately reflect the actual slowest transactions in your app, make this value lower. If you want to sample a more diverse array of transactions, make the value higher. A value of 0 would mean that only the slowest transaction is always traced. This is considered not to be optimal, though, because you may have one or two transactions that are always the slowest, and repeatedly seeing those same transaction traces will probably not give you much value. If the same transaction is often the slowest, the top_n setting allows the Java agent (over time) to sample the slowest n transactions. This gives you greater variety and more insight into your application. transaction_threshold Type String (float) Default apdex_f The time threshold used to determine when a transaction is eligible to be traced. When the transaction's response time exceeds this threshold, a transaction trace will be recorded and sent to New Relic. The default is apdex_f (default), which sets the threshold to be the \"Frustrated\" Apdex level (four times the apdex_t value). You can also set a specific time threshold by entering a float value that represents a number of seconds. slow_query_whitelist (DEPRECATED) Type String Default (none) Important This config has been deprecated as of agent version 5.10.0 and will be removed in a future agent version. Instead use collect_slow_queries_from. By default, high security mode does not allow the agent to collect slow queries. Enable this option to collect Cassandra queries from the DataStax driver, even with high security enabled. If you don't use high security, the agent collects slow queries automatically. For DataStax driver 2.1.2, add this rule to your allow list: transaction_tracer: slow_query_whitelist: 'com.newrelic.instrumentation.cassandra-datastax-2.1.2' Copy For DataStax driver 3.0.0, add this rule to your allow list: transaction_tracer: slow_query_whitelist: 'com.newrelic.instrumentation.cassandra-datastax-3.0.0' Copy collect_slow_queries_from Type String Default (none) By default, high security mode does not allow the agent to collect slow queries. Enable this option to collect Cassandra queries from the DataStax driver, even with high security enabled. If you don't use high security, the agent collects slow queries automatically. For DataStax driver 2.1.2, add this rule to your allow list: transaction_tracer: collect_slow_queries_from: 'com.newrelic.instrumentation.cassandra-datastax-2.1.2' Copy For DataStax driver 3.0.0, add this rule to your allow list: transaction_tracer: collect_slow_queries_from: 'com.newrelic.instrumentation.cassandra-datastax-3.0.0' Copy attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for transaction traces. If attributes.enabled at the root level is false, no attributes will be sent to transaction traces regardless on how this property (transaction_tracer.attributes.enabled) is set. attributes.include Type List of strings Default (none) If attributes are enabled for transaction traces, all attribute keys found in this list will be sent to New Relic in transaction traces. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in transaction traces. For more information, see the agent attribute rules. token_limit Type Integer Default 3000 Limits the number of Tokens that can be created per Transaction. Increasing this value may impact performance, because it increases the amount of memory the agent uses and the amount of data sent to New Relic. segment_limit Type Integer Default 3000 Limits the number of segments that can be created per transaction. Increasing this value may impact performance, because it increases the amount of memory the agent uses and the amount of data sent to New Relic. Transaction segments These options are set in the transaction_segments stanza and can be overridden by using a newrelic.config.transaction_segments prefixed system property. Transaction segments represent discrete pieces of work (generally method calls) and are displayed within transaction traces. Important Transaction segment attribute filtering requires Java agent version 4.10.0 or higher. attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for transaction segments. If attributes.enabled at the root level is false, no attributes will be sent to transaction segments regardless on how this property (transaction_segments.attributes.enabled) is set. attributes.include Type List of strings Default (none) If attributes are enabled for transaction segments, all attribute keys found in this list will be sent to New Relic in transaction segments. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in transaction segments. For more information, see the agent attribute rules. Browser monitoring These options are set in the browser_monitoring stanza and can be overridden by using a newrelic.config.browser_monitoring prefixed system property. Browser monitoring gives you insight into the performance real users are experiencing with your website. This is accomplished by measuring the time it takes for your users' browsers to download and render your web pages by injecting a small amount of JavaScript code into the header and footer of each page. auto_instrument Type Boolean Default true By default the agent automatically inserts API calls in compiled JSPs to inject the monitoring JavaScript into web pages. Set this attribute to false to turn off this behavior. disabled_auto_pages Type Comma-separated list of strings Default (none) When auto_instrument is true, by default all pages are instrumented. List all pages that you want the auto instrumentation to skip here. You can still use manual instrumentation on these pages. For example: browser_monitoring: disabled_auto_pages: /WEB-INF/jsp/testpage_1.jsp, /WEB-INF/jsp/testpage_2.jsp Copy attributes.enabled Type Boolean Default false This setting can be used to turn on or off all attributes for browser monitoring. This is the data you can query. If attributes.enabled is false at the root level, no attributes will be sent up in browser monitoring regardless on how this property under browser_monitoring is set. attributes.include Type List of Strings Default (none) If attributes are enabled for browser_monitoring, all attribute keys found in this list will be sent to New Relic in page views. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in page views. For more information, see the agent attribute rules. External tracer The external tracing options are set in the external_tracer stanza and can be overridden by using a newrelic.config.external_tracer prefixed system property. exclude_request_uri Type Boolean Default false This setting can be used to control the collection of outgoing request URIs for errors and transaction traces. Set this to true to disable collecting this information. Cross application tracer The cross application tracing options are set in the cross_application_tracer stanza and can be overridden by using a newrelic.config.cross_application_tracer prefixed system property. Cross application tracing adds request and response headers to external calls using the Apache HttpClient libraries. This provides better performance data when calling applications monitored by other New Relic Agents. enabled Type Boolean Default true Cross application tracing is enabled by default. Set this to false to turn it off. Error collector These options are set in the error_collector stanza and unless noted otherwise can be overridden by using a newrelic.config.error_collector prefixed system property. The error collector captures information about uncaught exceptions and sends them to New Relic for viewing. Tip For how to configure errors for the Java agent, including how to configure errors via the UI, see Java agent error configuration. enabled Type Boolean Default true Enable error collection. ignore_classes Type Stanza containing a list of fully qualified class_name strings Default (none) Specified exception class names will be ignored and will not affect error rate or Apdex score, or be reported to APM. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: ignore_classes: - \"com.example.MyException\" - \"com.example.DifferentException\" Copy ignore_messages Type Stanza containing a fully qualified class_name and a list of messages per error class Default (none) Specify exception class names the agent should ignore. Ignored messages will not affect error rate or Apdex score, or be reported to APM. Contains yaml pairs consisting of: A fully qualified exception class name that should not be reported to APM AND A list of exception messages to match against (at least one is required) If the exception class name matches an error but the message does not, then that error will not be ignored. Message strings use contains for matching. A message cannot be provided on its own and must always be paired with a fully qualified class name. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: ignore_messages: com.example.MyException: - \"Some error message to ignore\" - \"Some other error message to ignore\" com.example.DifferentException: - \"Some different error message to ignore\" Copy ignore_status_codes Type Comma-separated list of strings and ranges Default 404 A comma-separated list comprised of individual and dashed ranges of HTTP status codes that should not be treated as errors. If this property is commented out in the newrelic.yml configuration file, then the 404 status code will automatically be ignored. When using server-side configuration, the status code 404 must be specified in order for it to be ignored. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: ignore_status_codes: 404,507-511 Copy expected_classes Type Stanza containing a List of fully qualified class_name strings Default (none) Prevents specified exception classes from affecting error rate or Apdex score while still reporting the errors to APM. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: expected_classes: - \"com.example.MyException\" - \"com.example.DifferentException\" Copy expected_messages Type Stanza containing a fully qualified class_name and a List of messages per error class Default (none) Contains yaml pairs consisting of a fully qualified exception class name that should be marked as expected and thus prevented from affecting error rate or Apdex score and a List of exception messages to match against, the latter of which at least one is required. If the exception class name matches an error but the message does not, then that error will not be marked as expected and therefore will affect error rate and Apdex score. Message strings use contains for matching. A message cannot be provided on its own and must always be paired with a fully qualified class name. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: expected_messages: com.example.MyException: - \"Some expected error message\" - \"Some other expected error message\" com.example.DifferentException: - \"Some different expected error message\"​ Copy expected_status_codes Type Comma-separated list of strings and ranges Default (none) A comma-separated list comprised of individual and dashed ranges of HTTP status codes to be marked as expected and thus prevented from affecting error rate or Apdex score. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: expected_status_codes: 415,500-506 Copy attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for traced errors. If attributes.enabled is false at the root level, then no attributes will be sent to traced errors regardless of how this property is set under error_collector. attributes.include Type List of strings Default (none) If attributes are enabled for traced errors, all attribute keys found in this list will be sent to New Relic in traced errors. For more information, see the agent attribute rules. attributes.exclude Type List of strings Default (none) Attribute keys found in this list will not be sent to New Relic in traced errors. For more information, see the agent attribute rules. ignore_errors (DEPRECATED) Type Comma-separated list of Strings Default (none) All specified exception class names specified will not be treated as errors. Deprecated as of Java agent 3.40.0 and replaced by ignore_classes. For example: error_collector: ignore_errors: some.other.MyException Copy Strip exceptions These options are set in the strip_exception_messages stanza and unless noted otherwise can be overridden by using a newrelic.config.strip_exception_messages​prefixed system property. This configuration can be enabled to control whether Java exception messages are reported to New Relic. enabled Type Boolean Default false By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you set this to true, the agent strips the messages from exceptions in order to prevent it from inadvertently capturing sensitive information. If you enable high security mode, this is automatically set to true. If you set enabled to true but you want the agent to capture messages from specific exceptions, add the exceptions to your allow list. whitelist (DEPRECATED) Type String Default (none) Important This config has been deprecated as of agent version 5.10.0 and will be removed in a future agent version. Instead use allowed_classes. If you set enabled to true but you want the agent to capture messages for specific exceptions, add each exception to the whitelist, separated by a comma. allowed_classes Type String Default (none) If you set enabled to true but you want the agent to capture messages for specific exceptions, add each exception to allowed_classes, separated by a comma. Thread profiler These options are set in the thread_profiler stanza and can be overridden by using a newrelic.config.thread_profiler prefixed system property. Thread profiler measures wall clock time, CPU time, and method call counts in your application's threads as they run. enabled Type Boolean Default true Enable the thread profiler. Transaction events These options are set in the transaction_events stanza and can be overridden by using a newrelic.config.transaction_events prefixed system property. Transaction events provide the data for displaying histograms and percentiles in the UI. Important Previously this stanza was called analytics_events. If your configuration file still uses analytics_events, update your agent to use transaction_events. enabled Type Boolean Default true Enable the transaction events service. max_samples_stored Type Integer Default 2000 Max 10000 The maximum number of sampled transaction events reported every 60 seconds. custom_request_headers Type List of maps Default None Important Unlike other settings, custom_request_headers have to be paired together and must be set in the newrelic.yml file. They can't be overwritten by Java virtual machine arguments (system property) or environment variables. A list of maps with the paired keys header_name and the optional header_alias. Choose one or more custom HTTP request headers to add as transaction attributes. You can list multiple header configurations: transaction_events: custom_request_headers: - header_name: \"X-Custom-Header-1\" - header_name: \"X-Custom-Header-2\" header_alias: \"CustomHeader2alias\" Copy In the first map set, X-Custom-Header-1 is captured and reported by the agent as the header name for a corresponding value from the request object. The header_name will also be the name of the attribute sent to New Relic. In the second map set, the request header is X-Custom-Header-2, but the CustomHeader2alias is the name sent to New Relic. attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for transaction events. If attributes.enabled is false at the root level, then no attributes will be sent to transaction events regardless of how this property is set under transaction_events. attributes.include Type List of Strings Default (none) If attributes are enabled for transaction events, all attribute keys found in this list will be sent to New Relic in transaction events. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in transaction events. For more information, see the agent attribute rules. Custom events Custom events are set in the custom_insights_events stanza and can be overridden by using a newrelic.config.custom_insights_events prefixed system property. APM lets you record custom event data via the New Relic language agent APIs, which you can then query. Important For Java agent versions prior to 4.1.0, the following YAML configuration is recognized: custom_insights_events.enabled: true custom_insights_events.max_samples_stored: 5000 Copy For agent versions 4.1.0 and above, the YAML configuration uses the nested stanza formatting: custom_insights_events: enabled: false max_samples_stored: 5000 Copy enabled Type Boolean Default true This enables the custom event service. max_samples_stored Type Integer Default/Max 10000 The maximum number of sampled custom events reported every 60 seconds. Hostname configuration These options are set in the process_host stanza and can be overridden by using a newrelic.config.process_host prefixed system property. These properties are used for configuring the hostname displayed in the UI: display_name Type String Default (none) Set a display name to decorate the \"host:port\" label in the New Relic UI. ipv_preference Type String Default 4 If the hostname cannot be determined, then the IP address of the host will be used. This property determines whether the IPv4 or IPv6 address should be used. The default is IPv4. Custom instrumentation These options set in the class_transformer stanza and can be overridden by using a newrelic.config.class_transformer prefixed system property. trace_annotation_class_name Type String Default (none) String containing the full class name of the annotation class the agent uses to determine which user-specified methods to instrument. For more information about custom annotations, see Java custom metric collection. com.newrelic.instrumentation.servlet-user Type Boolean Default false Enable this option to capture the userPrincipal name. This name is included as a transaction trace attribute, and can be queried. System properties You can override any setting in the newrelic.yml file by setting a system property. The system property corresponding to a given setting in the config file is the setting name prefixed by newrelic.config. For example, the system property for the log_level setting is newrelic.config.log_level. For settings nested in stanzas, prepend the stanza name to the setting name. For example, the system property for the enabled setting in the transaction_tracer stanza is newrelic.config.transaction_tracer.enabled. In addition to overriding configuration settings, the following system properties are recognized by the agent: newrelic.config.process_host.display_name Type String Default (none) Set a display name to decorate the \"host:port\" label in the New Relic UI. Requires Java agent 3.17 or higher. newrelic.config.file Type String Default (none) String containing a fully qualified path to the newrelic configuration file. If empty, the agent assumes newrelic.yml is in the same directory as newrelic.jar. newrelic.debug Type Boolean Default (none) Enable debug logging. newrelic.environment Type String Default (none) String containing the environment configuration for the agent to use. newrelic.home Type String Default (none) String containing the home directory of agent. This defaults to the same directory as the agent jarfile. newrelic.logfile Type String Default newrelic_agent.log String containing the name of the agent log file. Environment variables Environment variables take the highest precedence and override the system properties and yml config settings. To set environment variables, use the export VARNAME=value command. To permanently set environment variables, add the export line to a file such as ~/.bashrc or ~/.bash_profile. You can override any setting from a system property or in the newrelic.yml by setting an environment variable. The environment variable corresponding to a given setting in the config file is the setting name prefixed by NEW_RELIC with all dots (.) and dashes (-) replaced by underscores (_). For example, the environment variable for the log_level setting is NEW_RELIC_LOG_LEVEL. For settings nested in stanzas, prepend the stanza name to the setting name. For example, the environment variable for the enabled setting in the transaction_tracer stanza is NEW_RELIC_TRANSACTION_TRACER_ENABLED. Important Agent configuration via environment variables requires Java agent version 4.10.0 or higher. For agent versions older than 4.10.0 the following environment variables are available: NEW_RELIC_APP_NAME (REQUIRED) Type String Default (none) This setting is required. Contains the application name under which to report data to New Relic. Set the name of your application as you want it to appear in New Relic. If enable_auto_app_naming is false, the agent reports all data to this application. Otherwise, the agent reports only background tasks (transactions for non-web applications) to this application. To report data to more than one application, separate the application names with a semicolon ;. For example, to report data to My Application and My Application 2: app_name: My Application;My Application 2 Copy For more methods of naming your application, see Name your Java application. NEW_RELIC_DISTRIBUTED_TRACING_ENABLED Type String Default false Enables distributed tracing. Case sensitive: use true or false. For more information, see the distributed tracing section. NEW_RELIC_PROCESS_HOST_DISPLAY_NAME Type String Default (none) Set a display name to decorate the \"host:port\" label in the New Relic UI. NEW_RELIC_LICENSE_KEY (REQUIRED) Type String Default (none) This setting is required. Contains your New Relic account license. You must specify the license key associated with your New Relic account. This key binds your agent's data to your account in the New Relic service. NEW_RELIC_LOG Type String Default newrelic_agent.log The unqualified log file name or the string STDOUT which will log to standard out. Cloud platform utilization These options are set in the utilization stanza and can be overridden by using a newrelic.config.utilization prefixed system property. The agent collects utilization information and sends it to the New Relic service. The agent can collect information from Amazon Web Services (AWS) EC2 instances and Docker containers. detect_aws Type Boolean Default true Determines whether the agent polls AWS metadata API. detect_docker Type Boolean Default true Determines whether the agent reads Docker information from the file system. Async instrumentation These options are set directly in the common stanza and can be overridden by using a prefixed system property. token_timeout Type Integer Default (seconds) 180 The number of seconds after which the agent will automatically expire an async token that has not been explicitly expired with token.expire(). For usage instructions, see Tokens: Connect async threads. Important Increasing this value may impact performance, because it increases the amount of memory the agent uses and prevents transactions from being reported due to unexpired tokens. segment_timeout Type Integer Default (seconds) 600 The number of seconds after which the agent will automatically end a segment that has not been explicitly ended with segment.end() or segment.ignore(). For usage instructions, see Segments: Time arbitrary async activity. Important Increasing this value may impact performance, because it increases the amount of memory the agent uses and prevents transactions from being reported due to un-ended segments. Circuit breaker These settings customize the behavior of the Java circuit breaker. These settings are not included in newrelic.yml by default. You do not need to restart your JVM after changing them. If you want to customize the circuit breaker, add the stanza under the common stanza: common: &default_settings​ ​ OTHER_CONFIG_SETTINGS circuitbreaker: enabled: true memory_threshold: 20 gc_cpu_threshold: 10 Copy enabled Type Boolean Default true If your application is behaving as expected, you may want to disable the circuit breaker. memory_threshold Type Integer (0 to 100) Default 20 Customize the precentage of free heap memory below which the circuit breaker should trip. When the percentage of free heap memory is less than memory_threshold, and the CPU time spent doing garbage collection is greater than gc_cpu_threshold, the circuit breaker trips. In order to make the circuit breaker less likely to trip, decrease memory_threshold and/or increase gc_cpu_threshold. Adjust these values as needed, based on your application's operating performance and behavior. gc_cpu_threshold Type Integer (0 to 100) Default 10 Customize the precentage of garbage collection CPU time above which the circuit breaker should trip. When the percentage of free heap memory is less than memory_threshold, and the CPU time spent doing garbage collection is greater than gc_cpu_threshold, the circuit breaker trips. In order to make the circuit breaker less likely to trip, decrease memory_threshold and/or increase gc_cpu_threshold. Adjust these values as needed, based on your application's operating performance and behavior. Message tracer These options are set in the message_tracer stanza and can be overridden by using a newrelic.config.message_tracer prefixed system property. segment_parameters.enabled Type Boolean Default true Adds message properties to tracer attributes. Set this to false to turn it off. Distributed tracing Important Enabling distributed tracing disables cross application tracing, and has other effects on APM features. Before enabling, read the transition guide. Requires Java agent version 4.3.0 or higher. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. In the config file, it can be set in the distributed_tracing stanza. It can be overridden using a newrelic.config.distributed_tracing prefixed system property. enabled Type Boolean Default false Set this to true to enable distributed tracing. For example, to enable this in the config file, you would use: distributed_tracing: enabled: true Copy To enable this using a system property, you would use: -Dnewrelic.config.distributed_tracing.enabled=true Copy exclude_newrelic_header Type Boolean Default false By default, supported versions of the agent utilize both the newrelic header and W3C Trace Context headers for distributed tracing. The newrelic distributed tracing header allows interoperability with older agents that don't support W3C Trace Context headers. Agent versions that support W3C Trace Context headers will prioritize them over newrelic headers for distributed tracing. If you do not want to utilize the newrelic header, setting this to true will result in the agent excluding the newrelic header and only using W3C Trace Context headers for distributed tracing. For example, to exclude newrelic headers in the config file, you would use: distributed_tracing: exclude_newrelic_header: true Copy To exclude newrelic headers using a system property, you would use: -Dnewrelic.config.distributed_tracing.exclude_newrelic_header=true Copy Infinite Tracing Important Requirements: Java Agent 5.12.1 or higher. Infinite Tracing does not work if enable_auto_app_naming is enabled. To turn on Infinite Tracing, enable distributed tracing and add the additional setting below. For an example, see Language Agents: Configure Distributed Tracing. trace_observer.host Type String Default None For help getting a valid Infinite Tracing trace observer host entry, see find or create a Trace Observer. You can configure this via YAML: infinite_tracing: trace_observer: host: YOUR_TRACE_OBSERVER_HOST Copy You can also use the system property newrelic.config.infinite_tracing.trace_observer.host or the environment variable NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_HOST. Span events Span events are reported for distributed tracing. Distributed tracing must be enabled to report span events. Span configuration is set in the span_events stanza and can be overridden by using a newrelic.config.span_events prefixed system property. Options include: enabled Type Boolean Default true Used to enable/disable span event reporting. attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for span events. If attributes.enabled at the root level is false, no attributes will be sent to span events regardless on how this property (span_events.attributes.enabled) is set. attributes.include Type List of strings Default (none) If attributes are enabled for span events, all attribute keys found in this list will be sent to New Relic in span_events. For more information, see the agent attribute rules. attributes.exclude Type List of strings Default (none) All attribute keys found in this list will not be sent to New Relic in span events. For more information, see the agent attribute rules. Important Span event attribute filtering requires Java agent version 4.10.0 or higher. Jar collector The Java agent collects and information about jars and their versions on the application classpath. Jar collection configuration is set in the jar_collector stanza and can be overridden by using a newrelic.config.jar_collector prefixed system property. Options include: enabled Type Boolean Default true Used to enable/disable jar collection and reporting. skip_temp_jars Type Boolean Default true Used to enable/disable collection of temporary jars. Temporary jars are those residing in the directory specified by the system property java.io.tmpdir. jars_per_second Type Integer Default 10 The maximum number of jars to process per second. Must be positive.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 94.53699,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> <em>configuration</em>: Config file",
        "sections": "<em>Java</em> <em>agent</em> <em>configuration</em>: Config file",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> reads its <em>configuration</em> from the newrelic.yml file. By default the <em>agent</em> looks for this file in the directory that contains newrelic.jar. You can override the config file&#x27;s location by setting the newrelic.config.file system property to a fully qualified file name"
      },
      "id": "603eb739e7b9d2a2432a07e0"
    },
    {
      "sections": [
        "Java agent config file template"
      ],
      "title": "Java agent config file template",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "cab129eda0df59e172b299574d8e44fbb3c04617",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-config-file-template/",
      "published_at": "2021-05-05T06:49:05Z",
      "updated_at": "2021-03-16T13:47:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains a templated version of the newrelic.yml file that the Java agent reads for configuration. The config file format is YAML. While no knowledge of YAML is necessary to edit the file, be careful to maintain the proper indentation. Learn more about YAML on Wikipedia. When making changes to the newrelic.yml file, use a YAML validator to ensure the syntax is accurate and follow these rules: YML files are case sensitive. All indentations are in increments of two characters. Data in the same stanza of the file must use the same level of indentation, and sub-stanzas should be indented by an additional two spaces. For more information about structure, directories, and settings, see Java agent configuration. # This file configures the New Relic Agent. New Relic monitors # Java applications with deep visibility and low overhead. For more details and additional # configuration options visit https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-configuration-config-file. # # <%= generated_for_user %> # # This section is for settings common to all environments. # Do not add anything above this next line. common: &default_settings # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic # account. For example, if your license key is 12345 use this: # license_key: '12345' # The key binds your Agent's data to your account in the New Relic service. license_key: '<%= license_key %>' # Agent Enabled # Use this setting to disable the agent instead of removing it from the startup command. # Default is true. agent_enabled: true # Set the name of your application as you'd like it show up in New Relic. # If enable_auto_app_naming is false, the agent reports all data to this application. # Otherwise, the agent reports only background tasks (transactions for non-web applications) # to this application. To report data to more than one application # (useful for rollup reporting), separate the application names with \";\". # For example, to report data to \"My Application\" and \"My Application 2\" use this: # app_name: My Application;My Application 2 # This setting is required. Up to 3 different application names can be specified. # The first application name must be unique. app_name: My Application # To enable high security, set this property to true. When in high # security mode, the agent will use SSL and obfuscated SQL. Additionally, # request parameters and message parameters will not be sent to New Relic. high_security: false # Set to true to enable support for auto app naming. # The name of each web app is detected automatically # and the agent reports data separately for each one. # This provides a finer-grained performance breakdown for # web apps in New Relic. # Default is false. enable_auto_app_naming: false # Set to true to enable component-based transaction naming. # Set to false to use the URI of a web request as the name of the transaction. # Default is true. enable_auto_transaction_naming: true # The agent uses its own log file to keep its logging # separate from that of your application. Specify the log level here. # This setting is dynamic, so changes do not require restarting your application. # The levels in increasing order of verboseness are: # off, severe, warning, info, fine, finer, finest # Default is info. log_level: info # Log all data sent to and from New Relic in plain text. # This setting is dynamic, so changes do not require restarting your application. # Default is false. audit_mode: false # The number of backup log files to save. # Default is 1. log_file_count: 1 # The maximum number of kbytes to write to any one log file. # The log_file_count must be set greater than 1. # Default is 0 (no limit). log_limit_in_kbytes: 0 # Override other log rolling configuration and roll the logs daily. # Default is false. log_daily: false # The name of the log file. # Default is newrelic_agent.log. log_file_name: newrelic_agent.log # The log file directory. # Default is the logs directory in the newrelic.jar parent directory. #log_file_path: # Proxy settings for connecting to the New Relic server: # If a proxy is used, the host setting is required. Other settings # are optional. Default port is 8080. The username and password # settings will be used to authenticate to Basic Auth challenges # from a proxy server. Proxy scheme will allow the agent to # connect through proxies using the HTTPS scheme. #proxy_host: hostname #proxy_port: 8080 #proxy_user: username #proxy_password: password #proxy_scheme: https # Limits the number of lines to capture for each stack trace. # Default is 30 max_stack_trace_lines: 30 # Provides the ability to configure the attributes sent to New Relic. These # attributes can be found in transaction traces, traced errors, Insight's # transaction events, and Insight's page views. attributes: # When true, attributes will be sent to New Relic. The default is true. enabled: true #A comma separated list of attribute keys whose values should # be sent to New Relic. #include: # A comma separated list of attribute keys whose values should # not be sent to New Relic. #exclude: # Transaction tracer captures deep information about slow # transactions and sends this to the New Relic service once a # minute. Included in the transaction is the exact call sequence of # the transactions including any SQL statements issued. transaction_tracer: # Transaction tracer is enabled by default. Set this to false to turn it off. # This feature is not available to Lite accounts and is automatically disabled. # Default is true. enabled: true # Threshold in seconds for when to collect a transaction # trace. When the response time of a controller action exceeds # this threshold, a transaction trace will be recorded and sent to # New Relic. Valid values are any float value, or (default) \"apdex_f\", # which will use the threshold for the \"Frustrated\" Apdex level # (greater than four times the apdex_t value). # Default is apdex_f. transaction_threshold: apdex_f # When transaction tracer is on, SQL statements can optionally be # recorded. The recorder has three modes, \"off\" which sends no # SQL, \"raw\" which sends the SQL statement in its original form, # and \"obfuscated\", which strips out numeric and string literals. # Default is obfuscated. record_sql: obfuscated # Set this to true to log SQL statements instead of recording them. # SQL is logged using the record_sql mode. # Default is false. log_sql: false # Threshold in seconds for when to collect stack trace for a SQL # call. In other words, when SQL statements exceed this threshold, # then capture and send to New Relic the current stack trace. This is # helpful for pinpointing where long SQL calls originate from. # Default is 0.5 seconds. stack_trace_threshold: 0.5 # Determines whether the agent will capture query plans for slow # SQL queries. Only supported for MySQL and PostgreSQL. # Default is true. explain_enabled: true # Threshold for query execution time below which query plans will not # not be captured. Relevant only when `explain_enabled` is true. # Default is 0.5 seconds. explain_threshold: 0.5 # Use this setting to control the variety of transaction traces. # The higher the setting, the greater the variety. # Set this to 0 to always report the slowest transaction trace. # Default is 20. top_n: 20 # Error collector captures information about uncaught exceptions and # sends them to New Relic for viewing. error_collector: # This property enables the collection of errors. If the property is not # set or the property is set to false, then errors will not be collected. # Default is true. enabled: true # Use this property to exclude specific exceptions from being reported as errors # by providing a comma separated list of full class names. # The default is to exclude akka.actor.ActorKilledException. If you want to override # this, you must provide any new value as an empty list is ignored. ignore_errors: akka.actor.ActorKilledException # Use this property to exclude specific http status codes from being reported as errors # by providing a comma separated list of status codes. # The default is to exclude 404s. If you want to override # this, you must provide any new value as an empty list is ignored. ignore_status_codes: 404 # Transaction Events are used for Histograms and Percentiles. Unaggregated data is collected # for each web transaction and sent to the server on harvest. transaction_events: # Set to false to disable transaction events. # Default is true. enabled: true # Events are collected up to the configured amount. Afterwards, events are sampled to # maintain an even distribution across the harvest cycle. # Default is 2000. Setting to 0 will disable. max_samples_stored: 2000 # Distributed tracing lets you see the path that a request takes through your distributed system. # Enabling distributed tracing changes the behavior of some New Relic features, so carefully consult the transition # guide before you enable this feature: https://docs.newrelic.com/docs/apm/distributed-tracing/getting-started/transition-guide-distributed-tracing # Default is false. distributed_tracing: enabled: false # Cross Application Tracing adds request and response headers to # external calls using supported HTTP libraries to provide better # performance data when calling applications monitored by other New Relic Agents. cross_application_tracer: # Set to false to disable cross application tracing. # Default is true. enabled: true # Thread profiler measures wall clock time, CPU time, and method call counts # in your application's threads as they run. # This feature is not available to Lite accounts and is automatically disabled. thread_profiler: # Set to false to disable the thread profiler. # Default is true. enabled: true # New Relic Real User Monitoring gives you insight into the performance real users are # experiencing with your website. This is accomplished by measuring the time it takes for # your users' browsers to download and render your web pages by injecting a small amount # of JavaScript code into the header and footer of each page. browser_monitoring: # By default the agent automatically inserts API calls in compiled JSPs to # inject the monitoring JavaScript into web pages. Not all rendering engines are supported. # See https://docs.newrelic.com/docs/agents/java-agent/instrumentation/new-relic-browser-java-agent#manual_instrumentation # for instructions to add these manually to your pages. # Set this attribute to false to turn off this behavior. auto_instrument: true class_transformer: # This instrumentation reports the name of the user principal returned from # HttpServletRequest.getUserPrincipal() when servlets and filters are invoked. com.newrelic.instrumentation.servlet-user: enabled: false com.newrelic.instrumentation.spring-aop-2: enabled: false # This instrumentation reports metrics for resultset operations. com.newrelic.instrumentation.jdbc-resultset: enabled: false # Classes loaded by classloaders in this list will not be instrumented. # This is a useful optimization for runtimes which use classloaders to # load dynamic classes which the agent would not instrument. classloader_excludes: groovy.lang.GroovyClassLoader$InnerLoader, org.codehaus.groovy.runtime.callsite.CallSiteClassLoader, com.collaxa.cube.engine.deployment.BPELClassLoader, org.springframework.data.convert.ClassGeneratingEntityInstantiator$ObjectInstantiatorClassGenerator, org.mvel2.optimizers.impl.asm.ASMAccessorOptimizer$ContextClassLoader, gw.internal.gosu.compiler.SingleServingGosuClassLoader, # User-configurable custom labels for this agent. Labels are name-value pairs. # There is a maximum of 64 labels per agent. Names and values are limited to 255 characters. # Names and values may not contain colons (:) or semicolons (;). labels: # An example label #label_name: label_value # Application Environments # ------------------------------------------ # Environment specific settings are in this section. # You can use the environment to override the default settings. # For example, to change the app_name setting. # Use -Dnewrelic.environment=<environment> on the Java startup command line # to set the environment. # The default environment is production. # NOTE if your application has other named environments, you should # provide configuration settings for these environments here. development: <<: *default_settings app_name: My Application (Development) test: <<: *default_settings app_name: My Application (Test) production: <<: *default_settings staging: <<: *default_settings app_name: My Application (Staging) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 94.515625,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> config file template",
        "sections": "<em>Java</em> <em>agent</em> config file template",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " options visit https:&#x2F;&#x2F;docs.newrelic.com&#x2F;docs&#x2F;<em>agents</em>&#x2F;<em>java</em>-<em>agent</em>&#x2F;<em>configuration</em>&#x2F;<em>java</em>-<em>agent</em>-<em>configuration</em>-config-file. # # &lt;%= generated_for_user %&gt; # # This section is for settings common to all environments. # Do not add anything above this next line. common: &amp;default_settings"
      },
      "id": "603eb738e7b9d242542a0815"
    }
  ],
  "/docs/agents/java-agent/custom-instrumentation/circuit-breaker-java-custom-instrumentation": [
    {
      "sections": [
        "Custom JMX YAML examples",
        "Contents",
        "YAML example",
        "Example explanation",
        "Properties",
        "MBeans",
        "Attributes",
        "Type",
        "Metric names",
        "Tip",
        "Finding object and attribute names",
        "For more help"
      ],
      "title": "Custom JMX YAML examples",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "38e6f21e2a3344f554072dff9919df049db60224",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/custom-jmx-yaml-examples/",
      "published_at": "2021-05-05T06:53:28Z",
      "updated_at": "2021-03-16T13:47:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This is an example of a custom JMX YAML file for New Relic's Java agent, including value and definition, MBean, attributes, type, and names for metrics, objects, and attributes. For more information, including a video, see Custom JMX monitoring by YAML. Contents YAML example Here is an example of a custom JMX YAML file. YAML files are space senstive. name: TomcatCustom version: 1.0 enabled: true jmx: - object_name: Catalina:type=Cache,host=localhost,path=/examples metrics: - attributes: accessCount, cacheSize, hitsCount type: simple - object_name: Catalina:type=Connector,port=8009 metrics: - attributes: bufferSize, maxHeaderCount - object_name: java.nio:type=BufferPool,name=* metrics: - attributes: Count type: monotonically_increasing Copy Example explanation Properties Value Definition name A descriptive name identifying your YAML custom instrumentation file, using one space before the property name. In the above example, the name is TomcatCustom. version The version of the extension file. Use a double. If two extensions have the same name, only the extension with the highest version will be used. Use one space before the property version. In the above example, the version is 1.0. enabled If true, the Java agent will read the extension. If false, the Java agent will ignore the extension. Use one space before the property enabled. The above example is enabled. MBeans Each line in the YAML starting with - object_name represents an MBean. For example, the following lines describe the information to be pulled from the first MBean: - object_name: Catalina:type=Cache,host=localhost,path=/examples metrics: - attributes: accessCount, cacheSize, hitsCount type: simple Copy The object_name property itself can match one or more MBeans. For example, the line below only matches one MBean: - object_name: Catalina:type=Cache,host=localhost,path=/examples Copy The following line could match multiple MBeans: - object_name: java.nio:type=BufferPool,name=* Copy The asterisk ( * ) wildcard can only be used with JDK 1.6 and higher. The three MBeans listed in the above example have the following object names: Catalina:type=Cache,host=localhost,path=/examples Catalina:type=Connector,port=8009 java.nio:type=BufferPool,name=* Copy Attributes The JMX example retrieves six different attributes from the three MBeans. New Relic's Java agent pulls these attributes from the first MBean: accessCount cacheSize hitsCount The agent pulls these attributes from the second MBean: bufferSize maxHeaderCount The agent pulls one attribute (Count) from third MBean. Type For type, use simple or monotonically_increasing. When type is not specified in the JMX YAML file, it defaults to monotonically_increasing. Value Definition simple The exact value of the attribute will be reported to New Relic each minute. monotonically_increasing The positive difference will be reported to New Relic each minute. In the example above, the attributes accessCount, cacheSize, and hitsCount will be reported as simple. The attributes bufferSize, maxHeaderCount, and Count will be reported as monotonically_increasing. If the hitsCount attribute value is always 5, then New Relic will report a 5 each minute. If the Count attribute value is always 5, then New Relic will report a 0 for the value each minute. If the Count attribute value changes from 5 to 7, then New Relic will report a 2 for that minute. Metric names When selecting custom dashboard metrics and not using the property root_metric_name, use the following format for all custom JMX metrics: JMX/beginning_of_object_name/type/any_properties_in_object_name/attribute_name Copy Tip Some object names do not include a type. In that case, a null will be present in the metric name. The configuration file does not use root_metric_name, so the following metrics will be created: JMX/Catalina/Cache/localhost/examples/accessCount JMX/Catalina/Cache/localhost/examples/cacheSize JMX/Catalina/Cache/localhost/examples/hitsCount JMX/Catalina/Connector/8009/bufferSize JMX/Catalina/Connector/8009/maxHeaderCount JMX/java.nio/BufferPool/direct/Count JMX/java.nio/BufferPool/mapped/Count Copy If you are using the property root_metric_name, then the metric will be your root metric name prefixed with JMX and followed by the attribute's name. You can use object name values by specifying the object name key in the root_metric_name between brackets {}. For example: Part of a configuration file: - object_name: Catalina:type=Cache,host=localhost,path=/examples root_metric_name: Tomcat/{host} metrics: - attributes: accessCount, cacheSize, hitsCount type: simple - object_name: mbean:type=Sample,host=localhost,path=* root_metric_name: SampleMBean metrics: - attributes: attOne, attTwo type: simple Copy Metric names: JMX/Tomcat/localhost/accessCount JMX/Tomcat/localhost/cacheSize JMX/Tomcat/localhost/hitsCount JMX/SampleMBean/attOne JMX/SampleMBean/attTwo Copy If an attribute does not actually exist on the MBean, then the metric will never appear in New Relic. Finding object and attribute names The easiest way to find available MBeans and its associated attributes is to use the JConsole instructions for JDK 1.6. For more help Additional documentation resources include: Custom instrumentation with the Java agent (method tracers, examples) Custom JMX monitoring by YAML (YAML file structure, value and definition)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.73256,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Custom</em> JMX YAML examples",
        "sections": "<em>Custom</em> JMX YAML examples",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " associated attributes is to use the JConsole instructions for JDK 1.6. For more help Additional documentation resources include: <em>Custom</em> <em>instrumentation</em> with the <em>Java</em> <em>agent</em> (method tracers, examples) <em>Custom</em> JMX monitoring by YAML (YAML file structure, value and definition)"
      },
      "id": "603eb76a196a67cba6a83db6"
    },
    {
      "sections": [
        "Messaging framework instrumentation",
        "Typical messaging",
        "Report the producing/consuming as external",
        "Add message metrics/custom parameters to current transaction",
        "Pass a distributed trace payload",
        "Edge cases",
        "Create a distributed trace payload and then receive a message",
        "Batch reading messages",
        "Capturing the processing time of the message",
        "For more help"
      ],
      "title": "Messaging framework instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "9b656fcf1790e65d1db825e35ab31c94b6561e08",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/messaging-framework-instrumentation/",
      "published_at": "2021-05-05T06:54:38Z",
      "updated_at": "2021-03-16T09:03:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "There are some messaging frameworks that New Relic doesn’t support by default. If you are interested in instrumenting these frameworks with our API here are some guidelines to follow. Typical messaging In the typical case, there is a process that produces a message and a process that consumes the message. Some useful things you could do here are below. Note you must be within a transaction for these to report. Report the producing/consuming as external You can create MessageProduceParameters and MessageConsumeParameters with relevant data and then call reportAsExternal(Params) to report the calls as externals. For example, when producing a message this would look like: MessageProduceParameters params = MessageProduceParameters.library(\"libraryName\").destinationType(NAMED_TOPIC).destinationName(\"topicName\").inboundHeaders(null).build(); NewRelic.getAgent().getTransaction().getTracedMethod().reportAsExternal(params); Copy A similar solution would work on the consumer side. Add message metrics/custom parameters to current transaction If there is useful information you want to add to your current transaction about the message, you can do that easily by calling our addCustomParameter() API. This looks like this: NewRelic.addCustomParameter(\"topic-name\", topic); Copy Pass a distributed trace payload In order to track the work across processes/services, the messaging framework must have a way to pass along metadata with the message, whether it’s via headers or some other mechanism. You can create a distributed trace payload on the producer side that can be attached to the message and read on the consumer side. You must be in a transaction for this to work. To do this you would follow a pattern like this: @Trace(dispatcher = true) public void sendData(Producer producer){ final DistributedTracePayload payload = NewRelic.getAgent().getTransaction().createDistributedTracePayload(); headers.add(new RecordHeader(\"newrelic\", payload.text().getBytes(StandardCharsets.UTF_8))); data = new ProducerRecord<String, String>(\"topic\", \"key\", \"value\", headers); producer.send(data); } Copy And on the consumer side: @Trace(dispatcher = true) public void processData(ConsumerRecord record){ final Iterator<Header> nrHeaders = record.headers().headers(\"newrelic\").iterator(); if (nrHeaders.hasNext()) { final Header nrHeader = nrHeaders.next(); final String payload = new String(nrHeader.value(), StandardCharsets.UTF_8); NewRelic.getAgent().getTransaction().acceptDistributedTracePayload(payload); } } Copy This example uses Kafka, which you can instrument. Instrument Kafka message queues provides information for instrumenting. Edge cases There are some edge cases that require extra care. Below are suggestions on the best way to tackle them. Create a distributed trace payload and then receive a message The problem here is that you can’t create a distributed trace payload and then accept a distributed trace payload within the same transaction in that order. This means that there are two attempts of distributed tracing and you have to choose which one you want. If you would like to accept the second payload rather than create the first one, you need to prevent the first payload from getting created. You can remove the custom instrumentation (if that’s what’s creating the payload) or disable instrumentation via our config Batch reading messages For batch consumption of messages, there is a problem of which distributed tracing payload you accept. If you are ok with linking just one of the distributed trace payloads then you can accept any one of the payloads in the batch but that will result in the rest of the payloads getting lost. However, if you want to see all of the distributed traces then you’ll need to create a transaction per message. The second solution could incur some overhead so take that into consideration when making a decision. A solution like that would look like: public void processMessages(ConsumerRecords<String, String> records) { for(ConsumerRecord<String, String> record: records) { processRecord(record); } } @Trace(dispatcher = true) private void processRecord(ConsumerRecord<String, String> record) { final Iterator<Header> nrHeaders = record.headers().headers(\"newrelicDTPayload\").iterator(); if (nrHeaders.hasNext()) { final Header nrHeader = nrHeaders.next(); final String payload = new String(nrHeader.value(), StandardCharsets.UTF_8); NewRelic.getAgent().getTransaction().acceptDistributedTracePayload(payload); } } Copy This will only work if there isn’t a transaction already started on the thread at this time. If there is one then just accepting one payload from the batch is your only solution. Capturing the processing time of the message If you would like to capture the processing time of a message then you will need to move the processing work into a method and then trace that method. For example: public void getMessages(){ KafkaConsumer consumer = new KafkaConsumer(props); consumer.subscribe(Arrays.asList(\"topic\")); while (true) { ConsumerRecords<String, String> recs = consumer.poll(10000); if (recs.count() == 0) { } else { for (ConsumerRecord<String, String> rec : recs) { processRec(rec); } } } } @Trace(dispatcher = true) private void processRec(ConsumerRecord<String, String> rec) { // some processing } Copy For more help Use the Guide to using the Java agent API to learn more about our Java agent API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.66919,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Messaging framework <em>instrumentation</em>",
        "sections": "Messaging framework <em>instrumentation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "(nrHeader.value(), StandardCharsets.UTF_8); NewRelic.get<em>Agent</em>().getTransaction().acceptDistributedTracePayload(payload); } } Copy This example uses Kafka, which you can <em>instrument</em>. <em>Instrument</em> Kafka message queues provides information for instrumenting. Edge cases There are some edge cases that require extra"
      },
      "id": "603ebc24196a67a6d7a83dc8"
    },
    {
      "sections": [
        "Java custom instrumentation",
        "Important",
        "When to choose custom instrumentation",
        "Implement custom instrumentation"
      ],
      "title": "Java custom instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "76fd78e33105744dc4c6342d8059b2b966f90196",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/java-custom-instrumentation/",
      "published_at": "2021-05-04T17:02:34Z",
      "updated_at": "2021-03-16T09:00:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM for Java will typically produce useful performance data automatically. However, if New Relic does not support your framework, or if you want to set up additional monitoring, you will want to implement custom instrumentation. Custom instrumentation allows you to track interactions that aren't captured by New Relic's automatic instrumentation, and lets you add detail to your transaction traces, to help you identify key issues. New Relic collects metrics and events from many frameworks automatically. If you are using a supported framework or component, you may see some transaction information out of the box, and custom instrumentation can be used to supplement the information the Agent reports by default. Important If you are using a supported framework, but are not seeing transactions, get support at support.newrelic.com to ensure the framework instrumentation is working. When to choose custom instrumentation Choose custom instrumentation in these situations: New Relic does not support your framework and transactions do not appear in the UI You would like to add detail to your transaction traces Transaction traces include large blocks of application code time without sufficient detail Implement custom instrumentation You can implement custom instrumentation with one of these methods: Method Description The New Relic UI New Relic for Java includes an option in the UI for custom instrumentation called the Custom Instrumentation Editor. This option doesn't require any direct modification of your application code, so is a good choice if you don't want to or can't modify your code. The editor is, however, fairly limited in functionality compared to the Java agent API. API annotation Using the New Relic Java agent API, you can annotate the methods in your application code that you want to monitor. The annotation method is robust and easy to troubleshoot. If you are willing to modify your source code, annotation is the recommended method. If you have many methods you want to instrument, you might prefer XML instrumentation. For more about the API and its other functions, see Intro to the Java agent API. XML If you can't modify your code, or if you need to instrument many methods, XML instrumentation is the best custom instrumentation method. With this method, you specify the classes you want to instrument in an external XML file. While XML instrumentation is powerful, it is also more difficult to use than the other instrumentation methods. For simpler instrumentation needs, New Relic recommends annotation or instrumentation via the UI. For more information, see Java instrumentation by XML. You can also monitor Java Management Extensions (JMX) via custom instrumentation. JMX is a way to monitor and manage applications, devices, and services. You can implement JMX monitoring via an external YAML file.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.66856,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>custom</em> <em>instrumentation</em>",
        "sections": "<em>Java</em> <em>custom</em> <em>instrumentation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " functions, see Intro to the <em>Java</em> <em>agent</em> API. XML If you can&#x27;t modify your code, or if you need to <em>instrument</em> many methods, XML <em>instrumentation</em> is the best <em>custom</em> <em>instrumentation</em> method. With this method, you specify the classes you want to <em>instrument</em> in an external XML file. While XML <em>instrumentation</em>"
      },
      "id": "603eb6b6196a67b753a83db7"
    }
  ],
  "/docs/agents/java-agent/custom-instrumentation/custom-instrumentation-editor-instrument-ui": [
    {
      "sections": [
        "Custom JMX YAML examples",
        "Contents",
        "YAML example",
        "Example explanation",
        "Properties",
        "MBeans",
        "Attributes",
        "Type",
        "Metric names",
        "Tip",
        "Finding object and attribute names",
        "For more help"
      ],
      "title": "Custom JMX YAML examples",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "38e6f21e2a3344f554072dff9919df049db60224",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/custom-jmx-yaml-examples/",
      "published_at": "2021-05-05T06:53:28Z",
      "updated_at": "2021-03-16T13:47:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This is an example of a custom JMX YAML file for New Relic's Java agent, including value and definition, MBean, attributes, type, and names for metrics, objects, and attributes. For more information, including a video, see Custom JMX monitoring by YAML. Contents YAML example Here is an example of a custom JMX YAML file. YAML files are space senstive. name: TomcatCustom version: 1.0 enabled: true jmx: - object_name: Catalina:type=Cache,host=localhost,path=/examples metrics: - attributes: accessCount, cacheSize, hitsCount type: simple - object_name: Catalina:type=Connector,port=8009 metrics: - attributes: bufferSize, maxHeaderCount - object_name: java.nio:type=BufferPool,name=* metrics: - attributes: Count type: monotonically_increasing Copy Example explanation Properties Value Definition name A descriptive name identifying your YAML custom instrumentation file, using one space before the property name. In the above example, the name is TomcatCustom. version The version of the extension file. Use a double. If two extensions have the same name, only the extension with the highest version will be used. Use one space before the property version. In the above example, the version is 1.0. enabled If true, the Java agent will read the extension. If false, the Java agent will ignore the extension. Use one space before the property enabled. The above example is enabled. MBeans Each line in the YAML starting with - object_name represents an MBean. For example, the following lines describe the information to be pulled from the first MBean: - object_name: Catalina:type=Cache,host=localhost,path=/examples metrics: - attributes: accessCount, cacheSize, hitsCount type: simple Copy The object_name property itself can match one or more MBeans. For example, the line below only matches one MBean: - object_name: Catalina:type=Cache,host=localhost,path=/examples Copy The following line could match multiple MBeans: - object_name: java.nio:type=BufferPool,name=* Copy The asterisk ( * ) wildcard can only be used with JDK 1.6 and higher. The three MBeans listed in the above example have the following object names: Catalina:type=Cache,host=localhost,path=/examples Catalina:type=Connector,port=8009 java.nio:type=BufferPool,name=* Copy Attributes The JMX example retrieves six different attributes from the three MBeans. New Relic's Java agent pulls these attributes from the first MBean: accessCount cacheSize hitsCount The agent pulls these attributes from the second MBean: bufferSize maxHeaderCount The agent pulls one attribute (Count) from third MBean. Type For type, use simple or monotonically_increasing. When type is not specified in the JMX YAML file, it defaults to monotonically_increasing. Value Definition simple The exact value of the attribute will be reported to New Relic each minute. monotonically_increasing The positive difference will be reported to New Relic each minute. In the example above, the attributes accessCount, cacheSize, and hitsCount will be reported as simple. The attributes bufferSize, maxHeaderCount, and Count will be reported as monotonically_increasing. If the hitsCount attribute value is always 5, then New Relic will report a 5 each minute. If the Count attribute value is always 5, then New Relic will report a 0 for the value each minute. If the Count attribute value changes from 5 to 7, then New Relic will report a 2 for that minute. Metric names When selecting custom dashboard metrics and not using the property root_metric_name, use the following format for all custom JMX metrics: JMX/beginning_of_object_name/type/any_properties_in_object_name/attribute_name Copy Tip Some object names do not include a type. In that case, a null will be present in the metric name. The configuration file does not use root_metric_name, so the following metrics will be created: JMX/Catalina/Cache/localhost/examples/accessCount JMX/Catalina/Cache/localhost/examples/cacheSize JMX/Catalina/Cache/localhost/examples/hitsCount JMX/Catalina/Connector/8009/bufferSize JMX/Catalina/Connector/8009/maxHeaderCount JMX/java.nio/BufferPool/direct/Count JMX/java.nio/BufferPool/mapped/Count Copy If you are using the property root_metric_name, then the metric will be your root metric name prefixed with JMX and followed by the attribute's name. You can use object name values by specifying the object name key in the root_metric_name between brackets {}. For example: Part of a configuration file: - object_name: Catalina:type=Cache,host=localhost,path=/examples root_metric_name: Tomcat/{host} metrics: - attributes: accessCount, cacheSize, hitsCount type: simple - object_name: mbean:type=Sample,host=localhost,path=* root_metric_name: SampleMBean metrics: - attributes: attOne, attTwo type: simple Copy Metric names: JMX/Tomcat/localhost/accessCount JMX/Tomcat/localhost/cacheSize JMX/Tomcat/localhost/hitsCount JMX/SampleMBean/attOne JMX/SampleMBean/attTwo Copy If an attribute does not actually exist on the MBean, then the metric will never appear in New Relic. Finding object and attribute names The easiest way to find available MBeans and its associated attributes is to use the JConsole instructions for JDK 1.6. For more help Additional documentation resources include: Custom instrumentation with the Java agent (method tracers, examples) Custom JMX monitoring by YAML (YAML file structure, value and definition)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.73256,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Custom</em> JMX YAML examples",
        "sections": "<em>Custom</em> JMX YAML examples",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " associated attributes is to use the JConsole instructions for JDK 1.6. For more help Additional documentation resources include: <em>Custom</em> <em>instrumentation</em> with the <em>Java</em> <em>agent</em> (method tracers, examples) <em>Custom</em> JMX monitoring by YAML (YAML file structure, value and definition)"
      },
      "id": "603eb76a196a67cba6a83db6"
    },
    {
      "sections": [
        "Messaging framework instrumentation",
        "Typical messaging",
        "Report the producing/consuming as external",
        "Add message metrics/custom parameters to current transaction",
        "Pass a distributed trace payload",
        "Edge cases",
        "Create a distributed trace payload and then receive a message",
        "Batch reading messages",
        "Capturing the processing time of the message",
        "For more help"
      ],
      "title": "Messaging framework instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "9b656fcf1790e65d1db825e35ab31c94b6561e08",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/messaging-framework-instrumentation/",
      "published_at": "2021-05-05T06:54:38Z",
      "updated_at": "2021-03-16T09:03:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "There are some messaging frameworks that New Relic doesn’t support by default. If you are interested in instrumenting these frameworks with our API here are some guidelines to follow. Typical messaging In the typical case, there is a process that produces a message and a process that consumes the message. Some useful things you could do here are below. Note you must be within a transaction for these to report. Report the producing/consuming as external You can create MessageProduceParameters and MessageConsumeParameters with relevant data and then call reportAsExternal(Params) to report the calls as externals. For example, when producing a message this would look like: MessageProduceParameters params = MessageProduceParameters.library(\"libraryName\").destinationType(NAMED_TOPIC).destinationName(\"topicName\").inboundHeaders(null).build(); NewRelic.getAgent().getTransaction().getTracedMethod().reportAsExternal(params); Copy A similar solution would work on the consumer side. Add message metrics/custom parameters to current transaction If there is useful information you want to add to your current transaction about the message, you can do that easily by calling our addCustomParameter() API. This looks like this: NewRelic.addCustomParameter(\"topic-name\", topic); Copy Pass a distributed trace payload In order to track the work across processes/services, the messaging framework must have a way to pass along metadata with the message, whether it’s via headers or some other mechanism. You can create a distributed trace payload on the producer side that can be attached to the message and read on the consumer side. You must be in a transaction for this to work. To do this you would follow a pattern like this: @Trace(dispatcher = true) public void sendData(Producer producer){ final DistributedTracePayload payload = NewRelic.getAgent().getTransaction().createDistributedTracePayload(); headers.add(new RecordHeader(\"newrelic\", payload.text().getBytes(StandardCharsets.UTF_8))); data = new ProducerRecord<String, String>(\"topic\", \"key\", \"value\", headers); producer.send(data); } Copy And on the consumer side: @Trace(dispatcher = true) public void processData(ConsumerRecord record){ final Iterator<Header> nrHeaders = record.headers().headers(\"newrelic\").iterator(); if (nrHeaders.hasNext()) { final Header nrHeader = nrHeaders.next(); final String payload = new String(nrHeader.value(), StandardCharsets.UTF_8); NewRelic.getAgent().getTransaction().acceptDistributedTracePayload(payload); } } Copy This example uses Kafka, which you can instrument. Instrument Kafka message queues provides information for instrumenting. Edge cases There are some edge cases that require extra care. Below are suggestions on the best way to tackle them. Create a distributed trace payload and then receive a message The problem here is that you can’t create a distributed trace payload and then accept a distributed trace payload within the same transaction in that order. This means that there are two attempts of distributed tracing and you have to choose which one you want. If you would like to accept the second payload rather than create the first one, you need to prevent the first payload from getting created. You can remove the custom instrumentation (if that’s what’s creating the payload) or disable instrumentation via our config Batch reading messages For batch consumption of messages, there is a problem of which distributed tracing payload you accept. If you are ok with linking just one of the distributed trace payloads then you can accept any one of the payloads in the batch but that will result in the rest of the payloads getting lost. However, if you want to see all of the distributed traces then you’ll need to create a transaction per message. The second solution could incur some overhead so take that into consideration when making a decision. A solution like that would look like: public void processMessages(ConsumerRecords<String, String> records) { for(ConsumerRecord<String, String> record: records) { processRecord(record); } } @Trace(dispatcher = true) private void processRecord(ConsumerRecord<String, String> record) { final Iterator<Header> nrHeaders = record.headers().headers(\"newrelicDTPayload\").iterator(); if (nrHeaders.hasNext()) { final Header nrHeader = nrHeaders.next(); final String payload = new String(nrHeader.value(), StandardCharsets.UTF_8); NewRelic.getAgent().getTransaction().acceptDistributedTracePayload(payload); } } Copy This will only work if there isn’t a transaction already started on the thread at this time. If there is one then just accepting one payload from the batch is your only solution. Capturing the processing time of the message If you would like to capture the processing time of a message then you will need to move the processing work into a method and then trace that method. For example: public void getMessages(){ KafkaConsumer consumer = new KafkaConsumer(props); consumer.subscribe(Arrays.asList(\"topic\")); while (true) { ConsumerRecords<String, String> recs = consumer.poll(10000); if (recs.count() == 0) { } else { for (ConsumerRecord<String, String> rec : recs) { processRec(rec); } } } } @Trace(dispatcher = true) private void processRec(ConsumerRecord<String, String> rec) { // some processing } Copy For more help Use the Guide to using the Java agent API to learn more about our Java agent API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.66919,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Messaging framework <em>instrumentation</em>",
        "sections": "Messaging framework <em>instrumentation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "(nrHeader.value(), StandardCharsets.UTF_8); NewRelic.get<em>Agent</em>().getTransaction().acceptDistributedTracePayload(payload); } } Copy This example uses Kafka, which you can <em>instrument</em>. <em>Instrument</em> Kafka message queues provides information for instrumenting. Edge cases There are some edge cases that require extra"
      },
      "id": "603ebc24196a67a6d7a83dc8"
    },
    {
      "sections": [
        "Java custom instrumentation",
        "Important",
        "When to choose custom instrumentation",
        "Implement custom instrumentation"
      ],
      "title": "Java custom instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "76fd78e33105744dc4c6342d8059b2b966f90196",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/java-custom-instrumentation/",
      "published_at": "2021-05-04T17:02:34Z",
      "updated_at": "2021-03-16T09:00:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM for Java will typically produce useful performance data automatically. However, if New Relic does not support your framework, or if you want to set up additional monitoring, you will want to implement custom instrumentation. Custom instrumentation allows you to track interactions that aren't captured by New Relic's automatic instrumentation, and lets you add detail to your transaction traces, to help you identify key issues. New Relic collects metrics and events from many frameworks automatically. If you are using a supported framework or component, you may see some transaction information out of the box, and custom instrumentation can be used to supplement the information the Agent reports by default. Important If you are using a supported framework, but are not seeing transactions, get support at support.newrelic.com to ensure the framework instrumentation is working. When to choose custom instrumentation Choose custom instrumentation in these situations: New Relic does not support your framework and transactions do not appear in the UI You would like to add detail to your transaction traces Transaction traces include large blocks of application code time without sufficient detail Implement custom instrumentation You can implement custom instrumentation with one of these methods: Method Description The New Relic UI New Relic for Java includes an option in the UI for custom instrumentation called the Custom Instrumentation Editor. This option doesn't require any direct modification of your application code, so is a good choice if you don't want to or can't modify your code. The editor is, however, fairly limited in functionality compared to the Java agent API. API annotation Using the New Relic Java agent API, you can annotate the methods in your application code that you want to monitor. The annotation method is robust and easy to troubleshoot. If you are willing to modify your source code, annotation is the recommended method. If you have many methods you want to instrument, you might prefer XML instrumentation. For more about the API and its other functions, see Intro to the Java agent API. XML If you can't modify your code, or if you need to instrument many methods, XML instrumentation is the best custom instrumentation method. With this method, you specify the classes you want to instrument in an external XML file. While XML instrumentation is powerful, it is also more difficult to use than the other instrumentation methods. For simpler instrumentation needs, New Relic recommends annotation or instrumentation via the UI. For more information, see Java instrumentation by XML. You can also monitor Java Management Extensions (JMX) via custom instrumentation. JMX is a way to monitor and manage applications, devices, and services. You can implement JMX monitoring via an external YAML file.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.66856,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>custom</em> <em>instrumentation</em>",
        "sections": "<em>Java</em> <em>custom</em> <em>instrumentation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " functions, see Intro to the <em>Java</em> <em>agent</em> API. XML If you can&#x27;t modify your code, or if you need to <em>instrument</em> many methods, XML <em>instrumentation</em> is the best <em>custom</em> <em>instrumentation</em> method. With this method, you specify the classes you want to <em>instrument</em> in an external XML file. While XML <em>instrumentation</em>"
      },
      "id": "603eb6b6196a67b753a83db7"
    }
  ],
  "/docs/agents/java-agent/custom-instrumentation/custom-jmx-yaml-examples": [
    {
      "sections": [
        "Messaging framework instrumentation",
        "Typical messaging",
        "Report the producing/consuming as external",
        "Add message metrics/custom parameters to current transaction",
        "Pass a distributed trace payload",
        "Edge cases",
        "Create a distributed trace payload and then receive a message",
        "Batch reading messages",
        "Capturing the processing time of the message",
        "For more help"
      ],
      "title": "Messaging framework instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "9b656fcf1790e65d1db825e35ab31c94b6561e08",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/messaging-framework-instrumentation/",
      "published_at": "2021-05-05T06:54:38Z",
      "updated_at": "2021-03-16T09:03:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "There are some messaging frameworks that New Relic doesn’t support by default. If you are interested in instrumenting these frameworks with our API here are some guidelines to follow. Typical messaging In the typical case, there is a process that produces a message and a process that consumes the message. Some useful things you could do here are below. Note you must be within a transaction for these to report. Report the producing/consuming as external You can create MessageProduceParameters and MessageConsumeParameters with relevant data and then call reportAsExternal(Params) to report the calls as externals. For example, when producing a message this would look like: MessageProduceParameters params = MessageProduceParameters.library(\"libraryName\").destinationType(NAMED_TOPIC).destinationName(\"topicName\").inboundHeaders(null).build(); NewRelic.getAgent().getTransaction().getTracedMethod().reportAsExternal(params); Copy A similar solution would work on the consumer side. Add message metrics/custom parameters to current transaction If there is useful information you want to add to your current transaction about the message, you can do that easily by calling our addCustomParameter() API. This looks like this: NewRelic.addCustomParameter(\"topic-name\", topic); Copy Pass a distributed trace payload In order to track the work across processes/services, the messaging framework must have a way to pass along metadata with the message, whether it’s via headers or some other mechanism. You can create a distributed trace payload on the producer side that can be attached to the message and read on the consumer side. You must be in a transaction for this to work. To do this you would follow a pattern like this: @Trace(dispatcher = true) public void sendData(Producer producer){ final DistributedTracePayload payload = NewRelic.getAgent().getTransaction().createDistributedTracePayload(); headers.add(new RecordHeader(\"newrelic\", payload.text().getBytes(StandardCharsets.UTF_8))); data = new ProducerRecord<String, String>(\"topic\", \"key\", \"value\", headers); producer.send(data); } Copy And on the consumer side: @Trace(dispatcher = true) public void processData(ConsumerRecord record){ final Iterator<Header> nrHeaders = record.headers().headers(\"newrelic\").iterator(); if (nrHeaders.hasNext()) { final Header nrHeader = nrHeaders.next(); final String payload = new String(nrHeader.value(), StandardCharsets.UTF_8); NewRelic.getAgent().getTransaction().acceptDistributedTracePayload(payload); } } Copy This example uses Kafka, which you can instrument. Instrument Kafka message queues provides information for instrumenting. Edge cases There are some edge cases that require extra care. Below are suggestions on the best way to tackle them. Create a distributed trace payload and then receive a message The problem here is that you can’t create a distributed trace payload and then accept a distributed trace payload within the same transaction in that order. This means that there are two attempts of distributed tracing and you have to choose which one you want. If you would like to accept the second payload rather than create the first one, you need to prevent the first payload from getting created. You can remove the custom instrumentation (if that’s what’s creating the payload) or disable instrumentation via our config Batch reading messages For batch consumption of messages, there is a problem of which distributed tracing payload you accept. If you are ok with linking just one of the distributed trace payloads then you can accept any one of the payloads in the batch but that will result in the rest of the payloads getting lost. However, if you want to see all of the distributed traces then you’ll need to create a transaction per message. The second solution could incur some overhead so take that into consideration when making a decision. A solution like that would look like: public void processMessages(ConsumerRecords<String, String> records) { for(ConsumerRecord<String, String> record: records) { processRecord(record); } } @Trace(dispatcher = true) private void processRecord(ConsumerRecord<String, String> record) { final Iterator<Header> nrHeaders = record.headers().headers(\"newrelicDTPayload\").iterator(); if (nrHeaders.hasNext()) { final Header nrHeader = nrHeaders.next(); final String payload = new String(nrHeader.value(), StandardCharsets.UTF_8); NewRelic.getAgent().getTransaction().acceptDistributedTracePayload(payload); } } Copy This will only work if there isn’t a transaction already started on the thread at this time. If there is one then just accepting one payload from the batch is your only solution. Capturing the processing time of the message If you would like to capture the processing time of a message then you will need to move the processing work into a method and then trace that method. For example: public void getMessages(){ KafkaConsumer consumer = new KafkaConsumer(props); consumer.subscribe(Arrays.asList(\"topic\")); while (true) { ConsumerRecords<String, String> recs = consumer.poll(10000); if (recs.count() == 0) { } else { for (ConsumerRecord<String, String> rec : recs) { processRec(rec); } } } } @Trace(dispatcher = true) private void processRec(ConsumerRecord<String, String> rec) { // some processing } Copy For more help Use the Guide to using the Java agent API to learn more about our Java agent API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.66918,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Messaging framework <em>instrumentation</em>",
        "sections": "Messaging framework <em>instrumentation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "(nrHeader.value(), StandardCharsets.UTF_8); NewRelic.get<em>Agent</em>().getTransaction().acceptDistributedTracePayload(payload); } } Copy This example uses Kafka, which you can <em>instrument</em>. <em>Instrument</em> Kafka message queues provides information for instrumenting. Edge cases There are some edge cases that require extra"
      },
      "id": "603ebc24196a67a6d7a83dc8"
    },
    {
      "sections": [
        "Java custom instrumentation",
        "Important",
        "When to choose custom instrumentation",
        "Implement custom instrumentation"
      ],
      "title": "Java custom instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "76fd78e33105744dc4c6342d8059b2b966f90196",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/java-custom-instrumentation/",
      "published_at": "2021-05-04T17:02:34Z",
      "updated_at": "2021-03-16T09:00:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM for Java will typically produce useful performance data automatically. However, if New Relic does not support your framework, or if you want to set up additional monitoring, you will want to implement custom instrumentation. Custom instrumentation allows you to track interactions that aren't captured by New Relic's automatic instrumentation, and lets you add detail to your transaction traces, to help you identify key issues. New Relic collects metrics and events from many frameworks automatically. If you are using a supported framework or component, you may see some transaction information out of the box, and custom instrumentation can be used to supplement the information the Agent reports by default. Important If you are using a supported framework, but are not seeing transactions, get support at support.newrelic.com to ensure the framework instrumentation is working. When to choose custom instrumentation Choose custom instrumentation in these situations: New Relic does not support your framework and transactions do not appear in the UI You would like to add detail to your transaction traces Transaction traces include large blocks of application code time without sufficient detail Implement custom instrumentation You can implement custom instrumentation with one of these methods: Method Description The New Relic UI New Relic for Java includes an option in the UI for custom instrumentation called the Custom Instrumentation Editor. This option doesn't require any direct modification of your application code, so is a good choice if you don't want to or can't modify your code. The editor is, however, fairly limited in functionality compared to the Java agent API. API annotation Using the New Relic Java agent API, you can annotate the methods in your application code that you want to monitor. The annotation method is robust and easy to troubleshoot. If you are willing to modify your source code, annotation is the recommended method. If you have many methods you want to instrument, you might prefer XML instrumentation. For more about the API and its other functions, see Intro to the Java agent API. XML If you can't modify your code, or if you need to instrument many methods, XML instrumentation is the best custom instrumentation method. With this method, you specify the classes you want to instrument in an external XML file. While XML instrumentation is powerful, it is also more difficult to use than the other instrumentation methods. For simpler instrumentation needs, New Relic recommends annotation or instrumentation via the UI. For more information, see Java instrumentation by XML. You can also monitor Java Management Extensions (JMX) via custom instrumentation. JMX is a way to monitor and manage applications, devices, and services. You can implement JMX monitoring via an external YAML file.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.66856,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>custom</em> <em>instrumentation</em>",
        "sections": "<em>Java</em> <em>custom</em> <em>instrumentation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " functions, see Intro to the <em>Java</em> <em>agent</em> API. XML If you can&#x27;t modify your code, or if you need to <em>instrument</em> many methods, XML <em>instrumentation</em> is the best <em>custom</em> <em>instrumentation</em> method. With this method, you specify the classes you want to <em>instrument</em> in an external XML file. While XML <em>instrumentation</em>"
      },
      "id": "603eb6b6196a67b753a83db7"
    },
    {
      "sections": [
        "Java instrumentation by XML",
        "Accessing your XML file",
        "XML file structure",
        "XML file validation",
        "Java versions below Java 10",
        "All Java versions",
        "Tip",
        "XML file location",
        "Verify the file was read",
        "Multiple XML files",
        "XML and YAML",
        "Example XML file"
      ],
      "title": "Java instrumentation by XML",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "bf64043c85e0d690961fbbaa6a6dd6b52636e3d5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/java-instrumentation-xml/",
      "published_at": "2021-05-05T03:13:01Z",
      "updated_at": "2021-03-16T08:59:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For your New Relic-monitored Java application, one custom instrumentation method is to use an XML file to specify your app methods that should be instrumented. The Java agent will read the XML file and instrument the relevant classes on startup; XML files added to the extensions directory after startup do not require a JVM restart to be detected. See Java agent custom instrumentation for a description of the custom instrumentation options and the reasons to use them. Accessing your XML file Go to one.newrelic.com > APM > (select an app) > Settings > Instrumentation. From here you can: Download a sample XML file. (You can do this from the pop-up that appears when you click Import an XML file.) Select an edit existing XML file. Search the instrumentation history. XML file structure Your New Relic agent download package (newrelic_agent.zip) contains two templates for using XML instrumentation: The extension.xsd template is the XML schema definition which all custom extensions must follow. The extension-example.xml template is an example. This file instruments some of the basic JDK methods. If you edit and rename this file, ensure you modify the name=\"extension-example\" attribute to match the new filename. For more information about the properties in the extension.xsd template, see the XML file format overview. XML file validation Before starting your application, validate your XML file using New Relic's command line tool. The command line tool can only be used when your classes are in a jar. There are two ways to validate your XML instrumentation: Java versions below Java 10 The easiest way to do this for Java versions lower than Java 10 is with this command: java -Djava.ext.dirs=/path/to/jarred/classes -jar newrelic.jar instrument -file /path/to/file.xml -debug true Copy All Java versions Tip For Java versions below Java 10, see the recommended procedure. That procedure is not possible with Java 10 or higher because those versions no longer allow java.ext.dirs to be set. For all Java versions, you can set the classpath manually: java -cp /path/to/your-app.jar:/path/to/newrelic.jar com.newrelic.bootstrap.BootstrapAgent instrument -file /path/to/file.xml -debug true Copy The application is run with the newrelic.jar. The call must contain the keyword instrument followed by the -file flag with the path to your XML file. The property -debug is optional and may be set to true to provide more information during the validation. The tool will: Validate the XML syntax. Check that each class to be instrumented is present on the class path. Check that each method is contained in the appropriate class. If the XML file is valid, you will see a pass statement printed to the terminal: PASS: The extension at file.txt was successfully validated. Copy If the XML fails validation, you will see a failure message printed to the terminal: FAIL: reason Copy XML file location The Java agent reads any XML files in the extensions directory on process start up. The extensions directory is also read every harvest cycle. XML files added to this directory during runtime will be read within a few minutes, so they do not require a JVM restart. There are two ways to specify the XML file location: XML file location options Procedure Create an extensions directory In the directory where the newrelic.jar and newrelic.yml is located, create a directory named extensions. Put the XML file in this directory with a .xml extension. In newrelic.yml, check that the property extensions.dir is not set. Specify an existing extensions directory In the newrelic.yml configuration file under the common section, use the property extensions.dir to specify the directory where the XML file is located. Make sure the file is in the specified directory and that the file has a .xml extension. Verify the file was read To verify the agent read the XML file, first set the Log management to finer: Edit the newrelic.yml configuration file and change the log_level property: log_level: finer Copy Start or restart the application. If the read was successful, logs/newrelic_agent.log will indicate this in a statement similar to: Reading custom extension file /path/to/file.xml Copy If no statement appears in logs/newrelic_agent.log, then the XML file was not found. Check the location of the XML file, and ensure the New Relic process has read access to the file. Multiple XML files While using a single XML file is preferred, you can use multiple custom XML files. These files will all be instrumented as long as the extension name in the files is unique. If two custom XML files contain the same extension name, then the one with the highest version will be implemented and the other will be ignored. If the two files have the same name and version, then the first file read by the agent will be implemented and the other will be ignored. XML and YAML Prior to 2.10.0, YAML files could be used for custom instrumentation. These legacy YAML files are still supported. However, new users should use XML files for custom instrumentation. Legacy users: If both a YAML and XML file exist with the same extension name, only the XML file will be instrumented. The YAML file will be ignored. If you want both the YAML and XML files to be instrumented, give each file a different extension name. Example XML file For an example of a custom instrumentation XML file, see Java XML examples.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.66824,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>instrumentation</em> by XML",
        "sections": "<em>Java</em> <em>instrumentation</em> by XML",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "For your New Relic-monitored <em>Java</em> application, one <em>custom</em> <em>instrumentation</em> method is to use an XML file to specify your app methods that should be instrumented. The <em>Java</em> <em>agent</em> will read the XML file and <em>instrument</em> the relevant classes on startup; XML files added to the extensions directory after"
      },
      "id": "603eb684196a67fe45a83dad"
    }
  ],
  "/docs/agents/java-agent/custom-instrumentation/java-agent-custom-jmx-instrumentation-yaml": [
    {
      "sections": [
        "Custom JMX YAML examples",
        "Contents",
        "YAML example",
        "Example explanation",
        "Properties",
        "MBeans",
        "Attributes",
        "Type",
        "Metric names",
        "Tip",
        "Finding object and attribute names",
        "For more help"
      ],
      "title": "Custom JMX YAML examples",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "38e6f21e2a3344f554072dff9919df049db60224",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/custom-jmx-yaml-examples/",
      "published_at": "2021-05-05T06:53:28Z",
      "updated_at": "2021-03-16T13:47:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This is an example of a custom JMX YAML file for New Relic's Java agent, including value and definition, MBean, attributes, type, and names for metrics, objects, and attributes. For more information, including a video, see Custom JMX monitoring by YAML. Contents YAML example Here is an example of a custom JMX YAML file. YAML files are space senstive. name: TomcatCustom version: 1.0 enabled: true jmx: - object_name: Catalina:type=Cache,host=localhost,path=/examples metrics: - attributes: accessCount, cacheSize, hitsCount type: simple - object_name: Catalina:type=Connector,port=8009 metrics: - attributes: bufferSize, maxHeaderCount - object_name: java.nio:type=BufferPool,name=* metrics: - attributes: Count type: monotonically_increasing Copy Example explanation Properties Value Definition name A descriptive name identifying your YAML custom instrumentation file, using one space before the property name. In the above example, the name is TomcatCustom. version The version of the extension file. Use a double. If two extensions have the same name, only the extension with the highest version will be used. Use one space before the property version. In the above example, the version is 1.0. enabled If true, the Java agent will read the extension. If false, the Java agent will ignore the extension. Use one space before the property enabled. The above example is enabled. MBeans Each line in the YAML starting with - object_name represents an MBean. For example, the following lines describe the information to be pulled from the first MBean: - object_name: Catalina:type=Cache,host=localhost,path=/examples metrics: - attributes: accessCount, cacheSize, hitsCount type: simple Copy The object_name property itself can match one or more MBeans. For example, the line below only matches one MBean: - object_name: Catalina:type=Cache,host=localhost,path=/examples Copy The following line could match multiple MBeans: - object_name: java.nio:type=BufferPool,name=* Copy The asterisk ( * ) wildcard can only be used with JDK 1.6 and higher. The three MBeans listed in the above example have the following object names: Catalina:type=Cache,host=localhost,path=/examples Catalina:type=Connector,port=8009 java.nio:type=BufferPool,name=* Copy Attributes The JMX example retrieves six different attributes from the three MBeans. New Relic's Java agent pulls these attributes from the first MBean: accessCount cacheSize hitsCount The agent pulls these attributes from the second MBean: bufferSize maxHeaderCount The agent pulls one attribute (Count) from third MBean. Type For type, use simple or monotonically_increasing. When type is not specified in the JMX YAML file, it defaults to monotonically_increasing. Value Definition simple The exact value of the attribute will be reported to New Relic each minute. monotonically_increasing The positive difference will be reported to New Relic each minute. In the example above, the attributes accessCount, cacheSize, and hitsCount will be reported as simple. The attributes bufferSize, maxHeaderCount, and Count will be reported as monotonically_increasing. If the hitsCount attribute value is always 5, then New Relic will report a 5 each minute. If the Count attribute value is always 5, then New Relic will report a 0 for the value each minute. If the Count attribute value changes from 5 to 7, then New Relic will report a 2 for that minute. Metric names When selecting custom dashboard metrics and not using the property root_metric_name, use the following format for all custom JMX metrics: JMX/beginning_of_object_name/type/any_properties_in_object_name/attribute_name Copy Tip Some object names do not include a type. In that case, a null will be present in the metric name. The configuration file does not use root_metric_name, so the following metrics will be created: JMX/Catalina/Cache/localhost/examples/accessCount JMX/Catalina/Cache/localhost/examples/cacheSize JMX/Catalina/Cache/localhost/examples/hitsCount JMX/Catalina/Connector/8009/bufferSize JMX/Catalina/Connector/8009/maxHeaderCount JMX/java.nio/BufferPool/direct/Count JMX/java.nio/BufferPool/mapped/Count Copy If you are using the property root_metric_name, then the metric will be your root metric name prefixed with JMX and followed by the attribute's name. You can use object name values by specifying the object name key in the root_metric_name between brackets {}. For example: Part of a configuration file: - object_name: Catalina:type=Cache,host=localhost,path=/examples root_metric_name: Tomcat/{host} metrics: - attributes: accessCount, cacheSize, hitsCount type: simple - object_name: mbean:type=Sample,host=localhost,path=* root_metric_name: SampleMBean metrics: - attributes: attOne, attTwo type: simple Copy Metric names: JMX/Tomcat/localhost/accessCount JMX/Tomcat/localhost/cacheSize JMX/Tomcat/localhost/hitsCount JMX/SampleMBean/attOne JMX/SampleMBean/attTwo Copy If an attribute does not actually exist on the MBean, then the metric will never appear in New Relic. Finding object and attribute names The easiest way to find available MBeans and its associated attributes is to use the JConsole instructions for JDK 1.6. For more help Additional documentation resources include: Custom instrumentation with the Java agent (method tracers, examples) Custom JMX monitoring by YAML (YAML file structure, value and definition)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.73256,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Custom</em> JMX YAML examples",
        "sections": "<em>Custom</em> JMX YAML examples",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " associated attributes is to use the JConsole instructions for JDK 1.6. For more help Additional documentation resources include: <em>Custom</em> <em>instrumentation</em> with the <em>Java</em> <em>agent</em> (method tracers, examples) <em>Custom</em> JMX monitoring by YAML (YAML file structure, value and definition)"
      },
      "id": "603eb76a196a67cba6a83db6"
    },
    {
      "sections": [
        "Messaging framework instrumentation",
        "Typical messaging",
        "Report the producing/consuming as external",
        "Add message metrics/custom parameters to current transaction",
        "Pass a distributed trace payload",
        "Edge cases",
        "Create a distributed trace payload and then receive a message",
        "Batch reading messages",
        "Capturing the processing time of the message",
        "For more help"
      ],
      "title": "Messaging framework instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "9b656fcf1790e65d1db825e35ab31c94b6561e08",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/messaging-framework-instrumentation/",
      "published_at": "2021-05-05T06:54:38Z",
      "updated_at": "2021-03-16T09:03:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "There are some messaging frameworks that New Relic doesn’t support by default. If you are interested in instrumenting these frameworks with our API here are some guidelines to follow. Typical messaging In the typical case, there is a process that produces a message and a process that consumes the message. Some useful things you could do here are below. Note you must be within a transaction for these to report. Report the producing/consuming as external You can create MessageProduceParameters and MessageConsumeParameters with relevant data and then call reportAsExternal(Params) to report the calls as externals. For example, when producing a message this would look like: MessageProduceParameters params = MessageProduceParameters.library(\"libraryName\").destinationType(NAMED_TOPIC).destinationName(\"topicName\").inboundHeaders(null).build(); NewRelic.getAgent().getTransaction().getTracedMethod().reportAsExternal(params); Copy A similar solution would work on the consumer side. Add message metrics/custom parameters to current transaction If there is useful information you want to add to your current transaction about the message, you can do that easily by calling our addCustomParameter() API. This looks like this: NewRelic.addCustomParameter(\"topic-name\", topic); Copy Pass a distributed trace payload In order to track the work across processes/services, the messaging framework must have a way to pass along metadata with the message, whether it’s via headers or some other mechanism. You can create a distributed trace payload on the producer side that can be attached to the message and read on the consumer side. You must be in a transaction for this to work. To do this you would follow a pattern like this: @Trace(dispatcher = true) public void sendData(Producer producer){ final DistributedTracePayload payload = NewRelic.getAgent().getTransaction().createDistributedTracePayload(); headers.add(new RecordHeader(\"newrelic\", payload.text().getBytes(StandardCharsets.UTF_8))); data = new ProducerRecord<String, String>(\"topic\", \"key\", \"value\", headers); producer.send(data); } Copy And on the consumer side: @Trace(dispatcher = true) public void processData(ConsumerRecord record){ final Iterator<Header> nrHeaders = record.headers().headers(\"newrelic\").iterator(); if (nrHeaders.hasNext()) { final Header nrHeader = nrHeaders.next(); final String payload = new String(nrHeader.value(), StandardCharsets.UTF_8); NewRelic.getAgent().getTransaction().acceptDistributedTracePayload(payload); } } Copy This example uses Kafka, which you can instrument. Instrument Kafka message queues provides information for instrumenting. Edge cases There are some edge cases that require extra care. Below are suggestions on the best way to tackle them. Create a distributed trace payload and then receive a message The problem here is that you can’t create a distributed trace payload and then accept a distributed trace payload within the same transaction in that order. This means that there are two attempts of distributed tracing and you have to choose which one you want. If you would like to accept the second payload rather than create the first one, you need to prevent the first payload from getting created. You can remove the custom instrumentation (if that’s what’s creating the payload) or disable instrumentation via our config Batch reading messages For batch consumption of messages, there is a problem of which distributed tracing payload you accept. If you are ok with linking just one of the distributed trace payloads then you can accept any one of the payloads in the batch but that will result in the rest of the payloads getting lost. However, if you want to see all of the distributed traces then you’ll need to create a transaction per message. The second solution could incur some overhead so take that into consideration when making a decision. A solution like that would look like: public void processMessages(ConsumerRecords<String, String> records) { for(ConsumerRecord<String, String> record: records) { processRecord(record); } } @Trace(dispatcher = true) private void processRecord(ConsumerRecord<String, String> record) { final Iterator<Header> nrHeaders = record.headers().headers(\"newrelicDTPayload\").iterator(); if (nrHeaders.hasNext()) { final Header nrHeader = nrHeaders.next(); final String payload = new String(nrHeader.value(), StandardCharsets.UTF_8); NewRelic.getAgent().getTransaction().acceptDistributedTracePayload(payload); } } Copy This will only work if there isn’t a transaction already started on the thread at this time. If there is one then just accepting one payload from the batch is your only solution. Capturing the processing time of the message If you would like to capture the processing time of a message then you will need to move the processing work into a method and then trace that method. For example: public void getMessages(){ KafkaConsumer consumer = new KafkaConsumer(props); consumer.subscribe(Arrays.asList(\"topic\")); while (true) { ConsumerRecords<String, String> recs = consumer.poll(10000); if (recs.count() == 0) { } else { for (ConsumerRecord<String, String> rec : recs) { processRec(rec); } } } } @Trace(dispatcher = true) private void processRec(ConsumerRecord<String, String> rec) { // some processing } Copy For more help Use the Guide to using the Java agent API to learn more about our Java agent API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.66918,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Messaging framework <em>instrumentation</em>",
        "sections": "Messaging framework <em>instrumentation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "(nrHeader.value(), StandardCharsets.UTF_8); NewRelic.get<em>Agent</em>().getTransaction().acceptDistributedTracePayload(payload); } } Copy This example uses Kafka, which you can <em>instrument</em>. <em>Instrument</em> Kafka message queues provides information for instrumenting. Edge cases There are some edge cases that require extra"
      },
      "id": "603ebc24196a67a6d7a83dc8"
    },
    {
      "sections": [
        "Java custom instrumentation",
        "Important",
        "When to choose custom instrumentation",
        "Implement custom instrumentation"
      ],
      "title": "Java custom instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "76fd78e33105744dc4c6342d8059b2b966f90196",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/java-custom-instrumentation/",
      "published_at": "2021-05-04T17:02:34Z",
      "updated_at": "2021-03-16T09:00:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM for Java will typically produce useful performance data automatically. However, if New Relic does not support your framework, or if you want to set up additional monitoring, you will want to implement custom instrumentation. Custom instrumentation allows you to track interactions that aren't captured by New Relic's automatic instrumentation, and lets you add detail to your transaction traces, to help you identify key issues. New Relic collects metrics and events from many frameworks automatically. If you are using a supported framework or component, you may see some transaction information out of the box, and custom instrumentation can be used to supplement the information the Agent reports by default. Important If you are using a supported framework, but are not seeing transactions, get support at support.newrelic.com to ensure the framework instrumentation is working. When to choose custom instrumentation Choose custom instrumentation in these situations: New Relic does not support your framework and transactions do not appear in the UI You would like to add detail to your transaction traces Transaction traces include large blocks of application code time without sufficient detail Implement custom instrumentation You can implement custom instrumentation with one of these methods: Method Description The New Relic UI New Relic for Java includes an option in the UI for custom instrumentation called the Custom Instrumentation Editor. This option doesn't require any direct modification of your application code, so is a good choice if you don't want to or can't modify your code. The editor is, however, fairly limited in functionality compared to the Java agent API. API annotation Using the New Relic Java agent API, you can annotate the methods in your application code that you want to monitor. The annotation method is robust and easy to troubleshoot. If you are willing to modify your source code, annotation is the recommended method. If you have many methods you want to instrument, you might prefer XML instrumentation. For more about the API and its other functions, see Intro to the Java agent API. XML If you can't modify your code, or if you need to instrument many methods, XML instrumentation is the best custom instrumentation method. With this method, you specify the classes you want to instrument in an external XML file. While XML instrumentation is powerful, it is also more difficult to use than the other instrumentation methods. For simpler instrumentation needs, New Relic recommends annotation or instrumentation via the UI. For more information, see Java instrumentation by XML. You can also monitor Java Management Extensions (JMX) via custom instrumentation. JMX is a way to monitor and manage applications, devices, and services. You can implement JMX monitoring via an external YAML file.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.66856,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>custom</em> <em>instrumentation</em>",
        "sections": "<em>Java</em> <em>custom</em> <em>instrumentation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " functions, see Intro to the <em>Java</em> <em>agent</em> API. XML If you can&#x27;t modify your code, or if you need to <em>instrument</em> many methods, XML <em>instrumentation</em> is the best <em>custom</em> <em>instrumentation</em> method. With this method, you specify the classes you want to <em>instrument</em> in an external XML file. While XML <em>instrumentation</em>"
      },
      "id": "603eb6b6196a67b753a83db7"
    }
  ],
  "/docs/agents/java-agent/custom-instrumentation/java-custom-instrumentation": [
    {
      "sections": [
        "Custom JMX YAML examples",
        "Contents",
        "YAML example",
        "Example explanation",
        "Properties",
        "MBeans",
        "Attributes",
        "Type",
        "Metric names",
        "Tip",
        "Finding object and attribute names",
        "For more help"
      ],
      "title": "Custom JMX YAML examples",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "38e6f21e2a3344f554072dff9919df049db60224",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/custom-jmx-yaml-examples/",
      "published_at": "2021-05-05T06:53:28Z",
      "updated_at": "2021-03-16T13:47:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This is an example of a custom JMX YAML file for New Relic's Java agent, including value and definition, MBean, attributes, type, and names for metrics, objects, and attributes. For more information, including a video, see Custom JMX monitoring by YAML. Contents YAML example Here is an example of a custom JMX YAML file. YAML files are space senstive. name: TomcatCustom version: 1.0 enabled: true jmx: - object_name: Catalina:type=Cache,host=localhost,path=/examples metrics: - attributes: accessCount, cacheSize, hitsCount type: simple - object_name: Catalina:type=Connector,port=8009 metrics: - attributes: bufferSize, maxHeaderCount - object_name: java.nio:type=BufferPool,name=* metrics: - attributes: Count type: monotonically_increasing Copy Example explanation Properties Value Definition name A descriptive name identifying your YAML custom instrumentation file, using one space before the property name. In the above example, the name is TomcatCustom. version The version of the extension file. Use a double. If two extensions have the same name, only the extension with the highest version will be used. Use one space before the property version. In the above example, the version is 1.0. enabled If true, the Java agent will read the extension. If false, the Java agent will ignore the extension. Use one space before the property enabled. The above example is enabled. MBeans Each line in the YAML starting with - object_name represents an MBean. For example, the following lines describe the information to be pulled from the first MBean: - object_name: Catalina:type=Cache,host=localhost,path=/examples metrics: - attributes: accessCount, cacheSize, hitsCount type: simple Copy The object_name property itself can match one or more MBeans. For example, the line below only matches one MBean: - object_name: Catalina:type=Cache,host=localhost,path=/examples Copy The following line could match multiple MBeans: - object_name: java.nio:type=BufferPool,name=* Copy The asterisk ( * ) wildcard can only be used with JDK 1.6 and higher. The three MBeans listed in the above example have the following object names: Catalina:type=Cache,host=localhost,path=/examples Catalina:type=Connector,port=8009 java.nio:type=BufferPool,name=* Copy Attributes The JMX example retrieves six different attributes from the three MBeans. New Relic's Java agent pulls these attributes from the first MBean: accessCount cacheSize hitsCount The agent pulls these attributes from the second MBean: bufferSize maxHeaderCount The agent pulls one attribute (Count) from third MBean. Type For type, use simple or monotonically_increasing. When type is not specified in the JMX YAML file, it defaults to monotonically_increasing. Value Definition simple The exact value of the attribute will be reported to New Relic each minute. monotonically_increasing The positive difference will be reported to New Relic each minute. In the example above, the attributes accessCount, cacheSize, and hitsCount will be reported as simple. The attributes bufferSize, maxHeaderCount, and Count will be reported as monotonically_increasing. If the hitsCount attribute value is always 5, then New Relic will report a 5 each minute. If the Count attribute value is always 5, then New Relic will report a 0 for the value each minute. If the Count attribute value changes from 5 to 7, then New Relic will report a 2 for that minute. Metric names When selecting custom dashboard metrics and not using the property root_metric_name, use the following format for all custom JMX metrics: JMX/beginning_of_object_name/type/any_properties_in_object_name/attribute_name Copy Tip Some object names do not include a type. In that case, a null will be present in the metric name. The configuration file does not use root_metric_name, so the following metrics will be created: JMX/Catalina/Cache/localhost/examples/accessCount JMX/Catalina/Cache/localhost/examples/cacheSize JMX/Catalina/Cache/localhost/examples/hitsCount JMX/Catalina/Connector/8009/bufferSize JMX/Catalina/Connector/8009/maxHeaderCount JMX/java.nio/BufferPool/direct/Count JMX/java.nio/BufferPool/mapped/Count Copy If you are using the property root_metric_name, then the metric will be your root metric name prefixed with JMX and followed by the attribute's name. You can use object name values by specifying the object name key in the root_metric_name between brackets {}. For example: Part of a configuration file: - object_name: Catalina:type=Cache,host=localhost,path=/examples root_metric_name: Tomcat/{host} metrics: - attributes: accessCount, cacheSize, hitsCount type: simple - object_name: mbean:type=Sample,host=localhost,path=* root_metric_name: SampleMBean metrics: - attributes: attOne, attTwo type: simple Copy Metric names: JMX/Tomcat/localhost/accessCount JMX/Tomcat/localhost/cacheSize JMX/Tomcat/localhost/hitsCount JMX/SampleMBean/attOne JMX/SampleMBean/attTwo Copy If an attribute does not actually exist on the MBean, then the metric will never appear in New Relic. Finding object and attribute names The easiest way to find available MBeans and its associated attributes is to use the JConsole instructions for JDK 1.6. For more help Additional documentation resources include: Custom instrumentation with the Java agent (method tracers, examples) Custom JMX monitoring by YAML (YAML file structure, value and definition)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.73255,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Custom</em> JMX YAML examples",
        "sections": "<em>Custom</em> JMX YAML examples",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " associated attributes is to use the JConsole instructions for JDK 1.6. For more help Additional documentation resources include: <em>Custom</em> <em>instrumentation</em> with the <em>Java</em> <em>agent</em> (method tracers, examples) <em>Custom</em> JMX monitoring by YAML (YAML file structure, value and definition)"
      },
      "id": "603eb76a196a67cba6a83db6"
    },
    {
      "sections": [
        "Messaging framework instrumentation",
        "Typical messaging",
        "Report the producing/consuming as external",
        "Add message metrics/custom parameters to current transaction",
        "Pass a distributed trace payload",
        "Edge cases",
        "Create a distributed trace payload and then receive a message",
        "Batch reading messages",
        "Capturing the processing time of the message",
        "For more help"
      ],
      "title": "Messaging framework instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "9b656fcf1790e65d1db825e35ab31c94b6561e08",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/messaging-framework-instrumentation/",
      "published_at": "2021-05-05T06:54:38Z",
      "updated_at": "2021-03-16T09:03:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "There are some messaging frameworks that New Relic doesn’t support by default. If you are interested in instrumenting these frameworks with our API here are some guidelines to follow. Typical messaging In the typical case, there is a process that produces a message and a process that consumes the message. Some useful things you could do here are below. Note you must be within a transaction for these to report. Report the producing/consuming as external You can create MessageProduceParameters and MessageConsumeParameters with relevant data and then call reportAsExternal(Params) to report the calls as externals. For example, when producing a message this would look like: MessageProduceParameters params = MessageProduceParameters.library(\"libraryName\").destinationType(NAMED_TOPIC).destinationName(\"topicName\").inboundHeaders(null).build(); NewRelic.getAgent().getTransaction().getTracedMethod().reportAsExternal(params); Copy A similar solution would work on the consumer side. Add message metrics/custom parameters to current transaction If there is useful information you want to add to your current transaction about the message, you can do that easily by calling our addCustomParameter() API. This looks like this: NewRelic.addCustomParameter(\"topic-name\", topic); Copy Pass a distributed trace payload In order to track the work across processes/services, the messaging framework must have a way to pass along metadata with the message, whether it’s via headers or some other mechanism. You can create a distributed trace payload on the producer side that can be attached to the message and read on the consumer side. You must be in a transaction for this to work. To do this you would follow a pattern like this: @Trace(dispatcher = true) public void sendData(Producer producer){ final DistributedTracePayload payload = NewRelic.getAgent().getTransaction().createDistributedTracePayload(); headers.add(new RecordHeader(\"newrelic\", payload.text().getBytes(StandardCharsets.UTF_8))); data = new ProducerRecord<String, String>(\"topic\", \"key\", \"value\", headers); producer.send(data); } Copy And on the consumer side: @Trace(dispatcher = true) public void processData(ConsumerRecord record){ final Iterator<Header> nrHeaders = record.headers().headers(\"newrelic\").iterator(); if (nrHeaders.hasNext()) { final Header nrHeader = nrHeaders.next(); final String payload = new String(nrHeader.value(), StandardCharsets.UTF_8); NewRelic.getAgent().getTransaction().acceptDistributedTracePayload(payload); } } Copy This example uses Kafka, which you can instrument. Instrument Kafka message queues provides information for instrumenting. Edge cases There are some edge cases that require extra care. Below are suggestions on the best way to tackle them. Create a distributed trace payload and then receive a message The problem here is that you can’t create a distributed trace payload and then accept a distributed trace payload within the same transaction in that order. This means that there are two attempts of distributed tracing and you have to choose which one you want. If you would like to accept the second payload rather than create the first one, you need to prevent the first payload from getting created. You can remove the custom instrumentation (if that’s what’s creating the payload) or disable instrumentation via our config Batch reading messages For batch consumption of messages, there is a problem of which distributed tracing payload you accept. If you are ok with linking just one of the distributed trace payloads then you can accept any one of the payloads in the batch but that will result in the rest of the payloads getting lost. However, if you want to see all of the distributed traces then you’ll need to create a transaction per message. The second solution could incur some overhead so take that into consideration when making a decision. A solution like that would look like: public void processMessages(ConsumerRecords<String, String> records) { for(ConsumerRecord<String, String> record: records) { processRecord(record); } } @Trace(dispatcher = true) private void processRecord(ConsumerRecord<String, String> record) { final Iterator<Header> nrHeaders = record.headers().headers(\"newrelicDTPayload\").iterator(); if (nrHeaders.hasNext()) { final Header nrHeader = nrHeaders.next(); final String payload = new String(nrHeader.value(), StandardCharsets.UTF_8); NewRelic.getAgent().getTransaction().acceptDistributedTracePayload(payload); } } Copy This will only work if there isn’t a transaction already started on the thread at this time. If there is one then just accepting one payload from the batch is your only solution. Capturing the processing time of the message If you would like to capture the processing time of a message then you will need to move the processing work into a method and then trace that method. For example: public void getMessages(){ KafkaConsumer consumer = new KafkaConsumer(props); consumer.subscribe(Arrays.asList(\"topic\")); while (true) { ConsumerRecords<String, String> recs = consumer.poll(10000); if (recs.count() == 0) { } else { for (ConsumerRecord<String, String> rec : recs) { processRec(rec); } } } } @Trace(dispatcher = true) private void processRec(ConsumerRecord<String, String> rec) { // some processing } Copy For more help Use the Guide to using the Java agent API to learn more about our Java agent API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.66918,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Messaging framework <em>instrumentation</em>",
        "sections": "Messaging framework <em>instrumentation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "(nrHeader.value(), StandardCharsets.UTF_8); NewRelic.get<em>Agent</em>().getTransaction().acceptDistributedTracePayload(payload); } } Copy This example uses Kafka, which you can <em>instrument</em>. <em>Instrument</em> Kafka message queues provides information for instrumenting. Edge cases There are some edge cases that require extra"
      },
      "id": "603ebc24196a67a6d7a83dc8"
    },
    {
      "sections": [
        "Java instrumentation by XML",
        "Accessing your XML file",
        "XML file structure",
        "XML file validation",
        "Java versions below Java 10",
        "All Java versions",
        "Tip",
        "XML file location",
        "Verify the file was read",
        "Multiple XML files",
        "XML and YAML",
        "Example XML file"
      ],
      "title": "Java instrumentation by XML",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "bf64043c85e0d690961fbbaa6a6dd6b52636e3d5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/java-instrumentation-xml/",
      "published_at": "2021-05-05T03:13:01Z",
      "updated_at": "2021-03-16T08:59:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For your New Relic-monitored Java application, one custom instrumentation method is to use an XML file to specify your app methods that should be instrumented. The Java agent will read the XML file and instrument the relevant classes on startup; XML files added to the extensions directory after startup do not require a JVM restart to be detected. See Java agent custom instrumentation for a description of the custom instrumentation options and the reasons to use them. Accessing your XML file Go to one.newrelic.com > APM > (select an app) > Settings > Instrumentation. From here you can: Download a sample XML file. (You can do this from the pop-up that appears when you click Import an XML file.) Select an edit existing XML file. Search the instrumentation history. XML file structure Your New Relic agent download package (newrelic_agent.zip) contains two templates for using XML instrumentation: The extension.xsd template is the XML schema definition which all custom extensions must follow. The extension-example.xml template is an example. This file instruments some of the basic JDK methods. If you edit and rename this file, ensure you modify the name=\"extension-example\" attribute to match the new filename. For more information about the properties in the extension.xsd template, see the XML file format overview. XML file validation Before starting your application, validate your XML file using New Relic's command line tool. The command line tool can only be used when your classes are in a jar. There are two ways to validate your XML instrumentation: Java versions below Java 10 The easiest way to do this for Java versions lower than Java 10 is with this command: java -Djava.ext.dirs=/path/to/jarred/classes -jar newrelic.jar instrument -file /path/to/file.xml -debug true Copy All Java versions Tip For Java versions below Java 10, see the recommended procedure. That procedure is not possible with Java 10 or higher because those versions no longer allow java.ext.dirs to be set. For all Java versions, you can set the classpath manually: java -cp /path/to/your-app.jar:/path/to/newrelic.jar com.newrelic.bootstrap.BootstrapAgent instrument -file /path/to/file.xml -debug true Copy The application is run with the newrelic.jar. The call must contain the keyword instrument followed by the -file flag with the path to your XML file. The property -debug is optional and may be set to true to provide more information during the validation. The tool will: Validate the XML syntax. Check that each class to be instrumented is present on the class path. Check that each method is contained in the appropriate class. If the XML file is valid, you will see a pass statement printed to the terminal: PASS: The extension at file.txt was successfully validated. Copy If the XML fails validation, you will see a failure message printed to the terminal: FAIL: reason Copy XML file location The Java agent reads any XML files in the extensions directory on process start up. The extensions directory is also read every harvest cycle. XML files added to this directory during runtime will be read within a few minutes, so they do not require a JVM restart. There are two ways to specify the XML file location: XML file location options Procedure Create an extensions directory In the directory where the newrelic.jar and newrelic.yml is located, create a directory named extensions. Put the XML file in this directory with a .xml extension. In newrelic.yml, check that the property extensions.dir is not set. Specify an existing extensions directory In the newrelic.yml configuration file under the common section, use the property extensions.dir to specify the directory where the XML file is located. Make sure the file is in the specified directory and that the file has a .xml extension. Verify the file was read To verify the agent read the XML file, first set the Log management to finer: Edit the newrelic.yml configuration file and change the log_level property: log_level: finer Copy Start or restart the application. If the read was successful, logs/newrelic_agent.log will indicate this in a statement similar to: Reading custom extension file /path/to/file.xml Copy If no statement appears in logs/newrelic_agent.log, then the XML file was not found. Check the location of the XML file, and ensure the New Relic process has read access to the file. Multiple XML files While using a single XML file is preferred, you can use multiple custom XML files. These files will all be instrumented as long as the extension name in the files is unique. If two custom XML files contain the same extension name, then the one with the highest version will be implemented and the other will be ignored. If the two files have the same name and version, then the first file read by the agent will be implemented and the other will be ignored. XML and YAML Prior to 2.10.0, YAML files could be used for custom instrumentation. These legacy YAML files are still supported. However, new users should use XML files for custom instrumentation. Legacy users: If both a YAML and XML file exist with the same extension name, only the XML file will be instrumented. The YAML file will be ignored. If you want both the YAML and XML files to be instrumented, give each file a different extension name. Example XML file For an example of a custom instrumentation XML file, see Java XML examples.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.66824,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>instrumentation</em> by XML",
        "sections": "<em>Java</em> <em>instrumentation</em> by XML",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "For your New Relic-monitored <em>Java</em> application, one <em>custom</em> <em>instrumentation</em> method is to use an XML file to specify your app methods that should be instrumented. The <em>Java</em> <em>agent</em> will read the XML file and <em>instrument</em> the relevant classes on startup; XML files added to the extensions directory after"
      },
      "id": "603eb684196a67fe45a83dad"
    }
  ],
  "/docs/agents/java-agent/custom-instrumentation/java-instrumentation-xml": [
    {
      "sections": [
        "Custom JMX YAML examples",
        "Contents",
        "YAML example",
        "Example explanation",
        "Properties",
        "MBeans",
        "Attributes",
        "Type",
        "Metric names",
        "Tip",
        "Finding object and attribute names",
        "For more help"
      ],
      "title": "Custom JMX YAML examples",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "38e6f21e2a3344f554072dff9919df049db60224",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/custom-jmx-yaml-examples/",
      "published_at": "2021-05-05T06:53:28Z",
      "updated_at": "2021-03-16T13:47:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This is an example of a custom JMX YAML file for New Relic's Java agent, including value and definition, MBean, attributes, type, and names for metrics, objects, and attributes. For more information, including a video, see Custom JMX monitoring by YAML. Contents YAML example Here is an example of a custom JMX YAML file. YAML files are space senstive. name: TomcatCustom version: 1.0 enabled: true jmx: - object_name: Catalina:type=Cache,host=localhost,path=/examples metrics: - attributes: accessCount, cacheSize, hitsCount type: simple - object_name: Catalina:type=Connector,port=8009 metrics: - attributes: bufferSize, maxHeaderCount - object_name: java.nio:type=BufferPool,name=* metrics: - attributes: Count type: monotonically_increasing Copy Example explanation Properties Value Definition name A descriptive name identifying your YAML custom instrumentation file, using one space before the property name. In the above example, the name is TomcatCustom. version The version of the extension file. Use a double. If two extensions have the same name, only the extension with the highest version will be used. Use one space before the property version. In the above example, the version is 1.0. enabled If true, the Java agent will read the extension. If false, the Java agent will ignore the extension. Use one space before the property enabled. The above example is enabled. MBeans Each line in the YAML starting with - object_name represents an MBean. For example, the following lines describe the information to be pulled from the first MBean: - object_name: Catalina:type=Cache,host=localhost,path=/examples metrics: - attributes: accessCount, cacheSize, hitsCount type: simple Copy The object_name property itself can match one or more MBeans. For example, the line below only matches one MBean: - object_name: Catalina:type=Cache,host=localhost,path=/examples Copy The following line could match multiple MBeans: - object_name: java.nio:type=BufferPool,name=* Copy The asterisk ( * ) wildcard can only be used with JDK 1.6 and higher. The three MBeans listed in the above example have the following object names: Catalina:type=Cache,host=localhost,path=/examples Catalina:type=Connector,port=8009 java.nio:type=BufferPool,name=* Copy Attributes The JMX example retrieves six different attributes from the three MBeans. New Relic's Java agent pulls these attributes from the first MBean: accessCount cacheSize hitsCount The agent pulls these attributes from the second MBean: bufferSize maxHeaderCount The agent pulls one attribute (Count) from third MBean. Type For type, use simple or monotonically_increasing. When type is not specified in the JMX YAML file, it defaults to monotonically_increasing. Value Definition simple The exact value of the attribute will be reported to New Relic each minute. monotonically_increasing The positive difference will be reported to New Relic each minute. In the example above, the attributes accessCount, cacheSize, and hitsCount will be reported as simple. The attributes bufferSize, maxHeaderCount, and Count will be reported as monotonically_increasing. If the hitsCount attribute value is always 5, then New Relic will report a 5 each minute. If the Count attribute value is always 5, then New Relic will report a 0 for the value each minute. If the Count attribute value changes from 5 to 7, then New Relic will report a 2 for that minute. Metric names When selecting custom dashboard metrics and not using the property root_metric_name, use the following format for all custom JMX metrics: JMX/beginning_of_object_name/type/any_properties_in_object_name/attribute_name Copy Tip Some object names do not include a type. In that case, a null will be present in the metric name. The configuration file does not use root_metric_name, so the following metrics will be created: JMX/Catalina/Cache/localhost/examples/accessCount JMX/Catalina/Cache/localhost/examples/cacheSize JMX/Catalina/Cache/localhost/examples/hitsCount JMX/Catalina/Connector/8009/bufferSize JMX/Catalina/Connector/8009/maxHeaderCount JMX/java.nio/BufferPool/direct/Count JMX/java.nio/BufferPool/mapped/Count Copy If you are using the property root_metric_name, then the metric will be your root metric name prefixed with JMX and followed by the attribute's name. You can use object name values by specifying the object name key in the root_metric_name between brackets {}. For example: Part of a configuration file: - object_name: Catalina:type=Cache,host=localhost,path=/examples root_metric_name: Tomcat/{host} metrics: - attributes: accessCount, cacheSize, hitsCount type: simple - object_name: mbean:type=Sample,host=localhost,path=* root_metric_name: SampleMBean metrics: - attributes: attOne, attTwo type: simple Copy Metric names: JMX/Tomcat/localhost/accessCount JMX/Tomcat/localhost/cacheSize JMX/Tomcat/localhost/hitsCount JMX/SampleMBean/attOne JMX/SampleMBean/attTwo Copy If an attribute does not actually exist on the MBean, then the metric will never appear in New Relic. Finding object and attribute names The easiest way to find available MBeans and its associated attributes is to use the JConsole instructions for JDK 1.6. For more help Additional documentation resources include: Custom instrumentation with the Java agent (method tracers, examples) Custom JMX monitoring by YAML (YAML file structure, value and definition)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.73255,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Custom</em> JMX YAML examples",
        "sections": "<em>Custom</em> JMX YAML examples",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " associated attributes is to use the JConsole instructions for JDK 1.6. For more help Additional documentation resources include: <em>Custom</em> <em>instrumentation</em> with the <em>Java</em> <em>agent</em> (method tracers, examples) <em>Custom</em> JMX monitoring by YAML (YAML file structure, value and definition)"
      },
      "id": "603eb76a196a67cba6a83db6"
    },
    {
      "sections": [
        "Messaging framework instrumentation",
        "Typical messaging",
        "Report the producing/consuming as external",
        "Add message metrics/custom parameters to current transaction",
        "Pass a distributed trace payload",
        "Edge cases",
        "Create a distributed trace payload and then receive a message",
        "Batch reading messages",
        "Capturing the processing time of the message",
        "For more help"
      ],
      "title": "Messaging framework instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "9b656fcf1790e65d1db825e35ab31c94b6561e08",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/messaging-framework-instrumentation/",
      "published_at": "2021-05-05T06:54:38Z",
      "updated_at": "2021-03-16T09:03:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "There are some messaging frameworks that New Relic doesn’t support by default. If you are interested in instrumenting these frameworks with our API here are some guidelines to follow. Typical messaging In the typical case, there is a process that produces a message and a process that consumes the message. Some useful things you could do here are below. Note you must be within a transaction for these to report. Report the producing/consuming as external You can create MessageProduceParameters and MessageConsumeParameters with relevant data and then call reportAsExternal(Params) to report the calls as externals. For example, when producing a message this would look like: MessageProduceParameters params = MessageProduceParameters.library(\"libraryName\").destinationType(NAMED_TOPIC).destinationName(\"topicName\").inboundHeaders(null).build(); NewRelic.getAgent().getTransaction().getTracedMethod().reportAsExternal(params); Copy A similar solution would work on the consumer side. Add message metrics/custom parameters to current transaction If there is useful information you want to add to your current transaction about the message, you can do that easily by calling our addCustomParameter() API. This looks like this: NewRelic.addCustomParameter(\"topic-name\", topic); Copy Pass a distributed trace payload In order to track the work across processes/services, the messaging framework must have a way to pass along metadata with the message, whether it’s via headers or some other mechanism. You can create a distributed trace payload on the producer side that can be attached to the message and read on the consumer side. You must be in a transaction for this to work. To do this you would follow a pattern like this: @Trace(dispatcher = true) public void sendData(Producer producer){ final DistributedTracePayload payload = NewRelic.getAgent().getTransaction().createDistributedTracePayload(); headers.add(new RecordHeader(\"newrelic\", payload.text().getBytes(StandardCharsets.UTF_8))); data = new ProducerRecord<String, String>(\"topic\", \"key\", \"value\", headers); producer.send(data); } Copy And on the consumer side: @Trace(dispatcher = true) public void processData(ConsumerRecord record){ final Iterator<Header> nrHeaders = record.headers().headers(\"newrelic\").iterator(); if (nrHeaders.hasNext()) { final Header nrHeader = nrHeaders.next(); final String payload = new String(nrHeader.value(), StandardCharsets.UTF_8); NewRelic.getAgent().getTransaction().acceptDistributedTracePayload(payload); } } Copy This example uses Kafka, which you can instrument. Instrument Kafka message queues provides information for instrumenting. Edge cases There are some edge cases that require extra care. Below are suggestions on the best way to tackle them. Create a distributed trace payload and then receive a message The problem here is that you can’t create a distributed trace payload and then accept a distributed trace payload within the same transaction in that order. This means that there are two attempts of distributed tracing and you have to choose which one you want. If you would like to accept the second payload rather than create the first one, you need to prevent the first payload from getting created. You can remove the custom instrumentation (if that’s what’s creating the payload) or disable instrumentation via our config Batch reading messages For batch consumption of messages, there is a problem of which distributed tracing payload you accept. If you are ok with linking just one of the distributed trace payloads then you can accept any one of the payloads in the batch but that will result in the rest of the payloads getting lost. However, if you want to see all of the distributed traces then you’ll need to create a transaction per message. The second solution could incur some overhead so take that into consideration when making a decision. A solution like that would look like: public void processMessages(ConsumerRecords<String, String> records) { for(ConsumerRecord<String, String> record: records) { processRecord(record); } } @Trace(dispatcher = true) private void processRecord(ConsumerRecord<String, String> record) { final Iterator<Header> nrHeaders = record.headers().headers(\"newrelicDTPayload\").iterator(); if (nrHeaders.hasNext()) { final Header nrHeader = nrHeaders.next(); final String payload = new String(nrHeader.value(), StandardCharsets.UTF_8); NewRelic.getAgent().getTransaction().acceptDistributedTracePayload(payload); } } Copy This will only work if there isn’t a transaction already started on the thread at this time. If there is one then just accepting one payload from the batch is your only solution. Capturing the processing time of the message If you would like to capture the processing time of a message then you will need to move the processing work into a method and then trace that method. For example: public void getMessages(){ KafkaConsumer consumer = new KafkaConsumer(props); consumer.subscribe(Arrays.asList(\"topic\")); while (true) { ConsumerRecords<String, String> recs = consumer.poll(10000); if (recs.count() == 0) { } else { for (ConsumerRecord<String, String> rec : recs) { processRec(rec); } } } } @Trace(dispatcher = true) private void processRec(ConsumerRecord<String, String> rec) { // some processing } Copy For more help Use the Guide to using the Java agent API to learn more about our Java agent API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.66918,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Messaging framework <em>instrumentation</em>",
        "sections": "Messaging framework <em>instrumentation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "(nrHeader.value(), StandardCharsets.UTF_8); NewRelic.get<em>Agent</em>().getTransaction().acceptDistributedTracePayload(payload); } } Copy This example uses Kafka, which you can <em>instrument</em>. <em>Instrument</em> Kafka message queues provides information for instrumenting. Edge cases There are some edge cases that require extra"
      },
      "id": "603ebc24196a67a6d7a83dc8"
    },
    {
      "sections": [
        "Java custom instrumentation",
        "Important",
        "When to choose custom instrumentation",
        "Implement custom instrumentation"
      ],
      "title": "Java custom instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "76fd78e33105744dc4c6342d8059b2b966f90196",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/java-custom-instrumentation/",
      "published_at": "2021-05-04T17:02:34Z",
      "updated_at": "2021-03-16T09:00:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM for Java will typically produce useful performance data automatically. However, if New Relic does not support your framework, or if you want to set up additional monitoring, you will want to implement custom instrumentation. Custom instrumentation allows you to track interactions that aren't captured by New Relic's automatic instrumentation, and lets you add detail to your transaction traces, to help you identify key issues. New Relic collects metrics and events from many frameworks automatically. If you are using a supported framework or component, you may see some transaction information out of the box, and custom instrumentation can be used to supplement the information the Agent reports by default. Important If you are using a supported framework, but are not seeing transactions, get support at support.newrelic.com to ensure the framework instrumentation is working. When to choose custom instrumentation Choose custom instrumentation in these situations: New Relic does not support your framework and transactions do not appear in the UI You would like to add detail to your transaction traces Transaction traces include large blocks of application code time without sufficient detail Implement custom instrumentation You can implement custom instrumentation with one of these methods: Method Description The New Relic UI New Relic for Java includes an option in the UI for custom instrumentation called the Custom Instrumentation Editor. This option doesn't require any direct modification of your application code, so is a good choice if you don't want to or can't modify your code. The editor is, however, fairly limited in functionality compared to the Java agent API. API annotation Using the New Relic Java agent API, you can annotate the methods in your application code that you want to monitor. The annotation method is robust and easy to troubleshoot. If you are willing to modify your source code, annotation is the recommended method. If you have many methods you want to instrument, you might prefer XML instrumentation. For more about the API and its other functions, see Intro to the Java agent API. XML If you can't modify your code, or if you need to instrument many methods, XML instrumentation is the best custom instrumentation method. With this method, you specify the classes you want to instrument in an external XML file. While XML instrumentation is powerful, it is also more difficult to use than the other instrumentation methods. For simpler instrumentation needs, New Relic recommends annotation or instrumentation via the UI. For more information, see Java instrumentation by XML. You can also monitor Java Management Extensions (JMX) via custom instrumentation. JMX is a way to monitor and manage applications, devices, and services. You can implement JMX monitoring via an external YAML file.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.66855,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>custom</em> <em>instrumentation</em>",
        "sections": "<em>Java</em> <em>custom</em> <em>instrumentation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " functions, see Intro to the <em>Java</em> <em>agent</em> API. XML If you can&#x27;t modify your code, or if you need to <em>instrument</em> many methods, XML <em>instrumentation</em> is the best <em>custom</em> <em>instrumentation</em> method. With this method, you specify the classes you want to <em>instrument</em> in an external XML file. While XML <em>instrumentation</em>"
      },
      "id": "603eb6b6196a67b753a83db7"
    }
  ],
  "/docs/agents/java-agent/custom-instrumentation/java-xml-instrumentation-examples": [
    {
      "sections": [
        "Custom JMX YAML examples",
        "Contents",
        "YAML example",
        "Example explanation",
        "Properties",
        "MBeans",
        "Attributes",
        "Type",
        "Metric names",
        "Tip",
        "Finding object and attribute names",
        "For more help"
      ],
      "title": "Custom JMX YAML examples",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "38e6f21e2a3344f554072dff9919df049db60224",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/custom-jmx-yaml-examples/",
      "published_at": "2021-05-05T06:53:28Z",
      "updated_at": "2021-03-16T13:47:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This is an example of a custom JMX YAML file for New Relic's Java agent, including value and definition, MBean, attributes, type, and names for metrics, objects, and attributes. For more information, including a video, see Custom JMX monitoring by YAML. Contents YAML example Here is an example of a custom JMX YAML file. YAML files are space senstive. name: TomcatCustom version: 1.0 enabled: true jmx: - object_name: Catalina:type=Cache,host=localhost,path=/examples metrics: - attributes: accessCount, cacheSize, hitsCount type: simple - object_name: Catalina:type=Connector,port=8009 metrics: - attributes: bufferSize, maxHeaderCount - object_name: java.nio:type=BufferPool,name=* metrics: - attributes: Count type: monotonically_increasing Copy Example explanation Properties Value Definition name A descriptive name identifying your YAML custom instrumentation file, using one space before the property name. In the above example, the name is TomcatCustom. version The version of the extension file. Use a double. If two extensions have the same name, only the extension with the highest version will be used. Use one space before the property version. In the above example, the version is 1.0. enabled If true, the Java agent will read the extension. If false, the Java agent will ignore the extension. Use one space before the property enabled. The above example is enabled. MBeans Each line in the YAML starting with - object_name represents an MBean. For example, the following lines describe the information to be pulled from the first MBean: - object_name: Catalina:type=Cache,host=localhost,path=/examples metrics: - attributes: accessCount, cacheSize, hitsCount type: simple Copy The object_name property itself can match one or more MBeans. For example, the line below only matches one MBean: - object_name: Catalina:type=Cache,host=localhost,path=/examples Copy The following line could match multiple MBeans: - object_name: java.nio:type=BufferPool,name=* Copy The asterisk ( * ) wildcard can only be used with JDK 1.6 and higher. The three MBeans listed in the above example have the following object names: Catalina:type=Cache,host=localhost,path=/examples Catalina:type=Connector,port=8009 java.nio:type=BufferPool,name=* Copy Attributes The JMX example retrieves six different attributes from the three MBeans. New Relic's Java agent pulls these attributes from the first MBean: accessCount cacheSize hitsCount The agent pulls these attributes from the second MBean: bufferSize maxHeaderCount The agent pulls one attribute (Count) from third MBean. Type For type, use simple or monotonically_increasing. When type is not specified in the JMX YAML file, it defaults to monotonically_increasing. Value Definition simple The exact value of the attribute will be reported to New Relic each minute. monotonically_increasing The positive difference will be reported to New Relic each minute. In the example above, the attributes accessCount, cacheSize, and hitsCount will be reported as simple. The attributes bufferSize, maxHeaderCount, and Count will be reported as monotonically_increasing. If the hitsCount attribute value is always 5, then New Relic will report a 5 each minute. If the Count attribute value is always 5, then New Relic will report a 0 for the value each minute. If the Count attribute value changes from 5 to 7, then New Relic will report a 2 for that minute. Metric names When selecting custom dashboard metrics and not using the property root_metric_name, use the following format for all custom JMX metrics: JMX/beginning_of_object_name/type/any_properties_in_object_name/attribute_name Copy Tip Some object names do not include a type. In that case, a null will be present in the metric name. The configuration file does not use root_metric_name, so the following metrics will be created: JMX/Catalina/Cache/localhost/examples/accessCount JMX/Catalina/Cache/localhost/examples/cacheSize JMX/Catalina/Cache/localhost/examples/hitsCount JMX/Catalina/Connector/8009/bufferSize JMX/Catalina/Connector/8009/maxHeaderCount JMX/java.nio/BufferPool/direct/Count JMX/java.nio/BufferPool/mapped/Count Copy If you are using the property root_metric_name, then the metric will be your root metric name prefixed with JMX and followed by the attribute's name. You can use object name values by specifying the object name key in the root_metric_name between brackets {}. For example: Part of a configuration file: - object_name: Catalina:type=Cache,host=localhost,path=/examples root_metric_name: Tomcat/{host} metrics: - attributes: accessCount, cacheSize, hitsCount type: simple - object_name: mbean:type=Sample,host=localhost,path=* root_metric_name: SampleMBean metrics: - attributes: attOne, attTwo type: simple Copy Metric names: JMX/Tomcat/localhost/accessCount JMX/Tomcat/localhost/cacheSize JMX/Tomcat/localhost/hitsCount JMX/SampleMBean/attOne JMX/SampleMBean/attTwo Copy If an attribute does not actually exist on the MBean, then the metric will never appear in New Relic. Finding object and attribute names The easiest way to find available MBeans and its associated attributes is to use the JConsole instructions for JDK 1.6. For more help Additional documentation resources include: Custom instrumentation with the Java agent (method tracers, examples) Custom JMX monitoring by YAML (YAML file structure, value and definition)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.73255,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Custom</em> JMX YAML examples",
        "sections": "<em>Custom</em> JMX YAML examples",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " associated attributes is to use the JConsole instructions for JDK 1.6. For more help Additional documentation resources include: <em>Custom</em> <em>instrumentation</em> with the <em>Java</em> <em>agent</em> (method tracers, examples) <em>Custom</em> JMX monitoring by YAML (YAML file structure, value and definition)"
      },
      "id": "603eb76a196a67cba6a83db6"
    },
    {
      "sections": [
        "Messaging framework instrumentation",
        "Typical messaging",
        "Report the producing/consuming as external",
        "Add message metrics/custom parameters to current transaction",
        "Pass a distributed trace payload",
        "Edge cases",
        "Create a distributed trace payload and then receive a message",
        "Batch reading messages",
        "Capturing the processing time of the message",
        "For more help"
      ],
      "title": "Messaging framework instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "9b656fcf1790e65d1db825e35ab31c94b6561e08",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/messaging-framework-instrumentation/",
      "published_at": "2021-05-05T06:54:38Z",
      "updated_at": "2021-03-16T09:03:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "There are some messaging frameworks that New Relic doesn’t support by default. If you are interested in instrumenting these frameworks with our API here are some guidelines to follow. Typical messaging In the typical case, there is a process that produces a message and a process that consumes the message. Some useful things you could do here are below. Note you must be within a transaction for these to report. Report the producing/consuming as external You can create MessageProduceParameters and MessageConsumeParameters with relevant data and then call reportAsExternal(Params) to report the calls as externals. For example, when producing a message this would look like: MessageProduceParameters params = MessageProduceParameters.library(\"libraryName\").destinationType(NAMED_TOPIC).destinationName(\"topicName\").inboundHeaders(null).build(); NewRelic.getAgent().getTransaction().getTracedMethod().reportAsExternal(params); Copy A similar solution would work on the consumer side. Add message metrics/custom parameters to current transaction If there is useful information you want to add to your current transaction about the message, you can do that easily by calling our addCustomParameter() API. This looks like this: NewRelic.addCustomParameter(\"topic-name\", topic); Copy Pass a distributed trace payload In order to track the work across processes/services, the messaging framework must have a way to pass along metadata with the message, whether it’s via headers or some other mechanism. You can create a distributed trace payload on the producer side that can be attached to the message and read on the consumer side. You must be in a transaction for this to work. To do this you would follow a pattern like this: @Trace(dispatcher = true) public void sendData(Producer producer){ final DistributedTracePayload payload = NewRelic.getAgent().getTransaction().createDistributedTracePayload(); headers.add(new RecordHeader(\"newrelic\", payload.text().getBytes(StandardCharsets.UTF_8))); data = new ProducerRecord<String, String>(\"topic\", \"key\", \"value\", headers); producer.send(data); } Copy And on the consumer side: @Trace(dispatcher = true) public void processData(ConsumerRecord record){ final Iterator<Header> nrHeaders = record.headers().headers(\"newrelic\").iterator(); if (nrHeaders.hasNext()) { final Header nrHeader = nrHeaders.next(); final String payload = new String(nrHeader.value(), StandardCharsets.UTF_8); NewRelic.getAgent().getTransaction().acceptDistributedTracePayload(payload); } } Copy This example uses Kafka, which you can instrument. Instrument Kafka message queues provides information for instrumenting. Edge cases There are some edge cases that require extra care. Below are suggestions on the best way to tackle them. Create a distributed trace payload and then receive a message The problem here is that you can’t create a distributed trace payload and then accept a distributed trace payload within the same transaction in that order. This means that there are two attempts of distributed tracing and you have to choose which one you want. If you would like to accept the second payload rather than create the first one, you need to prevent the first payload from getting created. You can remove the custom instrumentation (if that’s what’s creating the payload) or disable instrumentation via our config Batch reading messages For batch consumption of messages, there is a problem of which distributed tracing payload you accept. If you are ok with linking just one of the distributed trace payloads then you can accept any one of the payloads in the batch but that will result in the rest of the payloads getting lost. However, if you want to see all of the distributed traces then you’ll need to create a transaction per message. The second solution could incur some overhead so take that into consideration when making a decision. A solution like that would look like: public void processMessages(ConsumerRecords<String, String> records) { for(ConsumerRecord<String, String> record: records) { processRecord(record); } } @Trace(dispatcher = true) private void processRecord(ConsumerRecord<String, String> record) { final Iterator<Header> nrHeaders = record.headers().headers(\"newrelicDTPayload\").iterator(); if (nrHeaders.hasNext()) { final Header nrHeader = nrHeaders.next(); final String payload = new String(nrHeader.value(), StandardCharsets.UTF_8); NewRelic.getAgent().getTransaction().acceptDistributedTracePayload(payload); } } Copy This will only work if there isn’t a transaction already started on the thread at this time. If there is one then just accepting one payload from the batch is your only solution. Capturing the processing time of the message If you would like to capture the processing time of a message then you will need to move the processing work into a method and then trace that method. For example: public void getMessages(){ KafkaConsumer consumer = new KafkaConsumer(props); consumer.subscribe(Arrays.asList(\"topic\")); while (true) { ConsumerRecords<String, String> recs = consumer.poll(10000); if (recs.count() == 0) { } else { for (ConsumerRecord<String, String> rec : recs) { processRec(rec); } } } } @Trace(dispatcher = true) private void processRec(ConsumerRecord<String, String> rec) { // some processing } Copy For more help Use the Guide to using the Java agent API to learn more about our Java agent API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.669174,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Messaging framework <em>instrumentation</em>",
        "sections": "Messaging framework <em>instrumentation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "(nrHeader.value(), StandardCharsets.UTF_8); NewRelic.get<em>Agent</em>().getTransaction().acceptDistributedTracePayload(payload); } } Copy This example uses Kafka, which you can <em>instrument</em>. <em>Instrument</em> Kafka message queues provides information for instrumenting. Edge cases There are some edge cases that require extra"
      },
      "id": "603ebc24196a67a6d7a83dc8"
    },
    {
      "sections": [
        "Java custom instrumentation",
        "Important",
        "When to choose custom instrumentation",
        "Implement custom instrumentation"
      ],
      "title": "Java custom instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "76fd78e33105744dc4c6342d8059b2b966f90196",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/java-custom-instrumentation/",
      "published_at": "2021-05-04T17:02:34Z",
      "updated_at": "2021-03-16T09:00:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM for Java will typically produce useful performance data automatically. However, if New Relic does not support your framework, or if you want to set up additional monitoring, you will want to implement custom instrumentation. Custom instrumentation allows you to track interactions that aren't captured by New Relic's automatic instrumentation, and lets you add detail to your transaction traces, to help you identify key issues. New Relic collects metrics and events from many frameworks automatically. If you are using a supported framework or component, you may see some transaction information out of the box, and custom instrumentation can be used to supplement the information the Agent reports by default. Important If you are using a supported framework, but are not seeing transactions, get support at support.newrelic.com to ensure the framework instrumentation is working. When to choose custom instrumentation Choose custom instrumentation in these situations: New Relic does not support your framework and transactions do not appear in the UI You would like to add detail to your transaction traces Transaction traces include large blocks of application code time without sufficient detail Implement custom instrumentation You can implement custom instrumentation with one of these methods: Method Description The New Relic UI New Relic for Java includes an option in the UI for custom instrumentation called the Custom Instrumentation Editor. This option doesn't require any direct modification of your application code, so is a good choice if you don't want to or can't modify your code. The editor is, however, fairly limited in functionality compared to the Java agent API. API annotation Using the New Relic Java agent API, you can annotate the methods in your application code that you want to monitor. The annotation method is robust and easy to troubleshoot. If you are willing to modify your source code, annotation is the recommended method. If you have many methods you want to instrument, you might prefer XML instrumentation. For more about the API and its other functions, see Intro to the Java agent API. XML If you can't modify your code, or if you need to instrument many methods, XML instrumentation is the best custom instrumentation method. With this method, you specify the classes you want to instrument in an external XML file. While XML instrumentation is powerful, it is also more difficult to use than the other instrumentation methods. For simpler instrumentation needs, New Relic recommends annotation or instrumentation via the UI. For more information, see Java instrumentation by XML. You can also monitor Java Management Extensions (JMX) via custom instrumentation. JMX is a way to monitor and manage applications, devices, and services. You can implement JMX monitoring via an external YAML file.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.66855,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>custom</em> <em>instrumentation</em>",
        "sections": "<em>Java</em> <em>custom</em> <em>instrumentation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " functions, see Intro to the <em>Java</em> <em>agent</em> API. XML If you can&#x27;t modify your code, or if you need to <em>instrument</em> many methods, XML <em>instrumentation</em> is the best <em>custom</em> <em>instrumentation</em> method. With this method, you specify the classes you want to <em>instrument</em> in an external XML file. While XML <em>instrumentation</em>"
      },
      "id": "603eb6b6196a67b753a83db7"
    }
  ],
  "/docs/agents/java-agent/custom-instrumentation/messaging-framework-instrumentation": [
    {
      "sections": [
        "Custom JMX YAML examples",
        "Contents",
        "YAML example",
        "Example explanation",
        "Properties",
        "MBeans",
        "Attributes",
        "Type",
        "Metric names",
        "Tip",
        "Finding object and attribute names",
        "For more help"
      ],
      "title": "Custom JMX YAML examples",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "38e6f21e2a3344f554072dff9919df049db60224",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/custom-jmx-yaml-examples/",
      "published_at": "2021-05-05T06:53:28Z",
      "updated_at": "2021-03-16T13:47:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This is an example of a custom JMX YAML file for New Relic's Java agent, including value and definition, MBean, attributes, type, and names for metrics, objects, and attributes. For more information, including a video, see Custom JMX monitoring by YAML. Contents YAML example Here is an example of a custom JMX YAML file. YAML files are space senstive. name: TomcatCustom version: 1.0 enabled: true jmx: - object_name: Catalina:type=Cache,host=localhost,path=/examples metrics: - attributes: accessCount, cacheSize, hitsCount type: simple - object_name: Catalina:type=Connector,port=8009 metrics: - attributes: bufferSize, maxHeaderCount - object_name: java.nio:type=BufferPool,name=* metrics: - attributes: Count type: monotonically_increasing Copy Example explanation Properties Value Definition name A descriptive name identifying your YAML custom instrumentation file, using one space before the property name. In the above example, the name is TomcatCustom. version The version of the extension file. Use a double. If two extensions have the same name, only the extension with the highest version will be used. Use one space before the property version. In the above example, the version is 1.0. enabled If true, the Java agent will read the extension. If false, the Java agent will ignore the extension. Use one space before the property enabled. The above example is enabled. MBeans Each line in the YAML starting with - object_name represents an MBean. For example, the following lines describe the information to be pulled from the first MBean: - object_name: Catalina:type=Cache,host=localhost,path=/examples metrics: - attributes: accessCount, cacheSize, hitsCount type: simple Copy The object_name property itself can match one or more MBeans. For example, the line below only matches one MBean: - object_name: Catalina:type=Cache,host=localhost,path=/examples Copy The following line could match multiple MBeans: - object_name: java.nio:type=BufferPool,name=* Copy The asterisk ( * ) wildcard can only be used with JDK 1.6 and higher. The three MBeans listed in the above example have the following object names: Catalina:type=Cache,host=localhost,path=/examples Catalina:type=Connector,port=8009 java.nio:type=BufferPool,name=* Copy Attributes The JMX example retrieves six different attributes from the three MBeans. New Relic's Java agent pulls these attributes from the first MBean: accessCount cacheSize hitsCount The agent pulls these attributes from the second MBean: bufferSize maxHeaderCount The agent pulls one attribute (Count) from third MBean. Type For type, use simple or monotonically_increasing. When type is not specified in the JMX YAML file, it defaults to monotonically_increasing. Value Definition simple The exact value of the attribute will be reported to New Relic each minute. monotonically_increasing The positive difference will be reported to New Relic each minute. In the example above, the attributes accessCount, cacheSize, and hitsCount will be reported as simple. The attributes bufferSize, maxHeaderCount, and Count will be reported as monotonically_increasing. If the hitsCount attribute value is always 5, then New Relic will report a 5 each minute. If the Count attribute value is always 5, then New Relic will report a 0 for the value each minute. If the Count attribute value changes from 5 to 7, then New Relic will report a 2 for that minute. Metric names When selecting custom dashboard metrics and not using the property root_metric_name, use the following format for all custom JMX metrics: JMX/beginning_of_object_name/type/any_properties_in_object_name/attribute_name Copy Tip Some object names do not include a type. In that case, a null will be present in the metric name. The configuration file does not use root_metric_name, so the following metrics will be created: JMX/Catalina/Cache/localhost/examples/accessCount JMX/Catalina/Cache/localhost/examples/cacheSize JMX/Catalina/Cache/localhost/examples/hitsCount JMX/Catalina/Connector/8009/bufferSize JMX/Catalina/Connector/8009/maxHeaderCount JMX/java.nio/BufferPool/direct/Count JMX/java.nio/BufferPool/mapped/Count Copy If you are using the property root_metric_name, then the metric will be your root metric name prefixed with JMX and followed by the attribute's name. You can use object name values by specifying the object name key in the root_metric_name between brackets {}. For example: Part of a configuration file: - object_name: Catalina:type=Cache,host=localhost,path=/examples root_metric_name: Tomcat/{host} metrics: - attributes: accessCount, cacheSize, hitsCount type: simple - object_name: mbean:type=Sample,host=localhost,path=* root_metric_name: SampleMBean metrics: - attributes: attOne, attTwo type: simple Copy Metric names: JMX/Tomcat/localhost/accessCount JMX/Tomcat/localhost/cacheSize JMX/Tomcat/localhost/hitsCount JMX/SampleMBean/attOne JMX/SampleMBean/attTwo Copy If an attribute does not actually exist on the MBean, then the metric will never appear in New Relic. Finding object and attribute names The easiest way to find available MBeans and its associated attributes is to use the JConsole instructions for JDK 1.6. For more help Additional documentation resources include: Custom instrumentation with the Java agent (method tracers, examples) Custom JMX monitoring by YAML (YAML file structure, value and definition)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.73255,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Custom</em> JMX YAML examples",
        "sections": "<em>Custom</em> JMX YAML examples",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " associated attributes is to use the JConsole instructions for JDK 1.6. For more help Additional documentation resources include: <em>Custom</em> <em>instrumentation</em> with the <em>Java</em> <em>agent</em> (method tracers, examples) <em>Custom</em> JMX monitoring by YAML (YAML file structure, value and definition)"
      },
      "id": "603eb76a196a67cba6a83db6"
    },
    {
      "sections": [
        "Java custom instrumentation",
        "Important",
        "When to choose custom instrumentation",
        "Implement custom instrumentation"
      ],
      "title": "Java custom instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "76fd78e33105744dc4c6342d8059b2b966f90196",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/java-custom-instrumentation/",
      "published_at": "2021-05-04T17:02:34Z",
      "updated_at": "2021-03-16T09:00:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM for Java will typically produce useful performance data automatically. However, if New Relic does not support your framework, or if you want to set up additional monitoring, you will want to implement custom instrumentation. Custom instrumentation allows you to track interactions that aren't captured by New Relic's automatic instrumentation, and lets you add detail to your transaction traces, to help you identify key issues. New Relic collects metrics and events from many frameworks automatically. If you are using a supported framework or component, you may see some transaction information out of the box, and custom instrumentation can be used to supplement the information the Agent reports by default. Important If you are using a supported framework, but are not seeing transactions, get support at support.newrelic.com to ensure the framework instrumentation is working. When to choose custom instrumentation Choose custom instrumentation in these situations: New Relic does not support your framework and transactions do not appear in the UI You would like to add detail to your transaction traces Transaction traces include large blocks of application code time without sufficient detail Implement custom instrumentation You can implement custom instrumentation with one of these methods: Method Description The New Relic UI New Relic for Java includes an option in the UI for custom instrumentation called the Custom Instrumentation Editor. This option doesn't require any direct modification of your application code, so is a good choice if you don't want to or can't modify your code. The editor is, however, fairly limited in functionality compared to the Java agent API. API annotation Using the New Relic Java agent API, you can annotate the methods in your application code that you want to monitor. The annotation method is robust and easy to troubleshoot. If you are willing to modify your source code, annotation is the recommended method. If you have many methods you want to instrument, you might prefer XML instrumentation. For more about the API and its other functions, see Intro to the Java agent API. XML If you can't modify your code, or if you need to instrument many methods, XML instrumentation is the best custom instrumentation method. With this method, you specify the classes you want to instrument in an external XML file. While XML instrumentation is powerful, it is also more difficult to use than the other instrumentation methods. For simpler instrumentation needs, New Relic recommends annotation or instrumentation via the UI. For more information, see Java instrumentation by XML. You can also monitor Java Management Extensions (JMX) via custom instrumentation. JMX is a way to monitor and manage applications, devices, and services. You can implement JMX monitoring via an external YAML file.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.66855,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>custom</em> <em>instrumentation</em>",
        "sections": "<em>Java</em> <em>custom</em> <em>instrumentation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " functions, see Intro to the <em>Java</em> <em>agent</em> API. XML If you can&#x27;t modify your code, or if you need to <em>instrument</em> many methods, XML <em>instrumentation</em> is the best <em>custom</em> <em>instrumentation</em> method. With this method, you specify the classes you want to <em>instrument</em> in an external XML file. While XML <em>instrumentation</em>"
      },
      "id": "603eb6b6196a67b753a83db7"
    },
    {
      "sections": [
        "Java instrumentation by XML",
        "Accessing your XML file",
        "XML file structure",
        "XML file validation",
        "Java versions below Java 10",
        "All Java versions",
        "Tip",
        "XML file location",
        "Verify the file was read",
        "Multiple XML files",
        "XML and YAML",
        "Example XML file"
      ],
      "title": "Java instrumentation by XML",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "bf64043c85e0d690961fbbaa6a6dd6b52636e3d5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/java-instrumentation-xml/",
      "published_at": "2021-05-05T03:13:01Z",
      "updated_at": "2021-03-16T08:59:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For your New Relic-monitored Java application, one custom instrumentation method is to use an XML file to specify your app methods that should be instrumented. The Java agent will read the XML file and instrument the relevant classes on startup; XML files added to the extensions directory after startup do not require a JVM restart to be detected. See Java agent custom instrumentation for a description of the custom instrumentation options and the reasons to use them. Accessing your XML file Go to one.newrelic.com > APM > (select an app) > Settings > Instrumentation. From here you can: Download a sample XML file. (You can do this from the pop-up that appears when you click Import an XML file.) Select an edit existing XML file. Search the instrumentation history. XML file structure Your New Relic agent download package (newrelic_agent.zip) contains two templates for using XML instrumentation: The extension.xsd template is the XML schema definition which all custom extensions must follow. The extension-example.xml template is an example. This file instruments some of the basic JDK methods. If you edit and rename this file, ensure you modify the name=\"extension-example\" attribute to match the new filename. For more information about the properties in the extension.xsd template, see the XML file format overview. XML file validation Before starting your application, validate your XML file using New Relic's command line tool. The command line tool can only be used when your classes are in a jar. There are two ways to validate your XML instrumentation: Java versions below Java 10 The easiest way to do this for Java versions lower than Java 10 is with this command: java -Djava.ext.dirs=/path/to/jarred/classes -jar newrelic.jar instrument -file /path/to/file.xml -debug true Copy All Java versions Tip For Java versions below Java 10, see the recommended procedure. That procedure is not possible with Java 10 or higher because those versions no longer allow java.ext.dirs to be set. For all Java versions, you can set the classpath manually: java -cp /path/to/your-app.jar:/path/to/newrelic.jar com.newrelic.bootstrap.BootstrapAgent instrument -file /path/to/file.xml -debug true Copy The application is run with the newrelic.jar. The call must contain the keyword instrument followed by the -file flag with the path to your XML file. The property -debug is optional and may be set to true to provide more information during the validation. The tool will: Validate the XML syntax. Check that each class to be instrumented is present on the class path. Check that each method is contained in the appropriate class. If the XML file is valid, you will see a pass statement printed to the terminal: PASS: The extension at file.txt was successfully validated. Copy If the XML fails validation, you will see a failure message printed to the terminal: FAIL: reason Copy XML file location The Java agent reads any XML files in the extensions directory on process start up. The extensions directory is also read every harvest cycle. XML files added to this directory during runtime will be read within a few minutes, so they do not require a JVM restart. There are two ways to specify the XML file location: XML file location options Procedure Create an extensions directory In the directory where the newrelic.jar and newrelic.yml is located, create a directory named extensions. Put the XML file in this directory with a .xml extension. In newrelic.yml, check that the property extensions.dir is not set. Specify an existing extensions directory In the newrelic.yml configuration file under the common section, use the property extensions.dir to specify the directory where the XML file is located. Make sure the file is in the specified directory and that the file has a .xml extension. Verify the file was read To verify the agent read the XML file, first set the Log management to finer: Edit the newrelic.yml configuration file and change the log_level property: log_level: finer Copy Start or restart the application. If the read was successful, logs/newrelic_agent.log will indicate this in a statement similar to: Reading custom extension file /path/to/file.xml Copy If no statement appears in logs/newrelic_agent.log, then the XML file was not found. Check the location of the XML file, and ensure the New Relic process has read access to the file. Multiple XML files While using a single XML file is preferred, you can use multiple custom XML files. These files will all be instrumented as long as the extension name in the files is unique. If two custom XML files contain the same extension name, then the one with the highest version will be implemented and the other will be ignored. If the two files have the same name and version, then the first file read by the agent will be implemented and the other will be ignored. XML and YAML Prior to 2.10.0, YAML files could be used for custom instrumentation. These legacy YAML files are still supported. However, new users should use XML files for custom instrumentation. Legacy users: If both a YAML and XML file exist with the same extension name, only the XML file will be instrumented. The YAML file will be ignored. If you want both the YAML and XML files to be instrumented, give each file a different extension name. Example XML file For an example of a custom instrumentation XML file, see Java XML examples.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.66824,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>instrumentation</em> by XML",
        "sections": "<em>Java</em> <em>instrumentation</em> by XML",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "For your New Relic-monitored <em>Java</em> application, one <em>custom</em> <em>instrumentation</em> method is to use an XML file to specify your app methods that should be instrumented. The <em>Java</em> <em>agent</em> will read the XML file and <em>instrument</em> the relevant classes on startup; XML files added to the extensions directory after"
      },
      "id": "603eb684196a67fe45a83dad"
    }
  ],
  "/docs/agents/java-agent/custom-instrumentation/troubleshooting-java-custom-instrumentation": [
    {
      "sections": [
        "Custom JMX YAML examples",
        "Contents",
        "YAML example",
        "Example explanation",
        "Properties",
        "MBeans",
        "Attributes",
        "Type",
        "Metric names",
        "Tip",
        "Finding object and attribute names",
        "For more help"
      ],
      "title": "Custom JMX YAML examples",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "38e6f21e2a3344f554072dff9919df049db60224",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/custom-jmx-yaml-examples/",
      "published_at": "2021-05-05T06:53:28Z",
      "updated_at": "2021-03-16T13:47:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This is an example of a custom JMX YAML file for New Relic's Java agent, including value and definition, MBean, attributes, type, and names for metrics, objects, and attributes. For more information, including a video, see Custom JMX monitoring by YAML. Contents YAML example Here is an example of a custom JMX YAML file. YAML files are space senstive. name: TomcatCustom version: 1.0 enabled: true jmx: - object_name: Catalina:type=Cache,host=localhost,path=/examples metrics: - attributes: accessCount, cacheSize, hitsCount type: simple - object_name: Catalina:type=Connector,port=8009 metrics: - attributes: bufferSize, maxHeaderCount - object_name: java.nio:type=BufferPool,name=* metrics: - attributes: Count type: monotonically_increasing Copy Example explanation Properties Value Definition name A descriptive name identifying your YAML custom instrumentation file, using one space before the property name. In the above example, the name is TomcatCustom. version The version of the extension file. Use a double. If two extensions have the same name, only the extension with the highest version will be used. Use one space before the property version. In the above example, the version is 1.0. enabled If true, the Java agent will read the extension. If false, the Java agent will ignore the extension. Use one space before the property enabled. The above example is enabled. MBeans Each line in the YAML starting with - object_name represents an MBean. For example, the following lines describe the information to be pulled from the first MBean: - object_name: Catalina:type=Cache,host=localhost,path=/examples metrics: - attributes: accessCount, cacheSize, hitsCount type: simple Copy The object_name property itself can match one or more MBeans. For example, the line below only matches one MBean: - object_name: Catalina:type=Cache,host=localhost,path=/examples Copy The following line could match multiple MBeans: - object_name: java.nio:type=BufferPool,name=* Copy The asterisk ( * ) wildcard can only be used with JDK 1.6 and higher. The three MBeans listed in the above example have the following object names: Catalina:type=Cache,host=localhost,path=/examples Catalina:type=Connector,port=8009 java.nio:type=BufferPool,name=* Copy Attributes The JMX example retrieves six different attributes from the three MBeans. New Relic's Java agent pulls these attributes from the first MBean: accessCount cacheSize hitsCount The agent pulls these attributes from the second MBean: bufferSize maxHeaderCount The agent pulls one attribute (Count) from third MBean. Type For type, use simple or monotonically_increasing. When type is not specified in the JMX YAML file, it defaults to monotonically_increasing. Value Definition simple The exact value of the attribute will be reported to New Relic each minute. monotonically_increasing The positive difference will be reported to New Relic each minute. In the example above, the attributes accessCount, cacheSize, and hitsCount will be reported as simple. The attributes bufferSize, maxHeaderCount, and Count will be reported as monotonically_increasing. If the hitsCount attribute value is always 5, then New Relic will report a 5 each minute. If the Count attribute value is always 5, then New Relic will report a 0 for the value each minute. If the Count attribute value changes from 5 to 7, then New Relic will report a 2 for that minute. Metric names When selecting custom dashboard metrics and not using the property root_metric_name, use the following format for all custom JMX metrics: JMX/beginning_of_object_name/type/any_properties_in_object_name/attribute_name Copy Tip Some object names do not include a type. In that case, a null will be present in the metric name. The configuration file does not use root_metric_name, so the following metrics will be created: JMX/Catalina/Cache/localhost/examples/accessCount JMX/Catalina/Cache/localhost/examples/cacheSize JMX/Catalina/Cache/localhost/examples/hitsCount JMX/Catalina/Connector/8009/bufferSize JMX/Catalina/Connector/8009/maxHeaderCount JMX/java.nio/BufferPool/direct/Count JMX/java.nio/BufferPool/mapped/Count Copy If you are using the property root_metric_name, then the metric will be your root metric name prefixed with JMX and followed by the attribute's name. You can use object name values by specifying the object name key in the root_metric_name between brackets {}. For example: Part of a configuration file: - object_name: Catalina:type=Cache,host=localhost,path=/examples root_metric_name: Tomcat/{host} metrics: - attributes: accessCount, cacheSize, hitsCount type: simple - object_name: mbean:type=Sample,host=localhost,path=* root_metric_name: SampleMBean metrics: - attributes: attOne, attTwo type: simple Copy Metric names: JMX/Tomcat/localhost/accessCount JMX/Tomcat/localhost/cacheSize JMX/Tomcat/localhost/hitsCount JMX/SampleMBean/attOne JMX/SampleMBean/attTwo Copy If an attribute does not actually exist on the MBean, then the metric will never appear in New Relic. Finding object and attribute names The easiest way to find available MBeans and its associated attributes is to use the JConsole instructions for JDK 1.6. For more help Additional documentation resources include: Custom instrumentation with the Java agent (method tracers, examples) Custom JMX monitoring by YAML (YAML file structure, value and definition)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.732544,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Custom</em> JMX YAML examples",
        "sections": "<em>Custom</em> JMX YAML examples",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " associated attributes is to use the JConsole instructions for JDK 1.6. For more help Additional documentation resources include: <em>Custom</em> <em>instrumentation</em> with the <em>Java</em> <em>agent</em> (method tracers, examples) <em>Custom</em> JMX monitoring by YAML (YAML file structure, value and definition)"
      },
      "id": "603eb76a196a67cba6a83db6"
    },
    {
      "sections": [
        "Messaging framework instrumentation",
        "Typical messaging",
        "Report the producing/consuming as external",
        "Add message metrics/custom parameters to current transaction",
        "Pass a distributed trace payload",
        "Edge cases",
        "Create a distributed trace payload and then receive a message",
        "Batch reading messages",
        "Capturing the processing time of the message",
        "For more help"
      ],
      "title": "Messaging framework instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "9b656fcf1790e65d1db825e35ab31c94b6561e08",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/messaging-framework-instrumentation/",
      "published_at": "2021-05-05T06:54:38Z",
      "updated_at": "2021-03-16T09:03:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "There are some messaging frameworks that New Relic doesn’t support by default. If you are interested in instrumenting these frameworks with our API here are some guidelines to follow. Typical messaging In the typical case, there is a process that produces a message and a process that consumes the message. Some useful things you could do here are below. Note you must be within a transaction for these to report. Report the producing/consuming as external You can create MessageProduceParameters and MessageConsumeParameters with relevant data and then call reportAsExternal(Params) to report the calls as externals. For example, when producing a message this would look like: MessageProduceParameters params = MessageProduceParameters.library(\"libraryName\").destinationType(NAMED_TOPIC).destinationName(\"topicName\").inboundHeaders(null).build(); NewRelic.getAgent().getTransaction().getTracedMethod().reportAsExternal(params); Copy A similar solution would work on the consumer side. Add message metrics/custom parameters to current transaction If there is useful information you want to add to your current transaction about the message, you can do that easily by calling our addCustomParameter() API. This looks like this: NewRelic.addCustomParameter(\"topic-name\", topic); Copy Pass a distributed trace payload In order to track the work across processes/services, the messaging framework must have a way to pass along metadata with the message, whether it’s via headers or some other mechanism. You can create a distributed trace payload on the producer side that can be attached to the message and read on the consumer side. You must be in a transaction for this to work. To do this you would follow a pattern like this: @Trace(dispatcher = true) public void sendData(Producer producer){ final DistributedTracePayload payload = NewRelic.getAgent().getTransaction().createDistributedTracePayload(); headers.add(new RecordHeader(\"newrelic\", payload.text().getBytes(StandardCharsets.UTF_8))); data = new ProducerRecord<String, String>(\"topic\", \"key\", \"value\", headers); producer.send(data); } Copy And on the consumer side: @Trace(dispatcher = true) public void processData(ConsumerRecord record){ final Iterator<Header> nrHeaders = record.headers().headers(\"newrelic\").iterator(); if (nrHeaders.hasNext()) { final Header nrHeader = nrHeaders.next(); final String payload = new String(nrHeader.value(), StandardCharsets.UTF_8); NewRelic.getAgent().getTransaction().acceptDistributedTracePayload(payload); } } Copy This example uses Kafka, which you can instrument. Instrument Kafka message queues provides information for instrumenting. Edge cases There are some edge cases that require extra care. Below are suggestions on the best way to tackle them. Create a distributed trace payload and then receive a message The problem here is that you can’t create a distributed trace payload and then accept a distributed trace payload within the same transaction in that order. This means that there are two attempts of distributed tracing and you have to choose which one you want. If you would like to accept the second payload rather than create the first one, you need to prevent the first payload from getting created. You can remove the custom instrumentation (if that’s what’s creating the payload) or disable instrumentation via our config Batch reading messages For batch consumption of messages, there is a problem of which distributed tracing payload you accept. If you are ok with linking just one of the distributed trace payloads then you can accept any one of the payloads in the batch but that will result in the rest of the payloads getting lost. However, if you want to see all of the distributed traces then you’ll need to create a transaction per message. The second solution could incur some overhead so take that into consideration when making a decision. A solution like that would look like: public void processMessages(ConsumerRecords<String, String> records) { for(ConsumerRecord<String, String> record: records) { processRecord(record); } } @Trace(dispatcher = true) private void processRecord(ConsumerRecord<String, String> record) { final Iterator<Header> nrHeaders = record.headers().headers(\"newrelicDTPayload\").iterator(); if (nrHeaders.hasNext()) { final Header nrHeader = nrHeaders.next(); final String payload = new String(nrHeader.value(), StandardCharsets.UTF_8); NewRelic.getAgent().getTransaction().acceptDistributedTracePayload(payload); } } Copy This will only work if there isn’t a transaction already started on the thread at this time. If there is one then just accepting one payload from the batch is your only solution. Capturing the processing time of the message If you would like to capture the processing time of a message then you will need to move the processing work into a method and then trace that method. For example: public void getMessages(){ KafkaConsumer consumer = new KafkaConsumer(props); consumer.subscribe(Arrays.asList(\"topic\")); while (true) { ConsumerRecords<String, String> recs = consumer.poll(10000); if (recs.count() == 0) { } else { for (ConsumerRecord<String, String> rec : recs) { processRec(rec); } } } } @Trace(dispatcher = true) private void processRec(ConsumerRecord<String, String> rec) { // some processing } Copy For more help Use the Guide to using the Java agent API to learn more about our Java agent API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.669174,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Messaging framework <em>instrumentation</em>",
        "sections": "Messaging framework <em>instrumentation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "(nrHeader.value(), StandardCharsets.UTF_8); NewRelic.get<em>Agent</em>().getTransaction().acceptDistributedTracePayload(payload); } } Copy This example uses Kafka, which you can <em>instrument</em>. <em>Instrument</em> Kafka message queues provides information for instrumenting. Edge cases There are some edge cases that require extra"
      },
      "id": "603ebc24196a67a6d7a83dc8"
    },
    {
      "sections": [
        "Java custom instrumentation",
        "Important",
        "When to choose custom instrumentation",
        "Implement custom instrumentation"
      ],
      "title": "Java custom instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "76fd78e33105744dc4c6342d8059b2b966f90196",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/java-custom-instrumentation/",
      "published_at": "2021-05-04T17:02:34Z",
      "updated_at": "2021-03-16T09:00:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM for Java will typically produce useful performance data automatically. However, if New Relic does not support your framework, or if you want to set up additional monitoring, you will want to implement custom instrumentation. Custom instrumentation allows you to track interactions that aren't captured by New Relic's automatic instrumentation, and lets you add detail to your transaction traces, to help you identify key issues. New Relic collects metrics and events from many frameworks automatically. If you are using a supported framework or component, you may see some transaction information out of the box, and custom instrumentation can be used to supplement the information the Agent reports by default. Important If you are using a supported framework, but are not seeing transactions, get support at support.newrelic.com to ensure the framework instrumentation is working. When to choose custom instrumentation Choose custom instrumentation in these situations: New Relic does not support your framework and transactions do not appear in the UI You would like to add detail to your transaction traces Transaction traces include large blocks of application code time without sufficient detail Implement custom instrumentation You can implement custom instrumentation with one of these methods: Method Description The New Relic UI New Relic for Java includes an option in the UI for custom instrumentation called the Custom Instrumentation Editor. This option doesn't require any direct modification of your application code, so is a good choice if you don't want to or can't modify your code. The editor is, however, fairly limited in functionality compared to the Java agent API. API annotation Using the New Relic Java agent API, you can annotate the methods in your application code that you want to monitor. The annotation method is robust and easy to troubleshoot. If you are willing to modify your source code, annotation is the recommended method. If you have many methods you want to instrument, you might prefer XML instrumentation. For more about the API and its other functions, see Intro to the Java agent API. XML If you can't modify your code, or if you need to instrument many methods, XML instrumentation is the best custom instrumentation method. With this method, you specify the classes you want to instrument in an external XML file. While XML instrumentation is powerful, it is also more difficult to use than the other instrumentation methods. For simpler instrumentation needs, New Relic recommends annotation or instrumentation via the UI. For more information, see Java instrumentation by XML. You can also monitor Java Management Extensions (JMX) via custom instrumentation. JMX is a way to monitor and manage applications, devices, and services. You can implement JMX monitoring via an external YAML file.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.66854,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>custom</em> <em>instrumentation</em>",
        "sections": "<em>Java</em> <em>custom</em> <em>instrumentation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " functions, see Intro to the <em>Java</em> <em>agent</em> API. XML If you can&#x27;t modify your code, or if you need to <em>instrument</em> many methods, XML <em>instrumentation</em> is the best <em>custom</em> <em>instrumentation</em> method. With this method, you specify the classes you want to <em>instrument</em> in an external XML file. While XML <em>instrumentation</em>"
      },
      "id": "603eb6b6196a67b753a83db7"
    }
  ],
  "/docs/agents/java-agent/features/jvms-page-java-view-app-server-metrics-jmx": [
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Requirements",
        "Important",
        "Installation",
        "Tip",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-05-05T07:03:34Z",
      "updated_at": "2021-03-30T15:01:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The New Relic JFR daemon runs as its own Java process and monitors a JVM for JFR events over remote JMX. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. On startup the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic Java agent. If the Java agent is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the agent will then report to the same APM entity. If the the Java agent is not detected, then the daemon will report as a unique entity under the app name that you configured for it. Requirements Requirements include: Java 8 (version 8u262+) or higher for both the JFR daemon process, and the application process An Insights insert API key or an APM license key. JFR daemon jar. Required for flamegraphs, otherwise optional but recommended: Install of New Relic Java agent version 6.1.0 or higher on your JVM. The JFR daemon can run without a Java agent being included, but if the Java agent is present it will combine agent and daemon data into a single APM application. Important Apps running with the JFR daemon should expect the JFR subsystem to use about 150MB of additional memory. Installation The application that you wish to monitor with the JFR daemon must be configured to expose JFR data over remote JMX by adding the following system properties: -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false Copy Tip By default, the JFR daemon will connect via JMX to localhost on port 1099 and send data to New Relic's US production metric and event ingest endpoints. Additionally, if you need the JFR daemon to report through a proxy that will require special configuration settings. To configure the JFR daemon's behavior, please see the fully documented configuration options. To use the JFR daemon: Download the latest version of the JFR daemon jar: jfr-daemon-n.n.n.jar. Register an Insert API key or an APM license key for publishing data to New Relic. Required: Assign your key to the INSIGHTS_INSERT_KEY environment variable. If you are using an APM license key then you will also need to set the USE_LICENSE_KEY=true environment variable. Recommended: Set the name of the application being monitored to the NEW_RELIC_APP_NAME environment variable. If this is not set, then the default app name will be used instead. Start your application and the JFR daemon: java -jar jfr-daemon-n.n.n.jar Copy Optional (but recommended): Include the Java agent: Install Java agent version 6.1.0 or higher to monitor your application. Configure the Java agent to allow it to communicate with the JMX daemon by adding the following configuration to the newrelic.yml configuration file: jmx: enabled: true linkingMetadataMBean: true Copy Tip Enabling linkingMetadataMBean allows the JFR daemon to acquire the entity GUID that was generated by the Java agent for the application. If the entity GUID is successfully acquired, then data collected by the daemon will be reported to the same application as the Java agent. Any name configured for the daemon using NEW_RELIC_APP_NAMEwould be overridden in favor of the name specified by the agent. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Requirements: Early access to our flamegraphs feature is available upon request. All other real-time profiling features are available by default. To request this early access, please email flamegraph@newrelic.com. At this time, this requires deployment of both the JFR daemon and Java agent and the daemon must be reporting as the same entity as the agent. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your application’s overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.370316,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " access to our flamegraphs feature is available upon request. All other real-time profiling <em>features</em> are available by default. To request this early access, please email flamegraph@newrelic.com. At this time, this requires deployment of both the JFR daemon and <em>Java</em> <em>agent</em> and the daemon must"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    },
    {
      "sections": [
        "Garbage collection",
        "Important",
        "Enable garbage collection instrumentation",
        "View app-wide GC statistics",
        "View detailed GC metrics",
        "For more help"
      ],
      "title": "Garbage collection",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Features"
      ],
      "external_id": "9981cf22973c76aec7d8d0ac31c2793e04a42e48",
      "image": "https://docs.newrelic.com/static/e2fdc5c35adef00b9a2646a1ec6589c9/c1b63/garbage_collection_overview.png",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/features/garbage-collection/",
      "published_at": "2021-05-05T14:31:38Z",
      "updated_at": "2021-05-05T14:31:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Garbage collection (GC) finds unused data objects and reclaims that memory space for use by another process. The New Relic Ruby agent can collect information about how much time is spent in garbage collection for applications running on MRI 1.9.2 or higher or Ruby Enterprise Edition, but you must explicitly enable this feature in your application. Important Avoid using garbage collection in production for long periods of time, as it increases overhead. Enable garbage collection instrumentation To activate the feature, add the appropriate call in your application initialization. MRI 1.9.2 or higher: GC::Profiler.enable Ruby Enterprise Edition: GC.enable_stats For Rails applications, you can either add this call to an initializer in config/initializers, or add it directly to your config/application.rb file. View app-wide GC statistics To view overall garbage collection statistics: Log into New Relic, select a Ruby app, and go to Summary. From the APM Summary page, look for GC Execution statistics on the Web transactions time chart. one.newrelic.com > APM > (select a Ruby app) > Summary: On the Web transactions time chart, garbage collection statistics are labeled GC Execution. View detailed GC metrics To view garbage collection metrics on a per-transaction basis, go to one.newrelic.com > APM > (select a Ruby app) > Transactions > (select a transaction). You can then view the amount of time spent in GC, and the average number of times GC is called for each transaction. Hide other labels for a detailed view of garbage collection. one.newrelic.com > APM > (select a Ruby app) > Transactions > (select a transaction): Select an individual transaction to view detailed GC metrics, including average time and average number of calls. Detailed information includes: Garbage collection details Comments Trend of garbage collection time Garbage collection usually takes a small amount of time, and therefore the trend line may not be visible in your charts. To view the trend in garbage collection time, navigate to the overview chart or to detailed transaction metrics. Then, hide every chart label except GC Execution by selecting each label. Average number of calls To view the average number of garbage collection calls for each controller action: From your APM Summary page, select Transaction. Then select a controller action and view the App Server Breakdown. For more help Additional documentation resources include: \"Eating the 1.9 elephant\" blog post (what New Relic discovered when we used garbage collection to fine-tune our own website) APM Summary page (features and drill-down details when using the APM Summary page) Transactions page (features and drill-down details for transactions) Ruby agent configuration (update procedures and configuration file values, including general, proxy, transaction traces, and error collector)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 100.425385,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Agents</em>",
        "body": " Additional documentation resources include: &quot;Eating the 1.9 elephant&quot; blog post (what New Relic discovered when we used garbage collection to fine-tune our own website) APM Summary page (<em>features</em> and drill-down details when using the APM Summary page) Transactions page (<em>features</em> and drill-down details for transactions) Ruby <em>agent</em> configuration (update procedures and configuration file values, including general, proxy, transaction traces, and error collector)"
      },
      "id": "603eba3a28ccbcb144eba7aa"
    },
    {
      "sections": [
        "Message queues",
        "Requirements",
        "Performance improvements with background tasks",
        "Queue operations",
        "View in New Relic UI",
        "Transactions page",
        "Tip",
        "Transaction trace summary page",
        "Transaction trace details tab"
      ],
      "title": "Message queues",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Features"
      ],
      "external_id": "1c074612f5486198c2639542507e2008abb20187",
      "image": "https://docs.newrelic.com/static/1789ce28689c4575593e79b8305171fd/c1b63/transactions_page.png",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/features/message-queues/",
      "published_at": "2021-05-05T01:16:15Z",
      "updated_at": "2021-05-05T01:16:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Ruby agent supports the Bunny RabbitMQ client library, giving you insight into the performance of your message processing, for both incoming and outgoing messages. The APM UI shows transactions initiated via RabbitMQ message receipt (subscribe/consume messages) as Message background tasks. Message creation via RabbitMQ also appears in transaction traces. Requirements Requires New Relic Ruby agent version 4.3.0 or higher. Instrumentation is automatic for supported versions of Bunny AMQP, and requires no additional configuration. Performance improvements with background tasks One way to increase responsiveness of web applications is to delegate work to background processes. Message queues are commonly used for this inter-process communication. In the context of message queuing systems, applications typically interact with message brokers to send and receive messages. The RabbitMQ Bunny client library allows Ruby applications to interface with message brokers that implement the Advanced Message Queuing Protocol (AMQP). New Relic's Ruby agent shows messages sent and received using the RabbitMQ client library. With this visibility, you can see details including: Number of messages produced by your app Time your app spends publishing messages Time your app spends processing \"consumed\" messages APM conveniently groups and reports operations that interact with queues. By analyzing this information, you can more easily identify bottlenecks and areas for performance improvement in your message passing architecture. Queue operations Supported entry points for queue operations appear as Put (publish a message) or Take (receive a message) in APM's user interface. Queue operations Publish a message (Put in UI) Receive a message (Take in UI) RabbitMQ publish pop subscribe (with block) View in New Relic UI Message queue operations are visible in several places in the APM UI: Transactions page Queue operations appear on APM's Transactions page for the selected app. The Put and Take metrics appear in the Breakdown table and are categorized as MessageBroker metrics. Here is an example: Transaction traces also provide additional details for messages. Tip You can select transaction traces from the app's Summary or Transactions pages in APM. Transaction trace summary page The Transaction trace summary page may show Put and Take operations in the Slowest components section. For example: Transaction trace details tab The Transaction trace page includes a dedicated Details tab that shows more detailed information about the transaction. Here is an example:",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 97.54225,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Agents</em>",
        "body": "The New Relic Ruby <em>agent</em> supports the Bunny RabbitMQ client library, giving you insight into the performance of your message processing, for both incoming and outgoing messages. The APM UI shows transactions initiated via RabbitMQ message receipt (subscribe&#x2F;consume messages) as Message background"
      },
      "id": "604427cb28ccbcc86f2c606a"
    }
  ],
  "/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics": [
    {
      "sections": [
        "Garbage collection",
        "Important",
        "Enable garbage collection instrumentation",
        "View app-wide GC statistics",
        "View detailed GC metrics",
        "For more help"
      ],
      "title": "Garbage collection",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Features"
      ],
      "external_id": "9981cf22973c76aec7d8d0ac31c2793e04a42e48",
      "image": "https://docs.newrelic.com/static/e2fdc5c35adef00b9a2646a1ec6589c9/c1b63/garbage_collection_overview.png",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/features/garbage-collection/",
      "published_at": "2021-05-05T14:31:38Z",
      "updated_at": "2021-05-05T14:31:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Garbage collection (GC) finds unused data objects and reclaims that memory space for use by another process. The New Relic Ruby agent can collect information about how much time is spent in garbage collection for applications running on MRI 1.9.2 or higher or Ruby Enterprise Edition, but you must explicitly enable this feature in your application. Important Avoid using garbage collection in production for long periods of time, as it increases overhead. Enable garbage collection instrumentation To activate the feature, add the appropriate call in your application initialization. MRI 1.9.2 or higher: GC::Profiler.enable Ruby Enterprise Edition: GC.enable_stats For Rails applications, you can either add this call to an initializer in config/initializers, or add it directly to your config/application.rb file. View app-wide GC statistics To view overall garbage collection statistics: Log into New Relic, select a Ruby app, and go to Summary. From the APM Summary page, look for GC Execution statistics on the Web transactions time chart. one.newrelic.com > APM > (select a Ruby app) > Summary: On the Web transactions time chart, garbage collection statistics are labeled GC Execution. View detailed GC metrics To view garbage collection metrics on a per-transaction basis, go to one.newrelic.com > APM > (select a Ruby app) > Transactions > (select a transaction). You can then view the amount of time spent in GC, and the average number of times GC is called for each transaction. Hide other labels for a detailed view of garbage collection. one.newrelic.com > APM > (select a Ruby app) > Transactions > (select a transaction): Select an individual transaction to view detailed GC metrics, including average time and average number of calls. Detailed information includes: Garbage collection details Comments Trend of garbage collection time Garbage collection usually takes a small amount of time, and therefore the trend line may not be visible in your charts. To view the trend in garbage collection time, navigate to the overview chart or to detailed transaction metrics. Then, hide every chart label except GC Execution by selecting each label. Average number of calls To view the average number of garbage collection calls for each controller action: From your APM Summary page, select Transaction. Then select a controller action and view the App Server Breakdown. For more help Additional documentation resources include: \"Eating the 1.9 elephant\" blog post (what New Relic discovered when we used garbage collection to fine-tune our own website) APM Summary page (features and drill-down details when using the APM Summary page) Transactions page (features and drill-down details for transactions) Ruby agent configuration (update procedures and configuration file values, including general, proxy, transaction traces, and error collector)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 100.42532,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Agents</em>",
        "body": " Additional documentation resources include: &quot;Eating the 1.9 elephant&quot; blog post (what New Relic discovered when we used garbage collection to fine-tune our own website) APM Summary page (<em>features</em> and drill-down details when using the APM Summary page) Transactions page (<em>features</em> and drill-down details for transactions) Ruby <em>agent</em> configuration (update procedures and configuration file values, including general, proxy, transaction traces, and error collector)"
      },
      "id": "603eba3a28ccbcb144eba7aa"
    },
    {
      "sections": [
        "JVMs page (Java): View app server metrics from JMX",
        "View JVM metrics",
        "Tabs available by app server",
        "Metrics available by tab",
        "Data source metrics by app server",
        "Enable for Spring Boot 2.2 and higher with Tomcat",
        "Enable WebSphere PMI metrics",
        "Enable all statistic sets (recommended)",
        "Enable custom statistic sets (advanced)",
        "Collected WebSphere PMI metrics",
        "stats.ActiveCount",
        "maximumSize",
        "stats.CommittedCount",
        "stats.RolledbackCount",
        "stats.GlobalTimeoutCount",
        "stats.LiveCount",
        "WebLogic JMX metrics",
        "Tip",
        "ThreadCount",
        "TotalStartedThreadCount",
        "LoadedClassCount",
        "UnloadedClassCount",
        "HoggingThreadCount",
        "ExecuteThreadIdleCount",
        "StandbyThreadCount",
        "TransactionTotalCount",
        "TransactionCommittedTotalCount",
        "TransactionRolledBackTotalCount",
        "TransactionAbandonedTotalCount",
        "NumAvailable",
        "CurrCapacity",
        "ConnectionsTotalCount",
        "ActiveConnectionsCurrentCount",
        "LeakedConnectionCount",
        "PrepStmtCacheCurrentSize",
        "WaitingForConnectionCurrentCount",
        "WaitingForConnectionTotal",
        "WaitingForConnectionSuccessTotal",
        "WaitingForConnectionFailureTotal",
        "AccessTotalCount - MissTotalCount",
        "MissTotalCount",
        "WaiterCurrentCount",
        "DestroyedTotalCount",
        "BeansInUseCurrentCount",
        "PooledBeansCurrentCount",
        "TransactionsCommittedTotalCount +TransactionsRolledBackTotalCount +TransactionsTimedOutTotalCount",
        "TransactionsCommittedTotalCount",
        "TransactionsRolledBackTotalCount",
        "TransactionsTimedOutTotalCount"
      ],
      "title": "JVMs page (Java): View app server metrics from JMX",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "da87ac2a630aa7d23dcfcd29838c92a0ec1b3ec3",
      "image": "https://docs.newrelic.com/static/9fc8aafbabec1473134b718135fdef74/c1b63/apm_jvm.png",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/jvms-page-java-view-app-server-metrics-jmx/",
      "published_at": "2021-05-05T00:37:38Z",
      "updated_at": "2021-03-16T04:31:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use New Relic's Java agent to collect and view additional metrics provided by the most common application servers via JMX. The collected metrics vary by app server and include measurements of thread pools, HTTP sessions, and transactions. View JVM metrics Application servers collect and report different metrics, which appear on APM's JVMs page. (For applications using New Relic via Heroku, the JVMs page is named Instances.) At a minimum, each app server collects and reports metric data on memory. For instructions on enabling JMX metrics, refer to your app server's documentation. To view JVM metrics: Go to one.newrelic.com > APM > (select an app) > Monitoring > JVMs > (select a JVM). From the selected JVM's Memory page, use any of New Relic's standard user interface functions to drill down into detailed information. To view other metrics, select any available tab. Optional: To use the thread profiler to look for bottlenecks in data on executing threads, select Profile this JVM. one.newrelic.com > APM > (select an app) > Monitoring > JVMs: Depending on the metrics your app server is reporting, one or more tabs appear on your JVM page. Tabs available by app server This table lists which tabs appear on the JVM page for app servers. If your app server does not report a particular type of metric data, the tab does not appear on your JVM page. App server Memory Thread pools HTTP sessions App server transactions Data sources Glassfish JBoss 5AS JBoss 6AS JBoss 6EAP JBoss 7AS Jetty Resin 3 Resin 4 Tomcat TomEE WebLogic Websphere Liberty Websphere Traditional WildFly Metrics available by tab Here is a summary of the metrics available from the JVM page. If the app server does not support a particular metric, that tab does not appear on your JVM page. JMX Metric charts Memory Heap memory usage: Each chart shows the used and committed heap space in MB for a given heap. Non-heap memory pool usage for the JVM: The used code cache and used CMS Perm Gen in MB. Garbage collection: The garbage collection CPU time. Class count: The loaded and unloaded class count for the JVM. Threads Thread count: The current number of active threads in the JVM. Thread pool: The active and idle thread count for the pool. On supported app servers, a chart shows each thread pool present in the app server, as well as the ratio of active to maximum thread count for each thread pool. HTTP sessions Session: The active, invalidated by timeout, and invalidated HTTP session counts for the application. On supported app servers, a chart shows each application present in the app server. App server transactions Active transaction: The number of active transactions within the app server's transaction manager. Created transaction: The change in the total number of created transactions per app server. Some app servers separate top level transactions and nested transactions. Finished transaction: The change in the total number of finished transactions per app server. Some app servers separate them by aborted and committed completed transactions. Data sources The metrics for the data source tab vary by app server. For more details, see Data source metrics by app server. For details on WebLogic's data source metrics, see WebLogic JMX metrics. Data source metrics by app server For supported app servers, the agent collects JMX data source metrics. You can view these metrics at one.newrelic.com > APM > (select an app) > Monitoring > JVMs > Data sources. To see these metrics, ensure that your data source has been properly configured for JMX monitoring for your app server. App server Metrics Tomcat Max connections: The maximum connections available for a data source. This is generally a configurable parameter. Active connections: The current number of active connections in a data source. Idle connections: The current number of idle connections in a data source. WebSphere Liberty Max connections: The maximum connections available for a data source. This is generally a configurable parameter. Active connections: The current number of active connections in a data source. Idle connections: The current number of idle connections in a data source. Wait time: The average amount of time a connections needs to wait before being handled. Destroyed connections: The number of destroyed connections. Resin Max connections: The maximum connections available for a data source. This is generally a configurable parameter. Active connections: The current number of active connections in a data source. Idle connections: The current number of idle connections in a data source. Created connections: The number of created connections. Enable for Spring Boot 2.2 and higher with Tomcat To enable New Relic to access Tomcat JMX metrics when running with Spring Boot 2.2 and higher, the system property server.tomcat.mbeanregistry.enabled must be set to true. See the Spring Boot 2.2 release notes. Enable WebSphere PMI metrics To enable New Relic to access WebSphere PMI metrics, you will need to configure WebSphere to monitor the necessary statistic sets. Enable all statistic sets (recommended) The simplest approach is to enable the collection of all statistic sets: If you are using Java 2 Security, ensure you have granted New Relic proper permissions. From the WebSphere admin console, select Monitoring and Tuning > Performance Monitoring Infrastructure (PMI) > (your server name). Select the Enable Performance Monitoring Infrastructure (PMI) checkbox. In the Currently monitored statistic set section, select All, then save your changes. Enable custom statistic sets (advanced) You can also collect only the PMI metrics that New Relic monitors by default. To collect only some PMI metrics: If you are using Java 2 Security, ensure you have granted New Relic proper permissions. From the WebSphere admin console, select Monitoring and Tuning > Performance Monitoring Infrastructure (PMI) > (selected app server). Select the Enable Performance Monitoring Infrastructure (PMI) checkbox. Select Custom. From the custom statistic set list, enable the following metrics: In the ThreadPool category, select the ActiveCount and PoolSize checkboxes. In the Servlet Session Manager category, select the ActiveCount and LiveCount checkboxes. In the Transaction Manager category, select the CommittedCount, RolledbackCount, and GlobalTimeoutCount checkboxes. From the Messages panel, select Save directly to the master configuration. Collected WebSphere PMI metrics When enabled, New Relic collects the following WebSphere PMI metrics. If you want other PMI metrics besides these to be collected and displayed in New Relic custom dashboards, use JMX instrumentation. stats.ActiveCount WebSphere PMI metrics Details Attribute stats.ActiveCount Object name pattern WebSphere:type=ThreadPool,name=*,process=*,platform=*,node=*,* Copy New Relic metric JmxBuiltIn/ThreadPool/WebContainer/Active Copy Type Simple maximumSize WebSphere PMI metrics Details Attribute maximumSize Object name pattern WebSphere:type=ThreadPool,name=*,process=*,platform=*,node=*,* Copy New Relic metric JmxBuiltIn/ThreadPool/WebContainer/Max Copy Type Simple stats.CommittedCount WebSphere PMI metrics Details Attribute stats.CommittedCount Object name pattern WebSphere:j2eeType=JTAResource,type=TransactionService,name=*,process=*,platform=*,node=*,* Copy New Relic metric JmxBuiltIn/JTA/TransactionService/Committed Copy Type Simple stats.RolledbackCount WebSphere PMI metrics Details Attribute stats.RolledbackCount Object name pattern WebSphere:j2eeType=JTAResource,type=TransactionService,name=*,process=*,platform=*,node=*,* Copy New Relic metric JmxBuiltIn/JTA/TransactionService/Rolled Back Copy Type Simple stats.GlobalTimeoutCount WebSphere PMI metrics Details Attribute stats.GlobalTimeoutCount Object name pattern WebSphere:j2eeType=JTAResource,type=TransactionService,name=*,process=*,platform=*,node=*,* Copy New Relic metric JmxBuiltIn/JTA/TransactionService/Timed Out Copy Type Simple stats.LiveCount WebSphere PMI metrics Details Attribute stats.GlobalTimeoutCount Object name pattern WebSphere:type=SessionManager,name=*,process=*,platform=*,node=*,* Copy New Relic metric JmxBuiltIn/Session/DefaultApplication#DefaultWebApplication.war/Active Copy Type Simple WebLogic JMX metrics In WebLogic, JMX is enabled by default. New Relic collects the following mbeans metrics. Tip To collect additional JMX metrics, use a custom YAML file. ThreadCount WebLogic JMX metrics Details Attribute ThreadCount Object name pattern java.lang:type=Threading Copy New Relic metric JmxBuiltIn/Threads/Thread Count Copy Type Simple TotalStartedThreadCount WebLogic JMX metrics Details Attribute TotalStartedThreadCount Object name pattern java.lang:type=Threading Copy New Relic metric JmxBuiltIn/Threads/TotalStartedCount Copy Type Simple LoadedClassCount WebLogic JMX metrics Details Attribute LoadedClassCount Object name pattern java.lang:type=ClassLoading Copy New Relic metric JmxBuiltIn/Classes/Loaded Copy Type Simple UnloadedClassCount WebLogic JMX metrics Details Attribute UnloadedClassCount Object name pattern java.lang:type=ClassLoading Copy New Relic metric JmxBuiltIn/Classes/Unloaded Copy Type Simple HoggingThreadCount WebLogic JMX metrics Details Attribute HoggingThreadCount Object name pattern com.bea:ServerRuntime=*,Name=ThreadPoolRuntime,Type=ThreadPoolRuntime Copy New Relic metric JmxBuiltIn/ThreadPool/{Name}/Active Copy Type Simple ExecuteThreadIdleCount WebLogic JMX metrics Details Attribute ExecuteThreadIdleCount Object name pattern com.bea:ServerRuntime=*,Name=ThreadPoolRuntime,Type=ThreadPoolRuntime Copy New Relic metric JmxBuiltIn/ThreadPool/{Name}/Idle Copy Type Simple StandbyThreadCount WebLogic JMX metrics Details Attribute StandbyThreadCount Object name pattern com.bea:ServerRuntime=*,Name=ThreadPoolRuntime,Type=ThreadPoolRuntime Copy New Relic metric JmxBuiltIn/ThreadPool/{Name}/Standby Copy Type Simple TransactionTotalCount WebLogic JMX metrics Details Attribute TransactionTotalCount Object name pattern com.bea:ServerRuntime=*,Name=JTARuntime,Type=JTARuntime Copy New Relic metric JmxBuiltIn/JTA/{Name}/Count Copy Type Monotonic TransactionCommittedTotalCount WebLogic JMX metrics Details Attribute TransactionCommittedTotalCount Object name pattern com.bea:ServerRuntime=*,Name=JTARuntime,Type=JTARuntime Copy New Relic metric JmxBuiltIn/JTA/{Name}/Committed Copy Type Monotonic TransactionRolledBackTotalCount WebLogic JMX metrics Details Attribute TransactionRolledBackTotalCount Object name pattern com.bea:ServerRuntime=*,Name=JTARuntime,Type=JTARuntime Copy New Relic metric JmxBuiltIn/JTA/{Name}/Rolled Back Copy Type Monotonic TransactionAbandonedTotalCount WebLogic JMX metrics Details Attribute TransactionAbandonedTotalCount Object name pattern com.bea:ServerRuntime=*,Name=JTARuntime,Type=JTARuntime Copy New Relic metric JmxBuiltIn/JTA/{Name}/Abandoned Copy Type Monotonic NumAvailable WebLogic JMX metrics Details Attribute NumAvailable Object name pattern com.bea:ServerRuntime=*,Name=*,Type=JDBCDataSourceRuntime Copy New Relic metric JmxBuiltIn/DataSources/{Name}/Connections/Available Copy Type Simple CurrCapacity WebLogic JMX metrics Details Attribute CurrCapacity Object name pattern com.bea:ServerRuntime=*,Name=*,Type=JDBCDataSourceRuntime Copy New Relic metric JmxBuiltIn/DataSources/{Name}/Connections/PoolSize Copy Type Simple ConnectionsTotalCount WebLogic JMX metrics Details Attribute ConnectionsTotalCount Object name pattern com.bea:ServerRuntime=*,Name=*,Type=JDBCDataSourceRuntime Copy New Relic metric JmxBuiltIn/DataSources/{Name}/Connections/Created Copy Type Monotonic ActiveConnectionsCurrentCount WebLogic JMX metrics Details Attribute ActiveConnectionsCurrentCount Object name pattern com.bea:ServerRuntime=*,Name=*,Type=JDBCDataSourceRuntime Copy New Relic metric JmxBuiltIn/DataSources/{Name}/Connections/Active Copy Type Simple LeakedConnectionCount WebLogic JMX metrics Details Attribute LeakedConnectionCount Object name pattern com.bea:ServerRuntime=*,Name=*,Type=JDBCDataSourceRuntime Copy New Relic metric JmxBuiltIn/DataSources/{Name}/Connections/Leaked Copy Type Monotonic PrepStmtCacheCurrentSize WebLogic JMX metrics Details Attribute PrepStmtCacheCurrentSize Object name pattern com.bea:ServerRuntime=*,Name=*,Type=JDBCDataSourceRuntime Copy New Relic metric JmxBuiltIn/DataSources/{Name}/Statement Cache/Size Copy Type Simple WaitingForConnectionCurrentCount WebLogic JMX metrics Details Attribute WaitingForConnectionCurrentCount Object name pattern com.bea:ServerRuntime=*,Name=*,Type=JDBCDataSourceRuntime Copy New Relic metric JmxBuiltIn/DataSources/{Name}/Requests/Currently Waiting Copy Type Simple WaitingForConnectionTotal WebLogic JMX metrics Details Attribute WaitingForConnectionTotal Object name pattern com.bea:ServerRuntime=*,Name=*,Type=JDBCDataSourceRuntime Copy New Relic metric JmxBuiltIn/DataSources/{Name}/Requests/Count Copy Type Monotonic WaitingForConnectionSuccessTotal WebLogic JMX metrics Details Attribute WaitingForConnectionSuccessTotal Object name pattern com.bea:ServerRuntime=*,Name=*,Type=JDBCDataSourceRuntime Copy New Relic metric JmxBuiltIn/DataSources/{Name}/Requests/Successful Copy Type Monotonic WaitingForConnectionFailureTotal WebLogic JMX metrics Details Attribute WaitingForConnectionFailureTotal Object name pattern com.bea:ServerRuntime=*,Name=*,Type=JDBCDataSourceRuntime Copy New Relic metric JmxBuiltIn/DataSources/{Name}/Requests/Failed Copy Type Monotonic AccessTotalCount - MissTotalCount WebLogic JMX metrics Details Attribute AccessTotalCount - MissTotalCount Object name pattern com.bea:ServerRuntime=*,Name=*,ApplicationRuntime=*,Type=EJBPoolRuntime,EJBComponentRuntime=*,* Copy New Relic metric JmxBuiltIn/EJB/Pool/Bean/{ApplicationRuntime}/{EJBComponentRuntime}/{Name}/Attempts/Successful Copy Type Monotonic MissTotalCount WebLogic JMX metrics Details Attribute MissTotalCount Object name pattern com.bea:ServerRuntime=*,Name=*,ApplicationRuntime=*,Type=EJBPoolRuntime,EJBComponentRuntime=*,* Copy New Relic metric JmxBuiltIn/EJB/Pool/Bean/{ApplicationRuntime}/{EJBComponentRuntime}/{Name}/Attempts/Failed Copy Type Monotonic WaiterCurrentCount WebLogic JMX metrics Details Attribute WaiterCurrentCount Object name pattern com.bea:ServerRuntime=*,Name=*,ApplicationRuntime=*,Type=EJBPoolRuntime,EJBComponentRuntime=*,*> Copy New Relic metric JmxBuiltIn/EJB/Pool/Bean/{ApplicationRuntime}/{EJBComponentRuntime}/{Name}/Threads/Waiting Copy Type Simple DestroyedTotalCount WebLogic JMX metrics Details Attribute DestroyedTotalCount Object name pattern com.bea:ServerRuntime=*,Name=*,ApplicationRuntime=*,Type=EJBPoolRuntime,EJBComponentRuntime=*,* Copy New Relic metric JmxBuiltIn/EJB/Pool/Bean/{ApplicationRuntime}/{EJBComponentRuntime}/{Name}/Beans/Destroyed Copy Type Monotonic BeansInUseCurrentCount WebLogic JMX metrics Details Attribute BeansInUseCurrentCount Object name pattern com.bea:ServerRuntime=*,Name=*,ApplicationRuntime=*,Type=EJBPoolRuntime,EJBComponentRuntime=*,* Copy New Relic metric JmxBuiltIn/EJB/Pool/Bean/{ApplicationRuntime}/{EJBComponentRuntime}/{Name}/Beans/Active Copy Type Simple PooledBeansCurrentCount WebLogic JMX metrics Details Attribute PooledBeansCurrentCount Object name pattern com.bea:ServerRuntime=*,Name=*,ApplicationRuntime=*,Type=EJBPoolRuntime,EJBComponentRuntime=*,* Copy New Relic metric JmxBuiltIn/EJB/Pool/Bean/{ApplicationRuntime}/{EJBComponentRuntime}/{Name}/Beans/Available Copy Type Simple TransactionsCommittedTotalCount +TransactionsRolledBackTotalCount +TransactionsTimedOutTotalCount WebLogic JMX metrics Details Attribute TransactionsCommittedTotalCount +TransactionsRolledBackTotalCount +TransactionsTimedOutTotalCount Object name pattern com.bea:ServerRuntime=*,Name=*,ApplicationRuntime=*,Type=EJBTransactionRuntime,EJBComponentRuntime=*,* Copy New Relic metric JmxBuiltIn/EJB/Transactions/Application/{ApplicationRuntime}/Count Copy Type Monotonic TransactionsCommittedTotalCount WebLogic JMX metrics Details Attribute TransactionsCommittedTotalCount Object name pattern com.bea:ServerRuntime=*,Name=*,ApplicationRuntime=*,Type=EJBTransactionRuntime,EJBComponentRuntime=*,* Copy New Relic metric JmxBuiltIn/EJB/Transactions/Application/{ApplicationRuntime}/Committed Copy Type Monotonic TransactionsRolledBackTotalCount WebLogic JMX metrics Details Attribute TransactionsRolledBackTotalCount Object name pattern com.bea:ServerRuntime=*,Name=*,ApplicationRuntime=*,Type=EJBTransactionRuntime,EJBComponentRuntime=*,* Copy New Relic metric JmxBuiltIn/EJB/Transactions/Application/{ApplicationRuntime}/Rolled Back Copy Type Monotonic TransactionsTimedOutTotalCount WebLogic JMX metrics Details Attribute TransactionsTimedOutTotalCount Object name pattern com.bea:ServerRuntime=*,Name=*,ApplicationRuntime=*,Type=EJBTransactionRuntime,EJBComponentRuntime=*,* Copy New Relic metric JmxBuiltIn/EJB/Transactions/Application/{ApplicationRuntime}/Timed Out Copy Type Monotonic",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 99.506165,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "JVMs page (<em>Java</em>): View app server metrics from JMX",
        "sections": "JVMs page (<em>Java</em>): View app server metrics from JMX",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "You can use New Relic&#x27;s <em>Java</em> <em>agent</em> to collect and view additional metrics provided by the most common application servers via JMX. The collected metrics vary by app server and include measurements of thread pools, HTTP sessions, and transactions. View JVM metrics Application servers collect"
      },
      "id": "603eb1c3e7b9d2d4182a07dc"
    },
    {
      "sections": [
        "Message queues",
        "Requirements",
        "Performance improvements with background tasks",
        "Queue operations",
        "View in New Relic UI",
        "Transactions page",
        "Tip",
        "Transaction trace summary page",
        "Transaction trace details tab"
      ],
      "title": "Message queues",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Features"
      ],
      "external_id": "1c074612f5486198c2639542507e2008abb20187",
      "image": "https://docs.newrelic.com/static/1789ce28689c4575593e79b8305171fd/c1b63/transactions_page.png",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/features/message-queues/",
      "published_at": "2021-05-05T01:16:15Z",
      "updated_at": "2021-05-05T01:16:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Ruby agent supports the Bunny RabbitMQ client library, giving you insight into the performance of your message processing, for both incoming and outgoing messages. The APM UI shows transactions initiated via RabbitMQ message receipt (subscribe/consume messages) as Message background tasks. Message creation via RabbitMQ also appears in transaction traces. Requirements Requires New Relic Ruby agent version 4.3.0 or higher. Instrumentation is automatic for supported versions of Bunny AMQP, and requires no additional configuration. Performance improvements with background tasks One way to increase responsiveness of web applications is to delegate work to background processes. Message queues are commonly used for this inter-process communication. In the context of message queuing systems, applications typically interact with message brokers to send and receive messages. The RabbitMQ Bunny client library allows Ruby applications to interface with message brokers that implement the Advanced Message Queuing Protocol (AMQP). New Relic's Ruby agent shows messages sent and received using the RabbitMQ client library. With this visibility, you can see details including: Number of messages produced by your app Time your app spends publishing messages Time your app spends processing \"consumed\" messages APM conveniently groups and reports operations that interact with queues. By analyzing this information, you can more easily identify bottlenecks and areas for performance improvement in your message passing architecture. Queue operations Supported entry points for queue operations appear as Put (publish a message) or Take (receive a message) in APM's user interface. Queue operations Publish a message (Put in UI) Receive a message (Take in UI) RabbitMQ publish pop subscribe (with block) View in New Relic UI Message queue operations are visible in several places in the APM UI: Transactions page Queue operations appear on APM's Transactions page for the selected app. The Put and Take metrics appear in the Breakdown table and are categorized as MessageBroker metrics. Here is an example: Transaction traces also provide additional details for messages. Tip You can select transaction traces from the app's Summary or Transactions pages in APM. Transaction trace summary page The Transaction trace summary page may show Put and Take operations in the Slowest components section. For example: Transaction trace details tab The Transaction trace page includes a dedicated Details tab that shows more detailed information about the transaction. Here is an example:",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 97.54219,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Agents</em>",
        "body": "The New Relic Ruby <em>agent</em> supports the Bunny RabbitMQ client library, giving you insight into the performance of your message processing, for both incoming and outgoing messages. The APM UI shows transactions initiated via RabbitMQ message receipt (subscribe&#x2F;consume messages) as Message background"
      },
      "id": "604427cb28ccbcc86f2c606a"
    }
  ],
  "/docs/agents/java-agent/frameworks/scala-installation-java": [
    {
      "sections": [
        "Custom JMX YAML examples",
        "Contents",
        "YAML example",
        "Example explanation",
        "Properties",
        "MBeans",
        "Attributes",
        "Type",
        "Metric names",
        "Tip",
        "Finding object and attribute names",
        "For more help"
      ],
      "title": "Custom JMX YAML examples",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "38e6f21e2a3344f554072dff9919df049db60224",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/custom-jmx-yaml-examples/",
      "published_at": "2021-05-05T06:53:28Z",
      "updated_at": "2021-03-16T13:47:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This is an example of a custom JMX YAML file for New Relic's Java agent, including value and definition, MBean, attributes, type, and names for metrics, objects, and attributes. For more information, including a video, see Custom JMX monitoring by YAML. Contents YAML example Here is an example of a custom JMX YAML file. YAML files are space senstive. name: TomcatCustom version: 1.0 enabled: true jmx: - object_name: Catalina:type=Cache,host=localhost,path=/examples metrics: - attributes: accessCount, cacheSize, hitsCount type: simple - object_name: Catalina:type=Connector,port=8009 metrics: - attributes: bufferSize, maxHeaderCount - object_name: java.nio:type=BufferPool,name=* metrics: - attributes: Count type: monotonically_increasing Copy Example explanation Properties Value Definition name A descriptive name identifying your YAML custom instrumentation file, using one space before the property name. In the above example, the name is TomcatCustom. version The version of the extension file. Use a double. If two extensions have the same name, only the extension with the highest version will be used. Use one space before the property version. In the above example, the version is 1.0. enabled If true, the Java agent will read the extension. If false, the Java agent will ignore the extension. Use one space before the property enabled. The above example is enabled. MBeans Each line in the YAML starting with - object_name represents an MBean. For example, the following lines describe the information to be pulled from the first MBean: - object_name: Catalina:type=Cache,host=localhost,path=/examples metrics: - attributes: accessCount, cacheSize, hitsCount type: simple Copy The object_name property itself can match one or more MBeans. For example, the line below only matches one MBean: - object_name: Catalina:type=Cache,host=localhost,path=/examples Copy The following line could match multiple MBeans: - object_name: java.nio:type=BufferPool,name=* Copy The asterisk ( * ) wildcard can only be used with JDK 1.6 and higher. The three MBeans listed in the above example have the following object names: Catalina:type=Cache,host=localhost,path=/examples Catalina:type=Connector,port=8009 java.nio:type=BufferPool,name=* Copy Attributes The JMX example retrieves six different attributes from the three MBeans. New Relic's Java agent pulls these attributes from the first MBean: accessCount cacheSize hitsCount The agent pulls these attributes from the second MBean: bufferSize maxHeaderCount The agent pulls one attribute (Count) from third MBean. Type For type, use simple or monotonically_increasing. When type is not specified in the JMX YAML file, it defaults to monotonically_increasing. Value Definition simple The exact value of the attribute will be reported to New Relic each minute. monotonically_increasing The positive difference will be reported to New Relic each minute. In the example above, the attributes accessCount, cacheSize, and hitsCount will be reported as simple. The attributes bufferSize, maxHeaderCount, and Count will be reported as monotonically_increasing. If the hitsCount attribute value is always 5, then New Relic will report a 5 each minute. If the Count attribute value is always 5, then New Relic will report a 0 for the value each minute. If the Count attribute value changes from 5 to 7, then New Relic will report a 2 for that minute. Metric names When selecting custom dashboard metrics and not using the property root_metric_name, use the following format for all custom JMX metrics: JMX/beginning_of_object_name/type/any_properties_in_object_name/attribute_name Copy Tip Some object names do not include a type. In that case, a null will be present in the metric name. The configuration file does not use root_metric_name, so the following metrics will be created: JMX/Catalina/Cache/localhost/examples/accessCount JMX/Catalina/Cache/localhost/examples/cacheSize JMX/Catalina/Cache/localhost/examples/hitsCount JMX/Catalina/Connector/8009/bufferSize JMX/Catalina/Connector/8009/maxHeaderCount JMX/java.nio/BufferPool/direct/Count JMX/java.nio/BufferPool/mapped/Count Copy If you are using the property root_metric_name, then the metric will be your root metric name prefixed with JMX and followed by the attribute's name. You can use object name values by specifying the object name key in the root_metric_name between brackets {}. For example: Part of a configuration file: - object_name: Catalina:type=Cache,host=localhost,path=/examples root_metric_name: Tomcat/{host} metrics: - attributes: accessCount, cacheSize, hitsCount type: simple - object_name: mbean:type=Sample,host=localhost,path=* root_metric_name: SampleMBean metrics: - attributes: attOne, attTwo type: simple Copy Metric names: JMX/Tomcat/localhost/accessCount JMX/Tomcat/localhost/cacheSize JMX/Tomcat/localhost/hitsCount JMX/SampleMBean/attOne JMX/SampleMBean/attTwo Copy If an attribute does not actually exist on the MBean, then the metric will never appear in New Relic. Finding object and attribute names The easiest way to find available MBeans and its associated attributes is to use the JConsole instructions for JDK 1.6. For more help Additional documentation resources include: Custom instrumentation with the Java agent (method tracers, examples) Custom JMX monitoring by YAML (YAML file structure, value and definition)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.732544,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Custom</em> JMX YAML examples",
        "sections": "<em>Custom</em> JMX YAML examples",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " associated attributes is to use the JConsole instructions for JDK 1.6. For more help Additional documentation resources include: <em>Custom</em> <em>instrumentation</em> with the <em>Java</em> <em>agent</em> (method tracers, examples) <em>Custom</em> JMX monitoring by YAML (YAML file structure, value and definition)"
      },
      "id": "603eb76a196a67cba6a83db6"
    },
    {
      "sections": [
        "Messaging framework instrumentation",
        "Typical messaging",
        "Report the producing/consuming as external",
        "Add message metrics/custom parameters to current transaction",
        "Pass a distributed trace payload",
        "Edge cases",
        "Create a distributed trace payload and then receive a message",
        "Batch reading messages",
        "Capturing the processing time of the message",
        "For more help"
      ],
      "title": "Messaging framework instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "9b656fcf1790e65d1db825e35ab31c94b6561e08",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/messaging-framework-instrumentation/",
      "published_at": "2021-05-05T06:54:38Z",
      "updated_at": "2021-03-16T09:03:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "There are some messaging frameworks that New Relic doesn’t support by default. If you are interested in instrumenting these frameworks with our API here are some guidelines to follow. Typical messaging In the typical case, there is a process that produces a message and a process that consumes the message. Some useful things you could do here are below. Note you must be within a transaction for these to report. Report the producing/consuming as external You can create MessageProduceParameters and MessageConsumeParameters with relevant data and then call reportAsExternal(Params) to report the calls as externals. For example, when producing a message this would look like: MessageProduceParameters params = MessageProduceParameters.library(\"libraryName\").destinationType(NAMED_TOPIC).destinationName(\"topicName\").inboundHeaders(null).build(); NewRelic.getAgent().getTransaction().getTracedMethod().reportAsExternal(params); Copy A similar solution would work on the consumer side. Add message metrics/custom parameters to current transaction If there is useful information you want to add to your current transaction about the message, you can do that easily by calling our addCustomParameter() API. This looks like this: NewRelic.addCustomParameter(\"topic-name\", topic); Copy Pass a distributed trace payload In order to track the work across processes/services, the messaging framework must have a way to pass along metadata with the message, whether it’s via headers or some other mechanism. You can create a distributed trace payload on the producer side that can be attached to the message and read on the consumer side. You must be in a transaction for this to work. To do this you would follow a pattern like this: @Trace(dispatcher = true) public void sendData(Producer producer){ final DistributedTracePayload payload = NewRelic.getAgent().getTransaction().createDistributedTracePayload(); headers.add(new RecordHeader(\"newrelic\", payload.text().getBytes(StandardCharsets.UTF_8))); data = new ProducerRecord<String, String>(\"topic\", \"key\", \"value\", headers); producer.send(data); } Copy And on the consumer side: @Trace(dispatcher = true) public void processData(ConsumerRecord record){ final Iterator<Header> nrHeaders = record.headers().headers(\"newrelic\").iterator(); if (nrHeaders.hasNext()) { final Header nrHeader = nrHeaders.next(); final String payload = new String(nrHeader.value(), StandardCharsets.UTF_8); NewRelic.getAgent().getTransaction().acceptDistributedTracePayload(payload); } } Copy This example uses Kafka, which you can instrument. Instrument Kafka message queues provides information for instrumenting. Edge cases There are some edge cases that require extra care. Below are suggestions on the best way to tackle them. Create a distributed trace payload and then receive a message The problem here is that you can’t create a distributed trace payload and then accept a distributed trace payload within the same transaction in that order. This means that there are two attempts of distributed tracing and you have to choose which one you want. If you would like to accept the second payload rather than create the first one, you need to prevent the first payload from getting created. You can remove the custom instrumentation (if that’s what’s creating the payload) or disable instrumentation via our config Batch reading messages For batch consumption of messages, there is a problem of which distributed tracing payload you accept. If you are ok with linking just one of the distributed trace payloads then you can accept any one of the payloads in the batch but that will result in the rest of the payloads getting lost. However, if you want to see all of the distributed traces then you’ll need to create a transaction per message. The second solution could incur some overhead so take that into consideration when making a decision. A solution like that would look like: public void processMessages(ConsumerRecords<String, String> records) { for(ConsumerRecord<String, String> record: records) { processRecord(record); } } @Trace(dispatcher = true) private void processRecord(ConsumerRecord<String, String> record) { final Iterator<Header> nrHeaders = record.headers().headers(\"newrelicDTPayload\").iterator(); if (nrHeaders.hasNext()) { final Header nrHeader = nrHeaders.next(); final String payload = new String(nrHeader.value(), StandardCharsets.UTF_8); NewRelic.getAgent().getTransaction().acceptDistributedTracePayload(payload); } } Copy This will only work if there isn’t a transaction already started on the thread at this time. If there is one then just accepting one payload from the batch is your only solution. Capturing the processing time of the message If you would like to capture the processing time of a message then you will need to move the processing work into a method and then trace that method. For example: public void getMessages(){ KafkaConsumer consumer = new KafkaConsumer(props); consumer.subscribe(Arrays.asList(\"topic\")); while (true) { ConsumerRecords<String, String> recs = consumer.poll(10000); if (recs.count() == 0) { } else { for (ConsumerRecord<String, String> rec : recs) { processRec(rec); } } } } @Trace(dispatcher = true) private void processRec(ConsumerRecord<String, String> rec) { // some processing } Copy For more help Use the Guide to using the Java agent API to learn more about our Java agent API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.66917,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Messaging framework <em>instrumentation</em>",
        "sections": "Messaging framework <em>instrumentation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "(nrHeader.value(), StandardCharsets.UTF_8); NewRelic.get<em>Agent</em>().getTransaction().acceptDistributedTracePayload(payload); } } Copy This example uses Kafka, which you can <em>instrument</em>. <em>Instrument</em> Kafka message queues provides information for instrumenting. Edge cases There are some edge cases that require extra"
      },
      "id": "603ebc24196a67a6d7a83dc8"
    },
    {
      "sections": [
        "Java custom instrumentation",
        "Important",
        "When to choose custom instrumentation",
        "Implement custom instrumentation"
      ],
      "title": "Java custom instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "76fd78e33105744dc4c6342d8059b2b966f90196",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/java-custom-instrumentation/",
      "published_at": "2021-05-04T17:02:34Z",
      "updated_at": "2021-03-16T09:00:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM for Java will typically produce useful performance data automatically. However, if New Relic does not support your framework, or if you want to set up additional monitoring, you will want to implement custom instrumentation. Custom instrumentation allows you to track interactions that aren't captured by New Relic's automatic instrumentation, and lets you add detail to your transaction traces, to help you identify key issues. New Relic collects metrics and events from many frameworks automatically. If you are using a supported framework or component, you may see some transaction information out of the box, and custom instrumentation can be used to supplement the information the Agent reports by default. Important If you are using a supported framework, but are not seeing transactions, get support at support.newrelic.com to ensure the framework instrumentation is working. When to choose custom instrumentation Choose custom instrumentation in these situations: New Relic does not support your framework and transactions do not appear in the UI You would like to add detail to your transaction traces Transaction traces include large blocks of application code time without sufficient detail Implement custom instrumentation You can implement custom instrumentation with one of these methods: Method Description The New Relic UI New Relic for Java includes an option in the UI for custom instrumentation called the Custom Instrumentation Editor. This option doesn't require any direct modification of your application code, so is a good choice if you don't want to or can't modify your code. The editor is, however, fairly limited in functionality compared to the Java agent API. API annotation Using the New Relic Java agent API, you can annotate the methods in your application code that you want to monitor. The annotation method is robust and easy to troubleshoot. If you are willing to modify your source code, annotation is the recommended method. If you have many methods you want to instrument, you might prefer XML instrumentation. For more about the API and its other functions, see Intro to the Java agent API. XML If you can't modify your code, or if you need to instrument many methods, XML instrumentation is the best custom instrumentation method. With this method, you specify the classes you want to instrument in an external XML file. While XML instrumentation is powerful, it is also more difficult to use than the other instrumentation methods. For simpler instrumentation needs, New Relic recommends annotation or instrumentation via the UI. For more information, see Java instrumentation by XML. You can also monitor Java Management Extensions (JMX) via custom instrumentation. JMX is a way to monitor and manage applications, devices, and services. You can implement JMX monitoring via an external YAML file.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.66854,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>custom</em> <em>instrumentation</em>",
        "sections": "<em>Java</em> <em>custom</em> <em>instrumentation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " functions, see Intro to the <em>Java</em> <em>agent</em> API. XML If you can&#x27;t modify your code, or if you need to <em>instrument</em> many methods, XML <em>instrumentation</em> is the best <em>custom</em> <em>instrumentation</em> method. With this method, you specify the classes you want to <em>instrument</em> in an external XML file. While XML <em>instrumentation</em>"
      },
      "id": "603eb6b6196a67b753a83db7"
    }
  ],
  "/docs/agents/java-agent/getting-started/apm-agent-security-java": [
    {
      "sections": [
        "Browser Summary page",
        "View the Summary page",
        "Core Web Vitals widgets",
        "User time on the site",
        "Initial page load and route change chart",
        "User-centric page load times chart",
        "Throughput chart",
        "Tip",
        "Front end vs. back end chart",
        "First interaction by device type, First interaction by user agent, JavaScript errors, and Longest first input delay by URL",
        "Related Entities widget",
        "View Synthetics monitors"
      ],
      "title": "Browser Summary page",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Getting started"
      ],
      "external_id": "a69bb31a3bff73ef8badce5ce435da62e9e7b644",
      "image": "https://docs.newrelic.com/static/d209fe2eab5c7d2da657e515ab49ae4a/c1b63/browser_summary_page.png",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/getting-started/browser-summary-page/",
      "published_at": "2021-05-05T17:32:47Z",
      "updated_at": "2021-05-05T17:32:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's Summary page summarizes the real-user browser performance of your app. Use the Summary page to: View trends in an app's browser-side performance Quickly troubleshoot page load timing issues Navigate to other Browser UI pages View the Summary page To view a summary of browser performance for an app: Go to one.newrelic.com, click Browser, and select an app from the Browser index. From the app's Summary page, use standard New Relic page functions to drill down into detailed information. one.newrelic.com > Browser > (select an app) > Summary: After you select an application from the New Relic Browser apps index, the Summary page shows a summary of browser performance for that app. The Summary page includes: Core Web Vitals widgets User time on the site Initial page load and route change chart User-centric page load times chart Throughput chart Front end vs. back end chart For Browser Pro: Charts for First interaction by device type, First interaction by user agent, JavaScript errors, and Longest first input delay by URL Related Entities widget View Synthetics monitors Core Web Vitals widgets The Core Web Vitals widgets show how your browser performs according to Google's Core Web Vitals. The Core Web Vitals widgets include: LCP - Largest Contentful Paint FID - First Input Delay CLS - Cumulative Layout Shift User time on the site The User time on the site widget shows the time a user remains on the site. Initial page load and route change chart The Initial page load and route change chart shows the load time of a traditional URL change stemming from a load or reload of a URL. This chart appears with more detail about the page load timing process on the Browser page load time page. User-centric page load times chart The User-centric page load times chart shows the load time of a page for a user. This chart appears with more detail about the page load timing process on the Browser page load time page. Throughput chart The Throughput chart displays browser throughput as pages per minute (ppm). The value in the upper right of the chart is the average value for the selected time range. If you have enabled SPA monitoring enabled and the Summary page shows the SPA load time chart, the Throughput chart will also use SPA data. Tip App server requests per minute (rpm) may show a different measurement than the browser page load timing's pages per minute (ppm). Front end vs. back end chart The Front end vs. back end chart links to the connect APM service application. For details on APM and tracing, see Language agents and distributed tracing. First interaction by device type, First interaction by user agent, JavaScript errors, and Longest first input delay by URL Depending on your subscription level, the following tables and charts may also be on your Summary page: First interaction by device type: Summarizes the Browser page load time page. First interaction by user agent: Summarizes the Browser page load time page. JavaScript errors: Summarizes the JS errors page. Longest first input delay by URL: Summarizes the Browser page load time page. Related Entities widget The Related Entities widget shows all the entities that are related to the browser. To understand more about connections between entities, read about Entity relationships. View Synthetics monitors The button directs you to the Synthetics page. To read more about Synthetics, see Synthetic monitoring.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.25935,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "First interaction by device type, First interaction by user <em>agent</em>, <em>JavaScript</em> errors, and Longest first input delay by URL",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": " minute (ppm). Front end vs. back end chart The Front end vs. back end chart links to the connect APM service application. For details on APM and tracing, see Language <em>agents</em> and distributed tracing. First interaction by device type, First interaction by user <em>agent</em>, <em>Java</em>Script errors, and Longest first"
      },
      "id": "60440d9c196a674ac8960f5b"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Automatically instrumented frameworks and libraries",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-05-04T17:04:41Z",
      "updated_at": "2021-04-05T10:32:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. Java version Agent support Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to current Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Fully supported: IBM JVM versions 7 and 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 7 to 15 for Linux, Windows, and macOS Oracle Hotspot JVM versions 7 to 15 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS Supported only with Java agent 4.3.x [ ZIP | 2.8 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS Supported only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Automatically instrumented frameworks and libraries After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 to latest Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to latest TomEE 1.5 to latest WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to latest JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to latest HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to latest (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon DynamoDB 1.11.106 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the Browser JavaScript agent when you enable auto-instrumentation. After enabling Browser injection, you can view Browser data in the APM Summary page and quickly switch between the APM and Browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.48205,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": " for calls to the <em>get</em>Bulk() API method. The <em>Java</em> <em>agent</em> reports the database name and database server&#x2F;identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, <em>get</em> support at support.newrelic.com"
      },
      "id": "6043b8f6196a6771a9960f87"
    },
    {
      "sections": [
        "Java agent with Scala on Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic add-on",
        "Caution",
        "2. Configure your Heroku environment for New Relic",
        "Custom build.sbt",
        "How to download a custom newrelic.yml",
        "3. Push your changes and open the app",
        "Troubleshooting your installation",
        "For more help"
      ],
      "title": "Java agent with Scala on Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "3e132d7c22df97d5cd8e189047cec608d77f06fd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-scala-heroku/",
      "published_at": "2021-05-05T06:56:48Z",
      "updated_at": "2021-03-11T03:21:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and Browser. Tip For non-Scala installations, see Java agent and Heroku. Compatibility and requirements Java 7 or higher Latest New Relic Java agent version 1. Enable the New Relic add-on After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install New Relic APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Configure your Heroku environment for New Relic After you complete the requirements and enable the New Relic add-on, configure your Scala Heroku environment for New Relic: Edit your Procfile to point to the agent jar in your app's root folder. Replace the contents of the file, substituting X.Y.Z with the latest agent version: web: target/universal/stage/bin/play-getting-started -Dhttp.port=${PORT} -J-javaagent:/app/target/universal/stage/lib/com.newrelic.agent.java.newrelic-agent-X.Y.Z.jar -J-Dnewrelic.config.file=conf/newrelic.yml Copy OR Identify the path to newrelic.jar with the JAVA_OPTS environment variable. Edit your build.sbt. Call the agent, substituting X.Y.Z with the latest Java agent version: Custom build.sbt name := \"\"\"play-getting-started\"\"\" version := \"1.0-SNAPSHOT\" lazy val root = (project in file(\".\")).enablePlugins(PlayScala) scalaVersion := \"2.11.7\" libraryDependencies ++= Seq( jdbc, cache, \"org.postgresql\" % \"postgresql\" % \"9.4-1201-jdbc41\", ws ) libraryDependencies <+= scalaVersion(\"org.scala-lang\" % \"scala-compiler\" % _ ) libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-agent\" % \"X.Y.Z\") libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\") Copy Download a customized newrelic.yml file from your APM account settings: How to download a custom newrelic.yml Log in to dashboard.heroku.com. Select your app. Select Add-ons > New Relic APM. From the New Relic UI's account dropdown, select Account settings. In the Update your New Relic agent section, download the latest agent for your Java SE release. Unzip the downloaded file. Copy newrelic.yml to the scala-getting-started/conf directory: Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 3. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshooting your installation If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find More Add Ons, and add the APM add-on. If no data appears after waiting a few minutes, see No data appears with Heroku (Java). For more help Additional documentation resources include: Java agent and Heroku (for non-Scala installation on Heroku) No data appears with Heroku (troubleshotoing steps after installation) Scala installation for Java (Scala installation if you don't use Heroku)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 99.58816,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "sections": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": ", substituting X.Y.Z with the latest <em>agent</em> version: web: target&#x2F;universal&#x2F;stage&#x2F;bin&#x2F;play-<em>getting</em>-<em>started</em> -Dhttp.port=${PORT} -J-javaagent:&#x2F;app&#x2F;target&#x2F;universal&#x2F;stage&#x2F;lib&#x2F;com.newrelic.<em>agent.java</em>.newrelic-<em>agent</em>-X.Y.Z.jar -J-Dnewrelic.config.file=conf&#x2F;newrelic.yml Copy OR Identify the path to newrelic.jar"
      },
      "id": "6043b879196a670bb4960f4b"
    }
  ],
  "/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent": [
    {
      "sections": [
        "Browser Summary page",
        "View the Summary page",
        "Core Web Vitals widgets",
        "User time on the site",
        "Initial page load and route change chart",
        "User-centric page load times chart",
        "Throughput chart",
        "Tip",
        "Front end vs. back end chart",
        "First interaction by device type, First interaction by user agent, JavaScript errors, and Longest first input delay by URL",
        "Related Entities widget",
        "View Synthetics monitors"
      ],
      "title": "Browser Summary page",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Getting started"
      ],
      "external_id": "a69bb31a3bff73ef8badce5ce435da62e9e7b644",
      "image": "https://docs.newrelic.com/static/d209fe2eab5c7d2da657e515ab49ae4a/c1b63/browser_summary_page.png",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/getting-started/browser-summary-page/",
      "published_at": "2021-05-05T17:32:47Z",
      "updated_at": "2021-05-05T17:32:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's Summary page summarizes the real-user browser performance of your app. Use the Summary page to: View trends in an app's browser-side performance Quickly troubleshoot page load timing issues Navigate to other Browser UI pages View the Summary page To view a summary of browser performance for an app: Go to one.newrelic.com, click Browser, and select an app from the Browser index. From the app's Summary page, use standard New Relic page functions to drill down into detailed information. one.newrelic.com > Browser > (select an app) > Summary: After you select an application from the New Relic Browser apps index, the Summary page shows a summary of browser performance for that app. The Summary page includes: Core Web Vitals widgets User time on the site Initial page load and route change chart User-centric page load times chart Throughput chart Front end vs. back end chart For Browser Pro: Charts for First interaction by device type, First interaction by user agent, JavaScript errors, and Longest first input delay by URL Related Entities widget View Synthetics monitors Core Web Vitals widgets The Core Web Vitals widgets show how your browser performs according to Google's Core Web Vitals. The Core Web Vitals widgets include: LCP - Largest Contentful Paint FID - First Input Delay CLS - Cumulative Layout Shift User time on the site The User time on the site widget shows the time a user remains on the site. Initial page load and route change chart The Initial page load and route change chart shows the load time of a traditional URL change stemming from a load or reload of a URL. This chart appears with more detail about the page load timing process on the Browser page load time page. User-centric page load times chart The User-centric page load times chart shows the load time of a page for a user. This chart appears with more detail about the page load timing process on the Browser page load time page. Throughput chart The Throughput chart displays browser throughput as pages per minute (ppm). The value in the upper right of the chart is the average value for the selected time range. If you have enabled SPA monitoring enabled and the Summary page shows the SPA load time chart, the Throughput chart will also use SPA data. Tip App server requests per minute (rpm) may show a different measurement than the browser page load timing's pages per minute (ppm). Front end vs. back end chart The Front end vs. back end chart links to the connect APM service application. For details on APM and tracing, see Language agents and distributed tracing. First interaction by device type, First interaction by user agent, JavaScript errors, and Longest first input delay by URL Depending on your subscription level, the following tables and charts may also be on your Summary page: First interaction by device type: Summarizes the Browser page load time page. First interaction by user agent: Summarizes the Browser page load time page. JavaScript errors: Summarizes the JS errors page. Longest first input delay by URL: Summarizes the Browser page load time page. Related Entities widget The Related Entities widget shows all the entities that are related to the browser. To understand more about connections between entities, read about Entity relationships. View Synthetics monitors The button directs you to the Synthetics page. To read more about Synthetics, see Synthetic monitoring.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.25935,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "First interaction by device type, First interaction by user <em>agent</em>, <em>JavaScript</em> errors, and Longest first input delay by URL",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": " minute (ppm). Front end vs. back end chart The Front end vs. back end chart links to the connect APM service application. For details on APM and tracing, see Language <em>agents</em> and distributed tracing. First interaction by device type, First interaction by user <em>agent</em>, <em>Java</em>Script errors, and Longest first"
      },
      "id": "60440d9c196a674ac8960f5b"
    },
    {
      "sections": [
        "Java agent with Scala on Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic add-on",
        "Caution",
        "2. Configure your Heroku environment for New Relic",
        "Custom build.sbt",
        "How to download a custom newrelic.yml",
        "3. Push your changes and open the app",
        "Troubleshooting your installation",
        "For more help"
      ],
      "title": "Java agent with Scala on Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "3e132d7c22df97d5cd8e189047cec608d77f06fd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-scala-heroku/",
      "published_at": "2021-05-05T06:56:48Z",
      "updated_at": "2021-03-11T03:21:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and Browser. Tip For non-Scala installations, see Java agent and Heroku. Compatibility and requirements Java 7 or higher Latest New Relic Java agent version 1. Enable the New Relic add-on After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install New Relic APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Configure your Heroku environment for New Relic After you complete the requirements and enable the New Relic add-on, configure your Scala Heroku environment for New Relic: Edit your Procfile to point to the agent jar in your app's root folder. Replace the contents of the file, substituting X.Y.Z with the latest agent version: web: target/universal/stage/bin/play-getting-started -Dhttp.port=${PORT} -J-javaagent:/app/target/universal/stage/lib/com.newrelic.agent.java.newrelic-agent-X.Y.Z.jar -J-Dnewrelic.config.file=conf/newrelic.yml Copy OR Identify the path to newrelic.jar with the JAVA_OPTS environment variable. Edit your build.sbt. Call the agent, substituting X.Y.Z with the latest Java agent version: Custom build.sbt name := \"\"\"play-getting-started\"\"\" version := \"1.0-SNAPSHOT\" lazy val root = (project in file(\".\")).enablePlugins(PlayScala) scalaVersion := \"2.11.7\" libraryDependencies ++= Seq( jdbc, cache, \"org.postgresql\" % \"postgresql\" % \"9.4-1201-jdbc41\", ws ) libraryDependencies <+= scalaVersion(\"org.scala-lang\" % \"scala-compiler\" % _ ) libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-agent\" % \"X.Y.Z\") libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\") Copy Download a customized newrelic.yml file from your APM account settings: How to download a custom newrelic.yml Log in to dashboard.heroku.com. Select your app. Select Add-ons > New Relic APM. From the New Relic UI's account dropdown, select Account settings. In the Update your New Relic agent section, download the latest agent for your Java SE release. Unzip the downloaded file. Copy newrelic.yml to the scala-getting-started/conf directory: Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 3. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshooting your installation If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find More Add Ons, and add the APM add-on. If no data appears after waiting a few minutes, see No data appears with Heroku (Java). For more help Additional documentation resources include: Java agent and Heroku (for non-Scala installation on Heroku) No data appears with Heroku (troubleshotoing steps after installation) Scala installation for Java (Scala installation if you don't use Heroku)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 99.58816,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "sections": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": ", substituting X.Y.Z with the latest <em>agent</em> version: web: target&#x2F;universal&#x2F;stage&#x2F;bin&#x2F;play-<em>getting</em>-<em>started</em> -Dhttp.port=${PORT} -J-javaagent:&#x2F;app&#x2F;target&#x2F;universal&#x2F;stage&#x2F;lib&#x2F;com.newrelic.<em>agent.java</em>.newrelic-<em>agent</em>-X.Y.Z.jar -J-Dnewrelic.config.file=conf&#x2F;newrelic.yml Copy OR Identify the path to newrelic.jar"
      },
      "id": "6043b879196a670bb4960f4b"
    },
    {
      "sections": [
        "APM agent security: Java",
        "Default security settings",
        "Caution",
        "High security mode settings",
        "Custom security settings"
      ],
      "title": "APM agent security: Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "fd9f5744c001453dbb9f129480f4e7e5ce42a176",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/apm-agent-security-java/",
      "published_at": "2021-05-05T06:41:12Z",
      "updated_at": "2021-03-11T02:31:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent default security settings automatically provide security for your APM data to ensure data privacy and to limit the kind of information New Relic receives. You may have business reasons to change these settings. If you want to restrict the information that New Relic receives, you can enable high security mode. If high security mode or the default settings do not work for your business needs, you can apply custom settings. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Default security settings Caution Stack traces cannot be obfuscated and may contain sensitive information, including SQL queries. For more information about ignoring errors, see Java agent error configuration. By default, here is how the New Relic Java agent handles the following potentially sensitive data:: Request parameters: The agent does not capture HTTP request parameters. HTTPS: The agent communicates with New Relic using HTTPS. SQL: The agent sets SQL recording to obfuscated, which removes the potentially sensitive numeric and string literal values. High security mode settings When you enable high security mode, the default settings are locked so that users cannot change them. In addition: The agent does not collect message queue parameters. You cannot create custom events. You cannot implement custom instrumentation using the Custom Instrumentation Editor. You cannot collect user attributes. Custom security settings Caution If you customize security settings, it may impact the security of your application. If you need different security settings than default or high security mode, you can customize these settings: Java agent configuration file Custom attributes Java agent API Setting Effects on data security audit_mode boolean Default: false By default, the Java agent does not log all data sent to New Relic in the agent log file. If you set this to true, the agent logs data sent to the New Relic collector in the agent log file. You can then evaluate the information that the agent sends by reviewing the agent log file to see if it includes sensitive information. high_security boolean Default: false To enable high security mode, set this to true and enable high security in New Relic. This restricts the information you can send to New Relic. proxy_host string Default: (none) Some proxies default to using HTTP, which is a less secure protocol. attributes.enabled boolean Default: true Default for the Custom Instrumentation Editor: false By default, you are sending attributes to New Relic, except for methods instrumented using the Custom Instrumentation Editor. If you do not want to send attributes to New Relic, set this to false. attributes.exclude string Default: (none) If there are specific attribute keys that you do not want to send to New Relic in transaction traces, identify them using attributes.exclude. This restricts the information sent to New Relic. Consider if you want to exclude these potentially sensitive attributes using attributes.exclude or if you need the information sent to New Relic: request.headers.*: Removes all request headers. (Note that HTTP headers that contain sensitive data such as cookie and authorization are never collected.) response.headers.*: Removes all response headers. request_uri: Removes the path for the transaction's incoming request. log_sql boolean Default: false By default, you are sending queries to New Relic using record_sql. If you want to log queries in the agent log file as well as send them to New Relic, set this to true. record_sql string Default: obfuscated By default, record_sql is set to obfuscated, which strips out the numeric and string literals. If you do not want the agent to capture query information, set this to off. If you want the agent to capture all query information in its original form, set this to raw. When you enable high security mode, this is automatically set to obfuscated. strip_exception_messages boolean Default: false By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you enable high security mode, this is automatically changed to true, and the agent strips the messages from exceptions. If you are not using high security mode but still want to strip messages from all exceptions except those in your allow list, set this to true. custom_insights_events.enabled boolean Default: true By default, the agent records events sent to the Insights custom events API via recordCustomEvent(). If you enable high security mode, this is automatically set to false.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 97.53503,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM <em>agent</em> security: <em>Java</em>",
        "sections": "APM <em>agent</em> security: <em>Java</em>",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> default security settings automatically provide security for your APM data to ensure data privacy and to limit the kind of information New Relic receives. You may have business reasons to change these settings. If you want to restrict the information that New Relic receives"
      },
      "id": "6043b8bb28ccbc3db92c60b7"
    }
  ],
  "/docs/agents/java-agent/getting-started/introduction-new-relic-java": [
    {
      "sections": [
        "Browser Summary page",
        "View the Summary page",
        "Core Web Vitals widgets",
        "User time on the site",
        "Initial page load and route change chart",
        "User-centric page load times chart",
        "Throughput chart",
        "Tip",
        "Front end vs. back end chart",
        "First interaction by device type, First interaction by user agent, JavaScript errors, and Longest first input delay by URL",
        "Related Entities widget",
        "View Synthetics monitors"
      ],
      "title": "Browser Summary page",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Getting started"
      ],
      "external_id": "a69bb31a3bff73ef8badce5ce435da62e9e7b644",
      "image": "https://docs.newrelic.com/static/d209fe2eab5c7d2da657e515ab49ae4a/c1b63/browser_summary_page.png",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/getting-started/browser-summary-page/",
      "published_at": "2021-05-05T17:32:47Z",
      "updated_at": "2021-05-05T17:32:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's Summary page summarizes the real-user browser performance of your app. Use the Summary page to: View trends in an app's browser-side performance Quickly troubleshoot page load timing issues Navigate to other Browser UI pages View the Summary page To view a summary of browser performance for an app: Go to one.newrelic.com, click Browser, and select an app from the Browser index. From the app's Summary page, use standard New Relic page functions to drill down into detailed information. one.newrelic.com > Browser > (select an app) > Summary: After you select an application from the New Relic Browser apps index, the Summary page shows a summary of browser performance for that app. The Summary page includes: Core Web Vitals widgets User time on the site Initial page load and route change chart User-centric page load times chart Throughput chart Front end vs. back end chart For Browser Pro: Charts for First interaction by device type, First interaction by user agent, JavaScript errors, and Longest first input delay by URL Related Entities widget View Synthetics monitors Core Web Vitals widgets The Core Web Vitals widgets show how your browser performs according to Google's Core Web Vitals. The Core Web Vitals widgets include: LCP - Largest Contentful Paint FID - First Input Delay CLS - Cumulative Layout Shift User time on the site The User time on the site widget shows the time a user remains on the site. Initial page load and route change chart The Initial page load and route change chart shows the load time of a traditional URL change stemming from a load or reload of a URL. This chart appears with more detail about the page load timing process on the Browser page load time page. User-centric page load times chart The User-centric page load times chart shows the load time of a page for a user. This chart appears with more detail about the page load timing process on the Browser page load time page. Throughput chart The Throughput chart displays browser throughput as pages per minute (ppm). The value in the upper right of the chart is the average value for the selected time range. If you have enabled SPA monitoring enabled and the Summary page shows the SPA load time chart, the Throughput chart will also use SPA data. Tip App server requests per minute (rpm) may show a different measurement than the browser page load timing's pages per minute (ppm). Front end vs. back end chart The Front end vs. back end chart links to the connect APM service application. For details on APM and tracing, see Language agents and distributed tracing. First interaction by device type, First interaction by user agent, JavaScript errors, and Longest first input delay by URL Depending on your subscription level, the following tables and charts may also be on your Summary page: First interaction by device type: Summarizes the Browser page load time page. First interaction by user agent: Summarizes the Browser page load time page. JavaScript errors: Summarizes the JS errors page. Longest first input delay by URL: Summarizes the Browser page load time page. Related Entities widget The Related Entities widget shows all the entities that are related to the browser. To understand more about connections between entities, read about Entity relationships. View Synthetics monitors The button directs you to the Synthetics page. To read more about Synthetics, see Synthetic monitoring.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.25928,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "First interaction by device type, First interaction by user <em>agent</em>, <em>JavaScript</em> errors, and Longest first input delay by URL",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": " minute (ppm). Front end vs. back end chart The Front end vs. back end chart links to the connect APM service application. For details on APM and tracing, see Language <em>agents</em> and distributed tracing. First interaction by device type, First interaction by user <em>agent</em>, <em>Java</em>Script errors, and Longest first"
      },
      "id": "60440d9c196a674ac8960f5b"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Automatically instrumented frameworks and libraries",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-05-04T17:04:41Z",
      "updated_at": "2021-04-05T10:32:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. Java version Agent support Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to current Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Fully supported: IBM JVM versions 7 and 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 7 to 15 for Linux, Windows, and macOS Oracle Hotspot JVM versions 7 to 15 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS Supported only with Java agent 4.3.x [ ZIP | 2.8 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS Supported only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Automatically instrumented frameworks and libraries After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 to latest Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to latest TomEE 1.5 to latest WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to latest JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to latest HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to latest (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon DynamoDB 1.11.106 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the Browser JavaScript agent when you enable auto-instrumentation. After enabling Browser injection, you can view Browser data in the APM Summary page and quickly switch between the APM and Browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.48204,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": " for calls to the <em>get</em>Bulk() API method. The <em>Java</em> <em>agent</em> reports the database name and database server&#x2F;identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, <em>get</em> support at support.newrelic.com"
      },
      "id": "6043b8f6196a6771a9960f87"
    },
    {
      "sections": [
        "Java agent with Scala on Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic add-on",
        "Caution",
        "2. Configure your Heroku environment for New Relic",
        "Custom build.sbt",
        "How to download a custom newrelic.yml",
        "3. Push your changes and open the app",
        "Troubleshooting your installation",
        "For more help"
      ],
      "title": "Java agent with Scala on Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "3e132d7c22df97d5cd8e189047cec608d77f06fd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-scala-heroku/",
      "published_at": "2021-05-05T06:56:48Z",
      "updated_at": "2021-03-11T03:21:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and Browser. Tip For non-Scala installations, see Java agent and Heroku. Compatibility and requirements Java 7 or higher Latest New Relic Java agent version 1. Enable the New Relic add-on After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install New Relic APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Configure your Heroku environment for New Relic After you complete the requirements and enable the New Relic add-on, configure your Scala Heroku environment for New Relic: Edit your Procfile to point to the agent jar in your app's root folder. Replace the contents of the file, substituting X.Y.Z with the latest agent version: web: target/universal/stage/bin/play-getting-started -Dhttp.port=${PORT} -J-javaagent:/app/target/universal/stage/lib/com.newrelic.agent.java.newrelic-agent-X.Y.Z.jar -J-Dnewrelic.config.file=conf/newrelic.yml Copy OR Identify the path to newrelic.jar with the JAVA_OPTS environment variable. Edit your build.sbt. Call the agent, substituting X.Y.Z with the latest Java agent version: Custom build.sbt name := \"\"\"play-getting-started\"\"\" version := \"1.0-SNAPSHOT\" lazy val root = (project in file(\".\")).enablePlugins(PlayScala) scalaVersion := \"2.11.7\" libraryDependencies ++= Seq( jdbc, cache, \"org.postgresql\" % \"postgresql\" % \"9.4-1201-jdbc41\", ws ) libraryDependencies <+= scalaVersion(\"org.scala-lang\" % \"scala-compiler\" % _ ) libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-agent\" % \"X.Y.Z\") libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\") Copy Download a customized newrelic.yml file from your APM account settings: How to download a custom newrelic.yml Log in to dashboard.heroku.com. Select your app. Select Add-ons > New Relic APM. From the New Relic UI's account dropdown, select Account settings. In the Update your New Relic agent section, download the latest agent for your Java SE release. Unzip the downloaded file. Copy newrelic.yml to the scala-getting-started/conf directory: Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 3. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshooting your installation If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find More Add Ons, and add the APM add-on. If no data appears after waiting a few minutes, see No data appears with Heroku (Java). For more help Additional documentation resources include: Java agent and Heroku (for non-Scala installation on Heroku) No data appears with Heroku (troubleshotoing steps after installation) Scala installation for Java (Scala installation if you don't use Heroku)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 99.58816,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "sections": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": ", substituting X.Y.Z with the latest <em>agent</em> version: web: target&#x2F;universal&#x2F;stage&#x2F;bin&#x2F;play-<em>getting</em>-<em>started</em> -Dhttp.port=${PORT} -J-javaagent:&#x2F;app&#x2F;target&#x2F;universal&#x2F;stage&#x2F;lib&#x2F;com.newrelic.<em>agent.java</em>.newrelic-<em>agent</em>-X.Y.Z.jar -J-Dnewrelic.config.file=conf&#x2F;newrelic.yml Copy OR Identify the path to newrelic.jar"
      },
      "id": "6043b879196a670bb4960f4b"
    }
  ],
  "/docs/agents/java-agent/heroku/java-agent-heroku": [
    {
      "sections": [
        "No data appears with Heroku (Java)",
        "Problem",
        "Solution"
      ],
      "title": "No data appears with Heroku (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "b08d6638b319ee5716e462566e8a8ad54a63fec5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/no-data-appears-heroku-java/",
      "published_at": "2021-05-05T06:57:49Z",
      "updated_at": "2021-03-11T03:21:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Problem After waiting a few minutes, data is not appearing in your Heroku app's APM Summary page. Solution Check the Heroku logs for errors with this Heroku toolbelt command: heroku logs --tail Copy Check that the files in your Heroku dyno match the file modifications from the Java on Heroku or Java with Scala on Heroku installation procedures. Use this Heroku toolbelt command: heroku run bash Copy Try the steps in No data appears (Java).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 125.24574,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "No data appears with <em>Heroku</em> (<em>Java</em>)",
        "sections": "No data appears with <em>Heroku</em> (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Problem After waiting a few minutes, data is not appearing in your <em>Heroku</em> app&#x27;s APM Summary page. Solution Check the <em>Heroku</em> logs for errors with this <em>Heroku</em> toolbelt command: <em>heroku</em> logs --tail Copy Check that the files in your <em>Heroku</em> dyno match the file modifications from the <em>Java</em> on <em>Heroku</em> or <em>Java</em> with Scala on <em>Heroku</em> installation procedures. Use this <em>Heroku</em> toolbelt command: <em>heroku</em> run bash Copy Try the steps in No data appears (<em>Java</em>)."
      },
      "id": "6043b7c9e7b9d29b015799da"
    },
    {
      "sections": [
        "Java agent with Scala on Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic add-on",
        "Caution",
        "2. Configure your Heroku environment for New Relic",
        "Custom build.sbt",
        "How to download a custom newrelic.yml",
        "3. Push your changes and open the app",
        "Troubleshooting your installation",
        "For more help"
      ],
      "title": "Java agent with Scala on Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "3e132d7c22df97d5cd8e189047cec608d77f06fd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-scala-heroku/",
      "published_at": "2021-05-05T06:56:48Z",
      "updated_at": "2021-03-11T03:21:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and Browser. Tip For non-Scala installations, see Java agent and Heroku. Compatibility and requirements Java 7 or higher Latest New Relic Java agent version 1. Enable the New Relic add-on After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install New Relic APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Configure your Heroku environment for New Relic After you complete the requirements and enable the New Relic add-on, configure your Scala Heroku environment for New Relic: Edit your Procfile to point to the agent jar in your app's root folder. Replace the contents of the file, substituting X.Y.Z with the latest agent version: web: target/universal/stage/bin/play-getting-started -Dhttp.port=${PORT} -J-javaagent:/app/target/universal/stage/lib/com.newrelic.agent.java.newrelic-agent-X.Y.Z.jar -J-Dnewrelic.config.file=conf/newrelic.yml Copy OR Identify the path to newrelic.jar with the JAVA_OPTS environment variable. Edit your build.sbt. Call the agent, substituting X.Y.Z with the latest Java agent version: Custom build.sbt name := \"\"\"play-getting-started\"\"\" version := \"1.0-SNAPSHOT\" lazy val root = (project in file(\".\")).enablePlugins(PlayScala) scalaVersion := \"2.11.7\" libraryDependencies ++= Seq( jdbc, cache, \"org.postgresql\" % \"postgresql\" % \"9.4-1201-jdbc41\", ws ) libraryDependencies <+= scalaVersion(\"org.scala-lang\" % \"scala-compiler\" % _ ) libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-agent\" % \"X.Y.Z\") libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\") Copy Download a customized newrelic.yml file from your APM account settings: How to download a custom newrelic.yml Log in to dashboard.heroku.com. Select your app. Select Add-ons > New Relic APM. From the New Relic UI's account dropdown, select Account settings. In the Update your New Relic agent section, download the latest agent for your Java SE release. Unzip the downloaded file. Copy newrelic.yml to the scala-getting-started/conf directory: Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 3. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshooting your installation If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find More Add Ons, and add the APM add-on. If no data appears after waiting a few minutes, see No data appears with Heroku (Java). For more help Additional documentation resources include: Java agent and Heroku (for non-Scala installation on Heroku) No data appears with Heroku (troubleshotoing steps after installation) Scala installation for Java (Scala installation if you don't use Heroku)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 125.24574,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> with Scala on <em>Heroku</em>",
        "sections": "<em>Java</em> <em>agent</em> with Scala on <em>Heroku</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "<em>Heroku</em> is a Platform as a Service (PaaS) solution for hosting web applications in various <em>agent</em> languages, including Scala. With New Relic, you can extend <em>Heroku</em> with metrics from APM and Browser. Tip For non-Scala installations, see <em>Java</em> <em>agent</em> and <em>Heroku</em>. Compatibility and requirements <em>Java</em> 7"
      },
      "id": "6043b879196a670bb4960f4b"
    },
    {
      "sections": [
        "Scala instrumentation",
        "Tip",
        "Scala frameworks",
        "Instrument Scala with the Java agent API",
        "Configure using the project/build.scala file",
        "Configure using the project/build.sbt file",
        "More API functions",
        "Additional instrumentation"
      ],
      "title": "Scala instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "7affd5ca652f6d59905d8cfc5ea4e6a57ffe793d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/frameworks/scala-installation-java/",
      "published_at": "2021-05-05T06:53:29Z",
      "updated_at": "2021-03-11T02:30:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent is compatible with Scala, and supports New Relic API calls, annotations, and custom instrumentation. All information below is supplemental to New Relic's Java agent installation directions. Tip For Heroku, see Java agent with Scala on Heroku. Scala frameworks If your framework is not natively supported by New Relic, or if you want to set up additional monitoring, custom instrumentation is a great way to dig deeper into your application. Instrument Scala with the Java agent API Instrument Scala to use the New Relic API class or annotations. Add the following information to your Scala configuration file: Configure using the project/build.scala file Add the following line (replacing X.Y.Z with the Java agent version you use) to the appDependencies method in your application's project/build.scala file: \"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\" Copy Configure using the project/build.sbt file Add the following line (replacing X.Y.Z with the Java agent version you use) to your application's project/build.sbt file: libraryDependencies += \"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\" Copy Import the NewRelic class and use it in your application: import com.newrelic.api.agent.NewRelic ... NewRelic.setTransactionName(null, \"/myTransaction\"); Copy More API functions For more about the Java agent API and its functionality, see the Java agent API introduction. Additional instrumentation If you use Kamon, take a look at the New Relic Kamon reporter.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.29722,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Instrument Scala with the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> is compatible with Scala, and supports New Relic API calls, annotations, and custom instrumentation. All information below is supplemental to New Relic&#x27;s <em>Java</em> <em>agent</em> installation directions. Tip For <em>Heroku</em>, see <em>Java</em> <em>agent</em> with Scala on <em>Heroku</em>. Scala frameworks If your"
      },
      "id": "6043b8bb196a671be4960f24"
    }
  ],
  "/docs/agents/java-agent/heroku/java-agent-scala-heroku": [
    {
      "sections": [
        "No data appears with Heroku (Java)",
        "Problem",
        "Solution"
      ],
      "title": "No data appears with Heroku (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "b08d6638b319ee5716e462566e8a8ad54a63fec5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/no-data-appears-heroku-java/",
      "published_at": "2021-05-05T06:57:49Z",
      "updated_at": "2021-03-11T03:21:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Problem After waiting a few minutes, data is not appearing in your Heroku app's APM Summary page. Solution Check the Heroku logs for errors with this Heroku toolbelt command: heroku logs --tail Copy Check that the files in your Heroku dyno match the file modifications from the Java on Heroku or Java with Scala on Heroku installation procedures. Use this Heroku toolbelt command: heroku run bash Copy Try the steps in No data appears (Java).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 125.24574,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "No data appears with <em>Heroku</em> (<em>Java</em>)",
        "sections": "No data appears with <em>Heroku</em> (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Problem After waiting a few minutes, data is not appearing in your <em>Heroku</em> app&#x27;s APM Summary page. Solution Check the <em>Heroku</em> logs for errors with this <em>Heroku</em> toolbelt command: <em>heroku</em> logs --tail Copy Check that the files in your <em>Heroku</em> dyno match the file modifications from the <em>Java</em> on <em>Heroku</em> or <em>Java</em> with Scala on <em>Heroku</em> installation procedures. Use this <em>Heroku</em> toolbelt command: <em>heroku</em> run bash Copy Try the steps in No data appears (<em>Java</em>)."
      },
      "id": "6043b7c9e7b9d29b015799da"
    },
    {
      "sections": [
        "Java agent and Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic agent add-on in Heroku",
        "Caution",
        "2. Provide the path to the jar file",
        "Deploy to Heroku",
        "Deploy locally",
        "3. Configure your Heroku environment for New Relic",
        "Maven configuration",
        "Manual configuration",
        "4. Push your changes and open the app",
        "Troubleshoot",
        "For more help"
      ],
      "title": "Java agent and Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "24069e33fc3bf337ebce684631a398f68eeb4d3b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-heroku/",
      "published_at": "2021-05-05T06:59:42Z",
      "updated_at": "2021-03-11T02:28:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Java. With New Relic, you can extend Heroku with metrics from APM or Browser. Tip If you use Scala, see Java agent Scala procedures for Heroku. Compatibility and requirements Java 7 or higher Maven 3 or higher (if you are using Maven) Latest New Relic Java agent version 1. Enable the New Relic agent add-on in Heroku After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install New Relic APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Provide the path to the jar file After you enable the New Relic agent add-on, pass the javaagent flag to the java process and provide the path to the jar file by editing your Procfile. Deploy to Heroku If you deploy to Heroku, the location of the jar file for both Maven and manual configuration is in the app's root folder in a directory called newrelic. Example: web: java -javaagent:/app/newrelic/newrelic.jar -jar target/HELLOWORLD.jar Copy Deploy locally If you deploy locally, your jar file might be in a different directory. If it is, replace PATH/TO/NEWRELIC.JAR with the path to the jar file in your local directory. Example: web: java -javaagent:PATH/TO/NEWRELIC.JAR -jar target/HELLOWORLD.jar Copy 3. Configure your Heroku environment for New Relic After you provide the path to the jar file, configure your Heroku environment for New Relic, depending on your platform: Maven configuration Give your app a meaningful name with this Heroku toolbelt command: heroku config:set NEW_RELIC_APP_NAME=\"APP_NAME\" Copy Add your New Relic license key: heroku config:set NEW_RELIC_LICENSE_KEY=\"LICENSE_KEY\" Copy In your pom.xml, add the newrelic-agent dependency, substituting X.Y.Z with the latest Java agent version. Recommended: To ensure proper formatting is applied and contents do not contain sensitive information, format the syntax using http://codebeautify.org/xmlviewer. <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>X.Y.Z</version> <scope>provided</scope> <type>zip</type> </dependency> Copy In the <build> element of pom.xml, customize the build so it downloads the agent: <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.0.2</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.basedir}</outputDirectory> <destFileName>newrelic</destFileName> </configuration> </execution> </executions> </plugin> Copy Manual configuration Log in to dashboard.heroku.com. Select your app. Select Add-ons > New Relic APM. From the New Relic UI's account dropdown, select Account settings. In the Update your New Relic agent section, download the latest agent release for your Java SE release. Unzip the file into your app root. Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 4. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshoot Here are some tips to help you troubleshoot: If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find More Add Ons, and add the APM add-on. If no data appears after waiting a few minutes, follow the troubleshooting procedures for Heroku (Java). For more help Additional documentation resources include: Heroku and New Relic (additional topics for Heroku users) Heroku Dev Center (information on the Heroku site on installing New Relic)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 125.23556,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> and <em>Heroku</em>",
        "sections": "<em>Java</em> <em>agent</em> and <em>Heroku</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "<em>Heroku</em> is a Platform as a Service (PaaS) solution for hosting web applications in various <em>agent</em> languages, including <em>Java</em>. With New Relic, you can extend <em>Heroku</em> with metrics from APM or Browser. Tip If you use Scala, see <em>Java</em> <em>agent</em> Scala procedures for <em>Heroku</em>. Compatibility and requirements <em>Java</em> 7"
      },
      "id": "6043ba0f64441f731e378ee0"
    },
    {
      "sections": [
        "Scala instrumentation",
        "Tip",
        "Scala frameworks",
        "Instrument Scala with the Java agent API",
        "Configure using the project/build.scala file",
        "Configure using the project/build.sbt file",
        "More API functions",
        "Additional instrumentation"
      ],
      "title": "Scala instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "7affd5ca652f6d59905d8cfc5ea4e6a57ffe793d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/frameworks/scala-installation-java/",
      "published_at": "2021-05-05T06:53:29Z",
      "updated_at": "2021-03-11T02:30:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent is compatible with Scala, and supports New Relic API calls, annotations, and custom instrumentation. All information below is supplemental to New Relic's Java agent installation directions. Tip For Heroku, see Java agent with Scala on Heroku. Scala frameworks If your framework is not natively supported by New Relic, or if you want to set up additional monitoring, custom instrumentation is a great way to dig deeper into your application. Instrument Scala with the Java agent API Instrument Scala to use the New Relic API class or annotations. Add the following information to your Scala configuration file: Configure using the project/build.scala file Add the following line (replacing X.Y.Z with the Java agent version you use) to the appDependencies method in your application's project/build.scala file: \"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\" Copy Configure using the project/build.sbt file Add the following line (replacing X.Y.Z with the Java agent version you use) to your application's project/build.sbt file: libraryDependencies += \"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\" Copy Import the NewRelic class and use it in your application: import com.newrelic.api.agent.NewRelic ... NewRelic.setTransactionName(null, \"/myTransaction\"); Copy More API functions For more about the Java agent API and its functionality, see the Java agent API introduction. Additional instrumentation If you use Kamon, take a look at the New Relic Kamon reporter.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.29722,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Instrument Scala with the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> is compatible with Scala, and supports New Relic API calls, annotations, and custom instrumentation. All information below is supplemental to New Relic&#x27;s <em>Java</em> <em>agent</em> installation directions. Tip For <em>Heroku</em>, see <em>Java</em> <em>agent</em> with Scala on <em>Heroku</em>. Scala frameworks If your"
      },
      "id": "6043b8bb196a671be4960f24"
    }
  ],
  "/docs/agents/java-agent/heroku/no-data-appears-heroku-java": [
    {
      "sections": [
        "Java agent with Scala on Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic add-on",
        "Caution",
        "2. Configure your Heroku environment for New Relic",
        "Custom build.sbt",
        "How to download a custom newrelic.yml",
        "3. Push your changes and open the app",
        "Troubleshooting your installation",
        "For more help"
      ],
      "title": "Java agent with Scala on Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "3e132d7c22df97d5cd8e189047cec608d77f06fd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-scala-heroku/",
      "published_at": "2021-05-05T06:56:48Z",
      "updated_at": "2021-03-11T03:21:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and Browser. Tip For non-Scala installations, see Java agent and Heroku. Compatibility and requirements Java 7 or higher Latest New Relic Java agent version 1. Enable the New Relic add-on After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install New Relic APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Configure your Heroku environment for New Relic After you complete the requirements and enable the New Relic add-on, configure your Scala Heroku environment for New Relic: Edit your Procfile to point to the agent jar in your app's root folder. Replace the contents of the file, substituting X.Y.Z with the latest agent version: web: target/universal/stage/bin/play-getting-started -Dhttp.port=${PORT} -J-javaagent:/app/target/universal/stage/lib/com.newrelic.agent.java.newrelic-agent-X.Y.Z.jar -J-Dnewrelic.config.file=conf/newrelic.yml Copy OR Identify the path to newrelic.jar with the JAVA_OPTS environment variable. Edit your build.sbt. Call the agent, substituting X.Y.Z with the latest Java agent version: Custom build.sbt name := \"\"\"play-getting-started\"\"\" version := \"1.0-SNAPSHOT\" lazy val root = (project in file(\".\")).enablePlugins(PlayScala) scalaVersion := \"2.11.7\" libraryDependencies ++= Seq( jdbc, cache, \"org.postgresql\" % \"postgresql\" % \"9.4-1201-jdbc41\", ws ) libraryDependencies <+= scalaVersion(\"org.scala-lang\" % \"scala-compiler\" % _ ) libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-agent\" % \"X.Y.Z\") libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\") Copy Download a customized newrelic.yml file from your APM account settings: How to download a custom newrelic.yml Log in to dashboard.heroku.com. Select your app. Select Add-ons > New Relic APM. From the New Relic UI's account dropdown, select Account settings. In the Update your New Relic agent section, download the latest agent for your Java SE release. Unzip the downloaded file. Copy newrelic.yml to the scala-getting-started/conf directory: Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 3. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshooting your installation If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find More Add Ons, and add the APM add-on. If no data appears after waiting a few minutes, see No data appears with Heroku (Java). For more help Additional documentation resources include: Java agent and Heroku (for non-Scala installation on Heroku) No data appears with Heroku (troubleshotoing steps after installation) Scala installation for Java (Scala installation if you don't use Heroku)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 125.24574,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> with Scala on <em>Heroku</em>",
        "sections": "<em>Java</em> <em>agent</em> with Scala on <em>Heroku</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "<em>Heroku</em> is a Platform as a Service (PaaS) solution for hosting web applications in various <em>agent</em> languages, including Scala. With New Relic, you can extend <em>Heroku</em> with metrics from APM and Browser. Tip For non-Scala installations, see <em>Java</em> <em>agent</em> and <em>Heroku</em>. Compatibility and requirements <em>Java</em> 7"
      },
      "id": "6043b879196a670bb4960f4b"
    },
    {
      "sections": [
        "Java agent and Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic agent add-on in Heroku",
        "Caution",
        "2. Provide the path to the jar file",
        "Deploy to Heroku",
        "Deploy locally",
        "3. Configure your Heroku environment for New Relic",
        "Maven configuration",
        "Manual configuration",
        "4. Push your changes and open the app",
        "Troubleshoot",
        "For more help"
      ],
      "title": "Java agent and Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "24069e33fc3bf337ebce684631a398f68eeb4d3b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-heroku/",
      "published_at": "2021-05-05T06:59:42Z",
      "updated_at": "2021-03-11T02:28:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Java. With New Relic, you can extend Heroku with metrics from APM or Browser. Tip If you use Scala, see Java agent Scala procedures for Heroku. Compatibility and requirements Java 7 or higher Maven 3 or higher (if you are using Maven) Latest New Relic Java agent version 1. Enable the New Relic agent add-on in Heroku After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install New Relic APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Provide the path to the jar file After you enable the New Relic agent add-on, pass the javaagent flag to the java process and provide the path to the jar file by editing your Procfile. Deploy to Heroku If you deploy to Heroku, the location of the jar file for both Maven and manual configuration is in the app's root folder in a directory called newrelic. Example: web: java -javaagent:/app/newrelic/newrelic.jar -jar target/HELLOWORLD.jar Copy Deploy locally If you deploy locally, your jar file might be in a different directory. If it is, replace PATH/TO/NEWRELIC.JAR with the path to the jar file in your local directory. Example: web: java -javaagent:PATH/TO/NEWRELIC.JAR -jar target/HELLOWORLD.jar Copy 3. Configure your Heroku environment for New Relic After you provide the path to the jar file, configure your Heroku environment for New Relic, depending on your platform: Maven configuration Give your app a meaningful name with this Heroku toolbelt command: heroku config:set NEW_RELIC_APP_NAME=\"APP_NAME\" Copy Add your New Relic license key: heroku config:set NEW_RELIC_LICENSE_KEY=\"LICENSE_KEY\" Copy In your pom.xml, add the newrelic-agent dependency, substituting X.Y.Z with the latest Java agent version. Recommended: To ensure proper formatting is applied and contents do not contain sensitive information, format the syntax using http://codebeautify.org/xmlviewer. <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>X.Y.Z</version> <scope>provided</scope> <type>zip</type> </dependency> Copy In the <build> element of pom.xml, customize the build so it downloads the agent: <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.0.2</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.basedir}</outputDirectory> <destFileName>newrelic</destFileName> </configuration> </execution> </executions> </plugin> Copy Manual configuration Log in to dashboard.heroku.com. Select your app. Select Add-ons > New Relic APM. From the New Relic UI's account dropdown, select Account settings. In the Update your New Relic agent section, download the latest agent release for your Java SE release. Unzip the file into your app root. Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 4. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshoot Here are some tips to help you troubleshoot: If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find More Add Ons, and add the APM add-on. If no data appears after waiting a few minutes, follow the troubleshooting procedures for Heroku (Java). For more help Additional documentation resources include: Heroku and New Relic (additional topics for Heroku users) Heroku Dev Center (information on the Heroku site on installing New Relic)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 125.23556,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> and <em>Heroku</em>",
        "sections": "<em>Java</em> <em>agent</em> and <em>Heroku</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "<em>Heroku</em> is a Platform as a Service (PaaS) solution for hosting web applications in various <em>agent</em> languages, including <em>Java</em>. With New Relic, you can extend <em>Heroku</em> with metrics from APM or Browser. Tip If you use Scala, see <em>Java</em> <em>agent</em> Scala procedures for <em>Heroku</em>. Compatibility and requirements <em>Java</em> 7"
      },
      "id": "6043ba0f64441f731e378ee0"
    },
    {
      "sections": [
        "Scala instrumentation",
        "Tip",
        "Scala frameworks",
        "Instrument Scala with the Java agent API",
        "Configure using the project/build.scala file",
        "Configure using the project/build.sbt file",
        "More API functions",
        "Additional instrumentation"
      ],
      "title": "Scala instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "7affd5ca652f6d59905d8cfc5ea4e6a57ffe793d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/frameworks/scala-installation-java/",
      "published_at": "2021-05-05T06:53:29Z",
      "updated_at": "2021-03-11T02:30:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent is compatible with Scala, and supports New Relic API calls, annotations, and custom instrumentation. All information below is supplemental to New Relic's Java agent installation directions. Tip For Heroku, see Java agent with Scala on Heroku. Scala frameworks If your framework is not natively supported by New Relic, or if you want to set up additional monitoring, custom instrumentation is a great way to dig deeper into your application. Instrument Scala with the Java agent API Instrument Scala to use the New Relic API class or annotations. Add the following information to your Scala configuration file: Configure using the project/build.scala file Add the following line (replacing X.Y.Z with the Java agent version you use) to the appDependencies method in your application's project/build.scala file: \"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\" Copy Configure using the project/build.sbt file Add the following line (replacing X.Y.Z with the Java agent version you use) to your application's project/build.sbt file: libraryDependencies += \"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\" Copy Import the NewRelic class and use it in your application: import com.newrelic.api.agent.NewRelic ... NewRelic.setTransactionName(null, \"/myTransaction\"); Copy More API functions For more about the Java agent API and its functionality, see the Java agent API introduction. Additional instrumentation If you use Kamon, take a look at the New Relic Kamon reporter.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.29722,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Instrument Scala with the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> is compatible with Scala, and supports New Relic API calls, annotations, and custom instrumentation. All information below is supplemental to New Relic&#x27;s <em>Java</em> <em>agent</em> installation directions. Tip For <em>Heroku</em>, see <em>Java</em> <em>agent</em> with Scala on <em>Heroku</em>. Scala frameworks If your"
      },
      "id": "6043b8bb196a671be4960f24"
    }
  ],
  "/docs/agents/java-agent/index": [
    {
      "sections": [
        "Configuring your SSL certificates",
        "Notice of expired SSL certificates and certificate removal",
        "Caution",
        "Important",
        "Java Agent versions 6.2.0 - 6.4.2",
        "Java Agent versions 6.0.0/6.1.0",
        "Using YAML-based configuration",
        "Java Agent versions prior to 6.0.0 (Deprecated)",
        "For more help"
      ],
      "title": "Configuring your SSL certificates",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "af154f250e87f571db157972e22dbb1f907a8fde",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/configuring-your-ssl-certificates/",
      "published_at": "2021-05-05T06:44:59Z",
      "updated_at": "2021-04-28T23:01:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To communicate with the New Relic collector over HTTPS, you need to have the proper certificates for trusted signers in the trust store on your app server. By default, most JREs contain a valid root certificate that allows the agent to connect to newrelic.com. For SSL connection issues, please visit SSL or connection errors (Java). Notice of expired SSL certificates and certificate removal Caution The SSL certificates that were bundled with Java agent versions 6.1.0 to 6.4.2 have expired and are no longer valid. This means that Java agent versions 6.1.0 to 6.4.2 can no longer use the certificates bundled with the agent to establish a connection with New Relic and that you must provide your own SSL certificates. Please see this community forum post for additional details. Important Java agent versions higher than 6.4.2 no longer ship with SSL certificates bundled into the agent. You must provide your own SSL truststore to the agent by explicitly using the ca_bundle_path configuration option, or by using the default truststore provided by the JDK/JRE (the agent will look to use the latter by default). Additionally the use_private_ssl configuration option has been removed from Java agent versions higher than 6.4.2. Users wishing to add the global certificate to their local trust store can download the DigiCert Global Root CA from DigiCert. Java Agent versions 6.2.0 - 6.4.2 Starting with Java agent version 6.2.0, the use_private_ssl configuration option has been reintroduced so you can use the SSL certificates that are bundled into the agent jar. The following bundled SSL certificates are valid for up to a year after release. META-INF/certs/eu-newrelic-com.pem META-INF/certs/eu01-nr-data-net.pem META-INF/certs/newrelic-com.pem Copy Important The Java agent will begin logging a warning message upon application startup when there are less than three months before the bundled certificate expires. When the bundled certificates expire, the Java agent will no longer be able to connect to New Relic and you must either update to the latest agent version or provide a valid certificate using the ca_bundle_path configuration. Users wishing to add the global certificate to their local trust store can download the DigiCert Global Root CA from DigiCert. Using YAML-based configuration common: default_settings ca_bundle_path: /path/to/digicert.pem use_private_ssl: false # # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic ... Copy Summary There are two configuration settings that determine what certs are used by the agent to establish a secure connection to New Relic. They are: use_private_ssl and ca_bundle_path. Here's how they work together: DEFAULT: Neither configuration option (ca_bundle_path/use_private_ssl) is provided, because both are using default values. The agent will use the default SSL certificates bundled into the Java Development Kit (JDK). If these certificates aren't present or don't include certificates that trust New Relic, then the agent will not connect. You'll need to merge valid certificates into your JDK certificate bundle. Only use_private_ssl is configured. The agent will use the SSL certificates that are bundled with it. Only ca_bundle_path is configured. The agent will try to connect using the custom SSL certificates bundle at the configured path. If the configured custom certificate bundle doesn’t include certificates that trust New Relic, then the agent will not connect. You'll need to merge valid certificates into your custom certificate bundle. Both use_private_ssl and ca_bundle_path are configured. The ca_bundle_path configuration setting takes precedence and the use_private_ssl config is ignored. This behavior is the same as only specifying ca_bundle_path. Java Agent versions 6.0.0/6.1.0 Starting in 6.0.0, the Java agent no longer includes the nrcert global certificate chain. Users wishing to add the global certificate to their local trust store must download the DigiCert Global Root CA from DigiCert. Note: In versions 6.1.0+, the Java agent will use a bundled New Relic certificate that is valid for up to a year after release. Before the certificate expires, you must either update the agent to the latest version or provide a valid certificate using the ca_bundle_path configuration. Important The Java agent will begin logging a warning message upon application startup when there are less than three months before the bundled certificate expires. Using YAML-based configuration common: default_settings ca_bundle_path: /path/to/digicert.pem # # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic ... Copy Java Agent versions prior to 6.0.0 (Deprecated) For Java agent versions prior to 6.0.0, applications that require valid certificates may add them in one of the following two ways: Use YAML-based configuration. Add the bundled list of New Relic trusted signers to the local store. Using YAML-based configuration The New Relic Java agent bundles the list of trusted signers in the agent newrelic.jar file. If you do not want to change the local trust store, you can activate them by setting use_private_ssl to true in the newrelic.yml agent configuration file: common: default_settings use_private_ssl: true # # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic ... Copy For more help Additional documentation resources include New Relic for Java (compatibility and requirements, installation, and configuration.)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 85.212036,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Java</em> <em>Agent</em> versions 6.2.0 - 6.4.2",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " visit SSL or connection errors (<em>Java</em>). Notice of expired SSL certificates and certificate removal Caution The SSL certificates that were bundled with <em>Java</em> <em>agent</em> versions 6.1.0 to 6.4.2 have expired and are no longer valid. This means that <em>Java</em> <em>agent</em> versions 6.1.0 to 6.4.2 can no longer use"
      },
      "id": "603eb7a2e7b9d247c02a080d"
    },
    {
      "sections": [
        "Include the Java agent with a JVM argument",
        "Tip",
        "Coldfusion",
        "Geronimo",
        "Glassfish",
        "Important",
        "Grails",
        "Pass with run-app",
        "Pass with run-war",
        "JBoss",
        "Set with domain mode (6.x EAP and 7.0 AS)",
        "Caution",
        "Set with standalone mode (other versions)",
        "Jetty",
        "If you set exec in jetty.sh",
        "If you set exec in start.ini",
        "Play",
        "Play 1.2.4",
        "Play 2.0",
        "Play 2.2",
        "Play 2.3, 2.4, and 2.5",
        "Resin",
        "Solr",
        "Standalone Solr 5.x or higher",
        "Standalone Solr 4.x or lower",
        "App server Solr",
        "Spring Boot",
        "Tanuki Wrapper",
        "Tomcat",
        "With setenv.sh",
        "With setenv.bat",
        "With catalina.sh (NOT RECOMMENDED)",
        "With catalina.bat (NOT RECOMMENDED)",
        "With Windows",
        "With Apache Commons daemon",
        "WebLogic",
        "Administration servers on Linux or macOS",
        "Administration servers on Windows",
        "Managed server instances",
        "WebSphere",
        "WebSphere Community",
        "WebSphere Liberty Profile",
        "Wildfly",
        "Set with domain mode",
        "Set with standalone mode",
        "Other application servers"
      ],
      "title": "Include the Java agent with a JVM argument",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Installation"
      ],
      "external_id": "e2026d6c9754047a8a1056b061f9be471f80b42f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/installation/include-java-agent-jvm-argument/",
      "published_at": "2021-05-05T00:35:31Z",
      "updated_at": "2021-04-11T14:41:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document describes how to pass the -javaagent argument to the JVM for your framework. This installation step ensures the agent is included in your app. For all app servers, ensure you pass the full path to the newrelic.jar file. This document is simply a reference for how to pass the argument. For detailed installation procedures, see Java agent installation. Tip To use Java or any other agent, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Coldfusion To pass the -javaagent argument on Coldfusion: Start your ColdFusion server and navigate to your ColdFusion admin console. From the left menu, select SERVER SETTINGS > Java and JVM. If using the agent API: Specify the path to newrelic-api.jar in the ColdFusion Class Path field. In the JVM Arguments field, add the -javaagent argument: -javaagent:/full/path/to/newrelic.jar Copy Select Submit Changes, then restart your ColdFusion server. Geronimo To pass the -javaagent argument on Geronimo, refer to the New Relic agent jar in the JAVA_OPTS environment variable when running the startup command: export JAVA_OPTS=\"$JAVA_OPTS -javaagent:/full/path/to/newrelic.jar\" && geronimo run Copy Glassfish To pass the -javaagent argument on Glassfish: From the Glassfish console, select Application Server > JVM Settings > JVM Options. On the JVM Options page, select Add JVM Option. Add an entry for the -javaagent argument: -javaagent:/full/path/to/newrelic.jar Copy Save and restart Glassfish. If Glassfish does not start, the -javaagent argument might not have been set correctly. You can change the server JVM arguments by editing the domain.xml file. Important A bug in Glassfish 2.1 prevents classes on the bootstrap class loader (the New Relic agent) from using the Java logging API. This appears to be fixed in 2.1.1 or higher releases. Grails To pass the -javaagent argument on Grails: Pass with run-app Begin with an unzipped version of Grails. Run this command: grails -noreloading -javaagent:/full/path/to/newrelic.jar run-app Copy Pass with run-war In your Grails app, open this file with your text editor: grails-app/conf/BuildConfig.groovy Copy Add or edit the JVM arguments line: grails.tomcat.jvmArgs = [\"-javaagent:/full/path/to/newrelic.jar\"] Copy JBoss To pass the -javaagent argument on JBoss: Set with domain mode (6.x EAP and 7.0 AS) Use domain mode for JBoss versions 6.x EAP and 7.0 AS or above: Edit the JVM properties for your server group, located in: domain/configuration/domain.xml Copy Modify the properties to include the -javaagent argument: <server-group name=\"main-server-group\" profile=\"full\"> <jvm name=\"default\"> <jvm-options> <option value=\"-javaagent:/full/path/to/newrelic.jar\"/> </jvm-options> </jvm> ... </server-group> Copy Caution A JBoss bug in 7.0.2.Final and 7.1.0.Alpha1 does not allow JVM options to be set in domain.xml. If you encounter this problem, upgrade your JBoss application server. Set with standalone mode (other versions) Use standalone mode for other platforms and versions: Platform Directions Unix / macOS with 6.x EAP or 7.0.x AS and above At the bottom of bin/standalone.conf, add: JAVA_OPTS=\"$JAVA_OPTS -javaagent:/full/path/to/newrelic.jar\" Copy Windows with 6.x EAP or 7.0.x AS or higher In bin/standalone.bat, before the line: set JBOSS_ENDORSED_DIRS=%JBOSS_HOME%\\lib\\endorsed Copy Add: set \"JAVA_OPTS=-javaagent:C:/full/path/to/newrelic.jar %JAVA_OPTS%\" Copy Unix / macOS with 6.x or earlier At the bottom of bin/run.conf, add this: JAVA_OPTS=\"$JAVA_OPTS -javaagent:/full/path/to/newrelic.jar\" Copy Windows with 6.x or earlier In bin/run.bat, before the line: set JBOSS_CLASSPATH=%RUN_CLASSPATH% Copy Add: set \"JAVA_OPTS=-javaagent:C:/full/path/to/newrelic.jar %JAVA_OPTS%\" Copy Jetty To pass the -javaagent argument on Jetty: If you set exec in jetty.sh Edit the JAVA_OPTIONS in your jetty.sh script: export JAVA_OPTIONS=\"${JAVA_OPTIONS} -javaagent:/full/path/to/newrelic.jar\" Copy If you set exec in start.ini Add the agent path to your start.ini config file: -javaagent:/full/path/to/newrelic.jar Copy Play To pass the -javaagent argument on Play: Play 1.2.4 Append the -javaagent argument when running your Play application: play run your_app_name -javaagent:/full/path/to/newrelic.jar Copy Play 2.0 Begin with an unzipped distribution containing the start script: play clean dist && unzip dist/*.zip Copy Append the -javaagent argument when starting your Play app: cd unzipped/folder; chmod a+x start; ./start -javaagent:/full/path/to/newrelic.jar Copy Play 2.2 Begin with an unzipped distribution containing the start script: play clean dist && unzip target/directory/universal/*.zip Copy Append the -J-javaagent argument when starting your Play app: cd unzipped/folder; ./bin/scriptname -J-javaagent:/full/path/to/newrelic.jar Copy Tip To enable page load timing, see Manual instrumentation with Play 2.2. Play 2.3, 2.4, and 2.5 Begin with an unzipped distribution containing the start script: activator clean dist && unzip target/directory/universal/*.zip Copy Append the -J-javaagent argument when starting your Play app: cd unzipped/folder; ./bin/scriptname -J-javaagent:/full/path/to/newrelic.jar Copy If you use Typesafe Activator with Play 2.4, add this line to your build.sbt: javaOptions ++= Seq(\"-javaagent:/full/path/to/newrelic.jar\") Copy Resin To pass the -javaagent argument on Resin, add it to the <jvm-args> section in your resin.conf or resin.xml file: <jvm-arg>-javaagent:/full/path/to/newrelic.jar</jvm-arg> Copy Solr To pass the -javaagent argument on Solr: Standalone Solr 5.x or higher Add the -javaagent property to bin/solr.in.sh: SOLR_OPTS=\"$SOLR_OPTS -javaagent:/full/path/to/newrelic.jar\" Copy Standalone Solr 4.x or lower Add the -javaagent before the start.jar: java -javaagent:/full/path/to/newrelic.jar -jar start.jar Copy App server Solr When running Solr in an application server, follow the instructions of that application server to add the -javaagent flag. Also ensure that JMX is enabled for the application server. If you don't see data in the APM UI's Solr page, follow the troubleshooting procedures for Solr data. Spring Boot To pass the -javaagent argument on Spring Boot, add it to the command line in which you start your app. Make sure to add it before the -jar argument: java -javaagent:/full/path/to/newrelic.jar -jar app.jar Copy Tanuki Wrapper To pass the -javaagent argument on Tanuki Wrapper, add a wrapper option wrapper.conf. In the line below, substitute XXX for an unused number in this file: wrapper.java.additional.XXX=-javaagent:/full/path/to/newrelic.jar Copy Tip On Linux systems, no quotation marks are required when setting this value. This behavior may vary on other operating systems. Tomcat To pass the -javaagent argument on Tomcat: With setenv.sh Create a CATALINA_BASE/bin/setenv.sh script if one doesn't already exist. Configure your setenv.sh script to use the New Relic agent using the CATALINA_OPTS environment variable: export CATALINA_OPTS=\"$CATALINA_OPTS -javaagent:/full/path/to/newrelic.jar\" Copy With setenv.bat Create a CATALINA_BASE/bin/setenv.bat script if one doesn't already exist. Configure your setenv.bat script to use the New Relic agent using the CATALINA_OPTS environment variable: SET \"CATALINA_OPTS=%CATALINA_OPTS% -javaagent:/full/path/to/newrelic.jar\" Copy With catalina.sh (NOT RECOMMENDED) Tip We recommend that you do not set any variables in this script. Instead put them into a script setenv.sh in CATALINA_BASE/bin to keep your customizations separate. Configure your catalina.sh file to use the New Relic agent using the JAVA_OPTS environment variable: export JAVA_OPTS=\"$JAVA_OPTS -javaagent:/full/path/to/newrelic.jar\" Copy With catalina.bat (NOT RECOMMENDED) Tip We recommend that you do not set any variables in this script. Instead put them into a script setenv.bat in CATALINA_BASE/bin to keep your customizations separate. If you use catalina.bat to launch Tomcat, set the JAVA_OPTS variable near the top of the file: SET JAVA_OPTS=%JAVA_OPTS% -javaagent:/full/path/to/newrelic.jar Copy With Windows Select Start > Apache Tomcat X.Y.Z. > Configure Tomcat > Java. In the Java Options text box, enter the argument. Use forward slashes / for the path separator. For Tomcat 6, add a line break after the -javaagent argument. -javaagent:/full/path/to/newrelic.jar Copy Select Apply, then restart Tomcat. With Apache Commons daemon The version of Apache Commons Daemon (jsvc) included with Tomcat 6 does not support the -javaagent argument used by New Relic. However, a build of the jsvc daemon from the trunk source will support the -javaagent argument via the -X prefix. See the Apache bug tracking the issue. There is a fix in the Apache Commons source repository. For more information: See the Apache source repository documentation. Go directly to the SVN source repository. WebLogic To pass the -javaagent argument on WebLogic: Administration servers on Linux or macOS Edit your startWebLogic.sh file, located in the domain's bin directory. Near the beginning of the file, add: export JAVA_OPTIONS=\"$JAVA_OPTIONS -javaagent:/full/path/to/newrelic.jar\" Copy Administration servers on Windows Edit your startWebLogic.bat file, located in the domain's bin directory. Near the beginning of the file, add: set JAVA_OPTIONS=%JAVA_OPTIONS% -javaagent:\"C:\\full\\path\\to\\newrelic.jar\" Copy Managed server instances For administration server instances, follow the Linux/macOS or Windows instructions. You cannot use the administration console to install administration server instances. For managed server instances, use the admin console: From the administration console, navigate to Environments > Servers > (select a server) > Server Start > Arguments. From Arguments, add: -javaagent:/full/path/to/newrelic.jar Copy Save the page, then restart your server instance. WebSphere To pass the -javaagent argument on WebSphere: From the admin console, select Servers > Application servers > (select a server) > Configuration > Service Infrastructure > Java and Process Management. Select Process Definition > Additional Properties, then select Java Virtual Machine. In the Generic JVM arguments field, add the -javaagent argument for your newrelic.jar file: -javaagent:/full/path/to/newrelic.jar Copy Select Apply, then select Save. Restart your server. For more information, see the documentation about collecting WebSphere PMI metrics. WebSphere Community To pass the -javaagent argument on WebSphere Community Edition, refer to the New Relic agent jar in the JAVA_OPTS environment variable when running the startup command: export JAVA_OPTS=\"$JAVA_OPTS -javaagent:/full/path/to/newrelic.jar\" && startup Copy WebSphere Liberty Profile To pass the -javaagent argument on WebSphere Liberty Profile: Edit ${server.config.dir}/jvm.options. Add the -javaagent argument to point to your newrelic.jar file: -javaagent:/full/path/to/newrelic.jar Copy Restart your server. Wildfly To pass the -javaagent argument on Wildfly (if using Wildfly 11 or higher, see additional install instructions): Set with domain mode Edit the JVM properties for your server group, located in: domain/configuration/domain.xml Copy Modify the properties to include the -javaagent argument: <server-group name=\"main-server-group\" profile=\"full\"> <jvm name=\"default\"> <jvm-options> <option value=\"-javaagent:/full/path/to/newrelic.jar\"/> </jvm-options> </jvm> ... </server-group> Copy Set with standalone mode Platform Directions Unix or macOS At the bottom of bin/standalone.conf, add: JAVA_OPTS=\"$JAVA_OPTS -javaagent:/full/path/to/newrelic.jar\" Copy Windows In bin/standalone.bat, find this line: rem Setup JBoss specific properties Copy Then add: set \"JAVA_OPTS=-javaagent:C:/full/path/to/newrelic.jar %JAVA_OPTS%\" Copy Other application servers The New Relic Java agent works on any supported app server. If your app server is not listed in this document, follow standard procedures for your app server to pass this argument to the JVM before the app jar: -javaagent:/full/path/to/newrelic.jar Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 67.54976,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Include the <em>Java</em> <em>agent</em> with a JVM argument",
        "sections": "Include the <em>Java</em> <em>agent</em> with a JVM argument",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": ". For detailed installation procedures, see <em>Java</em> <em>agent</em> installation. Tip To use <em>Java</em> or any other <em>agent</em>, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month"
      },
      "id": "6043b8f6e7b9d209f5579a28"
    },
    {
      "sections": [
        "SSL or connection errors (Java)",
        "Problem A: SSL/connection errors in logs",
        "Tip",
        "Solution A",
        "Problem B: logs show exception",
        "Solution B"
      ],
      "title": "SSL or connection errors (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "0e5af5c4f29a8e7b75f4c4c61235952f91624fc1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/ssl-or-connection-errors-java/",
      "published_at": "2021-05-05T06:44:58Z",
      "updated_at": "2021-04-05T10:48:22Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem A: SSL/connection errors in logs Your New Relic Java agent's log data shows SSL or connection errors. Tip See Configuring your SSL certificates for instructions on how to communicate with the New Relic collector over HTTPS. Solution A Failures to connect via SSL typically appear early in the Java agent's log files. For example: PKIX path building failed: java.security.cert.CertPathBuilderException: PKIXCertPathBuilderImpl could not build a valid CertPath Copy INFO: connection error: java.net.SocketException: java.lang.ClassNotFoundException: Cannot find the specified class com.ibm.websphere.ssl.protocol.SSLSocketFactory Copy If you see either of these errors, your JDK instance probably is using a customized trust store. Recommendation: Add the DigiCert Global Root Certificate Authority (CA), from which New Relic's certificate is derived, to your trust store. You can download the DigiCert Global Root CA from DigiCert (choose the \"Download PEM\" option). To import the cert to your trust store, use this command, or see Oracle's Java SE documentation for keytool: keytool -importcert -alias ca_alias -file ca_file.pem -keystore truststore.ts -storepass ts_password Copy Parameters include: Parameter Description ca_alias The alias you want to use in your trust store for the imported cert. ca_file The file containing the cert you are adding. truststore.ts The trust store to which the cert will be added. ts_password The password used by truststore.ts. Problem B: logs show exception Your New Relic Java agent's log data shows the following CertificateException. java.security.cert.CertificateException: Could not parse certificate: java.io.IOException: Illegal header: -----BEGIN CERTIFICATE----- Copy This is most likely related to this JDK issue. Solution B Examine and validate that the header and footer of your certificates do not have trailing whitespaces. If they do, edit or use different certificates.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 64.97863,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "SSL or connection errors (<em>Java</em>)",
        "sections": "SSL or connection errors (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Problem A: SSL&#x2F;connection errors in logs Your New Relic <em>Java</em> <em>agent</em>&#x27;s log data shows SSL or connection errors. Tip See Configuring your SSL certificates for instructions on how to communicate with the New Relic collector over HTTPS. Solution A Failures to connect via SSL typically appear early"
      },
      "id": "603e870428ccbc75adeba789"
    }
  ],
  "/docs/agents/java-agent/installation/include-java-agent-jvm-argument": [
    {
      "sections": [
        "Configuring your SSL certificates",
        "Notice of expired SSL certificates and certificate removal",
        "Caution",
        "Important",
        "Java Agent versions 6.2.0 - 6.4.2",
        "Java Agent versions 6.0.0/6.1.0",
        "Using YAML-based configuration",
        "Java Agent versions prior to 6.0.0 (Deprecated)",
        "For more help"
      ],
      "title": "Configuring your SSL certificates",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "af154f250e87f571db157972e22dbb1f907a8fde",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/configuring-your-ssl-certificates/",
      "published_at": "2021-05-05T06:44:59Z",
      "updated_at": "2021-04-28T23:01:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To communicate with the New Relic collector over HTTPS, you need to have the proper certificates for trusted signers in the trust store on your app server. By default, most JREs contain a valid root certificate that allows the agent to connect to newrelic.com. For SSL connection issues, please visit SSL or connection errors (Java). Notice of expired SSL certificates and certificate removal Caution The SSL certificates that were bundled with Java agent versions 6.1.0 to 6.4.2 have expired and are no longer valid. This means that Java agent versions 6.1.0 to 6.4.2 can no longer use the certificates bundled with the agent to establish a connection with New Relic and that you must provide your own SSL certificates. Please see this community forum post for additional details. Important Java agent versions higher than 6.4.2 no longer ship with SSL certificates bundled into the agent. You must provide your own SSL truststore to the agent by explicitly using the ca_bundle_path configuration option, or by using the default truststore provided by the JDK/JRE (the agent will look to use the latter by default). Additionally the use_private_ssl configuration option has been removed from Java agent versions higher than 6.4.2. Users wishing to add the global certificate to their local trust store can download the DigiCert Global Root CA from DigiCert. Java Agent versions 6.2.0 - 6.4.2 Starting with Java agent version 6.2.0, the use_private_ssl configuration option has been reintroduced so you can use the SSL certificates that are bundled into the agent jar. The following bundled SSL certificates are valid for up to a year after release. META-INF/certs/eu-newrelic-com.pem META-INF/certs/eu01-nr-data-net.pem META-INF/certs/newrelic-com.pem Copy Important The Java agent will begin logging a warning message upon application startup when there are less than three months before the bundled certificate expires. When the bundled certificates expire, the Java agent will no longer be able to connect to New Relic and you must either update to the latest agent version or provide a valid certificate using the ca_bundle_path configuration. Users wishing to add the global certificate to their local trust store can download the DigiCert Global Root CA from DigiCert. Using YAML-based configuration common: default_settings ca_bundle_path: /path/to/digicert.pem use_private_ssl: false # # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic ... Copy Summary There are two configuration settings that determine what certs are used by the agent to establish a secure connection to New Relic. They are: use_private_ssl and ca_bundle_path. Here's how they work together: DEFAULT: Neither configuration option (ca_bundle_path/use_private_ssl) is provided, because both are using default values. The agent will use the default SSL certificates bundled into the Java Development Kit (JDK). If these certificates aren't present or don't include certificates that trust New Relic, then the agent will not connect. You'll need to merge valid certificates into your JDK certificate bundle. Only use_private_ssl is configured. The agent will use the SSL certificates that are bundled with it. Only ca_bundle_path is configured. The agent will try to connect using the custom SSL certificates bundle at the configured path. If the configured custom certificate bundle doesn’t include certificates that trust New Relic, then the agent will not connect. You'll need to merge valid certificates into your custom certificate bundle. Both use_private_ssl and ca_bundle_path are configured. The ca_bundle_path configuration setting takes precedence and the use_private_ssl config is ignored. This behavior is the same as only specifying ca_bundle_path. Java Agent versions 6.0.0/6.1.0 Starting in 6.0.0, the Java agent no longer includes the nrcert global certificate chain. Users wishing to add the global certificate to their local trust store must download the DigiCert Global Root CA from DigiCert. Note: In versions 6.1.0+, the Java agent will use a bundled New Relic certificate that is valid for up to a year after release. Before the certificate expires, you must either update the agent to the latest version or provide a valid certificate using the ca_bundle_path configuration. Important The Java agent will begin logging a warning message upon application startup when there are less than three months before the bundled certificate expires. Using YAML-based configuration common: default_settings ca_bundle_path: /path/to/digicert.pem # # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic ... Copy Java Agent versions prior to 6.0.0 (Deprecated) For Java agent versions prior to 6.0.0, applications that require valid certificates may add them in one of the following two ways: Use YAML-based configuration. Add the bundled list of New Relic trusted signers to the local store. Using YAML-based configuration The New Relic Java agent bundles the list of trusted signers in the agent newrelic.jar file. If you do not want to change the local trust store, you can activate them by setting use_private_ssl to true in the newrelic.yml agent configuration file: common: default_settings use_private_ssl: true # # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic ... Copy For more help Additional documentation resources include New Relic for Java (compatibility and requirements, installation, and configuration.)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 102.415535,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Java</em> <em>Agent</em> versions 6.2.0 - 6.4.2",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " visit SSL or connection errors (<em>Java</em>). Notice of expired SSL certificates and certificate removal Caution The SSL certificates that were bundled with <em>Java</em> <em>agent</em> versions 6.1.0 to 6.4.2 have expired and are no longer valid. This means that <em>Java</em> <em>agent</em> versions 6.1.0 to 6.4.2 can no longer use"
      },
      "id": "603eb7a2e7b9d247c02a080d"
    },
    {
      "sections": [
        "Update the Java agent",
        "Update to latest version",
        "Update agent config differences",
        "Java agent versions not supported",
        "Update unsupported agent versions",
        "Important"
      ],
      "title": "Update the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Installation"
      ],
      "external_id": "a1227c7d2b79b2080a67400bbc65920f7142d294",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/installation/update-java-agent/",
      "published_at": "2021-05-05T06:52:36Z",
      "updated_at": "2021-03-16T15:07:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To take full advantage of New Relic's latest features, enhancements, and important security patches, we recommend you update your Java agent to the latest version. For additional information about specific agent updates, refer to the Java agent release notes. These update procedures describe how to replace some of the current contents of your agent root directory, which contains the New Relic Java agent (newrelic.jar), with newly downloaded contents from the New Relic UI. Update to latest version To identify which version of the Java agent you're currently using, run java -jar newrelic.jar -v. Your Java agent version will be printed to your console. Then, to update to the latest Java agent version: Back up the entire Java agent root directory to another location. Rename that directory to NewRelic_Agent#.#.#, where #.#.# is the agent version number. Go to one.newrelic.com > (account dropdown) > Account settings. Download the agent for your platform. Unzip the new agent download file, then copy newrelic-api.jar and newrelic.jar into the original Java agent root directory. Diff your current newrelic.yml with the newly downloaded newrelic.yml from the zip, and update customized differences as needed. Restart your Java dispatcher. If you experience issues after the Java agent update, restore from the backed-up New Relic agent directory. Update agent config differences If differences between the two versions are unrelated to your app's customizations, align the newrelic.yml you use moving forward with the latest updates to the default newrelic.yml from New Relic. For example, if you diff the default newrelic.yml files for Java agent versions 3.29.0 and 3.30.0, the results printed to the console will be: ➜ diff newrelic_3.29.0.yml newrelic_3.30.0.yml 254a255,265 > # Classes loaded by classloaders in this list will not be instrumented. > # This is a useful optimization for runtimes which use classloaders to > # load dynamic classes which the agent would not instrument. > classloader_excludes: > groovy.lang.GroovyClassLoader$InnerLoader, > org.codehaus.groovy.runtime.callsite.CallSiteClassLoader, > com.collaxa.cube.engine.deployment.BPELClassLoader, > org.springframework.data.convert.ClassGeneratingEntityInstantiator$ObjectInstantiatorClassGenerator, > org.mvel2.optimizers.impl.asm.ASMAccessorOptimizer$ContextClassLoader, > gw.internal.gosu.compiler.SingleServingGosuClassLoader, > Copy These lines were added to the default newrelic.yml in Java agent version 3.30.0. If you want to run Java agent version 3.30.0 or higher, ensure you include these lines in your newrelic.yml. Java agent versions not supported End of life notification: As of January 26, 2015, New Relic will no longer accept data from Java agent versions earlier than 3.6.0, except version 2.21.7. These agent versions use an out-of-date protocol when communicating with New Relic's data collection services. In addition, many of these versions contain a potential security issue where they may incorrectly send sensitive data to the New Relic collector. Update unsupported agent versions Important If you are updating from an older agent version, including major version jumps, review the following list for changes in functionality. Migration Comments 5.0.0 Release notes: Java agent 5.0.0 Self installer: The New Relic Java agent's self-installer has been removed in order to provide a more consistent user experience. To install the Java agent, add the full path to the newrelic.jar to the -javaagent flag in your JVM options. For more information, see the documentation on installing the agent on specific application servers, including Docker, Maven, or Gradle. Deprecated instrumentation: The following instrumentation modules have been moved out of the default Java agent. They are now provided as a separate download. To continue using these modules, just add them to the agent's extensions directory in your New Relic folder or wherever your extensions directory is configured. Deprecated modules include: Akka 2.0 Akka 2.1 Akka-http 1.0 Akka-http 2.0 - 2.4.1 Akka-http 2.4.2 - 2.4.4 Hystrix 1.2 Hystrix 1.3 Play 1: Instrumentation for Play-1.x is not available as an extension. Play 2.0 Play 2.1 Play 2.2 Solr 3.1 - 3.4 Solr 3.5 Solr 3.6 4.12.0 Release notes: Java agent 4.12.0 Deprecated APIs: The custom transport channel API is now deprecated in favor of the distributed tracing API. The skipTransactionTrace attribute on the @Trace annotation is now deprecated. Instead, use the excludeFromTransactionTrace attribute. Deprecated instrumentation: JetS3t: Removed built-in instrumentation for JetS3t. The agent will continue to report external calls made with the JetS3t client. 4.4.0 Release notes: Java agent 4.4.0 Java 6 support removed: You must use 4.3 or earlier. EU data center: Minimum version required for use in EU datacenter. Removed the SSL configuration option: SSL is now always used in communication with New Relic servers. The newrelic.yml ssl configuration and -Dnewrelic.config.ssl system property are no longer used. Setting either value to anything other than true will result in logging a warning. Legacy agent 2.21.7 Release notes: Java agent 2.21.7 Java SE 5.0: This is a bugfix release for the legacy Java SE 5.0 version of the agent. Unless you are a Java SE5 user, use the latest version of the New Relic Java agent. This affects: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, OS X Oracle JRockit up to and including 1.6.0_50",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.22806,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Update the <em>Java</em> <em>agent</em>",
        "sections": "Update the <em>Java</em> <em>agent</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "To take full advantage of New Relic&#x27;s latest features, enhancements, and important security patches, we recommend you update your <em>Java</em> <em>agent</em> to the latest version. For additional information about specific <em>agent</em> updates, refer to the <em>Java</em> <em>agent</em> release notes. These update procedures describe how"
      },
      "id": "603ec448196a67700ba83dc5"
    },
    {
      "sections": [
        "Install the Java agent",
        "Tip",
        "1. Before you install",
        "2. Get the agent",
        "Download using curl",
        "Download using Invoke-WebRequest (PowerShell)",
        "Download from the New Relic UI",
        "3. Configure the agent",
        "4. Install the agent",
        "5. Post-installation tasks",
        "What's next?"
      ],
      "title": "Install the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Installation"
      ],
      "external_id": "919e7366b24cb9cce5c366d0394060d2332a5ec6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/installation/install-java-agent/",
      "published_at": "2021-05-04T17:04:08Z",
      "updated_at": "2021-03-16T09:15:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Java agent auto-instruments your code so you can start monitoring applications. You can use our launcher, or follow the instructions in this document to complete a basic Java agent installation. Add Java data Tip To use Java or any other agent, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. 1. Before you install Check the following: Make sure you have signed up for a New Relic account. Review the compatibility and requirements. Check if your environment requires additional or alternative install steps. 2. Get the agent Download newrelic-java.zip using curl, Invoke-WebRequest (PowerShell), or the New Relic UI: Download using curl Complete the following: Start a command-line session. Change to a temporary directory where you can download the zip file. Execute this curl command: curl -O https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip Copy Unzip newrelic-java.zip Download using Invoke-WebRequest (PowerShell) Complete the following: Start a PowerShell session. Change to a temporary directory where you can download the zip file. Execute this PowerShell command: Invoke-WebRequest -Uri https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip -OutFile newrelic-java.zip Copy Unzip newrelic-java.zip: Expand-Archive -Path newrelic-java.zip -DestinationPath DESTINATION_PATH Copy Download from the New Relic UI Complete the following: Sign in to New Relic. From the account dropdown in the New Relic UI, select Account settings. In the right sidebar under Most recent, select the Java agent, and save the newrelic-java.zip to a temporary directory. Unzip newrelic-java.zip. 3. Configure the agent Here's how to do a basic setup with agent configuration settings in newrelic.yml. Tip For an advanced installation, you can pass settings with environment variables, Java system properties, or server-side configuration. To understand the precedence of these configuration settings, see Java agent configuration: Config file. The Java agent requires the license_key and app_name settings at startup. All the other settings are optional, and you can review them in Java agent configuration: Config file. Go to the unzipped installation file, and inside the newrelic subdirectory, edit newrelic.yml: Find the line with license_key. Replace ' < %= license_key %>' with your license. For example: license_key: 456n20n1367ov2s174v51nvn789d21s67v26NRAL Copy Find the line with app_name. Replace My Application with a name that helps you identify the application. For example: app_name: Tax Calculator Copy Tip If you need tips about how to name your application, see Name your application. Add optional settings that you want, such as agent logging and distributed tracing (or add them later). Save and close newrelic.yml. 4. Install the agent The Java agent installation involves copying all the unzipped New Relic files into the directory structure of your application server/container. For example, you can create a /opt/newrelic directory, but if you want to put the files elsewhere, make sure of the following: The .jar files in the directory cannot be on the classpath. The .jar files cannot be in directories specified in java.endorsed.dirs. To install the Java agent: In your application server/container directory structure, create a directory for New Relic files (for example, /opt/newrelic). Copy all the New Relic files from your unzipped newrelic directory into your new directory. Make sure that your application server/container includes this option when it starts Java (for tips on how to do this with your tool or framework, see JVM arguments): -javaagent:/full/path/to/newrelic.jar Copy Start or restart your application server/container. Generate some traffic for your app, and then wait a few minutes for data to appear in the APM Summary page. If nothing appears, follow the troubleshooting procedures. 5. Post-installation tasks If you are using newrelic.yml to make configuration settings, consider the following: We recommend you change the default newrelic.yml file permissions to read/write only for the owner of the application server process. As you would with other important files, be sure newrelic.yml is part of your backup routine. We recommend using New Relic Diagnostics to validate your settings, either before or after you deploy. What's next? Here are some additional topics to consider: For Docker questions, see Install New Relic Java agent for Docker. View your app in New Relic and get comfortable with the user interface. Read the documentation about APM. For example, read about the Summary page, the JVM metrics page, the Transactions page, and other performance monitoring features. Query your data using NRQL (New Relic Query Language). Learn about setting up custom instrumentation and async instrumentation for application activity not monitored by default.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.17076,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> the <em>Java</em> <em>agent</em>",
        "sections": "<em>Install</em> the <em>Java</em> <em>agent</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Our <em>Java</em> <em>agent</em> auto-instruments your code so you can start monitoring applications. You can use our launcher, or follow the instructions in this document to complete a basic <em>Java</em> <em>agent</em> <em>installation</em>. Add <em>Java</em> data Tip To use <em>Java</em> or any other <em>agent</em>, as well as the rest of our observability platform"
      },
      "id": "603eb6f428ccbc7695eba785"
    }
  ],
  "/docs/agents/java-agent/installation/install-java-agent-java-2-security": [
    {
      "sections": [
        "Install New Relic Java agent for Docker",
        "Tip",
        "Get the Java agent",
        "Download using curl",
        "Download using Invoke-WebRequest (PowerShell)",
        "Download from the New Relic UI",
        "Set up the installation directory",
        "Modify startup scripts",
        "Set agent configurations",
        "Application name",
        "License key",
        "Logs",
        "Environment (optional)",
        "Important",
        "Enabled (optional)",
        "Additional Tomcat Dockerfile examples",
        "Tomcat with environment and Java system properties",
        "How to start an application with the Java agent",
        "Next steps"
      ],
      "title": "Install New Relic Java agent for Docker",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "4de0ccd173c9851b045cfa036089e2f703b4a0f7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/install-new-relic-java-agent-docker/",
      "published_at": "2021-05-04T17:59:15Z",
      "updated_at": "2021-03-16T14:29:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains a basic installation of the APM agent for Java applications in a Docker container. We discuss required configurations and also explore some optional configurations, including: How to use identical New Relic configuration files for each container, regardless of the environment where the containers are used How to use the Docker layer when every agent in every environment needs slightly different configuration data How to disable the New Relic agent in some environments and enable it in others Although we don't discuss advanced options here, you can install the Java agent in Docker volumes and use your Docker container image in other software such as Swarm, ECS, AKS, EKS, OpenShift, and Kubernetes. Our Docker examples refer to Tomcat, so if you are using another application server, refer to your vendor’s documentation. Tip To use Java or any other agent, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Get the Java agent Download newrelic-java.zip using curl, Invoke-WebRequest (PowerShell), or the New Relic UI: Download using curl Complete the following: Start a command-line session. Change to a temporary directory where you can download the zip file. Execute this curl command: curl -O https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip Copy Unzip newrelic-java.zip Download using Invoke-WebRequest (PowerShell) Complete the following: Start a PowerShell session. Change to a temporary directory where you can download the zip file. Execute this PowerShell command: Invoke-WebRequest -Uri https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip -OutFile newrelic-java.zip Copy Unzip newrelic-java.zip: Expand-Archive -Path newrelic-java.zip -DestinationPath DESTINATION_PATH Copy Download from the New Relic UI Complete the following: Log in to New Relic. From the account dropdown in the New Relic UI, select Account settings. In the right sidebar under Most recent, select the Java agent, and save the newrelic-java.zip to a temporary directory. Unzip newrelic-java.zip. Set up the installation directory You can unzip the newrelic-java.zip file wherever it is convenient for you. In the subsequent sections we assume you extracted it in the current working directory, which puts the files we need in ./newrelic. Modify startup scripts The startup script that contains the command to start your application server must include Java’s built-in argument -javaagent. We recommend that you set this argument with the JAVA_OPTS environment variable. The value of that argument must contain the location where you ADD the Java APM agent’s jar file to the image. For example, with Tomcat, use commands like these in the Dockerfile: RUN mkdir -p /usr/local/tomcat/newrelic ADD ./newrelic/newrelic.jar /usr/local/tomcat/newrelic/newrelic.jar ENV JAVA_OPTS=\"$JAVA_OPTS -javaagent:/usr/local/tomcat/newrelic/newrelic.jar\" Copy Set agent configurations By default, agent behavior is controlled by configuration entries in newrelic.yml, which is typically located in the same directory as the agent. This section explains how to override these newrelic.yml configurations by using environment variables or Java system properties in the Dockerfile. Before we look at some specific configurations, here’s how to load newrelic.yml using the Dockerfile: ADD ./newrelic/newrelic.yml /usr/local/tomcat/newrelic/newrelic.yml Copy For a basic Docker installation, complete these configurations: Application name License key Logs Environment (optional) Enabled (optional) Application name The application name is a configuration you set to identify your application in New Relic. Tip You can reuse an application name for multiple apps serving the same role so that all the data from those apps rolls up into the same logical application in New Relic. For more detail about additional grouping options, see Use multiple names for an app. Replace MY_APP_NAME with your application name in one of these Dockerfile commands: Option Command Environment variable ENV NEW_RELIC_APP_NAME=\"MY_APP_NAME\" Copy Java system property ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.app_name='MY_APP_NAME'\" Copy After you boot the container, your application name appears in New Relic. License key This configuration is required for you to report on any data in your New Relic Account. To copy your license key: Go to one.newrelic.com > (account dropdown) > Account settings. Under Account information, copy the license key. In one of these Dockerfile commands, replace MY_LICENSE_KEY with your license key: Option Command Environment variable ENV NEW_RELIC_LICENSE_KEY=\"MY_LICENSE_KEY\" Copy Java system property ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.license_key='MY_LICENSE_KEY'\" Copy Logs By default, logs are written into the logs directory relative to the location of newrelic.jar. Make sure that the user account that starts your application server also has the right to perform tasks such as: Creating the logs directory. Creating and appending to the log files in that directory. Here’s a Dockerfile example where tomcat is the user who starts Tomcat: RUN mkdir -p /usr/local/tomcat/newrelic/logs RUN chown -R tomcat:tomcat /usr/local/tomcat/newrelic/logs Copy You can also send the logs to STDOUT by adding one of the following to the Dockerfile: Option Command Environment Variable ENV NEW_RELIC_LOG_FILE_NAME=STDOUT Copy Java system property ENV JAVA_OPTS=-Dnewrelic.config.log_file_name=STDOUT Copy Environment (optional) You can pass either a Java property or an environment variable to determine which of the environment-specific stanzas the agent uses in newrelic.yml. Use this approach if you prefer to have the newrelic.yml file control environment-specific configurations instead of passing all the configurations via Docker. Here’s a Dockerfile example of passing the newrelic.environment Java system property via Docker to use the custom value dev in the environment stanza of newrelic.yml: Using the shell form of the CMD instruction, include a reference to a new environment variable you choose (for example, ENV): CMD java -Dnewrelic.environment=$ENV -jar myjar.jar Copy In your docker run command line, include an argument to set the environment variable in the container: docker run -it -e \"ENV=dev\" myDockerImage Copy Important If you don’t specify a value for newrelic.environment, the agent assumes it is running in your production environment and uses the values from the main body of the configuration file. Enabled (optional) This configuration controls whether the agent is enabled. Let’s say you want the same Docker image for every installation. However, you don’t want to run the New Relic agent every time an engineer spins up a test app because you don’t want to run up your instance count. This problem can be solved using the newrelic.environment Java system property. In the main body of newrelic.yml, disable the Java agent by setting enabled: false. In specific environment stanzas of newrelic.yml, set enabled: true. Then, you can run specific agents by specifying the environment at runtime. Additional Tomcat Dockerfile examples Tomcat with environment and Java system properties FROM tomcat:9 # Add the newrelic.jar and -javaagent parameters RUN mkdir -p /usr/local/tomcat/newrelic ADD ./newrelic/newrelic.jar /usr/local/tomcat/newrelic/ ENV JAVA_OPTS=\"$JAVA_OPTS -javaagent:/usr/local/tomcat/newrelic/newrelic.jar\" # Add the configuration file ADD ./newrelic/newrelic.yml /usr/local/tomcat/newrelic/ # An example of setting a system property config ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.app_name='My Application'\" # An example of setting an Environment variable config ENV NEW_RELIC_LICENSE_KEY=\"license_key\" # Config to include the agent logs in Docker's stdout logging ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.log_file_name=STDOUT\" EXPOSE 8080 CMD [\"catalina.sh\", \"run\"] Copy How to start an application with the Java agent FROM openjdk:8 ADD my-application.jar /app ADD newrelic.jar /app ADD newrelic.yml /app ENV NEW_RELIC_APP_NAME=\"My Application\" ENV NEW_RELIC_LICENSE_KEY=\"license_key\" ENV NEW_RELIC_LOG_FILE_NAME=\"STDOUT\" ENTRYPOINT [\"java\",\"-javaagent:/app/newrelic.jar\",\"-jar\",\"/app/my-application.jar\"] Copy Next steps Now that you have a basic agent installation in Docker, here are some additional steps to consider: Review other configurations for the agent. Read a detailed Explorers Hub post about Docker and New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.513084,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> for Docker",
        "sections": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> for Docker",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": "This document explains a basic <em>installation</em> of the APM <em>agent</em> for <em>Java</em> applications in a Docker container. We discuss required configurations and also explore some optional configurations, including: How to use identical New Relic configuration files for each container, regardless of the environment"
      },
      "id": "603ea3dc28ccbc8889eba765"
    },
    {
      "sections": [
        "WildFly installation for Java",
        "Install WildFly versions earlier than 11",
        "Install WildFly version 11 or higher"
      ],
      "title": "WildFly installation for Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "7f9259f3b77efb78cd4861a9d7b519fe44191e3c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/wildfly-installation-java/",
      "published_at": "2021-05-05T00:37:37Z",
      "updated_at": "2021-03-16T14:29:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Before you install New Relic's Java agent, make sure your WildFly version is supported. Depending on which WildFly version your application uses, additional configuration steps may be required. Install WildFly versions earlier than 11 If your supported WildFly version is earlier than v11, follow standard Java installation procedures. You do not need to do any additional configuration. Install WildFly version 11 or higher If you use WildFly version 11 or higher, New Relic's Java agent requires additional configuration after you install it. Install the Java agent. If you already have it installed, update to the latest Java agent version. Versions 5.0.0 and higher include fixes for later WildFly versions 11 and higher. Open the standalone configuration file appropriate for your operating system and add the -javaagent property to JAVA_OPTS. For example, if you use Linux, edit the /bin/standalone.conf file or /bin/standalone.conf.bat for Windows. Make sure the agent jar is visible to all JBoss modules by adding com.newrelic to the JBoss modules system packages using either of these options in the standalone script: Recommended: Option 1 (same as adding -javaagent property): JAVA_OPTS=\"$JAVA_OPTS -Djboss.modules.system.pkgs=$JBOSS_MODULES_SYSTEM_PKGS,com.newrelic Copy Option 2: if [ \"x$JBOSS_MODULES_SYSTEM_PKGS\" = \"x\" ]; then JBOSS_MODULES_SYSTEM_PKGS=\"org.jboss.byteman,com.newrelic\" fi Copy Restart your application server.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.513084,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "WildFly <em>installation</em> for <em>Java</em>",
        "sections": "WildFly <em>installation</em> for <em>Java</em>",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": " standard <em>Java</em> <em>installation</em> procedures. You do not need to do any <em>additional</em> configuration. Install WildFly version 11 or higher If you use WildFly version 11 or higher, New Relic&#x27;s <em>Java</em> <em>agent</em> requires <em>additional</em> configuration after you install it. Install the <em>Java</em> <em>agent</em>. If you already have"
      },
      "id": "603e791764441f18724e88ab"
    },
    {
      "sections": [
        "Install New Relic Java agent with Ansible",
        "Compatibility and requirements",
        "Overview of process",
        "Step 1. Install the role",
        "Step 2. Incorporate the role into playbook",
        "Step 3. Configure the role",
        "Step 4. Configure the agent",
        "Step 5. Enable custom instrumentation (optional)",
        "For more help"
      ],
      "title": "Install New Relic Java agent with Ansible",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "328592f6b75e0eb638a0916082e034bb9782cad7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/install-new-relic-java-agent-ansible/",
      "published_at": "2021-05-05T06:55:40Z",
      "updated_at": "2021-03-16T14:28:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM for Java allows you to use an Ansible role for installation and configuration. Compatibility and requirements New Relic's Ansible role for the Java agent is open source and community-supported. It supports setting up our Java agent to instrument applications running under Tomcat, Jetty, and Wildfly (formerly JBoss) on Linux servers. The most common agent parameters can be configured through Ansible variables. You'll need to install Ansible to run this role. Ansible is run from a central server to configure target hosts; these hosts must be running Linux and have unzip installed. The role should be compatible with most popular Linux distributions. Overview of process There are several steps that may be involved for installation and configuration: Install the role Incorporate role in your playbook Configure the role Configure the agent Enable custom instrumentation (optional) Step 1. Install the role To install this role, use the ansible-galaxy command on the system where you run Ansible: $ ansible-galaxy install newrelic.newrelic_java_agent Copy This will download the role from Ansible Galaxy and make it available for use in Ansible playbooks. Step 2. Incorporate the role into playbook You'll need to call the role from your playbook using the include_role module. The role's GitHub repository contains an example playbook for you to start from, which looks like this: - hosts: YOUR_HOST_GROUP vars: nr_java_agent_config: license_key: YOUR_LICENSE_KEY app_name: YOUR_APP_NAME log_file_path: /tmp/newrelic server_type: tomcat server_root: /var/lib/tomcat8 jvm_conf_file: /usr/share/tomcat8/bin/setenv.sh server_user: tomcat8 server_group: tomcat8 service_name: tomcat8 restart_web_server: true tasks: - include_role: name: newrelic.newrelic_java_agent Copy The vars section contains a dictionary called nr_java_agent_config, which holds settings for the agent itself, and a number of variables for configuring the role's installation process. See the sections on agent configuration and role configuration for details. Step 3. Configure the role These variables are used to configure the install process. Most are required. For more information, see the examples on GitHub. Variable Description server_type Required. Web server used by your application. Possible values are: tomcat, jetty, and wildfly (standalone mode only). server_root Required. Location of the web server on the host. The agent's JAR, configuration, and (by default) log files will live in a subdirectory of this directory. jvm_conf_file Required. Path to the web server configuration file to reference the New Relic Java agent. For Tomcat, for instance, it's typically the setenv.sh file. If the file doesn't exist, it may be created, depending on the server_type. server_user server_group Required. User and group under which the web server runs. Used to set the ownership of the newrelic.jar and newrelic.yml files. restart_web_server Optional. Default: true. If set to false, the role does not restart the web server after installing the agent. Note that the agent is not activated until the web server is restarted. service_name Required (unless restart_web_server is set to false). Service name under which the web server runs. Used by Ansible to restart the web server after the agent is installed. nr_java_agent_version Optional; default: currentSpecifies the version of the Java agent to install. current will install the latest version. You can also install a specific version, like 5.9.0. For available versions, see Java agent downloads directory. Step 4. Configure the agent The following variables are used to configure the Java agent itself. These are just a few of the available options. For a full list of supported variables, see the README file on GitHub. For more about how to configure the agent, see Java agent configuration. Variable Description license_key Required. Your New Relic license key. app_name Required. Name of the application being instrumented. For more details, see App naming. proxy_host proxy_port proxy_user proxy_password proxy_scheme Optional. If you connect to the New Relic collector via a proxy, you can configure your proxy settings with these values. labels Optional. User-configurable custom labels for the agent. Labels are name-value pairs. Names and values are limited to 255 characters and cannot contain colons (:) nor semicolons (;). Value should be a semicolon-separated list of key-value pairs, for example Server:One;Data Center:Primary. Step 5. Enable custom instrumentation (optional) If you want to enable custom instrumentation, you can provide a list of XML files using the custom_instrumentation_files variable. For instance, you can specify that all Java agents being installed should use a file called my_instrumentation.xml by adding something like the following to your playbook: vars: custom_instrumentation_files: - /path/to/my_instrumentation.xml Copy See the README and examples on GitHub for more information. For more help If you need additional help, file an issue at newrelic/newrelic-java-agent-ansible-role on GitHub.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.51284,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> with Ansible",
        "sections": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> with Ansible",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": "APM for <em>Java</em> allows you to use an Ansible role for <em>installation</em> and configuration. Compatibility and requirements New Relic&#x27;s Ansible role for the <em>Java</em> <em>agent</em> is open source and community-supported. It supports setting up our <em>Java</em> <em>agent</em> to instrument applications running under Tomcat, Jetty"
      },
      "id": "603e92dce7b9d2a5d32a080c"
    }
  ],
  "/docs/agents/java-agent/installation/install-java-agent": [
    {
      "sections": [
        "Configuring your SSL certificates",
        "Notice of expired SSL certificates and certificate removal",
        "Caution",
        "Important",
        "Java Agent versions 6.2.0 - 6.4.2",
        "Java Agent versions 6.0.0/6.1.0",
        "Using YAML-based configuration",
        "Java Agent versions prior to 6.0.0 (Deprecated)",
        "For more help"
      ],
      "title": "Configuring your SSL certificates",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "af154f250e87f571db157972e22dbb1f907a8fde",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/configuring-your-ssl-certificates/",
      "published_at": "2021-05-05T06:44:59Z",
      "updated_at": "2021-04-28T23:01:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To communicate with the New Relic collector over HTTPS, you need to have the proper certificates for trusted signers in the trust store on your app server. By default, most JREs contain a valid root certificate that allows the agent to connect to newrelic.com. For SSL connection issues, please visit SSL or connection errors (Java). Notice of expired SSL certificates and certificate removal Caution The SSL certificates that were bundled with Java agent versions 6.1.0 to 6.4.2 have expired and are no longer valid. This means that Java agent versions 6.1.0 to 6.4.2 can no longer use the certificates bundled with the agent to establish a connection with New Relic and that you must provide your own SSL certificates. Please see this community forum post for additional details. Important Java agent versions higher than 6.4.2 no longer ship with SSL certificates bundled into the agent. You must provide your own SSL truststore to the agent by explicitly using the ca_bundle_path configuration option, or by using the default truststore provided by the JDK/JRE (the agent will look to use the latter by default). Additionally the use_private_ssl configuration option has been removed from Java agent versions higher than 6.4.2. Users wishing to add the global certificate to their local trust store can download the DigiCert Global Root CA from DigiCert. Java Agent versions 6.2.0 - 6.4.2 Starting with Java agent version 6.2.0, the use_private_ssl configuration option has been reintroduced so you can use the SSL certificates that are bundled into the agent jar. The following bundled SSL certificates are valid for up to a year after release. META-INF/certs/eu-newrelic-com.pem META-INF/certs/eu01-nr-data-net.pem META-INF/certs/newrelic-com.pem Copy Important The Java agent will begin logging a warning message upon application startup when there are less than three months before the bundled certificate expires. When the bundled certificates expire, the Java agent will no longer be able to connect to New Relic and you must either update to the latest agent version or provide a valid certificate using the ca_bundle_path configuration. Users wishing to add the global certificate to their local trust store can download the DigiCert Global Root CA from DigiCert. Using YAML-based configuration common: default_settings ca_bundle_path: /path/to/digicert.pem use_private_ssl: false # # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic ... Copy Summary There are two configuration settings that determine what certs are used by the agent to establish a secure connection to New Relic. They are: use_private_ssl and ca_bundle_path. Here's how they work together: DEFAULT: Neither configuration option (ca_bundle_path/use_private_ssl) is provided, because both are using default values. The agent will use the default SSL certificates bundled into the Java Development Kit (JDK). If these certificates aren't present or don't include certificates that trust New Relic, then the agent will not connect. You'll need to merge valid certificates into your JDK certificate bundle. Only use_private_ssl is configured. The agent will use the SSL certificates that are bundled with it. Only ca_bundle_path is configured. The agent will try to connect using the custom SSL certificates bundle at the configured path. If the configured custom certificate bundle doesn’t include certificates that trust New Relic, then the agent will not connect. You'll need to merge valid certificates into your custom certificate bundle. Both use_private_ssl and ca_bundle_path are configured. The ca_bundle_path configuration setting takes precedence and the use_private_ssl config is ignored. This behavior is the same as only specifying ca_bundle_path. Java Agent versions 6.0.0/6.1.0 Starting in 6.0.0, the Java agent no longer includes the nrcert global certificate chain. Users wishing to add the global certificate to their local trust store must download the DigiCert Global Root CA from DigiCert. Note: In versions 6.1.0+, the Java agent will use a bundled New Relic certificate that is valid for up to a year after release. Before the certificate expires, you must either update the agent to the latest version or provide a valid certificate using the ca_bundle_path configuration. Important The Java agent will begin logging a warning message upon application startup when there are less than three months before the bundled certificate expires. Using YAML-based configuration common: default_settings ca_bundle_path: /path/to/digicert.pem # # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic ... Copy Java Agent versions prior to 6.0.0 (Deprecated) For Java agent versions prior to 6.0.0, applications that require valid certificates may add them in one of the following two ways: Use YAML-based configuration. Add the bundled list of New Relic trusted signers to the local store. Using YAML-based configuration The New Relic Java agent bundles the list of trusted signers in the agent newrelic.jar file. If you do not want to change the local trust store, you can activate them by setting use_private_ssl to true in the newrelic.yml agent configuration file: common: default_settings use_private_ssl: true # # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic ... Copy For more help Additional documentation resources include New Relic for Java (compatibility and requirements, installation, and configuration.)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 102.41551,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Java</em> <em>Agent</em> versions 6.2.0 - 6.4.2",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " visit SSL or connection errors (<em>Java</em>). Notice of expired SSL certificates and certificate removal Caution The SSL certificates that were bundled with <em>Java</em> <em>agent</em> versions 6.1.0 to 6.4.2 have expired and are no longer valid. This means that <em>Java</em> <em>agent</em> versions 6.1.0 to 6.4.2 can no longer use"
      },
      "id": "603eb7a2e7b9d247c02a080d"
    },
    {
      "sections": [
        "Include the Java agent with a JVM argument",
        "Tip",
        "Coldfusion",
        "Geronimo",
        "Glassfish",
        "Important",
        "Grails",
        "Pass with run-app",
        "Pass with run-war",
        "JBoss",
        "Set with domain mode (6.x EAP and 7.0 AS)",
        "Caution",
        "Set with standalone mode (other versions)",
        "Jetty",
        "If you set exec in jetty.sh",
        "If you set exec in start.ini",
        "Play",
        "Play 1.2.4",
        "Play 2.0",
        "Play 2.2",
        "Play 2.3, 2.4, and 2.5",
        "Resin",
        "Solr",
        "Standalone Solr 5.x or higher",
        "Standalone Solr 4.x or lower",
        "App server Solr",
        "Spring Boot",
        "Tanuki Wrapper",
        "Tomcat",
        "With setenv.sh",
        "With setenv.bat",
        "With catalina.sh (NOT RECOMMENDED)",
        "With catalina.bat (NOT RECOMMENDED)",
        "With Windows",
        "With Apache Commons daemon",
        "WebLogic",
        "Administration servers on Linux or macOS",
        "Administration servers on Windows",
        "Managed server instances",
        "WebSphere",
        "WebSphere Community",
        "WebSphere Liberty Profile",
        "Wildfly",
        "Set with domain mode",
        "Set with standalone mode",
        "Other application servers"
      ],
      "title": "Include the Java agent with a JVM argument",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Installation"
      ],
      "external_id": "e2026d6c9754047a8a1056b061f9be471f80b42f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/installation/include-java-agent-jvm-argument/",
      "published_at": "2021-05-05T00:35:31Z",
      "updated_at": "2021-04-11T14:41:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document describes how to pass the -javaagent argument to the JVM for your framework. This installation step ensures the agent is included in your app. For all app servers, ensure you pass the full path to the newrelic.jar file. This document is simply a reference for how to pass the argument. For detailed installation procedures, see Java agent installation. Tip To use Java or any other agent, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Coldfusion To pass the -javaagent argument on Coldfusion: Start your ColdFusion server and navigate to your ColdFusion admin console. From the left menu, select SERVER SETTINGS > Java and JVM. If using the agent API: Specify the path to newrelic-api.jar in the ColdFusion Class Path field. In the JVM Arguments field, add the -javaagent argument: -javaagent:/full/path/to/newrelic.jar Copy Select Submit Changes, then restart your ColdFusion server. Geronimo To pass the -javaagent argument on Geronimo, refer to the New Relic agent jar in the JAVA_OPTS environment variable when running the startup command: export JAVA_OPTS=\"$JAVA_OPTS -javaagent:/full/path/to/newrelic.jar\" && geronimo run Copy Glassfish To pass the -javaagent argument on Glassfish: From the Glassfish console, select Application Server > JVM Settings > JVM Options. On the JVM Options page, select Add JVM Option. Add an entry for the -javaagent argument: -javaagent:/full/path/to/newrelic.jar Copy Save and restart Glassfish. If Glassfish does not start, the -javaagent argument might not have been set correctly. You can change the server JVM arguments by editing the domain.xml file. Important A bug in Glassfish 2.1 prevents classes on the bootstrap class loader (the New Relic agent) from using the Java logging API. This appears to be fixed in 2.1.1 or higher releases. Grails To pass the -javaagent argument on Grails: Pass with run-app Begin with an unzipped version of Grails. Run this command: grails -noreloading -javaagent:/full/path/to/newrelic.jar run-app Copy Pass with run-war In your Grails app, open this file with your text editor: grails-app/conf/BuildConfig.groovy Copy Add or edit the JVM arguments line: grails.tomcat.jvmArgs = [\"-javaagent:/full/path/to/newrelic.jar\"] Copy JBoss To pass the -javaagent argument on JBoss: Set with domain mode (6.x EAP and 7.0 AS) Use domain mode for JBoss versions 6.x EAP and 7.0 AS or above: Edit the JVM properties for your server group, located in: domain/configuration/domain.xml Copy Modify the properties to include the -javaagent argument: <server-group name=\"main-server-group\" profile=\"full\"> <jvm name=\"default\"> <jvm-options> <option value=\"-javaagent:/full/path/to/newrelic.jar\"/> </jvm-options> </jvm> ... </server-group> Copy Caution A JBoss bug in 7.0.2.Final and 7.1.0.Alpha1 does not allow JVM options to be set in domain.xml. If you encounter this problem, upgrade your JBoss application server. Set with standalone mode (other versions) Use standalone mode for other platforms and versions: Platform Directions Unix / macOS with 6.x EAP or 7.0.x AS and above At the bottom of bin/standalone.conf, add: JAVA_OPTS=\"$JAVA_OPTS -javaagent:/full/path/to/newrelic.jar\" Copy Windows with 6.x EAP or 7.0.x AS or higher In bin/standalone.bat, before the line: set JBOSS_ENDORSED_DIRS=%JBOSS_HOME%\\lib\\endorsed Copy Add: set \"JAVA_OPTS=-javaagent:C:/full/path/to/newrelic.jar %JAVA_OPTS%\" Copy Unix / macOS with 6.x or earlier At the bottom of bin/run.conf, add this: JAVA_OPTS=\"$JAVA_OPTS -javaagent:/full/path/to/newrelic.jar\" Copy Windows with 6.x or earlier In bin/run.bat, before the line: set JBOSS_CLASSPATH=%RUN_CLASSPATH% Copy Add: set \"JAVA_OPTS=-javaagent:C:/full/path/to/newrelic.jar %JAVA_OPTS%\" Copy Jetty To pass the -javaagent argument on Jetty: If you set exec in jetty.sh Edit the JAVA_OPTIONS in your jetty.sh script: export JAVA_OPTIONS=\"${JAVA_OPTIONS} -javaagent:/full/path/to/newrelic.jar\" Copy If you set exec in start.ini Add the agent path to your start.ini config file: -javaagent:/full/path/to/newrelic.jar Copy Play To pass the -javaagent argument on Play: Play 1.2.4 Append the -javaagent argument when running your Play application: play run your_app_name -javaagent:/full/path/to/newrelic.jar Copy Play 2.0 Begin with an unzipped distribution containing the start script: play clean dist && unzip dist/*.zip Copy Append the -javaagent argument when starting your Play app: cd unzipped/folder; chmod a+x start; ./start -javaagent:/full/path/to/newrelic.jar Copy Play 2.2 Begin with an unzipped distribution containing the start script: play clean dist && unzip target/directory/universal/*.zip Copy Append the -J-javaagent argument when starting your Play app: cd unzipped/folder; ./bin/scriptname -J-javaagent:/full/path/to/newrelic.jar Copy Tip To enable page load timing, see Manual instrumentation with Play 2.2. Play 2.3, 2.4, and 2.5 Begin with an unzipped distribution containing the start script: activator clean dist && unzip target/directory/universal/*.zip Copy Append the -J-javaagent argument when starting your Play app: cd unzipped/folder; ./bin/scriptname -J-javaagent:/full/path/to/newrelic.jar Copy If you use Typesafe Activator with Play 2.4, add this line to your build.sbt: javaOptions ++= Seq(\"-javaagent:/full/path/to/newrelic.jar\") Copy Resin To pass the -javaagent argument on Resin, add it to the <jvm-args> section in your resin.conf or resin.xml file: <jvm-arg>-javaagent:/full/path/to/newrelic.jar</jvm-arg> Copy Solr To pass the -javaagent argument on Solr: Standalone Solr 5.x or higher Add the -javaagent property to bin/solr.in.sh: SOLR_OPTS=\"$SOLR_OPTS -javaagent:/full/path/to/newrelic.jar\" Copy Standalone Solr 4.x or lower Add the -javaagent before the start.jar: java -javaagent:/full/path/to/newrelic.jar -jar start.jar Copy App server Solr When running Solr in an application server, follow the instructions of that application server to add the -javaagent flag. Also ensure that JMX is enabled for the application server. If you don't see data in the APM UI's Solr page, follow the troubleshooting procedures for Solr data. Spring Boot To pass the -javaagent argument on Spring Boot, add it to the command line in which you start your app. Make sure to add it before the -jar argument: java -javaagent:/full/path/to/newrelic.jar -jar app.jar Copy Tanuki Wrapper To pass the -javaagent argument on Tanuki Wrapper, add a wrapper option wrapper.conf. In the line below, substitute XXX for an unused number in this file: wrapper.java.additional.XXX=-javaagent:/full/path/to/newrelic.jar Copy Tip On Linux systems, no quotation marks are required when setting this value. This behavior may vary on other operating systems. Tomcat To pass the -javaagent argument on Tomcat: With setenv.sh Create a CATALINA_BASE/bin/setenv.sh script if one doesn't already exist. Configure your setenv.sh script to use the New Relic agent using the CATALINA_OPTS environment variable: export CATALINA_OPTS=\"$CATALINA_OPTS -javaagent:/full/path/to/newrelic.jar\" Copy With setenv.bat Create a CATALINA_BASE/bin/setenv.bat script if one doesn't already exist. Configure your setenv.bat script to use the New Relic agent using the CATALINA_OPTS environment variable: SET \"CATALINA_OPTS=%CATALINA_OPTS% -javaagent:/full/path/to/newrelic.jar\" Copy With catalina.sh (NOT RECOMMENDED) Tip We recommend that you do not set any variables in this script. Instead put them into a script setenv.sh in CATALINA_BASE/bin to keep your customizations separate. Configure your catalina.sh file to use the New Relic agent using the JAVA_OPTS environment variable: export JAVA_OPTS=\"$JAVA_OPTS -javaagent:/full/path/to/newrelic.jar\" Copy With catalina.bat (NOT RECOMMENDED) Tip We recommend that you do not set any variables in this script. Instead put them into a script setenv.bat in CATALINA_BASE/bin to keep your customizations separate. If you use catalina.bat to launch Tomcat, set the JAVA_OPTS variable near the top of the file: SET JAVA_OPTS=%JAVA_OPTS% -javaagent:/full/path/to/newrelic.jar Copy With Windows Select Start > Apache Tomcat X.Y.Z. > Configure Tomcat > Java. In the Java Options text box, enter the argument. Use forward slashes / for the path separator. For Tomcat 6, add a line break after the -javaagent argument. -javaagent:/full/path/to/newrelic.jar Copy Select Apply, then restart Tomcat. With Apache Commons daemon The version of Apache Commons Daemon (jsvc) included with Tomcat 6 does not support the -javaagent argument used by New Relic. However, a build of the jsvc daemon from the trunk source will support the -javaagent argument via the -X prefix. See the Apache bug tracking the issue. There is a fix in the Apache Commons source repository. For more information: See the Apache source repository documentation. Go directly to the SVN source repository. WebLogic To pass the -javaagent argument on WebLogic: Administration servers on Linux or macOS Edit your startWebLogic.sh file, located in the domain's bin directory. Near the beginning of the file, add: export JAVA_OPTIONS=\"$JAVA_OPTIONS -javaagent:/full/path/to/newrelic.jar\" Copy Administration servers on Windows Edit your startWebLogic.bat file, located in the domain's bin directory. Near the beginning of the file, add: set JAVA_OPTIONS=%JAVA_OPTIONS% -javaagent:\"C:\\full\\path\\to\\newrelic.jar\" Copy Managed server instances For administration server instances, follow the Linux/macOS or Windows instructions. You cannot use the administration console to install administration server instances. For managed server instances, use the admin console: From the administration console, navigate to Environments > Servers > (select a server) > Server Start > Arguments. From Arguments, add: -javaagent:/full/path/to/newrelic.jar Copy Save the page, then restart your server instance. WebSphere To pass the -javaagent argument on WebSphere: From the admin console, select Servers > Application servers > (select a server) > Configuration > Service Infrastructure > Java and Process Management. Select Process Definition > Additional Properties, then select Java Virtual Machine. In the Generic JVM arguments field, add the -javaagent argument for your newrelic.jar file: -javaagent:/full/path/to/newrelic.jar Copy Select Apply, then select Save. Restart your server. For more information, see the documentation about collecting WebSphere PMI metrics. WebSphere Community To pass the -javaagent argument on WebSphere Community Edition, refer to the New Relic agent jar in the JAVA_OPTS environment variable when running the startup command: export JAVA_OPTS=\"$JAVA_OPTS -javaagent:/full/path/to/newrelic.jar\" && startup Copy WebSphere Liberty Profile To pass the -javaagent argument on WebSphere Liberty Profile: Edit ${server.config.dir}/jvm.options. Add the -javaagent argument to point to your newrelic.jar file: -javaagent:/full/path/to/newrelic.jar Copy Restart your server. Wildfly To pass the -javaagent argument on Wildfly (if using Wildfly 11 or higher, see additional install instructions): Set with domain mode Edit the JVM properties for your server group, located in: domain/configuration/domain.xml Copy Modify the properties to include the -javaagent argument: <server-group name=\"main-server-group\" profile=\"full\"> <jvm name=\"default\"> <jvm-options> <option value=\"-javaagent:/full/path/to/newrelic.jar\"/> </jvm-options> </jvm> ... </server-group> Copy Set with standalone mode Platform Directions Unix or macOS At the bottom of bin/standalone.conf, add: JAVA_OPTS=\"$JAVA_OPTS -javaagent:/full/path/to/newrelic.jar\" Copy Windows In bin/standalone.bat, find this line: rem Setup JBoss specific properties Copy Then add: set \"JAVA_OPTS=-javaagent:C:/full/path/to/newrelic.jar %JAVA_OPTS%\" Copy Other application servers The New Relic Java agent works on any supported app server. If your app server is not listed in this document, follow standard procedures for your app server to pass this argument to the JVM before the app jar: -javaagent:/full/path/to/newrelic.jar Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 101.05803,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Include the <em>Java</em> <em>agent</em> with a JVM argument",
        "sections": "Include the <em>Java</em> <em>agent</em> with a JVM argument",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": ". For detailed <em>installation</em> procedures, see <em>Java</em> <em>agent</em> <em>installation</em>. Tip To use <em>Java</em> or any other <em>agent</em>, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month"
      },
      "id": "6043b8f6e7b9d209f5579a28"
    },
    {
      "sections": [
        "Update the Java agent",
        "Update to latest version",
        "Update agent config differences",
        "Java agent versions not supported",
        "Update unsupported agent versions",
        "Important"
      ],
      "title": "Update the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Installation"
      ],
      "external_id": "a1227c7d2b79b2080a67400bbc65920f7142d294",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/installation/update-java-agent/",
      "published_at": "2021-05-05T06:52:36Z",
      "updated_at": "2021-03-16T15:07:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To take full advantage of New Relic's latest features, enhancements, and important security patches, we recommend you update your Java agent to the latest version. For additional information about specific agent updates, refer to the Java agent release notes. These update procedures describe how to replace some of the current contents of your agent root directory, which contains the New Relic Java agent (newrelic.jar), with newly downloaded contents from the New Relic UI. Update to latest version To identify which version of the Java agent you're currently using, run java -jar newrelic.jar -v. Your Java agent version will be printed to your console. Then, to update to the latest Java agent version: Back up the entire Java agent root directory to another location. Rename that directory to NewRelic_Agent#.#.#, where #.#.# is the agent version number. Go to one.newrelic.com > (account dropdown) > Account settings. Download the agent for your platform. Unzip the new agent download file, then copy newrelic-api.jar and newrelic.jar into the original Java agent root directory. Diff your current newrelic.yml with the newly downloaded newrelic.yml from the zip, and update customized differences as needed. Restart your Java dispatcher. If you experience issues after the Java agent update, restore from the backed-up New Relic agent directory. Update agent config differences If differences between the two versions are unrelated to your app's customizations, align the newrelic.yml you use moving forward with the latest updates to the default newrelic.yml from New Relic. For example, if you diff the default newrelic.yml files for Java agent versions 3.29.0 and 3.30.0, the results printed to the console will be: ➜ diff newrelic_3.29.0.yml newrelic_3.30.0.yml 254a255,265 > # Classes loaded by classloaders in this list will not be instrumented. > # This is a useful optimization for runtimes which use classloaders to > # load dynamic classes which the agent would not instrument. > classloader_excludes: > groovy.lang.GroovyClassLoader$InnerLoader, > org.codehaus.groovy.runtime.callsite.CallSiteClassLoader, > com.collaxa.cube.engine.deployment.BPELClassLoader, > org.springframework.data.convert.ClassGeneratingEntityInstantiator$ObjectInstantiatorClassGenerator, > org.mvel2.optimizers.impl.asm.ASMAccessorOptimizer$ContextClassLoader, > gw.internal.gosu.compiler.SingleServingGosuClassLoader, > Copy These lines were added to the default newrelic.yml in Java agent version 3.30.0. If you want to run Java agent version 3.30.0 or higher, ensure you include these lines in your newrelic.yml. Java agent versions not supported End of life notification: As of January 26, 2015, New Relic will no longer accept data from Java agent versions earlier than 3.6.0, except version 2.21.7. These agent versions use an out-of-date protocol when communicating with New Relic's data collection services. In addition, many of these versions contain a potential security issue where they may incorrectly send sensitive data to the New Relic collector. Update unsupported agent versions Important If you are updating from an older agent version, including major version jumps, review the following list for changes in functionality. Migration Comments 5.0.0 Release notes: Java agent 5.0.0 Self installer: The New Relic Java agent's self-installer has been removed in order to provide a more consistent user experience. To install the Java agent, add the full path to the newrelic.jar to the -javaagent flag in your JVM options. For more information, see the documentation on installing the agent on specific application servers, including Docker, Maven, or Gradle. Deprecated instrumentation: The following instrumentation modules have been moved out of the default Java agent. They are now provided as a separate download. To continue using these modules, just add them to the agent's extensions directory in your New Relic folder or wherever your extensions directory is configured. Deprecated modules include: Akka 2.0 Akka 2.1 Akka-http 1.0 Akka-http 2.0 - 2.4.1 Akka-http 2.4.2 - 2.4.4 Hystrix 1.2 Hystrix 1.3 Play 1: Instrumentation for Play-1.x is not available as an extension. Play 2.0 Play 2.1 Play 2.2 Solr 3.1 - 3.4 Solr 3.5 Solr 3.6 4.12.0 Release notes: Java agent 4.12.0 Deprecated APIs: The custom transport channel API is now deprecated in favor of the distributed tracing API. The skipTransactionTrace attribute on the @Trace annotation is now deprecated. Instead, use the excludeFromTransactionTrace attribute. Deprecated instrumentation: JetS3t: Removed built-in instrumentation for JetS3t. The agent will continue to report external calls made with the JetS3t client. 4.4.0 Release notes: Java agent 4.4.0 Java 6 support removed: You must use 4.3 or earlier. EU data center: Minimum version required for use in EU datacenter. Removed the SSL configuration option: SSL is now always used in communication with New Relic servers. The newrelic.yml ssl configuration and -Dnewrelic.config.ssl system property are no longer used. Setting either value to anything other than true will result in logging a warning. Legacy agent 2.21.7 Release notes: Java agent 2.21.7 Java SE 5.0: This is a bugfix release for the legacy Java SE 5.0 version of the agent. Unless you are a Java SE5 user, use the latest version of the New Relic Java agent. This affects: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, OS X Oracle JRockit up to and including 1.6.0_50",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.22806,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Update the <em>Java</em> <em>agent</em>",
        "sections": "Update the <em>Java</em> <em>agent</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "To take full advantage of New Relic&#x27;s latest features, enhancements, and important security patches, we recommend you update your <em>Java</em> <em>agent</em> to the latest version. For additional information about specific <em>agent</em> updates, refer to the <em>Java</em> <em>agent</em> release notes. These update procedures describe how"
      },
      "id": "603ec448196a67700ba83dc5"
    }
  ],
  "/docs/agents/java-agent/installation/uninstall-java-agent": [
    {
      "sections": [
        "Configuring your SSL certificates",
        "Notice of expired SSL certificates and certificate removal",
        "Caution",
        "Important",
        "Java Agent versions 6.2.0 - 6.4.2",
        "Java Agent versions 6.0.0/6.1.0",
        "Using YAML-based configuration",
        "Java Agent versions prior to 6.0.0 (Deprecated)",
        "For more help"
      ],
      "title": "Configuring your SSL certificates",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "af154f250e87f571db157972e22dbb1f907a8fde",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/configuring-your-ssl-certificates/",
      "published_at": "2021-05-05T06:44:59Z",
      "updated_at": "2021-04-28T23:01:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To communicate with the New Relic collector over HTTPS, you need to have the proper certificates for trusted signers in the trust store on your app server. By default, most JREs contain a valid root certificate that allows the agent to connect to newrelic.com. For SSL connection issues, please visit SSL or connection errors (Java). Notice of expired SSL certificates and certificate removal Caution The SSL certificates that were bundled with Java agent versions 6.1.0 to 6.4.2 have expired and are no longer valid. This means that Java agent versions 6.1.0 to 6.4.2 can no longer use the certificates bundled with the agent to establish a connection with New Relic and that you must provide your own SSL certificates. Please see this community forum post for additional details. Important Java agent versions higher than 6.4.2 no longer ship with SSL certificates bundled into the agent. You must provide your own SSL truststore to the agent by explicitly using the ca_bundle_path configuration option, or by using the default truststore provided by the JDK/JRE (the agent will look to use the latter by default). Additionally the use_private_ssl configuration option has been removed from Java agent versions higher than 6.4.2. Users wishing to add the global certificate to their local trust store can download the DigiCert Global Root CA from DigiCert. Java Agent versions 6.2.0 - 6.4.2 Starting with Java agent version 6.2.0, the use_private_ssl configuration option has been reintroduced so you can use the SSL certificates that are bundled into the agent jar. The following bundled SSL certificates are valid for up to a year after release. META-INF/certs/eu-newrelic-com.pem META-INF/certs/eu01-nr-data-net.pem META-INF/certs/newrelic-com.pem Copy Important The Java agent will begin logging a warning message upon application startup when there are less than three months before the bundled certificate expires. When the bundled certificates expire, the Java agent will no longer be able to connect to New Relic and you must either update to the latest agent version or provide a valid certificate using the ca_bundle_path configuration. Users wishing to add the global certificate to their local trust store can download the DigiCert Global Root CA from DigiCert. Using YAML-based configuration common: default_settings ca_bundle_path: /path/to/digicert.pem use_private_ssl: false # # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic ... Copy Summary There are two configuration settings that determine what certs are used by the agent to establish a secure connection to New Relic. They are: use_private_ssl and ca_bundle_path. Here's how they work together: DEFAULT: Neither configuration option (ca_bundle_path/use_private_ssl) is provided, because both are using default values. The agent will use the default SSL certificates bundled into the Java Development Kit (JDK). If these certificates aren't present or don't include certificates that trust New Relic, then the agent will not connect. You'll need to merge valid certificates into your JDK certificate bundle. Only use_private_ssl is configured. The agent will use the SSL certificates that are bundled with it. Only ca_bundle_path is configured. The agent will try to connect using the custom SSL certificates bundle at the configured path. If the configured custom certificate bundle doesn’t include certificates that trust New Relic, then the agent will not connect. You'll need to merge valid certificates into your custom certificate bundle. Both use_private_ssl and ca_bundle_path are configured. The ca_bundle_path configuration setting takes precedence and the use_private_ssl config is ignored. This behavior is the same as only specifying ca_bundle_path. Java Agent versions 6.0.0/6.1.0 Starting in 6.0.0, the Java agent no longer includes the nrcert global certificate chain. Users wishing to add the global certificate to their local trust store must download the DigiCert Global Root CA from DigiCert. Note: In versions 6.1.0+, the Java agent will use a bundled New Relic certificate that is valid for up to a year after release. Before the certificate expires, you must either update the agent to the latest version or provide a valid certificate using the ca_bundle_path configuration. Important The Java agent will begin logging a warning message upon application startup when there are less than three months before the bundled certificate expires. Using YAML-based configuration common: default_settings ca_bundle_path: /path/to/digicert.pem # # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic ... Copy Java Agent versions prior to 6.0.0 (Deprecated) For Java agent versions prior to 6.0.0, applications that require valid certificates may add them in one of the following two ways: Use YAML-based configuration. Add the bundled list of New Relic trusted signers to the local store. Using YAML-based configuration The New Relic Java agent bundles the list of trusted signers in the agent newrelic.jar file. If you do not want to change the local trust store, you can activate them by setting use_private_ssl to true in the newrelic.yml agent configuration file: common: default_settings use_private_ssl: true # # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic ... Copy For more help Additional documentation resources include New Relic for Java (compatibility and requirements, installation, and configuration.)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 102.41548,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Java</em> <em>Agent</em> versions 6.2.0 - 6.4.2",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " visit SSL or connection errors (<em>Java</em>). Notice of expired SSL certificates and certificate removal Caution The SSL certificates that were bundled with <em>Java</em> <em>agent</em> versions 6.1.0 to 6.4.2 have expired and are no longer valid. This means that <em>Java</em> <em>agent</em> versions 6.1.0 to 6.4.2 can no longer use"
      },
      "id": "603eb7a2e7b9d247c02a080d"
    },
    {
      "sections": [
        "Include the Java agent with a JVM argument",
        "Tip",
        "Coldfusion",
        "Geronimo",
        "Glassfish",
        "Important",
        "Grails",
        "Pass with run-app",
        "Pass with run-war",
        "JBoss",
        "Set with domain mode (6.x EAP and 7.0 AS)",
        "Caution",
        "Set with standalone mode (other versions)",
        "Jetty",
        "If you set exec in jetty.sh",
        "If you set exec in start.ini",
        "Play",
        "Play 1.2.4",
        "Play 2.0",
        "Play 2.2",
        "Play 2.3, 2.4, and 2.5",
        "Resin",
        "Solr",
        "Standalone Solr 5.x or higher",
        "Standalone Solr 4.x or lower",
        "App server Solr",
        "Spring Boot",
        "Tanuki Wrapper",
        "Tomcat",
        "With setenv.sh",
        "With setenv.bat",
        "With catalina.sh (NOT RECOMMENDED)",
        "With catalina.bat (NOT RECOMMENDED)",
        "With Windows",
        "With Apache Commons daemon",
        "WebLogic",
        "Administration servers on Linux or macOS",
        "Administration servers on Windows",
        "Managed server instances",
        "WebSphere",
        "WebSphere Community",
        "WebSphere Liberty Profile",
        "Wildfly",
        "Set with domain mode",
        "Set with standalone mode",
        "Other application servers"
      ],
      "title": "Include the Java agent with a JVM argument",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Installation"
      ],
      "external_id": "e2026d6c9754047a8a1056b061f9be471f80b42f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/installation/include-java-agent-jvm-argument/",
      "published_at": "2021-05-05T00:35:31Z",
      "updated_at": "2021-04-11T14:41:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document describes how to pass the -javaagent argument to the JVM for your framework. This installation step ensures the agent is included in your app. For all app servers, ensure you pass the full path to the newrelic.jar file. This document is simply a reference for how to pass the argument. For detailed installation procedures, see Java agent installation. Tip To use Java or any other agent, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Coldfusion To pass the -javaagent argument on Coldfusion: Start your ColdFusion server and navigate to your ColdFusion admin console. From the left menu, select SERVER SETTINGS > Java and JVM. If using the agent API: Specify the path to newrelic-api.jar in the ColdFusion Class Path field. In the JVM Arguments field, add the -javaagent argument: -javaagent:/full/path/to/newrelic.jar Copy Select Submit Changes, then restart your ColdFusion server. Geronimo To pass the -javaagent argument on Geronimo, refer to the New Relic agent jar in the JAVA_OPTS environment variable when running the startup command: export JAVA_OPTS=\"$JAVA_OPTS -javaagent:/full/path/to/newrelic.jar\" && geronimo run Copy Glassfish To pass the -javaagent argument on Glassfish: From the Glassfish console, select Application Server > JVM Settings > JVM Options. On the JVM Options page, select Add JVM Option. Add an entry for the -javaagent argument: -javaagent:/full/path/to/newrelic.jar Copy Save and restart Glassfish. If Glassfish does not start, the -javaagent argument might not have been set correctly. You can change the server JVM arguments by editing the domain.xml file. Important A bug in Glassfish 2.1 prevents classes on the bootstrap class loader (the New Relic agent) from using the Java logging API. This appears to be fixed in 2.1.1 or higher releases. Grails To pass the -javaagent argument on Grails: Pass with run-app Begin with an unzipped version of Grails. Run this command: grails -noreloading -javaagent:/full/path/to/newrelic.jar run-app Copy Pass with run-war In your Grails app, open this file with your text editor: grails-app/conf/BuildConfig.groovy Copy Add or edit the JVM arguments line: grails.tomcat.jvmArgs = [\"-javaagent:/full/path/to/newrelic.jar\"] Copy JBoss To pass the -javaagent argument on JBoss: Set with domain mode (6.x EAP and 7.0 AS) Use domain mode for JBoss versions 6.x EAP and 7.0 AS or above: Edit the JVM properties for your server group, located in: domain/configuration/domain.xml Copy Modify the properties to include the -javaagent argument: <server-group name=\"main-server-group\" profile=\"full\"> <jvm name=\"default\"> <jvm-options> <option value=\"-javaagent:/full/path/to/newrelic.jar\"/> </jvm-options> </jvm> ... </server-group> Copy Caution A JBoss bug in 7.0.2.Final and 7.1.0.Alpha1 does not allow JVM options to be set in domain.xml. If you encounter this problem, upgrade your JBoss application server. Set with standalone mode (other versions) Use standalone mode for other platforms and versions: Platform Directions Unix / macOS with 6.x EAP or 7.0.x AS and above At the bottom of bin/standalone.conf, add: JAVA_OPTS=\"$JAVA_OPTS -javaagent:/full/path/to/newrelic.jar\" Copy Windows with 6.x EAP or 7.0.x AS or higher In bin/standalone.bat, before the line: set JBOSS_ENDORSED_DIRS=%JBOSS_HOME%\\lib\\endorsed Copy Add: set \"JAVA_OPTS=-javaagent:C:/full/path/to/newrelic.jar %JAVA_OPTS%\" Copy Unix / macOS with 6.x or earlier At the bottom of bin/run.conf, add this: JAVA_OPTS=\"$JAVA_OPTS -javaagent:/full/path/to/newrelic.jar\" Copy Windows with 6.x or earlier In bin/run.bat, before the line: set JBOSS_CLASSPATH=%RUN_CLASSPATH% Copy Add: set \"JAVA_OPTS=-javaagent:C:/full/path/to/newrelic.jar %JAVA_OPTS%\" Copy Jetty To pass the -javaagent argument on Jetty: If you set exec in jetty.sh Edit the JAVA_OPTIONS in your jetty.sh script: export JAVA_OPTIONS=\"${JAVA_OPTIONS} -javaagent:/full/path/to/newrelic.jar\" Copy If you set exec in start.ini Add the agent path to your start.ini config file: -javaagent:/full/path/to/newrelic.jar Copy Play To pass the -javaagent argument on Play: Play 1.2.4 Append the -javaagent argument when running your Play application: play run your_app_name -javaagent:/full/path/to/newrelic.jar Copy Play 2.0 Begin with an unzipped distribution containing the start script: play clean dist && unzip dist/*.zip Copy Append the -javaagent argument when starting your Play app: cd unzipped/folder; chmod a+x start; ./start -javaagent:/full/path/to/newrelic.jar Copy Play 2.2 Begin with an unzipped distribution containing the start script: play clean dist && unzip target/directory/universal/*.zip Copy Append the -J-javaagent argument when starting your Play app: cd unzipped/folder; ./bin/scriptname -J-javaagent:/full/path/to/newrelic.jar Copy Tip To enable page load timing, see Manual instrumentation with Play 2.2. Play 2.3, 2.4, and 2.5 Begin with an unzipped distribution containing the start script: activator clean dist && unzip target/directory/universal/*.zip Copy Append the -J-javaagent argument when starting your Play app: cd unzipped/folder; ./bin/scriptname -J-javaagent:/full/path/to/newrelic.jar Copy If you use Typesafe Activator with Play 2.4, add this line to your build.sbt: javaOptions ++= Seq(\"-javaagent:/full/path/to/newrelic.jar\") Copy Resin To pass the -javaagent argument on Resin, add it to the <jvm-args> section in your resin.conf or resin.xml file: <jvm-arg>-javaagent:/full/path/to/newrelic.jar</jvm-arg> Copy Solr To pass the -javaagent argument on Solr: Standalone Solr 5.x or higher Add the -javaagent property to bin/solr.in.sh: SOLR_OPTS=\"$SOLR_OPTS -javaagent:/full/path/to/newrelic.jar\" Copy Standalone Solr 4.x or lower Add the -javaagent before the start.jar: java -javaagent:/full/path/to/newrelic.jar -jar start.jar Copy App server Solr When running Solr in an application server, follow the instructions of that application server to add the -javaagent flag. Also ensure that JMX is enabled for the application server. If you don't see data in the APM UI's Solr page, follow the troubleshooting procedures for Solr data. Spring Boot To pass the -javaagent argument on Spring Boot, add it to the command line in which you start your app. Make sure to add it before the -jar argument: java -javaagent:/full/path/to/newrelic.jar -jar app.jar Copy Tanuki Wrapper To pass the -javaagent argument on Tanuki Wrapper, add a wrapper option wrapper.conf. In the line below, substitute XXX for an unused number in this file: wrapper.java.additional.XXX=-javaagent:/full/path/to/newrelic.jar Copy Tip On Linux systems, no quotation marks are required when setting this value. This behavior may vary on other operating systems. Tomcat To pass the -javaagent argument on Tomcat: With setenv.sh Create a CATALINA_BASE/bin/setenv.sh script if one doesn't already exist. Configure your setenv.sh script to use the New Relic agent using the CATALINA_OPTS environment variable: export CATALINA_OPTS=\"$CATALINA_OPTS -javaagent:/full/path/to/newrelic.jar\" Copy With setenv.bat Create a CATALINA_BASE/bin/setenv.bat script if one doesn't already exist. Configure your setenv.bat script to use the New Relic agent using the CATALINA_OPTS environment variable: SET \"CATALINA_OPTS=%CATALINA_OPTS% -javaagent:/full/path/to/newrelic.jar\" Copy With catalina.sh (NOT RECOMMENDED) Tip We recommend that you do not set any variables in this script. Instead put them into a script setenv.sh in CATALINA_BASE/bin to keep your customizations separate. Configure your catalina.sh file to use the New Relic agent using the JAVA_OPTS environment variable: export JAVA_OPTS=\"$JAVA_OPTS -javaagent:/full/path/to/newrelic.jar\" Copy With catalina.bat (NOT RECOMMENDED) Tip We recommend that you do not set any variables in this script. Instead put them into a script setenv.bat in CATALINA_BASE/bin to keep your customizations separate. If you use catalina.bat to launch Tomcat, set the JAVA_OPTS variable near the top of the file: SET JAVA_OPTS=%JAVA_OPTS% -javaagent:/full/path/to/newrelic.jar Copy With Windows Select Start > Apache Tomcat X.Y.Z. > Configure Tomcat > Java. In the Java Options text box, enter the argument. Use forward slashes / for the path separator. For Tomcat 6, add a line break after the -javaagent argument. -javaagent:/full/path/to/newrelic.jar Copy Select Apply, then restart Tomcat. With Apache Commons daemon The version of Apache Commons Daemon (jsvc) included with Tomcat 6 does not support the -javaagent argument used by New Relic. However, a build of the jsvc daemon from the trunk source will support the -javaagent argument via the -X prefix. See the Apache bug tracking the issue. There is a fix in the Apache Commons source repository. For more information: See the Apache source repository documentation. Go directly to the SVN source repository. WebLogic To pass the -javaagent argument on WebLogic: Administration servers on Linux or macOS Edit your startWebLogic.sh file, located in the domain's bin directory. Near the beginning of the file, add: export JAVA_OPTIONS=\"$JAVA_OPTIONS -javaagent:/full/path/to/newrelic.jar\" Copy Administration servers on Windows Edit your startWebLogic.bat file, located in the domain's bin directory. Near the beginning of the file, add: set JAVA_OPTIONS=%JAVA_OPTIONS% -javaagent:\"C:\\full\\path\\to\\newrelic.jar\" Copy Managed server instances For administration server instances, follow the Linux/macOS or Windows instructions. You cannot use the administration console to install administration server instances. For managed server instances, use the admin console: From the administration console, navigate to Environments > Servers > (select a server) > Server Start > Arguments. From Arguments, add: -javaagent:/full/path/to/newrelic.jar Copy Save the page, then restart your server instance. WebSphere To pass the -javaagent argument on WebSphere: From the admin console, select Servers > Application servers > (select a server) > Configuration > Service Infrastructure > Java and Process Management. Select Process Definition > Additional Properties, then select Java Virtual Machine. In the Generic JVM arguments field, add the -javaagent argument for your newrelic.jar file: -javaagent:/full/path/to/newrelic.jar Copy Select Apply, then select Save. Restart your server. For more information, see the documentation about collecting WebSphere PMI metrics. WebSphere Community To pass the -javaagent argument on WebSphere Community Edition, refer to the New Relic agent jar in the JAVA_OPTS environment variable when running the startup command: export JAVA_OPTS=\"$JAVA_OPTS -javaagent:/full/path/to/newrelic.jar\" && startup Copy WebSphere Liberty Profile To pass the -javaagent argument on WebSphere Liberty Profile: Edit ${server.config.dir}/jvm.options. Add the -javaagent argument to point to your newrelic.jar file: -javaagent:/full/path/to/newrelic.jar Copy Restart your server. Wildfly To pass the -javaagent argument on Wildfly (if using Wildfly 11 or higher, see additional install instructions): Set with domain mode Edit the JVM properties for your server group, located in: domain/configuration/domain.xml Copy Modify the properties to include the -javaagent argument: <server-group name=\"main-server-group\" profile=\"full\"> <jvm name=\"default\"> <jvm-options> <option value=\"-javaagent:/full/path/to/newrelic.jar\"/> </jvm-options> </jvm> ... </server-group> Copy Set with standalone mode Platform Directions Unix or macOS At the bottom of bin/standalone.conf, add: JAVA_OPTS=\"$JAVA_OPTS -javaagent:/full/path/to/newrelic.jar\" Copy Windows In bin/standalone.bat, find this line: rem Setup JBoss specific properties Copy Then add: set \"JAVA_OPTS=-javaagent:C:/full/path/to/newrelic.jar %JAVA_OPTS%\" Copy Other application servers The New Relic Java agent works on any supported app server. If your app server is not listed in this document, follow standard procedures for your app server to pass this argument to the JVM before the app jar: -javaagent:/full/path/to/newrelic.jar Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 101.058014,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Include the <em>Java</em> <em>agent</em> with a JVM argument",
        "sections": "Include the <em>Java</em> <em>agent</em> with a JVM argument",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": ". For detailed <em>installation</em> procedures, see <em>Java</em> <em>agent</em> <em>installation</em>. Tip To use <em>Java</em> or any other <em>agent</em>, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month"
      },
      "id": "6043b8f6e7b9d209f5579a28"
    },
    {
      "sections": [
        "Update the Java agent",
        "Update to latest version",
        "Update agent config differences",
        "Java agent versions not supported",
        "Update unsupported agent versions",
        "Important"
      ],
      "title": "Update the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Installation"
      ],
      "external_id": "a1227c7d2b79b2080a67400bbc65920f7142d294",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/installation/update-java-agent/",
      "published_at": "2021-05-05T06:52:36Z",
      "updated_at": "2021-03-16T15:07:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To take full advantage of New Relic's latest features, enhancements, and important security patches, we recommend you update your Java agent to the latest version. For additional information about specific agent updates, refer to the Java agent release notes. These update procedures describe how to replace some of the current contents of your agent root directory, which contains the New Relic Java agent (newrelic.jar), with newly downloaded contents from the New Relic UI. Update to latest version To identify which version of the Java agent you're currently using, run java -jar newrelic.jar -v. Your Java agent version will be printed to your console. Then, to update to the latest Java agent version: Back up the entire Java agent root directory to another location. Rename that directory to NewRelic_Agent#.#.#, where #.#.# is the agent version number. Go to one.newrelic.com > (account dropdown) > Account settings. Download the agent for your platform. Unzip the new agent download file, then copy newrelic-api.jar and newrelic.jar into the original Java agent root directory. Diff your current newrelic.yml with the newly downloaded newrelic.yml from the zip, and update customized differences as needed. Restart your Java dispatcher. If you experience issues after the Java agent update, restore from the backed-up New Relic agent directory. Update agent config differences If differences between the two versions are unrelated to your app's customizations, align the newrelic.yml you use moving forward with the latest updates to the default newrelic.yml from New Relic. For example, if you diff the default newrelic.yml files for Java agent versions 3.29.0 and 3.30.0, the results printed to the console will be: ➜ diff newrelic_3.29.0.yml newrelic_3.30.0.yml 254a255,265 > # Classes loaded by classloaders in this list will not be instrumented. > # This is a useful optimization for runtimes which use classloaders to > # load dynamic classes which the agent would not instrument. > classloader_excludes: > groovy.lang.GroovyClassLoader$InnerLoader, > org.codehaus.groovy.runtime.callsite.CallSiteClassLoader, > com.collaxa.cube.engine.deployment.BPELClassLoader, > org.springframework.data.convert.ClassGeneratingEntityInstantiator$ObjectInstantiatorClassGenerator, > org.mvel2.optimizers.impl.asm.ASMAccessorOptimizer$ContextClassLoader, > gw.internal.gosu.compiler.SingleServingGosuClassLoader, > Copy These lines were added to the default newrelic.yml in Java agent version 3.30.0. If you want to run Java agent version 3.30.0 or higher, ensure you include these lines in your newrelic.yml. Java agent versions not supported End of life notification: As of January 26, 2015, New Relic will no longer accept data from Java agent versions earlier than 3.6.0, except version 2.21.7. These agent versions use an out-of-date protocol when communicating with New Relic's data collection services. In addition, many of these versions contain a potential security issue where they may incorrectly send sensitive data to the New Relic collector. Update unsupported agent versions Important If you are updating from an older agent version, including major version jumps, review the following list for changes in functionality. Migration Comments 5.0.0 Release notes: Java agent 5.0.0 Self installer: The New Relic Java agent's self-installer has been removed in order to provide a more consistent user experience. To install the Java agent, add the full path to the newrelic.jar to the -javaagent flag in your JVM options. For more information, see the documentation on installing the agent on specific application servers, including Docker, Maven, or Gradle. Deprecated instrumentation: The following instrumentation modules have been moved out of the default Java agent. They are now provided as a separate download. To continue using these modules, just add them to the agent's extensions directory in your New Relic folder or wherever your extensions directory is configured. Deprecated modules include: Akka 2.0 Akka 2.1 Akka-http 1.0 Akka-http 2.0 - 2.4.1 Akka-http 2.4.2 - 2.4.4 Hystrix 1.2 Hystrix 1.3 Play 1: Instrumentation for Play-1.x is not available as an extension. Play 2.0 Play 2.1 Play 2.2 Solr 3.1 - 3.4 Solr 3.5 Solr 3.6 4.12.0 Release notes: Java agent 4.12.0 Deprecated APIs: The custom transport channel API is now deprecated in favor of the distributed tracing API. The skipTransactionTrace attribute on the @Trace annotation is now deprecated. Instead, use the excludeFromTransactionTrace attribute. Deprecated instrumentation: JetS3t: Removed built-in instrumentation for JetS3t. The agent will continue to report external calls made with the JetS3t client. 4.4.0 Release notes: Java agent 4.4.0 Java 6 support removed: You must use 4.3 or earlier. EU data center: Minimum version required for use in EU datacenter. Removed the SSL configuration option: SSL is now always used in communication with New Relic servers. The newrelic.yml ssl configuration and -Dnewrelic.config.ssl system property are no longer used. Setting either value to anything other than true will result in logging a warning. Legacy agent 2.21.7 Release notes: Java agent 2.21.7 Java SE 5.0: This is a bugfix release for the legacy Java SE 5.0 version of the agent. Unless you are a Java SE5 user, use the latest version of the New Relic Java agent. This affects: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, OS X Oracle JRockit up to and including 1.6.0_50",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.22806,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Update the <em>Java</em> <em>agent</em>",
        "sections": "Update the <em>Java</em> <em>agent</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "To take full advantage of New Relic&#x27;s latest features, enhancements, and important security patches, we recommend you update your <em>Java</em> <em>agent</em> to the latest version. For additional information about specific <em>agent</em> updates, refer to the <em>Java</em> <em>agent</em> release notes. These update procedures describe how"
      },
      "id": "603ec448196a67700ba83dc5"
    }
  ],
  "/docs/agents/java-agent/installation/update-java-agent": [
    {
      "sections": [
        "Configuring your SSL certificates",
        "Notice of expired SSL certificates and certificate removal",
        "Caution",
        "Important",
        "Java Agent versions 6.2.0 - 6.4.2",
        "Java Agent versions 6.0.0/6.1.0",
        "Using YAML-based configuration",
        "Java Agent versions prior to 6.0.0 (Deprecated)",
        "For more help"
      ],
      "title": "Configuring your SSL certificates",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "af154f250e87f571db157972e22dbb1f907a8fde",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/configuring-your-ssl-certificates/",
      "published_at": "2021-05-05T06:44:59Z",
      "updated_at": "2021-04-28T23:01:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To communicate with the New Relic collector over HTTPS, you need to have the proper certificates for trusted signers in the trust store on your app server. By default, most JREs contain a valid root certificate that allows the agent to connect to newrelic.com. For SSL connection issues, please visit SSL or connection errors (Java). Notice of expired SSL certificates and certificate removal Caution The SSL certificates that were bundled with Java agent versions 6.1.0 to 6.4.2 have expired and are no longer valid. This means that Java agent versions 6.1.0 to 6.4.2 can no longer use the certificates bundled with the agent to establish a connection with New Relic and that you must provide your own SSL certificates. Please see this community forum post for additional details. Important Java agent versions higher than 6.4.2 no longer ship with SSL certificates bundled into the agent. You must provide your own SSL truststore to the agent by explicitly using the ca_bundle_path configuration option, or by using the default truststore provided by the JDK/JRE (the agent will look to use the latter by default). Additionally the use_private_ssl configuration option has been removed from Java agent versions higher than 6.4.2. Users wishing to add the global certificate to their local trust store can download the DigiCert Global Root CA from DigiCert. Java Agent versions 6.2.0 - 6.4.2 Starting with Java agent version 6.2.0, the use_private_ssl configuration option has been reintroduced so you can use the SSL certificates that are bundled into the agent jar. The following bundled SSL certificates are valid for up to a year after release. META-INF/certs/eu-newrelic-com.pem META-INF/certs/eu01-nr-data-net.pem META-INF/certs/newrelic-com.pem Copy Important The Java agent will begin logging a warning message upon application startup when there are less than three months before the bundled certificate expires. When the bundled certificates expire, the Java agent will no longer be able to connect to New Relic and you must either update to the latest agent version or provide a valid certificate using the ca_bundle_path configuration. Users wishing to add the global certificate to their local trust store can download the DigiCert Global Root CA from DigiCert. Using YAML-based configuration common: default_settings ca_bundle_path: /path/to/digicert.pem use_private_ssl: false # # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic ... Copy Summary There are two configuration settings that determine what certs are used by the agent to establish a secure connection to New Relic. They are: use_private_ssl and ca_bundle_path. Here's how they work together: DEFAULT: Neither configuration option (ca_bundle_path/use_private_ssl) is provided, because both are using default values. The agent will use the default SSL certificates bundled into the Java Development Kit (JDK). If these certificates aren't present or don't include certificates that trust New Relic, then the agent will not connect. You'll need to merge valid certificates into your JDK certificate bundle. Only use_private_ssl is configured. The agent will use the SSL certificates that are bundled with it. Only ca_bundle_path is configured. The agent will try to connect using the custom SSL certificates bundle at the configured path. If the configured custom certificate bundle doesn’t include certificates that trust New Relic, then the agent will not connect. You'll need to merge valid certificates into your custom certificate bundle. Both use_private_ssl and ca_bundle_path are configured. The ca_bundle_path configuration setting takes precedence and the use_private_ssl config is ignored. This behavior is the same as only specifying ca_bundle_path. Java Agent versions 6.0.0/6.1.0 Starting in 6.0.0, the Java agent no longer includes the nrcert global certificate chain. Users wishing to add the global certificate to their local trust store must download the DigiCert Global Root CA from DigiCert. Note: In versions 6.1.0+, the Java agent will use a bundled New Relic certificate that is valid for up to a year after release. Before the certificate expires, you must either update the agent to the latest version or provide a valid certificate using the ca_bundle_path configuration. Important The Java agent will begin logging a warning message upon application startup when there are less than three months before the bundled certificate expires. Using YAML-based configuration common: default_settings ca_bundle_path: /path/to/digicert.pem # # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic ... Copy Java Agent versions prior to 6.0.0 (Deprecated) For Java agent versions prior to 6.0.0, applications that require valid certificates may add them in one of the following two ways: Use YAML-based configuration. Add the bundled list of New Relic trusted signers to the local store. Using YAML-based configuration The New Relic Java agent bundles the list of trusted signers in the agent newrelic.jar file. If you do not want to change the local trust store, you can activate them by setting use_private_ssl to true in the newrelic.yml agent configuration file: common: default_settings use_private_ssl: true # # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic ... Copy For more help Additional documentation resources include New Relic for Java (compatibility and requirements, installation, and configuration.)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 102.41548,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Java</em> <em>Agent</em> versions 6.2.0 - 6.4.2",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " visit SSL or connection errors (<em>Java</em>). Notice of expired SSL certificates and certificate removal Caution The SSL certificates that were bundled with <em>Java</em> <em>agent</em> versions 6.1.0 to 6.4.2 have expired and are no longer valid. This means that <em>Java</em> <em>agent</em> versions 6.1.0 to 6.4.2 can no longer use"
      },
      "id": "603eb7a2e7b9d247c02a080d"
    },
    {
      "sections": [
        "Include the Java agent with a JVM argument",
        "Tip",
        "Coldfusion",
        "Geronimo",
        "Glassfish",
        "Important",
        "Grails",
        "Pass with run-app",
        "Pass with run-war",
        "JBoss",
        "Set with domain mode (6.x EAP and 7.0 AS)",
        "Caution",
        "Set with standalone mode (other versions)",
        "Jetty",
        "If you set exec in jetty.sh",
        "If you set exec in start.ini",
        "Play",
        "Play 1.2.4",
        "Play 2.0",
        "Play 2.2",
        "Play 2.3, 2.4, and 2.5",
        "Resin",
        "Solr",
        "Standalone Solr 5.x or higher",
        "Standalone Solr 4.x or lower",
        "App server Solr",
        "Spring Boot",
        "Tanuki Wrapper",
        "Tomcat",
        "With setenv.sh",
        "With setenv.bat",
        "With catalina.sh (NOT RECOMMENDED)",
        "With catalina.bat (NOT RECOMMENDED)",
        "With Windows",
        "With Apache Commons daemon",
        "WebLogic",
        "Administration servers on Linux or macOS",
        "Administration servers on Windows",
        "Managed server instances",
        "WebSphere",
        "WebSphere Community",
        "WebSphere Liberty Profile",
        "Wildfly",
        "Set with domain mode",
        "Set with standalone mode",
        "Other application servers"
      ],
      "title": "Include the Java agent with a JVM argument",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Installation"
      ],
      "external_id": "e2026d6c9754047a8a1056b061f9be471f80b42f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/installation/include-java-agent-jvm-argument/",
      "published_at": "2021-05-05T00:35:31Z",
      "updated_at": "2021-04-11T14:41:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document describes how to pass the -javaagent argument to the JVM for your framework. This installation step ensures the agent is included in your app. For all app servers, ensure you pass the full path to the newrelic.jar file. This document is simply a reference for how to pass the argument. For detailed installation procedures, see Java agent installation. Tip To use Java or any other agent, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Coldfusion To pass the -javaagent argument on Coldfusion: Start your ColdFusion server and navigate to your ColdFusion admin console. From the left menu, select SERVER SETTINGS > Java and JVM. If using the agent API: Specify the path to newrelic-api.jar in the ColdFusion Class Path field. In the JVM Arguments field, add the -javaagent argument: -javaagent:/full/path/to/newrelic.jar Copy Select Submit Changes, then restart your ColdFusion server. Geronimo To pass the -javaagent argument on Geronimo, refer to the New Relic agent jar in the JAVA_OPTS environment variable when running the startup command: export JAVA_OPTS=\"$JAVA_OPTS -javaagent:/full/path/to/newrelic.jar\" && geronimo run Copy Glassfish To pass the -javaagent argument on Glassfish: From the Glassfish console, select Application Server > JVM Settings > JVM Options. On the JVM Options page, select Add JVM Option. Add an entry for the -javaagent argument: -javaagent:/full/path/to/newrelic.jar Copy Save and restart Glassfish. If Glassfish does not start, the -javaagent argument might not have been set correctly. You can change the server JVM arguments by editing the domain.xml file. Important A bug in Glassfish 2.1 prevents classes on the bootstrap class loader (the New Relic agent) from using the Java logging API. This appears to be fixed in 2.1.1 or higher releases. Grails To pass the -javaagent argument on Grails: Pass with run-app Begin with an unzipped version of Grails. Run this command: grails -noreloading -javaagent:/full/path/to/newrelic.jar run-app Copy Pass with run-war In your Grails app, open this file with your text editor: grails-app/conf/BuildConfig.groovy Copy Add or edit the JVM arguments line: grails.tomcat.jvmArgs = [\"-javaagent:/full/path/to/newrelic.jar\"] Copy JBoss To pass the -javaagent argument on JBoss: Set with domain mode (6.x EAP and 7.0 AS) Use domain mode for JBoss versions 6.x EAP and 7.0 AS or above: Edit the JVM properties for your server group, located in: domain/configuration/domain.xml Copy Modify the properties to include the -javaagent argument: <server-group name=\"main-server-group\" profile=\"full\"> <jvm name=\"default\"> <jvm-options> <option value=\"-javaagent:/full/path/to/newrelic.jar\"/> </jvm-options> </jvm> ... </server-group> Copy Caution A JBoss bug in 7.0.2.Final and 7.1.0.Alpha1 does not allow JVM options to be set in domain.xml. If you encounter this problem, upgrade your JBoss application server. Set with standalone mode (other versions) Use standalone mode for other platforms and versions: Platform Directions Unix / macOS with 6.x EAP or 7.0.x AS and above At the bottom of bin/standalone.conf, add: JAVA_OPTS=\"$JAVA_OPTS -javaagent:/full/path/to/newrelic.jar\" Copy Windows with 6.x EAP or 7.0.x AS or higher In bin/standalone.bat, before the line: set JBOSS_ENDORSED_DIRS=%JBOSS_HOME%\\lib\\endorsed Copy Add: set \"JAVA_OPTS=-javaagent:C:/full/path/to/newrelic.jar %JAVA_OPTS%\" Copy Unix / macOS with 6.x or earlier At the bottom of bin/run.conf, add this: JAVA_OPTS=\"$JAVA_OPTS -javaagent:/full/path/to/newrelic.jar\" Copy Windows with 6.x or earlier In bin/run.bat, before the line: set JBOSS_CLASSPATH=%RUN_CLASSPATH% Copy Add: set \"JAVA_OPTS=-javaagent:C:/full/path/to/newrelic.jar %JAVA_OPTS%\" Copy Jetty To pass the -javaagent argument on Jetty: If you set exec in jetty.sh Edit the JAVA_OPTIONS in your jetty.sh script: export JAVA_OPTIONS=\"${JAVA_OPTIONS} -javaagent:/full/path/to/newrelic.jar\" Copy If you set exec in start.ini Add the agent path to your start.ini config file: -javaagent:/full/path/to/newrelic.jar Copy Play To pass the -javaagent argument on Play: Play 1.2.4 Append the -javaagent argument when running your Play application: play run your_app_name -javaagent:/full/path/to/newrelic.jar Copy Play 2.0 Begin with an unzipped distribution containing the start script: play clean dist && unzip dist/*.zip Copy Append the -javaagent argument when starting your Play app: cd unzipped/folder; chmod a+x start; ./start -javaagent:/full/path/to/newrelic.jar Copy Play 2.2 Begin with an unzipped distribution containing the start script: play clean dist && unzip target/directory/universal/*.zip Copy Append the -J-javaagent argument when starting your Play app: cd unzipped/folder; ./bin/scriptname -J-javaagent:/full/path/to/newrelic.jar Copy Tip To enable page load timing, see Manual instrumentation with Play 2.2. Play 2.3, 2.4, and 2.5 Begin with an unzipped distribution containing the start script: activator clean dist && unzip target/directory/universal/*.zip Copy Append the -J-javaagent argument when starting your Play app: cd unzipped/folder; ./bin/scriptname -J-javaagent:/full/path/to/newrelic.jar Copy If you use Typesafe Activator with Play 2.4, add this line to your build.sbt: javaOptions ++= Seq(\"-javaagent:/full/path/to/newrelic.jar\") Copy Resin To pass the -javaagent argument on Resin, add it to the <jvm-args> section in your resin.conf or resin.xml file: <jvm-arg>-javaagent:/full/path/to/newrelic.jar</jvm-arg> Copy Solr To pass the -javaagent argument on Solr: Standalone Solr 5.x or higher Add the -javaagent property to bin/solr.in.sh: SOLR_OPTS=\"$SOLR_OPTS -javaagent:/full/path/to/newrelic.jar\" Copy Standalone Solr 4.x or lower Add the -javaagent before the start.jar: java -javaagent:/full/path/to/newrelic.jar -jar start.jar Copy App server Solr When running Solr in an application server, follow the instructions of that application server to add the -javaagent flag. Also ensure that JMX is enabled for the application server. If you don't see data in the APM UI's Solr page, follow the troubleshooting procedures for Solr data. Spring Boot To pass the -javaagent argument on Spring Boot, add it to the command line in which you start your app. Make sure to add it before the -jar argument: java -javaagent:/full/path/to/newrelic.jar -jar app.jar Copy Tanuki Wrapper To pass the -javaagent argument on Tanuki Wrapper, add a wrapper option wrapper.conf. In the line below, substitute XXX for an unused number in this file: wrapper.java.additional.XXX=-javaagent:/full/path/to/newrelic.jar Copy Tip On Linux systems, no quotation marks are required when setting this value. This behavior may vary on other operating systems. Tomcat To pass the -javaagent argument on Tomcat: With setenv.sh Create a CATALINA_BASE/bin/setenv.sh script if one doesn't already exist. Configure your setenv.sh script to use the New Relic agent using the CATALINA_OPTS environment variable: export CATALINA_OPTS=\"$CATALINA_OPTS -javaagent:/full/path/to/newrelic.jar\" Copy With setenv.bat Create a CATALINA_BASE/bin/setenv.bat script if one doesn't already exist. Configure your setenv.bat script to use the New Relic agent using the CATALINA_OPTS environment variable: SET \"CATALINA_OPTS=%CATALINA_OPTS% -javaagent:/full/path/to/newrelic.jar\" Copy With catalina.sh (NOT RECOMMENDED) Tip We recommend that you do not set any variables in this script. Instead put them into a script setenv.sh in CATALINA_BASE/bin to keep your customizations separate. Configure your catalina.sh file to use the New Relic agent using the JAVA_OPTS environment variable: export JAVA_OPTS=\"$JAVA_OPTS -javaagent:/full/path/to/newrelic.jar\" Copy With catalina.bat (NOT RECOMMENDED) Tip We recommend that you do not set any variables in this script. Instead put them into a script setenv.bat in CATALINA_BASE/bin to keep your customizations separate. If you use catalina.bat to launch Tomcat, set the JAVA_OPTS variable near the top of the file: SET JAVA_OPTS=%JAVA_OPTS% -javaagent:/full/path/to/newrelic.jar Copy With Windows Select Start > Apache Tomcat X.Y.Z. > Configure Tomcat > Java. In the Java Options text box, enter the argument. Use forward slashes / for the path separator. For Tomcat 6, add a line break after the -javaagent argument. -javaagent:/full/path/to/newrelic.jar Copy Select Apply, then restart Tomcat. With Apache Commons daemon The version of Apache Commons Daemon (jsvc) included with Tomcat 6 does not support the -javaagent argument used by New Relic. However, a build of the jsvc daemon from the trunk source will support the -javaagent argument via the -X prefix. See the Apache bug tracking the issue. There is a fix in the Apache Commons source repository. For more information: See the Apache source repository documentation. Go directly to the SVN source repository. WebLogic To pass the -javaagent argument on WebLogic: Administration servers on Linux or macOS Edit your startWebLogic.sh file, located in the domain's bin directory. Near the beginning of the file, add: export JAVA_OPTIONS=\"$JAVA_OPTIONS -javaagent:/full/path/to/newrelic.jar\" Copy Administration servers on Windows Edit your startWebLogic.bat file, located in the domain's bin directory. Near the beginning of the file, add: set JAVA_OPTIONS=%JAVA_OPTIONS% -javaagent:\"C:\\full\\path\\to\\newrelic.jar\" Copy Managed server instances For administration server instances, follow the Linux/macOS or Windows instructions. You cannot use the administration console to install administration server instances. For managed server instances, use the admin console: From the administration console, navigate to Environments > Servers > (select a server) > Server Start > Arguments. From Arguments, add: -javaagent:/full/path/to/newrelic.jar Copy Save the page, then restart your server instance. WebSphere To pass the -javaagent argument on WebSphere: From the admin console, select Servers > Application servers > (select a server) > Configuration > Service Infrastructure > Java and Process Management. Select Process Definition > Additional Properties, then select Java Virtual Machine. In the Generic JVM arguments field, add the -javaagent argument for your newrelic.jar file: -javaagent:/full/path/to/newrelic.jar Copy Select Apply, then select Save. Restart your server. For more information, see the documentation about collecting WebSphere PMI metrics. WebSphere Community To pass the -javaagent argument on WebSphere Community Edition, refer to the New Relic agent jar in the JAVA_OPTS environment variable when running the startup command: export JAVA_OPTS=\"$JAVA_OPTS -javaagent:/full/path/to/newrelic.jar\" && startup Copy WebSphere Liberty Profile To pass the -javaagent argument on WebSphere Liberty Profile: Edit ${server.config.dir}/jvm.options. Add the -javaagent argument to point to your newrelic.jar file: -javaagent:/full/path/to/newrelic.jar Copy Restart your server. Wildfly To pass the -javaagent argument on Wildfly (if using Wildfly 11 or higher, see additional install instructions): Set with domain mode Edit the JVM properties for your server group, located in: domain/configuration/domain.xml Copy Modify the properties to include the -javaagent argument: <server-group name=\"main-server-group\" profile=\"full\"> <jvm name=\"default\"> <jvm-options> <option value=\"-javaagent:/full/path/to/newrelic.jar\"/> </jvm-options> </jvm> ... </server-group> Copy Set with standalone mode Platform Directions Unix or macOS At the bottom of bin/standalone.conf, add: JAVA_OPTS=\"$JAVA_OPTS -javaagent:/full/path/to/newrelic.jar\" Copy Windows In bin/standalone.bat, find this line: rem Setup JBoss specific properties Copy Then add: set \"JAVA_OPTS=-javaagent:C:/full/path/to/newrelic.jar %JAVA_OPTS%\" Copy Other application servers The New Relic Java agent works on any supported app server. If your app server is not listed in this document, follow standard procedures for your app server to pass this argument to the JVM before the app jar: -javaagent:/full/path/to/newrelic.jar Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 101.058014,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Include the <em>Java</em> <em>agent</em> with a JVM argument",
        "sections": "Include the <em>Java</em> <em>agent</em> with a JVM argument",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": ". For detailed <em>installation</em> procedures, see <em>Java</em> <em>agent</em> <em>installation</em>. Tip To use <em>Java</em> or any other <em>agent</em>, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month"
      },
      "id": "6043b8f6e7b9d209f5579a28"
    },
    {
      "sections": [
        "Install the Java agent",
        "Tip",
        "1. Before you install",
        "2. Get the agent",
        "Download using curl",
        "Download using Invoke-WebRequest (PowerShell)",
        "Download from the New Relic UI",
        "3. Configure the agent",
        "4. Install the agent",
        "5. Post-installation tasks",
        "What's next?"
      ],
      "title": "Install the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Installation"
      ],
      "external_id": "919e7366b24cb9cce5c366d0394060d2332a5ec6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/installation/install-java-agent/",
      "published_at": "2021-05-04T17:04:08Z",
      "updated_at": "2021-03-16T09:15:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Java agent auto-instruments your code so you can start monitoring applications. You can use our launcher, or follow the instructions in this document to complete a basic Java agent installation. Add Java data Tip To use Java or any other agent, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. 1. Before you install Check the following: Make sure you have signed up for a New Relic account. Review the compatibility and requirements. Check if your environment requires additional or alternative install steps. 2. Get the agent Download newrelic-java.zip using curl, Invoke-WebRequest (PowerShell), or the New Relic UI: Download using curl Complete the following: Start a command-line session. Change to a temporary directory where you can download the zip file. Execute this curl command: curl -O https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip Copy Unzip newrelic-java.zip Download using Invoke-WebRequest (PowerShell) Complete the following: Start a PowerShell session. Change to a temporary directory where you can download the zip file. Execute this PowerShell command: Invoke-WebRequest -Uri https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip -OutFile newrelic-java.zip Copy Unzip newrelic-java.zip: Expand-Archive -Path newrelic-java.zip -DestinationPath DESTINATION_PATH Copy Download from the New Relic UI Complete the following: Sign in to New Relic. From the account dropdown in the New Relic UI, select Account settings. In the right sidebar under Most recent, select the Java agent, and save the newrelic-java.zip to a temporary directory. Unzip newrelic-java.zip. 3. Configure the agent Here's how to do a basic setup with agent configuration settings in newrelic.yml. Tip For an advanced installation, you can pass settings with environment variables, Java system properties, or server-side configuration. To understand the precedence of these configuration settings, see Java agent configuration: Config file. The Java agent requires the license_key and app_name settings at startup. All the other settings are optional, and you can review them in Java agent configuration: Config file. Go to the unzipped installation file, and inside the newrelic subdirectory, edit newrelic.yml: Find the line with license_key. Replace ' < %= license_key %>' with your license. For example: license_key: 456n20n1367ov2s174v51nvn789d21s67v26NRAL Copy Find the line with app_name. Replace My Application with a name that helps you identify the application. For example: app_name: Tax Calculator Copy Tip If you need tips about how to name your application, see Name your application. Add optional settings that you want, such as agent logging and distributed tracing (or add them later). Save and close newrelic.yml. 4. Install the agent The Java agent installation involves copying all the unzipped New Relic files into the directory structure of your application server/container. For example, you can create a /opt/newrelic directory, but if you want to put the files elsewhere, make sure of the following: The .jar files in the directory cannot be on the classpath. The .jar files cannot be in directories specified in java.endorsed.dirs. To install the Java agent: In your application server/container directory structure, create a directory for New Relic files (for example, /opt/newrelic). Copy all the New Relic files from your unzipped newrelic directory into your new directory. Make sure that your application server/container includes this option when it starts Java (for tips on how to do this with your tool or framework, see JVM arguments): -javaagent:/full/path/to/newrelic.jar Copy Start or restart your application server/container. Generate some traffic for your app, and then wait a few minutes for data to appear in the APM Summary page. If nothing appears, follow the troubleshooting procedures. 5. Post-installation tasks If you are using newrelic.yml to make configuration settings, consider the following: We recommend you change the default newrelic.yml file permissions to read/write only for the owner of the application server process. As you would with other important files, be sure newrelic.yml is part of your backup routine. We recommend using New Relic Diagnostics to validate your settings, either before or after you deploy. What's next? Here are some additional topics to consider: For Docker questions, see Install New Relic Java agent for Docker. View your app in New Relic and get comfortable with the user interface. Read the documentation about APM. For example, read about the Summary page, the JVM metrics page, the Transactions page, and other performance monitoring features. Query your data using NRQL (New Relic Query Language). Learn about setting up custom instrumentation and async instrumentation for application activity not monitored by default.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.17075,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> the <em>Java</em> <em>agent</em>",
        "sections": "<em>Install</em> the <em>Java</em> <em>agent</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Our <em>Java</em> <em>agent</em> auto-instruments your code so you can start monitoring applications. You can use our launcher, or follow the instructions in this document to complete a basic <em>Java</em> <em>agent</em> <em>installation</em>. Add <em>Java</em> data Tip To use <em>Java</em> or any other <em>agent</em>, as well as the rest of our observability platform"
      },
      "id": "603eb6f428ccbc7695eba785"
    }
  ],
  "/docs/agents/java-agent/instrumentation/extension-additional-instrumentation-modules": [
    {
      "sections": [
        "Ignore specific transactions",
        "Important",
        "Ignore web transactions with ServletRequest",
        "Ignore transactions with annotation",
        "Ignore apdex but not traces"
      ],
      "title": "Ignore specific transactions",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Instrumentation"
      ],
      "external_id": "030d29891f4c8ad625a3eb46adca8f371add7adc",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/instrumentation/ignore-transactions-using-api/",
      "published_at": "2021-05-05T07:02:42Z",
      "updated_at": "2021-03-16T14:48:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic for Java gives you multiple methods to ignore specific transactions. This document explains how to use the Java agent API annotations and ServletRequest to ignore transactions. It is also possible to use the ignoreTransaction() API call and XML instrumentation files to ignore transactions. Important Ignoring transactions involves changing your application's source code and recompiling your application in all cases unless you use an XML instrumentation file. If you cannot manipulate your code, use XML to ignore transactions. Ignore web transactions with ServletRequest To ignore a web transaction, set a ServletRequest attribute named com.newrelic.agent.IGNORE to true during the request: request.setAttribute(\"com.newrelic.agent.IGNORE\", true); Copy To specify URLs to ignore, create a servlet filter which sets that attribute and apply the filter to the servlet you want to ignore. The filter will have access to the request URI if you need to ignore specific URLs. Ignore transactions with annotation To tell the Java agent to ignore transactions using annotations: Define an annotation called NewRelicIgnoreTransaction in your application's code or a library you can integrate with your application: @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface NewRelicIgnoreTransaction { } Copy Apply the annotation to the methods or classes you want to ignore. For example: @NewRelicIgnoreTransaction public void methodToBeIgnored() { } Copy If a transaction calls a method or class annotated with @NewRelicIgnoreTransaction, the transaction is ignored. This means it does not contribute to the overall Apdex score; and the transaction trace and performance data is not reported. Ignore apdex but not traces You can also prevent the transaction from contributing to the Apdex score but still be used in transaction. This can prevent one particularly lengthy transaction from skewing your Apdex score. To prevent a transaction from contributing to your Apdex score: Define an annotation called NewRelicIgnoreApdex in your application's code or a library you can integrate with your application: @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface NewRelicIgnoreApdex { } Copy Apply the annotation to the methods or classes you want to ignore. For example: @NewRelicIgnoreApdex public void ignoreApdexOfThisMethod() { } Copy If a transaction calls a method or class annotated with @NewRelicIgnoreApdex, the transaction is reported, but does not contribute to the overall Apdex score.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.167595,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "New Relic for <em>Java</em> gives you multiple methods to ignore specific transactions. This document explains how to use the <em>Java</em> <em>agent</em> API annotations and ServletRequest to ignore transactions. It is also possible to use the ignoreTransaction() API call and XML <em>instrumentation</em> files to ignore transactions"
      },
      "id": "603eb7db64441f3cf84e8841"
    },
    {
      "sections": [
        "Java agent: Instrument Kafka message queues",
        "Tip",
        "View Kafka metrics",
        "Enable Kafka event collection",
        "Important",
        "Enable Kafka distributed traces",
        "1. Enable distributed tracing in the config file",
        "2. Instrument the Kafka producer",
        "3. Instrument the Kafka consumer"
      ],
      "title": "Java agent: Instrument Kafka message queues",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Instrumentation"
      ],
      "external_id": "05644cd866713698034d5419961a40af31d06b90",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/instrumentation/java-agent-instrument-kafka-message-queues/",
      "published_at": "2021-05-05T07:06:37Z",
      "updated_at": "2021-03-16T14:45:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent automatically collects data from Kafka's Java clients library. Because Kafka is a high-performance messaging system that generates a lot of data, you can customize the agent for your app's specific throughput and use cases. This document explains how to collect and view three types of Kafka data: Kafka metrics Kafka events Kafka distributed traces Kafka instrumentation is available in Java agent versions 4.12.0 or higher. For supported Kafka client versions, see Java compatibility and requirements. Tip For our Kafka integration, see Kafka monitoring integration. View Kafka metrics After installation, the agent automatically reports rich Kafka metrics with information about messaging rates, latency, lag, and more. The Java agent collects all Kafka consumer and producer metrics (but not connect or stream metrics). To view these metrics, create a custom dashboard: Go to the New Relic metric explorer. Use the metric explorer to locate your metrics. You can find Kafka metrics in this metric folder: MessageBroker/Kafka/Internal/KafkaMetricName Copy For example, the request-rate metric is located at: MessageBroker/Kafka/Internal/consumer-metrics/request-rate Copy Tip For a full list of Kafka consumer and producer metrics, see the Kafka documentation. Add the metrics you want to monitor to a dashboard by clicking Add to dashboard. Enable Kafka event collection You can configure the agent to collect event data instead of metric timeslice data (for the difference between metric timeslice and event data, see data collection). This allows you to use NRQL to filter and facet the default Kafka metrics. When enabled, the agent collects one Kafka event every 30 seconds. This event contains all of the the data from Kafka consumer and produce metrics captured since the previous event. Important The agent records up to 2000 events per harvest cycle, though you can change this value with max_samples_stored. Kafka event data is included in this pool. If you use the recordCustomEvent() API call to send custom events to New Relic and you send more than 2000 events, the agent will discard some Kafka or custom events. To enable Kafka event collection: Add the kafka.metrics.as_events.enabled element to your newrelic.yml config file: kafka.metrics.as_events.enabled: true Copy Restart your JVM. Use the event explorer to view your Kafka events, located in the KafkaMetrics event type. Or, use NRQL to query your events directly. For example: SELECT average('producer-metrics.record-send-rate') from KafkaMetrics SINCE 30 minutes ago timeseries Copy Enable Kafka distributed traces The Java agent can also collect distributed traces from Kafka clients. Enabling traces doesn't affect the agent's normal operations: it will still report metric or event data from Kafka. Impacts and requirements to consider before enabling: The instrumentation adds a 150 to 200 byte payload to message headers. If your Kafka messages are very small, traces can add significant processing and storage overhead. This additional payload size could cause Kafka to drop messages if they exceed your Kafka messaging size limit. For this reason, we recommend testing out Kafka distributed traces in a dev environment before enabling them in production. Distributed tracing is only available for Kafka client versions 0.11.0.0 or higher. If you have not enabled distributed tracing for your app before, read the Transition guide before enabling. To propagate W3C trace context via Kafka message headers, see the distributed tracing API usage guide for details on APIs that were released in Java agent 6.4.0. Note that adding additional headers to Kafka messages will further increase the payload size. To see these APIs in action, see Using Java agent trace APIs with Kafka. The complete process of enabling this is below but at a high level it involves these basic steps: 1) enable tracing via the agent config, and 2) calling the Java agent API to instrument transactions on both the producer and consumer side. To collect distributed traces from Kafka: 1. Enable distributed tracing in the config file If you have not enabled distributed tracing for your app before, read the distributed tracing transition guide before you enable it. To enable Kafka distributed tracings, enable two settings in your newrelic.yml config file: Set the distributed_tracing element to true: distributed_tracing: enabled: true Copy Enable the Kafka-specific distributed tracing features by adding the following to your config file: class_transformer: kafka-clients-spans: enabled: true Copy 2. Instrument the Kafka producer To instrument your Kafka producer, you'll need to start a transaction before any calls to Producer.send(ProducerRecord<K, V> record). To do this, add the Java agent @Trace(dispatcher = true) annotation to the method. For example: @Trace(dispatcher = true) public static void createAndSend(KafkaProducer<String, String> producer){ ProducerRecord<String, String> data = new ProducerRecord<String, String>(\"topic\", \"key\", \"value\"); producer.send(data); } Copy 3. Instrument the Kafka consumer To instrument your Kafka consumer, you'll need to start a transaction when the message is being processed. The agent stores the distributed tracing payload header under the newrelic key. Retrieve the header, then call the New Relic transaction API to accept the payload. For example: @Trace(dispatcher = true) private static void processMessage(ConsumerRecord<String, String> rec){ Iterable<Header> headers = rec.headers().headers(\"newrelic\"); for(Header header: headers) { NewRelic.getAgent().getTransaction().acceptDistributedTracePayload(new String(header.value(), StandardCharsets.UTF_8)); } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.1671,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em>: <em>Instrument</em> Kafka message queues",
        "sections": "<em>Java</em> <em>agent</em>: <em>Instrument</em> Kafka message queues",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " three types of Kafka data: Kafka metrics Kafka events Kafka distributed traces Kafka <em>instrumentation</em> is available in <em>Java</em> <em>agent</em> versions 4.12.0 or higher. For supported Kafka client versions, see <em>Java</em> compatibility and requirements. Tip For our Kafka integration, see Kafka monitoring integration. View"
      },
      "id": "603ebc2464441f7ce84e8885"
    },
    {
      "sections": [
        "Transaction naming protocol",
        "Important",
        "Grouping transactions",
        "Naming priority",
        "Request attributes",
        "API Calls",
        "Frameworks",
        "JavaServer Pages (JSPs)",
        "Servlets",
        "Servlet filters",
        "Disable component-based naming",
        "Caution"
      ],
      "title": "Transaction naming protocol",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Instrumentation"
      ],
      "external_id": "4ae52ce967d3677fdde6de027a04dbb69c55e4ab",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/instrumentation/transaction-naming-protocol/",
      "published_at": "2021-05-05T07:00:41Z",
      "updated_at": "2021-03-13T03:21:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you're using New Relic for Java with a supported framework, New Relic groups transactions based on transaction names obtained from the framework. Otherwise, New Relic groups transactions based on their component. Components are the JSPs, servlets, and filters invoked during the transaction. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. Grouping transactions The New Relic Java agent groups similar transactions together under a single name. If New Relic did not group transactions, each unique URI would generate a unique name. For example, your web application might produce URIs like: /user/123/control_panel.jhtml /user/456/control_panel.jhtml /user/789/control_panel.jhtml Copy Without grouping, this would produce three (fairly meaningless) individual metrics. Therefore, New Relic attempts to group transactions together under a meaningful label. For more information about metric grouping, see Metric grouping issues. Transaction names use URI format. For example: MyTransactionName /MyTransactionName /MyServlet/MyTransactionName Copy If you are using a supported framework, New Relic obtains the transaction name from the framework. For example, for Spring the transaction name typically comes from calling getViewName on the org.springframework.web.servlet.ModelAndView object. If you are not using a supported framework, New Relic names a transaction based on its components. The exact transaction name is determined by the component with the highest priority. If multiple component share priority, the agent uses the first component that was invoked. Naming priority New Relic assigns each transaction a name according to the following priority, from highest priority to lowest: Request attributes Request attributes and API calls have the highest naming priority. If a transaction has a request attribute or API call, the transaction will take its name from there. You can set the request attribute at any time during the web request. If you set multiple attributes during a request, the first name will be used. This example sets the transaction name using a request attribute in a servlet's doGet: protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { ... request.setAttribute(\"com.newrelic.agent.TRANSACTION_NAME\", \"MyTransactionName\"); ... } Copy API Calls You can also set the transaction name by calling the setTransactionName method from the Java agent API. An API call has the same priority as a request attribute. If you set multiple attributes or make multiple API calls during a request, the most recent name will be used. Frameworks If there are no request attributes or API calls, and you're using a supported framework, New Relic obtains the transaction name from the framework components. JavaServer Pages (JSPs) After frameworks, the New Relic Java agent will use JavaServer Pages (JSPs). A JSP gets the transaction name from its class name. For example, if the JSP servlet class name is org.apache.jsp.ShowBrowser_jsp the transaction name is ShowBrowser.jsp. Servlets After JSPs, the New Relic Java agent will use servlets. A servlet sets the transaction name from either an init parameter or the servlet name. The init parameter is higher priority, so servlets with an init parameter take precedence over servlets without. The servlet name and init parameter are defined in the deployment descriptor. For example: SqlServlet test.SqlServlet com.newrelic.agent.TRANSACTION_NAME MyTransactionName Servlet filters Servlet filters have the lowest priority. A filter gets the transaction name either from an init parameter or the filter name. The init parameter has a higher priority, so filters with an init parameter take precedence over filters without. The filter name and init parameter are defined in the deployment descriptor. For example: SqlFilter test.SqlFilter com.newrelic.agent.TRANSACTION_NAME MyTransactionName The filter name is the value of the filter-name element. The init parameter is the value of the param-value element of an init-param element with a param-name element of com.newrelic.agent.TRANSACTION_NAME. Disable component-based naming For some applications, you may want to disable component-based transaction naming. Set this value in your newrelic.yml file: enable_auto_transaction_naming: false Copy Caution Unless you implement API calls to name your transactions, disabling auto-transaction naming is very likely to cause Metric grouping issues.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 102.28413,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>JavaServer</em> Pages (JSPs)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": ". Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. Grouping transactions The New Relic <em>Java</em> <em>agent</em> groups similar transactions together under a single name. If New"
      },
      "id": "6043dc7ee7b9d22abc5799e0"
    }
  ],
  "/docs/agents/java-agent/instrumentation/ignore-transactions-using-api": [
    {
      "sections": [
        "Extension and additional instrumentation modules",
        "Tip",
        "Install extension modules",
        "Feature extension modules",
        "Class Histogram",
        "Incubator instrumentation modules",
        "Apache Camel 2.12",
        "C3P0 database connection pools",
        "Coda Hale's Metrics 2",
        "Coda Hale's Metrics 3",
        "HikariCP 2.3.0 - 2.3.8",
        "HikariCP 2.4.0 or higher",
        "Lettuce 4.0 - 5.0",
        "Lettuce 5.0 or higher",
        "Ratpack 1.4.0 or higher",
        "Ratpack Http Client 1.4.0 or higher",
        "Archived instrumentation modules",
        "Akka [2.0]",
        "Akka [2.1]",
        "Akka HTTP [1.0]",
        "Akka HTTP [2.0 – 2.4.1]",
        "Akka HTTP [2.4.2 – 2.4.4]",
        "Hystrix [1.0.2 – 1.1.7]",
        "Hystrix [1.2.0 – 1.2.18]",
        "Hystrix [1.3.0 – 1.3.13]",
        "Play [2.0]",
        "Play [2.1]",
        "Play [2.2]",
        "Solr [3.1.0 – 3.4.0]",
        "Solr [3.5.0]",
        "Solr [3.6.0 – 3.6.2]"
      ],
      "title": "Extension and additional instrumentation modules",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Instrumentation"
      ],
      "external_id": "7428cba4d64b06cc620b7407e87f510a3b42905c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/instrumentation/extension-additional-instrumentation-modules/",
      "published_at": "2021-05-05T07:02:44Z",
      "updated_at": "2021-03-16T14:49:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Java agent is a fully-featured library that automatically collects data from many popular servers, frameworks, libraries, and datastores (for a full list, see Compatibility and requirements). It also has a significant feature set. However, there are always additional requests for functionality and instrumentation of new libraries. The Java agent provides extension modules for this purpose. Extension modules fall into three general categories: Incubator instrumentation modules: Experimental new support to collect data from specific libraries Archived instrumentation modules: Instrumentation for libraries that the original company or author no longer maintains or updates. Feature extension modules: Code that adds new behavior to the agent, independent of any specific library. If your library isn't covered by the automatic instrumentation or by an instrumentation module, you can still collect data with custom instrumentation. Tip If you have feedback, questions, or problems with this instrumentation, create a post in New Relic's Explorers Hub, and tag your post with java_incubator. Install extension modules We recommend updating to the latest Java agent version before installing an extension module. To install an extension module: Download the appropriate .jar file from module lists below. Locate the directory that contains your newrelic.jar and newrelic.yml files. In that directory, create a sub-directory named extensions (if there is not already one there). Copy the .jar extension module you downloaded into the extensions directory. For Feature extension modules, update your newrelic.yml with feature-specific configuration. Restart your server. Send some traffic to the server or host that will exercise the feature or instrumentation. Tip Java agent extension modules are subject to the New Relic Java agent licenses, which are included in each module jar's LICENSE file. Feature extension modules Extension modules are additional libraries that add commonly-requested functionality. To use the an extension module, download it and put it in the Extensions Directory. Class Histogram Download link Download the module The Class Histogram extension runs jmap periodically and generates ClassHistogramRowEvent and ClassHistogramStatsEvent data that you can query and chart. Querying this data can be useful when troubleshooting memory leaks as you can see the values over time. You configure the Class Histogram extension the same way you configure the Java agent: using environment variables, system properties, or newrelic.yml. Here are available properties, with defaults: extensions: class_histogram: enabled: true # true is the default if the extension is present classes_per_histogram: 50 # 50 is the default, and memory leak issues are usually in the highest 50 classes by bytes jmap_path: /your/jdk/bin # The folder where the jmap binary lives. The default is $JAVA_HOME/bin. delay_between_calls_seconds: 60 # Length of the delay between executions to avoid frequent pauses Copy Incubator instrumentation modules Incubator modules are experimental instrumentation, which we may build into the agent's automatic instrumentation in the future. These are the incubator modules that are currently available: Apache Camel 2.12 Download link Download the module This instrumentation module intercepts the following: org.apache.camel.component.http.CamelServlet.resolve Copy To name the transaction so that web transactions have a finer grained name than the Camel servlet name, it uses this: org.apache.camel.component.http.HttpConsumer.getPath() Copy To view the bytecode, use this terminal command: javap -verbose -cp camel-2.12-FILENAME.jar org.apache.camel.component.http.CamelServlet Copy C3P0 database connection pools Download link Download the module Java agent version 3.12.0 or higher This instrumentation module samples C3P0 connection pools and reports busy and idle counts in metrics that start with this: Custom/Database Connection/C3P0/METRIC_NAME Copy You can view the metrics with the metric explorer. Coda Hale's Metrics 2 Download link Download the module This instrumentation module integrates with the MetricRegistry and begins sampling the registered metrics every minute. Reported metrics are prefixed with this: Custom/CodaHale/Metrics2/METRIC_NAME Copy You can view the metrics with the metric explorer. Coda Hale's Metrics 3 Download link Download the module This instrumentation module integrates with the MetricRegistry and begins sampling the registered metrics every minute. Reported metrics are prefixed with this: Custom/CodaHale/Metrics3/METRIC_NAME Copy You can view the metrics with the metric explorer. HikariCP 2.3.0 - 2.3.8 Download link Download the module Java agent version 3.12.0 or higher This instrumentation module samples HikariCP database connection pools and reports busy and idle counts in metrics that start with this: Custom/Database Connection/HikariCP/METRIC_NAME Copy You can view the metrics with the metric explorer. HikariCP 2.4.0 or higher Download link Download the module Java agent version 3.12.0 or higher This instrumentation module samples HikariCP database connection pools and reports busy and idle counts in metrics that start with this: Custom/Database Connection/HikariCP/METRIC_NAME Copy You can view the metrics with the metric explorer. Lettuce 4.0 - 5.0 Download link Download the module Java agent version 5.8.0 or higher This instrumentation package instruments the Lettuce 4.x Redis driver. It enables calls to Redis to show up as datastore calls. Lettuce 5.0 or higher Download link Download the module Java agent version 5.8.0 or higher This instrumentation package instruments the Lettuce 5.x Redis driver. It enables calls to Redis to show up as datastore calls. Ratpack 1.4.0 or higher Download link Download the module Java agent version 3.29 or higher This instrumentation module adds support for async linking of Ratpack's execution primitives. It also monitors handler execution. You must name the transactions manually by using the Java agent API. Ratpack Http Client 1.4.0 or higher Download link Download the module This instrumentation captures Ratpack's HTTP client requests and responses. Archived instrumentation modules Archived modules are instrumentation for libraries that are no longer maintained by the original company or author. Because the target library isn't being updated, our support for archived modules has designated end dates. These are the archived modules that are currently available: Akka [2.0] Download link Download the module Java agent version 3.22.1 or higher Support ends on December 2019 This module provides link instrumentation between actors that send and receive messages. It also traces messages broadcast by or forwarded to actors. In order to avoid over-instrumentation, this instrumentation does not start transactions. If you would like a given actor call to mark the beginning of a transaction, use the @Trace(dispatcher=true) annotation, or some other form of custom instrumentation. Akka [2.1] Download link Download the module Java agent version 3.22.1 or higher Support ends on December 2019 This module provides link instrumentation between actors that send and receive messages. It also traces messages broadcast by or forwarded to actors. In order to avoid over-instrumentation, this instrumentation does not start transactions. If you would like a given actor call to mark the beginning of a transaction, use the @Trace(dispatcher=true) annotation, or some other form of custom instrumentation. Akka HTTP [1.0] Download link Download the module Java agent version 3.24.1 or higher Support ends on December 2019 This module creates transactions from Akka HTTP calls. It also instruments hand-offs between Akka actors, and calls from Akka to other databases and services. For calling systems, this instrumentation collects cross application traces. If you're using a supported Akka version, you can view activity from your Akka HTTP apps from transactions all the way through your actor systems. Akka HTTP [2.0 – 2.4.1] Download link Download the module Java agent version 3.24.1 or higher Support ends on December 2019 This module creates transactions from Akka HTTP calls. It also instruments hand-offs between Akka actors, and calls from Akka to other databases and services. For calling systems, this instrumentation collects cross application traces. If you're using a supported Akka version, you can view activity from your Akka HTTP apps from transactions all the way through your actor systems. Akka HTTP [2.4.2 – 2.4.4] Download link Download the module Java agent version 3.24.1 or higher Support ends on December 2019 This module creates transactions from Akka HTTP calls. It also instruments hand-offs between Akka actors, and calls from Akka to other databases and services. For calling systems, this instrumentation collects cross application traces. You can use this instrumentation together with our built previously released support for Akka, to view activity from your Akka HTTP apps from transactions all the way through to your actor systems. Hystrix [1.0.2 – 1.1.7] Download link Download the module Java agent version 3.23.0 or higher Support ends on December 2019 This module provides timing information related to each Hystrix command. The agent will link chained Hystrix commands into one transaction. Hystrix [1.2.0 – 1.2.18] Download link Download the module Java agent version 3.23.0 or higher Support ends on December 2019 This module provides timing information related to each Hystrix command. The agent will link chained Hystrix commands into one transaction. Hystrix [1.3.0 – 1.3.13] Download link Download the module Java agent version 3.23.0 or higher Support ends on December 2019 This module provides timing information related to each Hystrix command. The agent will link chained Hystrix commands into one transaction. Play [2.0] Download link Download the module Java agent version 3.24.1 or higher Support ends on December 2019 This module creates and names transactions based on your Play controller classes. Play [2.1] Download link Download the module Java agent version 3.24.1 or higher Support ends on December 2019 This module creates and names transactions based on your Play controller classes. Play [2.2] Download link Download the module Java agent version 3.24.1 or higher Support ends on December 2019 This module creates and names transactions based on your Play controller classes. Solr [3.1.0 – 3.4.0] Download link Download the module Java agent version 3.34.0 or higher Support ends on December 2019 This module instruments database calls to Solr servers, and collects detailed information about the Solr server itself. It also provides the database server and database name for the queries displayed in transaction traces and slow query traces. Solr [3.5.0] Download link Download the module Java agent version 3.34.0 or higher Support ends on December 2019 This module instruments database calls to Solr servers, and collects detailed information about the Solr server itself. It also provides the database server and database name for the queries displayed in transaction traces and slow query traces. Solr [3.6.0 – 3.6.2] Download link Download the module Java agent version 3.34.0 or higher Support ends on December 2019 This module instruments database calls to Solr servers, and collects detailed information about the Solr server itself. It also provides the database server and database name for the queries displayed in transaction traces and slow query traces.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.16784,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Extension and additional <em>instrumentation</em> modules",
        "sections": "Extension and additional <em>instrumentation</em> modules",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " and <em>instrumentation</em> of new libraries. The <em>Java</em> <em>agent</em> provides extension modules for this purpose. Extension modules fall into three general categories: Incubator <em>instrumentation</em> modules: Experimental new support to collect data from specific libraries Archived <em>instrumentation</em> modules"
      },
      "id": "603eb6b5e7b9d293c92a07eb"
    },
    {
      "sections": [
        "Java agent: Instrument Kafka message queues",
        "Tip",
        "View Kafka metrics",
        "Enable Kafka event collection",
        "Important",
        "Enable Kafka distributed traces",
        "1. Enable distributed tracing in the config file",
        "2. Instrument the Kafka producer",
        "3. Instrument the Kafka consumer"
      ],
      "title": "Java agent: Instrument Kafka message queues",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Instrumentation"
      ],
      "external_id": "05644cd866713698034d5419961a40af31d06b90",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/instrumentation/java-agent-instrument-kafka-message-queues/",
      "published_at": "2021-05-05T07:06:37Z",
      "updated_at": "2021-03-16T14:45:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent automatically collects data from Kafka's Java clients library. Because Kafka is a high-performance messaging system that generates a lot of data, you can customize the agent for your app's specific throughput and use cases. This document explains how to collect and view three types of Kafka data: Kafka metrics Kafka events Kafka distributed traces Kafka instrumentation is available in Java agent versions 4.12.0 or higher. For supported Kafka client versions, see Java compatibility and requirements. Tip For our Kafka integration, see Kafka monitoring integration. View Kafka metrics After installation, the agent automatically reports rich Kafka metrics with information about messaging rates, latency, lag, and more. The Java agent collects all Kafka consumer and producer metrics (but not connect or stream metrics). To view these metrics, create a custom dashboard: Go to the New Relic metric explorer. Use the metric explorer to locate your metrics. You can find Kafka metrics in this metric folder: MessageBroker/Kafka/Internal/KafkaMetricName Copy For example, the request-rate metric is located at: MessageBroker/Kafka/Internal/consumer-metrics/request-rate Copy Tip For a full list of Kafka consumer and producer metrics, see the Kafka documentation. Add the metrics you want to monitor to a dashboard by clicking Add to dashboard. Enable Kafka event collection You can configure the agent to collect event data instead of metric timeslice data (for the difference between metric timeslice and event data, see data collection). This allows you to use NRQL to filter and facet the default Kafka metrics. When enabled, the agent collects one Kafka event every 30 seconds. This event contains all of the the data from Kafka consumer and produce metrics captured since the previous event. Important The agent records up to 2000 events per harvest cycle, though you can change this value with max_samples_stored. Kafka event data is included in this pool. If you use the recordCustomEvent() API call to send custom events to New Relic and you send more than 2000 events, the agent will discard some Kafka or custom events. To enable Kafka event collection: Add the kafka.metrics.as_events.enabled element to your newrelic.yml config file: kafka.metrics.as_events.enabled: true Copy Restart your JVM. Use the event explorer to view your Kafka events, located in the KafkaMetrics event type. Or, use NRQL to query your events directly. For example: SELECT average('producer-metrics.record-send-rate') from KafkaMetrics SINCE 30 minutes ago timeseries Copy Enable Kafka distributed traces The Java agent can also collect distributed traces from Kafka clients. Enabling traces doesn't affect the agent's normal operations: it will still report metric or event data from Kafka. Impacts and requirements to consider before enabling: The instrumentation adds a 150 to 200 byte payload to message headers. If your Kafka messages are very small, traces can add significant processing and storage overhead. This additional payload size could cause Kafka to drop messages if they exceed your Kafka messaging size limit. For this reason, we recommend testing out Kafka distributed traces in a dev environment before enabling them in production. Distributed tracing is only available for Kafka client versions 0.11.0.0 or higher. If you have not enabled distributed tracing for your app before, read the Transition guide before enabling. To propagate W3C trace context via Kafka message headers, see the distributed tracing API usage guide for details on APIs that were released in Java agent 6.4.0. Note that adding additional headers to Kafka messages will further increase the payload size. To see these APIs in action, see Using Java agent trace APIs with Kafka. The complete process of enabling this is below but at a high level it involves these basic steps: 1) enable tracing via the agent config, and 2) calling the Java agent API to instrument transactions on both the producer and consumer side. To collect distributed traces from Kafka: 1. Enable distributed tracing in the config file If you have not enabled distributed tracing for your app before, read the distributed tracing transition guide before you enable it. To enable Kafka distributed tracings, enable two settings in your newrelic.yml config file: Set the distributed_tracing element to true: distributed_tracing: enabled: true Copy Enable the Kafka-specific distributed tracing features by adding the following to your config file: class_transformer: kafka-clients-spans: enabled: true Copy 2. Instrument the Kafka producer To instrument your Kafka producer, you'll need to start a transaction before any calls to Producer.send(ProducerRecord<K, V> record). To do this, add the Java agent @Trace(dispatcher = true) annotation to the method. For example: @Trace(dispatcher = true) public static void createAndSend(KafkaProducer<String, String> producer){ ProducerRecord<String, String> data = new ProducerRecord<String, String>(\"topic\", \"key\", \"value\"); producer.send(data); } Copy 3. Instrument the Kafka consumer To instrument your Kafka consumer, you'll need to start a transaction when the message is being processed. The agent stores the distributed tracing payload header under the newrelic key. Retrieve the header, then call the New Relic transaction API to accept the payload. For example: @Trace(dispatcher = true) private static void processMessage(ConsumerRecord<String, String> rec){ Iterable<Header> headers = rec.headers().headers(\"newrelic\"); for(Header header: headers) { NewRelic.getAgent().getTransaction().acceptDistributedTracePayload(new String(header.value(), StandardCharsets.UTF_8)); } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.1671,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em>: <em>Instrument</em> Kafka message queues",
        "sections": "<em>Java</em> <em>agent</em>: <em>Instrument</em> Kafka message queues",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " three types of Kafka data: Kafka metrics Kafka events Kafka distributed traces Kafka <em>instrumentation</em> is available in <em>Java</em> <em>agent</em> versions 4.12.0 or higher. For supported Kafka client versions, see <em>Java</em> compatibility and requirements. Tip For our Kafka integration, see Kafka monitoring integration. View"
      },
      "id": "603ebc2464441f7ce84e8885"
    },
    {
      "sections": [
        "Transaction naming protocol",
        "Important",
        "Grouping transactions",
        "Naming priority",
        "Request attributes",
        "API Calls",
        "Frameworks",
        "JavaServer Pages (JSPs)",
        "Servlets",
        "Servlet filters",
        "Disable component-based naming",
        "Caution"
      ],
      "title": "Transaction naming protocol",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Instrumentation"
      ],
      "external_id": "4ae52ce967d3677fdde6de027a04dbb69c55e4ab",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/instrumentation/transaction-naming-protocol/",
      "published_at": "2021-05-05T07:00:41Z",
      "updated_at": "2021-03-13T03:21:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you're using New Relic for Java with a supported framework, New Relic groups transactions based on transaction names obtained from the framework. Otherwise, New Relic groups transactions based on their component. Components are the JSPs, servlets, and filters invoked during the transaction. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. Grouping transactions The New Relic Java agent groups similar transactions together under a single name. If New Relic did not group transactions, each unique URI would generate a unique name. For example, your web application might produce URIs like: /user/123/control_panel.jhtml /user/456/control_panel.jhtml /user/789/control_panel.jhtml Copy Without grouping, this would produce three (fairly meaningless) individual metrics. Therefore, New Relic attempts to group transactions together under a meaningful label. For more information about metric grouping, see Metric grouping issues. Transaction names use URI format. For example: MyTransactionName /MyTransactionName /MyServlet/MyTransactionName Copy If you are using a supported framework, New Relic obtains the transaction name from the framework. For example, for Spring the transaction name typically comes from calling getViewName on the org.springframework.web.servlet.ModelAndView object. If you are not using a supported framework, New Relic names a transaction based on its components. The exact transaction name is determined by the component with the highest priority. If multiple component share priority, the agent uses the first component that was invoked. Naming priority New Relic assigns each transaction a name according to the following priority, from highest priority to lowest: Request attributes Request attributes and API calls have the highest naming priority. If a transaction has a request attribute or API call, the transaction will take its name from there. You can set the request attribute at any time during the web request. If you set multiple attributes during a request, the first name will be used. This example sets the transaction name using a request attribute in a servlet's doGet: protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { ... request.setAttribute(\"com.newrelic.agent.TRANSACTION_NAME\", \"MyTransactionName\"); ... } Copy API Calls You can also set the transaction name by calling the setTransactionName method from the Java agent API. An API call has the same priority as a request attribute. If you set multiple attributes or make multiple API calls during a request, the most recent name will be used. Frameworks If there are no request attributes or API calls, and you're using a supported framework, New Relic obtains the transaction name from the framework components. JavaServer Pages (JSPs) After frameworks, the New Relic Java agent will use JavaServer Pages (JSPs). A JSP gets the transaction name from its class name. For example, if the JSP servlet class name is org.apache.jsp.ShowBrowser_jsp the transaction name is ShowBrowser.jsp. Servlets After JSPs, the New Relic Java agent will use servlets. A servlet sets the transaction name from either an init parameter or the servlet name. The init parameter is higher priority, so servlets with an init parameter take precedence over servlets without. The servlet name and init parameter are defined in the deployment descriptor. For example: SqlServlet test.SqlServlet com.newrelic.agent.TRANSACTION_NAME MyTransactionName Servlet filters Servlet filters have the lowest priority. A filter gets the transaction name either from an init parameter or the filter name. The init parameter has a higher priority, so filters with an init parameter take precedence over filters without. The filter name and init parameter are defined in the deployment descriptor. For example: SqlFilter test.SqlFilter com.newrelic.agent.TRANSACTION_NAME MyTransactionName The filter name is the value of the filter-name element. The init parameter is the value of the param-value element of an init-param element with a param-name element of com.newrelic.agent.TRANSACTION_NAME. Disable component-based naming For some applications, you may want to disable component-based transaction naming. Set this value in your newrelic.yml file: enable_auto_transaction_naming: false Copy Caution Unless you implement API calls to name your transactions, disabling auto-transaction naming is very likely to cause Metric grouping issues.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 102.28413,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>JavaServer</em> Pages (JSPs)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": ". Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. Grouping transactions The New Relic <em>Java</em> <em>agent</em> groups similar transactions together under a single name. If New"
      },
      "id": "6043dc7ee7b9d22abc5799e0"
    }
  ],
  "/docs/agents/java-agent/instrumentation/instrument-browser-monitoring-java-agent-api": [
    {
      "sections": [
        "Extension and additional instrumentation modules",
        "Tip",
        "Install extension modules",
        "Feature extension modules",
        "Class Histogram",
        "Incubator instrumentation modules",
        "Apache Camel 2.12",
        "C3P0 database connection pools",
        "Coda Hale's Metrics 2",
        "Coda Hale's Metrics 3",
        "HikariCP 2.3.0 - 2.3.8",
        "HikariCP 2.4.0 or higher",
        "Lettuce 4.0 - 5.0",
        "Lettuce 5.0 or higher",
        "Ratpack 1.4.0 or higher",
        "Ratpack Http Client 1.4.0 or higher",
        "Archived instrumentation modules",
        "Akka [2.0]",
        "Akka [2.1]",
        "Akka HTTP [1.0]",
        "Akka HTTP [2.0 – 2.4.1]",
        "Akka HTTP [2.4.2 – 2.4.4]",
        "Hystrix [1.0.2 – 1.1.7]",
        "Hystrix [1.2.0 – 1.2.18]",
        "Hystrix [1.3.0 – 1.3.13]",
        "Play [2.0]",
        "Play [2.1]",
        "Play [2.2]",
        "Solr [3.1.0 – 3.4.0]",
        "Solr [3.5.0]",
        "Solr [3.6.0 – 3.6.2]"
      ],
      "title": "Extension and additional instrumentation modules",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Instrumentation"
      ],
      "external_id": "7428cba4d64b06cc620b7407e87f510a3b42905c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/instrumentation/extension-additional-instrumentation-modules/",
      "published_at": "2021-05-05T07:02:44Z",
      "updated_at": "2021-03-16T14:49:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Java agent is a fully-featured library that automatically collects data from many popular servers, frameworks, libraries, and datastores (for a full list, see Compatibility and requirements). It also has a significant feature set. However, there are always additional requests for functionality and instrumentation of new libraries. The Java agent provides extension modules for this purpose. Extension modules fall into three general categories: Incubator instrumentation modules: Experimental new support to collect data from specific libraries Archived instrumentation modules: Instrumentation for libraries that the original company or author no longer maintains or updates. Feature extension modules: Code that adds new behavior to the agent, independent of any specific library. If your library isn't covered by the automatic instrumentation or by an instrumentation module, you can still collect data with custom instrumentation. Tip If you have feedback, questions, or problems with this instrumentation, create a post in New Relic's Explorers Hub, and tag your post with java_incubator. Install extension modules We recommend updating to the latest Java agent version before installing an extension module. To install an extension module: Download the appropriate .jar file from module lists below. Locate the directory that contains your newrelic.jar and newrelic.yml files. In that directory, create a sub-directory named extensions (if there is not already one there). Copy the .jar extension module you downloaded into the extensions directory. For Feature extension modules, update your newrelic.yml with feature-specific configuration. Restart your server. Send some traffic to the server or host that will exercise the feature or instrumentation. Tip Java agent extension modules are subject to the New Relic Java agent licenses, which are included in each module jar's LICENSE file. Feature extension modules Extension modules are additional libraries that add commonly-requested functionality. To use the an extension module, download it and put it in the Extensions Directory. Class Histogram Download link Download the module The Class Histogram extension runs jmap periodically and generates ClassHistogramRowEvent and ClassHistogramStatsEvent data that you can query and chart. Querying this data can be useful when troubleshooting memory leaks as you can see the values over time. You configure the Class Histogram extension the same way you configure the Java agent: using environment variables, system properties, or newrelic.yml. Here are available properties, with defaults: extensions: class_histogram: enabled: true # true is the default if the extension is present classes_per_histogram: 50 # 50 is the default, and memory leak issues are usually in the highest 50 classes by bytes jmap_path: /your/jdk/bin # The folder where the jmap binary lives. The default is $JAVA_HOME/bin. delay_between_calls_seconds: 60 # Length of the delay between executions to avoid frequent pauses Copy Incubator instrumentation modules Incubator modules are experimental instrumentation, which we may build into the agent's automatic instrumentation in the future. These are the incubator modules that are currently available: Apache Camel 2.12 Download link Download the module This instrumentation module intercepts the following: org.apache.camel.component.http.CamelServlet.resolve Copy To name the transaction so that web transactions have a finer grained name than the Camel servlet name, it uses this: org.apache.camel.component.http.HttpConsumer.getPath() Copy To view the bytecode, use this terminal command: javap -verbose -cp camel-2.12-FILENAME.jar org.apache.camel.component.http.CamelServlet Copy C3P0 database connection pools Download link Download the module Java agent version 3.12.0 or higher This instrumentation module samples C3P0 connection pools and reports busy and idle counts in metrics that start with this: Custom/Database Connection/C3P0/METRIC_NAME Copy You can view the metrics with the metric explorer. Coda Hale's Metrics 2 Download link Download the module This instrumentation module integrates with the MetricRegistry and begins sampling the registered metrics every minute. Reported metrics are prefixed with this: Custom/CodaHale/Metrics2/METRIC_NAME Copy You can view the metrics with the metric explorer. Coda Hale's Metrics 3 Download link Download the module This instrumentation module integrates with the MetricRegistry and begins sampling the registered metrics every minute. Reported metrics are prefixed with this: Custom/CodaHale/Metrics3/METRIC_NAME Copy You can view the metrics with the metric explorer. HikariCP 2.3.0 - 2.3.8 Download link Download the module Java agent version 3.12.0 or higher This instrumentation module samples HikariCP database connection pools and reports busy and idle counts in metrics that start with this: Custom/Database Connection/HikariCP/METRIC_NAME Copy You can view the metrics with the metric explorer. HikariCP 2.4.0 or higher Download link Download the module Java agent version 3.12.0 or higher This instrumentation module samples HikariCP database connection pools and reports busy and idle counts in metrics that start with this: Custom/Database Connection/HikariCP/METRIC_NAME Copy You can view the metrics with the metric explorer. Lettuce 4.0 - 5.0 Download link Download the module Java agent version 5.8.0 or higher This instrumentation package instruments the Lettuce 4.x Redis driver. It enables calls to Redis to show up as datastore calls. Lettuce 5.0 or higher Download link Download the module Java agent version 5.8.0 or higher This instrumentation package instruments the Lettuce 5.x Redis driver. It enables calls to Redis to show up as datastore calls. Ratpack 1.4.0 or higher Download link Download the module Java agent version 3.29 or higher This instrumentation module adds support for async linking of Ratpack's execution primitives. It also monitors handler execution. You must name the transactions manually by using the Java agent API. Ratpack Http Client 1.4.0 or higher Download link Download the module This instrumentation captures Ratpack's HTTP client requests and responses. Archived instrumentation modules Archived modules are instrumentation for libraries that are no longer maintained by the original company or author. Because the target library isn't being updated, our support for archived modules has designated end dates. These are the archived modules that are currently available: Akka [2.0] Download link Download the module Java agent version 3.22.1 or higher Support ends on December 2019 This module provides link instrumentation between actors that send and receive messages. It also traces messages broadcast by or forwarded to actors. In order to avoid over-instrumentation, this instrumentation does not start transactions. If you would like a given actor call to mark the beginning of a transaction, use the @Trace(dispatcher=true) annotation, or some other form of custom instrumentation. Akka [2.1] Download link Download the module Java agent version 3.22.1 or higher Support ends on December 2019 This module provides link instrumentation between actors that send and receive messages. It also traces messages broadcast by or forwarded to actors. In order to avoid over-instrumentation, this instrumentation does not start transactions. If you would like a given actor call to mark the beginning of a transaction, use the @Trace(dispatcher=true) annotation, or some other form of custom instrumentation. Akka HTTP [1.0] Download link Download the module Java agent version 3.24.1 or higher Support ends on December 2019 This module creates transactions from Akka HTTP calls. It also instruments hand-offs between Akka actors, and calls from Akka to other databases and services. For calling systems, this instrumentation collects cross application traces. If you're using a supported Akka version, you can view activity from your Akka HTTP apps from transactions all the way through your actor systems. Akka HTTP [2.0 – 2.4.1] Download link Download the module Java agent version 3.24.1 or higher Support ends on December 2019 This module creates transactions from Akka HTTP calls. It also instruments hand-offs between Akka actors, and calls from Akka to other databases and services. For calling systems, this instrumentation collects cross application traces. If you're using a supported Akka version, you can view activity from your Akka HTTP apps from transactions all the way through your actor systems. Akka HTTP [2.4.2 – 2.4.4] Download link Download the module Java agent version 3.24.1 or higher Support ends on December 2019 This module creates transactions from Akka HTTP calls. It also instruments hand-offs between Akka actors, and calls from Akka to other databases and services. For calling systems, this instrumentation collects cross application traces. You can use this instrumentation together with our built previously released support for Akka, to view activity from your Akka HTTP apps from transactions all the way through to your actor systems. Hystrix [1.0.2 – 1.1.7] Download link Download the module Java agent version 3.23.0 or higher Support ends on December 2019 This module provides timing information related to each Hystrix command. The agent will link chained Hystrix commands into one transaction. Hystrix [1.2.0 – 1.2.18] Download link Download the module Java agent version 3.23.0 or higher Support ends on December 2019 This module provides timing information related to each Hystrix command. The agent will link chained Hystrix commands into one transaction. Hystrix [1.3.0 – 1.3.13] Download link Download the module Java agent version 3.23.0 or higher Support ends on December 2019 This module provides timing information related to each Hystrix command. The agent will link chained Hystrix commands into one transaction. Play [2.0] Download link Download the module Java agent version 3.24.1 or higher Support ends on December 2019 This module creates and names transactions based on your Play controller classes. Play [2.1] Download link Download the module Java agent version 3.24.1 or higher Support ends on December 2019 This module creates and names transactions based on your Play controller classes. Play [2.2] Download link Download the module Java agent version 3.24.1 or higher Support ends on December 2019 This module creates and names transactions based on your Play controller classes. Solr [3.1.0 – 3.4.0] Download link Download the module Java agent version 3.34.0 or higher Support ends on December 2019 This module instruments database calls to Solr servers, and collects detailed information about the Solr server itself. It also provides the database server and database name for the queries displayed in transaction traces and slow query traces. Solr [3.5.0] Download link Download the module Java agent version 3.34.0 or higher Support ends on December 2019 This module instruments database calls to Solr servers, and collects detailed information about the Solr server itself. It also provides the database server and database name for the queries displayed in transaction traces and slow query traces. Solr [3.6.0 – 3.6.2] Download link Download the module Java agent version 3.34.0 or higher Support ends on December 2019 This module instruments database calls to Solr servers, and collects detailed information about the Solr server itself. It also provides the database server and database name for the queries displayed in transaction traces and slow query traces.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.16784,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Extension and additional <em>instrumentation</em> modules",
        "sections": "Extension and additional <em>instrumentation</em> modules",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " and <em>instrumentation</em> of new libraries. The <em>Java</em> <em>agent</em> provides extension modules for this purpose. Extension modules fall into three general categories: Incubator <em>instrumentation</em> modules: Experimental new support to collect data from specific libraries Archived <em>instrumentation</em> modules"
      },
      "id": "603eb6b5e7b9d293c92a07eb"
    },
    {
      "sections": [
        "Ignore specific transactions",
        "Important",
        "Ignore web transactions with ServletRequest",
        "Ignore transactions with annotation",
        "Ignore apdex but not traces"
      ],
      "title": "Ignore specific transactions",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Instrumentation"
      ],
      "external_id": "030d29891f4c8ad625a3eb46adca8f371add7adc",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/instrumentation/ignore-transactions-using-api/",
      "published_at": "2021-05-05T07:02:42Z",
      "updated_at": "2021-03-16T14:48:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic for Java gives you multiple methods to ignore specific transactions. This document explains how to use the Java agent API annotations and ServletRequest to ignore transactions. It is also possible to use the ignoreTransaction() API call and XML instrumentation files to ignore transactions. Important Ignoring transactions involves changing your application's source code and recompiling your application in all cases unless you use an XML instrumentation file. If you cannot manipulate your code, use XML to ignore transactions. Ignore web transactions with ServletRequest To ignore a web transaction, set a ServletRequest attribute named com.newrelic.agent.IGNORE to true during the request: request.setAttribute(\"com.newrelic.agent.IGNORE\", true); Copy To specify URLs to ignore, create a servlet filter which sets that attribute and apply the filter to the servlet you want to ignore. The filter will have access to the request URI if you need to ignore specific URLs. Ignore transactions with annotation To tell the Java agent to ignore transactions using annotations: Define an annotation called NewRelicIgnoreTransaction in your application's code or a library you can integrate with your application: @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface NewRelicIgnoreTransaction { } Copy Apply the annotation to the methods or classes you want to ignore. For example: @NewRelicIgnoreTransaction public void methodToBeIgnored() { } Copy If a transaction calls a method or class annotated with @NewRelicIgnoreTransaction, the transaction is ignored. This means it does not contribute to the overall Apdex score; and the transaction trace and performance data is not reported. Ignore apdex but not traces You can also prevent the transaction from contributing to the Apdex score but still be used in transaction. This can prevent one particularly lengthy transaction from skewing your Apdex score. To prevent a transaction from contributing to your Apdex score: Define an annotation called NewRelicIgnoreApdex in your application's code or a library you can integrate with your application: @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface NewRelicIgnoreApdex { } Copy Apply the annotation to the methods or classes you want to ignore. For example: @NewRelicIgnoreApdex public void ignoreApdexOfThisMethod() { } Copy If a transaction calls a method or class annotated with @NewRelicIgnoreApdex, the transaction is reported, but does not contribute to the overall Apdex score.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.16759,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "New Relic for <em>Java</em> gives you multiple methods to ignore specific transactions. This document explains how to use the <em>Java</em> <em>agent</em> API annotations and ServletRequest to ignore transactions. It is also possible to use the ignoreTransaction() API call and XML <em>instrumentation</em> files to ignore transactions"
      },
      "id": "603eb7db64441f3cf84e8841"
    },
    {
      "sections": [
        "Java agent: Instrument Kafka message queues",
        "Tip",
        "View Kafka metrics",
        "Enable Kafka event collection",
        "Important",
        "Enable Kafka distributed traces",
        "1. Enable distributed tracing in the config file",
        "2. Instrument the Kafka producer",
        "3. Instrument the Kafka consumer"
      ],
      "title": "Java agent: Instrument Kafka message queues",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Instrumentation"
      ],
      "external_id": "05644cd866713698034d5419961a40af31d06b90",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/instrumentation/java-agent-instrument-kafka-message-queues/",
      "published_at": "2021-05-05T07:06:37Z",
      "updated_at": "2021-03-16T14:45:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent automatically collects data from Kafka's Java clients library. Because Kafka is a high-performance messaging system that generates a lot of data, you can customize the agent for your app's specific throughput and use cases. This document explains how to collect and view three types of Kafka data: Kafka metrics Kafka events Kafka distributed traces Kafka instrumentation is available in Java agent versions 4.12.0 or higher. For supported Kafka client versions, see Java compatibility and requirements. Tip For our Kafka integration, see Kafka monitoring integration. View Kafka metrics After installation, the agent automatically reports rich Kafka metrics with information about messaging rates, latency, lag, and more. The Java agent collects all Kafka consumer and producer metrics (but not connect or stream metrics). To view these metrics, create a custom dashboard: Go to the New Relic metric explorer. Use the metric explorer to locate your metrics. You can find Kafka metrics in this metric folder: MessageBroker/Kafka/Internal/KafkaMetricName Copy For example, the request-rate metric is located at: MessageBroker/Kafka/Internal/consumer-metrics/request-rate Copy Tip For a full list of Kafka consumer and producer metrics, see the Kafka documentation. Add the metrics you want to monitor to a dashboard by clicking Add to dashboard. Enable Kafka event collection You can configure the agent to collect event data instead of metric timeslice data (for the difference between metric timeslice and event data, see data collection). This allows you to use NRQL to filter and facet the default Kafka metrics. When enabled, the agent collects one Kafka event every 30 seconds. This event contains all of the the data from Kafka consumer and produce metrics captured since the previous event. Important The agent records up to 2000 events per harvest cycle, though you can change this value with max_samples_stored. Kafka event data is included in this pool. If you use the recordCustomEvent() API call to send custom events to New Relic and you send more than 2000 events, the agent will discard some Kafka or custom events. To enable Kafka event collection: Add the kafka.metrics.as_events.enabled element to your newrelic.yml config file: kafka.metrics.as_events.enabled: true Copy Restart your JVM. Use the event explorer to view your Kafka events, located in the KafkaMetrics event type. Or, use NRQL to query your events directly. For example: SELECT average('producer-metrics.record-send-rate') from KafkaMetrics SINCE 30 minutes ago timeseries Copy Enable Kafka distributed traces The Java agent can also collect distributed traces from Kafka clients. Enabling traces doesn't affect the agent's normal operations: it will still report metric or event data from Kafka. Impacts and requirements to consider before enabling: The instrumentation adds a 150 to 200 byte payload to message headers. If your Kafka messages are very small, traces can add significant processing and storage overhead. This additional payload size could cause Kafka to drop messages if they exceed your Kafka messaging size limit. For this reason, we recommend testing out Kafka distributed traces in a dev environment before enabling them in production. Distributed tracing is only available for Kafka client versions 0.11.0.0 or higher. If you have not enabled distributed tracing for your app before, read the Transition guide before enabling. To propagate W3C trace context via Kafka message headers, see the distributed tracing API usage guide for details on APIs that were released in Java agent 6.4.0. Note that adding additional headers to Kafka messages will further increase the payload size. To see these APIs in action, see Using Java agent trace APIs with Kafka. The complete process of enabling this is below but at a high level it involves these basic steps: 1) enable tracing via the agent config, and 2) calling the Java agent API to instrument transactions on both the producer and consumer side. To collect distributed traces from Kafka: 1. Enable distributed tracing in the config file If you have not enabled distributed tracing for your app before, read the distributed tracing transition guide before you enable it. To enable Kafka distributed tracings, enable two settings in your newrelic.yml config file: Set the distributed_tracing element to true: distributed_tracing: enabled: true Copy Enable the Kafka-specific distributed tracing features by adding the following to your config file: class_transformer: kafka-clients-spans: enabled: true Copy 2. Instrument the Kafka producer To instrument your Kafka producer, you'll need to start a transaction before any calls to Producer.send(ProducerRecord<K, V> record). To do this, add the Java agent @Trace(dispatcher = true) annotation to the method. For example: @Trace(dispatcher = true) public static void createAndSend(KafkaProducer<String, String> producer){ ProducerRecord<String, String> data = new ProducerRecord<String, String>(\"topic\", \"key\", \"value\"); producer.send(data); } Copy 3. Instrument the Kafka consumer To instrument your Kafka consumer, you'll need to start a transaction when the message is being processed. The agent stores the distributed tracing payload header under the newrelic key. Retrieve the header, then call the New Relic transaction API to accept the payload. For example: @Trace(dispatcher = true) private static void processMessage(ConsumerRecord<String, String> rec){ Iterable<Header> headers = rec.headers().headers(\"newrelic\"); for(Header header: headers) { NewRelic.getAgent().getTransaction().acceptDistributedTracePayload(new String(header.value(), StandardCharsets.UTF_8)); } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.16709,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em>: <em>Instrument</em> Kafka message queues",
        "sections": "<em>Java</em> <em>agent</em>: <em>Instrument</em> Kafka message queues",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " three types of Kafka data: Kafka metrics Kafka events Kafka distributed traces Kafka <em>instrumentation</em> is available in <em>Java</em> <em>agent</em> versions 4.12.0 or higher. For supported Kafka client versions, see <em>Java</em> compatibility and requirements. Tip For our Kafka integration, see Kafka monitoring integration. View"
      },
      "id": "603ebc2464441f7ce84e8885"
    }
  ],
  "/docs/agents/java-agent/instrumentation/java-agent-instrument-kafka-message-queues": [
    {
      "sections": [
        "Extension and additional instrumentation modules",
        "Tip",
        "Install extension modules",
        "Feature extension modules",
        "Class Histogram",
        "Incubator instrumentation modules",
        "Apache Camel 2.12",
        "C3P0 database connection pools",
        "Coda Hale's Metrics 2",
        "Coda Hale's Metrics 3",
        "HikariCP 2.3.0 - 2.3.8",
        "HikariCP 2.4.0 or higher",
        "Lettuce 4.0 - 5.0",
        "Lettuce 5.0 or higher",
        "Ratpack 1.4.0 or higher",
        "Ratpack Http Client 1.4.0 or higher",
        "Archived instrumentation modules",
        "Akka [2.0]",
        "Akka [2.1]",
        "Akka HTTP [1.0]",
        "Akka HTTP [2.0 – 2.4.1]",
        "Akka HTTP [2.4.2 – 2.4.4]",
        "Hystrix [1.0.2 – 1.1.7]",
        "Hystrix [1.2.0 – 1.2.18]",
        "Hystrix [1.3.0 – 1.3.13]",
        "Play [2.0]",
        "Play [2.1]",
        "Play [2.2]",
        "Solr [3.1.0 – 3.4.0]",
        "Solr [3.5.0]",
        "Solr [3.6.0 – 3.6.2]"
      ],
      "title": "Extension and additional instrumentation modules",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Instrumentation"
      ],
      "external_id": "7428cba4d64b06cc620b7407e87f510a3b42905c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/instrumentation/extension-additional-instrumentation-modules/",
      "published_at": "2021-05-05T07:02:44Z",
      "updated_at": "2021-03-16T14:49:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Java agent is a fully-featured library that automatically collects data from many popular servers, frameworks, libraries, and datastores (for a full list, see Compatibility and requirements). It also has a significant feature set. However, there are always additional requests for functionality and instrumentation of new libraries. The Java agent provides extension modules for this purpose. Extension modules fall into three general categories: Incubator instrumentation modules: Experimental new support to collect data from specific libraries Archived instrumentation modules: Instrumentation for libraries that the original company or author no longer maintains or updates. Feature extension modules: Code that adds new behavior to the agent, independent of any specific library. If your library isn't covered by the automatic instrumentation or by an instrumentation module, you can still collect data with custom instrumentation. Tip If you have feedback, questions, or problems with this instrumentation, create a post in New Relic's Explorers Hub, and tag your post with java_incubator. Install extension modules We recommend updating to the latest Java agent version before installing an extension module. To install an extension module: Download the appropriate .jar file from module lists below. Locate the directory that contains your newrelic.jar and newrelic.yml files. In that directory, create a sub-directory named extensions (if there is not already one there). Copy the .jar extension module you downloaded into the extensions directory. For Feature extension modules, update your newrelic.yml with feature-specific configuration. Restart your server. Send some traffic to the server or host that will exercise the feature or instrumentation. Tip Java agent extension modules are subject to the New Relic Java agent licenses, which are included in each module jar's LICENSE file. Feature extension modules Extension modules are additional libraries that add commonly-requested functionality. To use the an extension module, download it and put it in the Extensions Directory. Class Histogram Download link Download the module The Class Histogram extension runs jmap periodically and generates ClassHistogramRowEvent and ClassHistogramStatsEvent data that you can query and chart. Querying this data can be useful when troubleshooting memory leaks as you can see the values over time. You configure the Class Histogram extension the same way you configure the Java agent: using environment variables, system properties, or newrelic.yml. Here are available properties, with defaults: extensions: class_histogram: enabled: true # true is the default if the extension is present classes_per_histogram: 50 # 50 is the default, and memory leak issues are usually in the highest 50 classes by bytes jmap_path: /your/jdk/bin # The folder where the jmap binary lives. The default is $JAVA_HOME/bin. delay_between_calls_seconds: 60 # Length of the delay between executions to avoid frequent pauses Copy Incubator instrumentation modules Incubator modules are experimental instrumentation, which we may build into the agent's automatic instrumentation in the future. These are the incubator modules that are currently available: Apache Camel 2.12 Download link Download the module This instrumentation module intercepts the following: org.apache.camel.component.http.CamelServlet.resolve Copy To name the transaction so that web transactions have a finer grained name than the Camel servlet name, it uses this: org.apache.camel.component.http.HttpConsumer.getPath() Copy To view the bytecode, use this terminal command: javap -verbose -cp camel-2.12-FILENAME.jar org.apache.camel.component.http.CamelServlet Copy C3P0 database connection pools Download link Download the module Java agent version 3.12.0 or higher This instrumentation module samples C3P0 connection pools and reports busy and idle counts in metrics that start with this: Custom/Database Connection/C3P0/METRIC_NAME Copy You can view the metrics with the metric explorer. Coda Hale's Metrics 2 Download link Download the module This instrumentation module integrates with the MetricRegistry and begins sampling the registered metrics every minute. Reported metrics are prefixed with this: Custom/CodaHale/Metrics2/METRIC_NAME Copy You can view the metrics with the metric explorer. Coda Hale's Metrics 3 Download link Download the module This instrumentation module integrates with the MetricRegistry and begins sampling the registered metrics every minute. Reported metrics are prefixed with this: Custom/CodaHale/Metrics3/METRIC_NAME Copy You can view the metrics with the metric explorer. HikariCP 2.3.0 - 2.3.8 Download link Download the module Java agent version 3.12.0 or higher This instrumentation module samples HikariCP database connection pools and reports busy and idle counts in metrics that start with this: Custom/Database Connection/HikariCP/METRIC_NAME Copy You can view the metrics with the metric explorer. HikariCP 2.4.0 or higher Download link Download the module Java agent version 3.12.0 or higher This instrumentation module samples HikariCP database connection pools and reports busy and idle counts in metrics that start with this: Custom/Database Connection/HikariCP/METRIC_NAME Copy You can view the metrics with the metric explorer. Lettuce 4.0 - 5.0 Download link Download the module Java agent version 5.8.0 or higher This instrumentation package instruments the Lettuce 4.x Redis driver. It enables calls to Redis to show up as datastore calls. Lettuce 5.0 or higher Download link Download the module Java agent version 5.8.0 or higher This instrumentation package instruments the Lettuce 5.x Redis driver. It enables calls to Redis to show up as datastore calls. Ratpack 1.4.0 or higher Download link Download the module Java agent version 3.29 or higher This instrumentation module adds support for async linking of Ratpack's execution primitives. It also monitors handler execution. You must name the transactions manually by using the Java agent API. Ratpack Http Client 1.4.0 or higher Download link Download the module This instrumentation captures Ratpack's HTTP client requests and responses. Archived instrumentation modules Archived modules are instrumentation for libraries that are no longer maintained by the original company or author. Because the target library isn't being updated, our support for archived modules has designated end dates. These are the archived modules that are currently available: Akka [2.0] Download link Download the module Java agent version 3.22.1 or higher Support ends on December 2019 This module provides link instrumentation between actors that send and receive messages. It also traces messages broadcast by or forwarded to actors. In order to avoid over-instrumentation, this instrumentation does not start transactions. If you would like a given actor call to mark the beginning of a transaction, use the @Trace(dispatcher=true) annotation, or some other form of custom instrumentation. Akka [2.1] Download link Download the module Java agent version 3.22.1 or higher Support ends on December 2019 This module provides link instrumentation between actors that send and receive messages. It also traces messages broadcast by or forwarded to actors. In order to avoid over-instrumentation, this instrumentation does not start transactions. If you would like a given actor call to mark the beginning of a transaction, use the @Trace(dispatcher=true) annotation, or some other form of custom instrumentation. Akka HTTP [1.0] Download link Download the module Java agent version 3.24.1 or higher Support ends on December 2019 This module creates transactions from Akka HTTP calls. It also instruments hand-offs between Akka actors, and calls from Akka to other databases and services. For calling systems, this instrumentation collects cross application traces. If you're using a supported Akka version, you can view activity from your Akka HTTP apps from transactions all the way through your actor systems. Akka HTTP [2.0 – 2.4.1] Download link Download the module Java agent version 3.24.1 or higher Support ends on December 2019 This module creates transactions from Akka HTTP calls. It also instruments hand-offs between Akka actors, and calls from Akka to other databases and services. For calling systems, this instrumentation collects cross application traces. If you're using a supported Akka version, you can view activity from your Akka HTTP apps from transactions all the way through your actor systems. Akka HTTP [2.4.2 – 2.4.4] Download link Download the module Java agent version 3.24.1 or higher Support ends on December 2019 This module creates transactions from Akka HTTP calls. It also instruments hand-offs between Akka actors, and calls from Akka to other databases and services. For calling systems, this instrumentation collects cross application traces. You can use this instrumentation together with our built previously released support for Akka, to view activity from your Akka HTTP apps from transactions all the way through to your actor systems. Hystrix [1.0.2 – 1.1.7] Download link Download the module Java agent version 3.23.0 or higher Support ends on December 2019 This module provides timing information related to each Hystrix command. The agent will link chained Hystrix commands into one transaction. Hystrix [1.2.0 – 1.2.18] Download link Download the module Java agent version 3.23.0 or higher Support ends on December 2019 This module provides timing information related to each Hystrix command. The agent will link chained Hystrix commands into one transaction. Hystrix [1.3.0 – 1.3.13] Download link Download the module Java agent version 3.23.0 or higher Support ends on December 2019 This module provides timing information related to each Hystrix command. The agent will link chained Hystrix commands into one transaction. Play [2.0] Download link Download the module Java agent version 3.24.1 or higher Support ends on December 2019 This module creates and names transactions based on your Play controller classes. Play [2.1] Download link Download the module Java agent version 3.24.1 or higher Support ends on December 2019 This module creates and names transactions based on your Play controller classes. Play [2.2] Download link Download the module Java agent version 3.24.1 or higher Support ends on December 2019 This module creates and names transactions based on your Play controller classes. Solr [3.1.0 – 3.4.0] Download link Download the module Java agent version 3.34.0 or higher Support ends on December 2019 This module instruments database calls to Solr servers, and collects detailed information about the Solr server itself. It also provides the database server and database name for the queries displayed in transaction traces and slow query traces. Solr [3.5.0] Download link Download the module Java agent version 3.34.0 or higher Support ends on December 2019 This module instruments database calls to Solr servers, and collects detailed information about the Solr server itself. It also provides the database server and database name for the queries displayed in transaction traces and slow query traces. Solr [3.6.0 – 3.6.2] Download link Download the module Java agent version 3.34.0 or higher Support ends on December 2019 This module instruments database calls to Solr servers, and collects detailed information about the Solr server itself. It also provides the database server and database name for the queries displayed in transaction traces and slow query traces.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.16784,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Extension and additional <em>instrumentation</em> modules",
        "sections": "Extension and additional <em>instrumentation</em> modules",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " and <em>instrumentation</em> of new libraries. The <em>Java</em> <em>agent</em> provides extension modules for this purpose. Extension modules fall into three general categories: Incubator <em>instrumentation</em> modules: Experimental new support to collect data from specific libraries Archived <em>instrumentation</em> modules"
      },
      "id": "603eb6b5e7b9d293c92a07eb"
    },
    {
      "sections": [
        "Ignore specific transactions",
        "Important",
        "Ignore web transactions with ServletRequest",
        "Ignore transactions with annotation",
        "Ignore apdex but not traces"
      ],
      "title": "Ignore specific transactions",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Instrumentation"
      ],
      "external_id": "030d29891f4c8ad625a3eb46adca8f371add7adc",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/instrumentation/ignore-transactions-using-api/",
      "published_at": "2021-05-05T07:02:42Z",
      "updated_at": "2021-03-16T14:48:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic for Java gives you multiple methods to ignore specific transactions. This document explains how to use the Java agent API annotations and ServletRequest to ignore transactions. It is also possible to use the ignoreTransaction() API call and XML instrumentation files to ignore transactions. Important Ignoring transactions involves changing your application's source code and recompiling your application in all cases unless you use an XML instrumentation file. If you cannot manipulate your code, use XML to ignore transactions. Ignore web transactions with ServletRequest To ignore a web transaction, set a ServletRequest attribute named com.newrelic.agent.IGNORE to true during the request: request.setAttribute(\"com.newrelic.agent.IGNORE\", true); Copy To specify URLs to ignore, create a servlet filter which sets that attribute and apply the filter to the servlet you want to ignore. The filter will have access to the request URI if you need to ignore specific URLs. Ignore transactions with annotation To tell the Java agent to ignore transactions using annotations: Define an annotation called NewRelicIgnoreTransaction in your application's code or a library you can integrate with your application: @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface NewRelicIgnoreTransaction { } Copy Apply the annotation to the methods or classes you want to ignore. For example: @NewRelicIgnoreTransaction public void methodToBeIgnored() { } Copy If a transaction calls a method or class annotated with @NewRelicIgnoreTransaction, the transaction is ignored. This means it does not contribute to the overall Apdex score; and the transaction trace and performance data is not reported. Ignore apdex but not traces You can also prevent the transaction from contributing to the Apdex score but still be used in transaction. This can prevent one particularly lengthy transaction from skewing your Apdex score. To prevent a transaction from contributing to your Apdex score: Define an annotation called NewRelicIgnoreApdex in your application's code or a library you can integrate with your application: @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface NewRelicIgnoreApdex { } Copy Apply the annotation to the methods or classes you want to ignore. For example: @NewRelicIgnoreApdex public void ignoreApdexOfThisMethod() { } Copy If a transaction calls a method or class annotated with @NewRelicIgnoreApdex, the transaction is reported, but does not contribute to the overall Apdex score.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.16759,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "New Relic for <em>Java</em> gives you multiple methods to ignore specific transactions. This document explains how to use the <em>Java</em> <em>agent</em> API annotations and ServletRequest to ignore transactions. It is also possible to use the ignoreTransaction() API call and XML <em>instrumentation</em> files to ignore transactions"
      },
      "id": "603eb7db64441f3cf84e8841"
    },
    {
      "sections": [
        "Transaction naming protocol",
        "Important",
        "Grouping transactions",
        "Naming priority",
        "Request attributes",
        "API Calls",
        "Frameworks",
        "JavaServer Pages (JSPs)",
        "Servlets",
        "Servlet filters",
        "Disable component-based naming",
        "Caution"
      ],
      "title": "Transaction naming protocol",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Instrumentation"
      ],
      "external_id": "4ae52ce967d3677fdde6de027a04dbb69c55e4ab",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/instrumentation/transaction-naming-protocol/",
      "published_at": "2021-05-05T07:00:41Z",
      "updated_at": "2021-03-13T03:21:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you're using New Relic for Java with a supported framework, New Relic groups transactions based on transaction names obtained from the framework. Otherwise, New Relic groups transactions based on their component. Components are the JSPs, servlets, and filters invoked during the transaction. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. Grouping transactions The New Relic Java agent groups similar transactions together under a single name. If New Relic did not group transactions, each unique URI would generate a unique name. For example, your web application might produce URIs like: /user/123/control_panel.jhtml /user/456/control_panel.jhtml /user/789/control_panel.jhtml Copy Without grouping, this would produce three (fairly meaningless) individual metrics. Therefore, New Relic attempts to group transactions together under a meaningful label. For more information about metric grouping, see Metric grouping issues. Transaction names use URI format. For example: MyTransactionName /MyTransactionName /MyServlet/MyTransactionName Copy If you are using a supported framework, New Relic obtains the transaction name from the framework. For example, for Spring the transaction name typically comes from calling getViewName on the org.springframework.web.servlet.ModelAndView object. If you are not using a supported framework, New Relic names a transaction based on its components. The exact transaction name is determined by the component with the highest priority. If multiple component share priority, the agent uses the first component that was invoked. Naming priority New Relic assigns each transaction a name according to the following priority, from highest priority to lowest: Request attributes Request attributes and API calls have the highest naming priority. If a transaction has a request attribute or API call, the transaction will take its name from there. You can set the request attribute at any time during the web request. If you set multiple attributes during a request, the first name will be used. This example sets the transaction name using a request attribute in a servlet's doGet: protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { ... request.setAttribute(\"com.newrelic.agent.TRANSACTION_NAME\", \"MyTransactionName\"); ... } Copy API Calls You can also set the transaction name by calling the setTransactionName method from the Java agent API. An API call has the same priority as a request attribute. If you set multiple attributes or make multiple API calls during a request, the most recent name will be used. Frameworks If there are no request attributes or API calls, and you're using a supported framework, New Relic obtains the transaction name from the framework components. JavaServer Pages (JSPs) After frameworks, the New Relic Java agent will use JavaServer Pages (JSPs). A JSP gets the transaction name from its class name. For example, if the JSP servlet class name is org.apache.jsp.ShowBrowser_jsp the transaction name is ShowBrowser.jsp. Servlets After JSPs, the New Relic Java agent will use servlets. A servlet sets the transaction name from either an init parameter or the servlet name. The init parameter is higher priority, so servlets with an init parameter take precedence over servlets without. The servlet name and init parameter are defined in the deployment descriptor. For example: SqlServlet test.SqlServlet com.newrelic.agent.TRANSACTION_NAME MyTransactionName Servlet filters Servlet filters have the lowest priority. A filter gets the transaction name either from an init parameter or the filter name. The init parameter has a higher priority, so filters with an init parameter take precedence over filters without. The filter name and init parameter are defined in the deployment descriptor. For example: SqlFilter test.SqlFilter com.newrelic.agent.TRANSACTION_NAME MyTransactionName The filter name is the value of the filter-name element. The init parameter is the value of the param-value element of an init-param element with a param-name element of com.newrelic.agent.TRANSACTION_NAME. Disable component-based naming For some applications, you may want to disable component-based transaction naming. Set this value in your newrelic.yml file: enable_auto_transaction_naming: false Copy Caution Unless you implement API calls to name your transactions, disabling auto-transaction naming is very likely to cause Metric grouping issues.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 102.28412,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>JavaServer</em> Pages (JSPs)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": ". Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. Grouping transactions The New Relic <em>Java</em> <em>agent</em> groups similar transactions together under a single name. If New"
      },
      "id": "6043dc7ee7b9d22abc5799e0"
    }
  ],
  "/docs/agents/java-agent/instrumentation/monitor-deployments-java-agent": [
    {
      "sections": [
        "Extension and additional instrumentation modules",
        "Tip",
        "Install extension modules",
        "Feature extension modules",
        "Class Histogram",
        "Incubator instrumentation modules",
        "Apache Camel 2.12",
        "C3P0 database connection pools",
        "Coda Hale's Metrics 2",
        "Coda Hale's Metrics 3",
        "HikariCP 2.3.0 - 2.3.8",
        "HikariCP 2.4.0 or higher",
        "Lettuce 4.0 - 5.0",
        "Lettuce 5.0 or higher",
        "Ratpack 1.4.0 or higher",
        "Ratpack Http Client 1.4.0 or higher",
        "Archived instrumentation modules",
        "Akka [2.0]",
        "Akka [2.1]",
        "Akka HTTP [1.0]",
        "Akka HTTP [2.0 – 2.4.1]",
        "Akka HTTP [2.4.2 – 2.4.4]",
        "Hystrix [1.0.2 – 1.1.7]",
        "Hystrix [1.2.0 – 1.2.18]",
        "Hystrix [1.3.0 – 1.3.13]",
        "Play [2.0]",
        "Play [2.1]",
        "Play [2.2]",
        "Solr [3.1.0 – 3.4.0]",
        "Solr [3.5.0]",
        "Solr [3.6.0 – 3.6.2]"
      ],
      "title": "Extension and additional instrumentation modules",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Instrumentation"
      ],
      "external_id": "7428cba4d64b06cc620b7407e87f510a3b42905c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/instrumentation/extension-additional-instrumentation-modules/",
      "published_at": "2021-05-05T07:02:44Z",
      "updated_at": "2021-03-16T14:49:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Java agent is a fully-featured library that automatically collects data from many popular servers, frameworks, libraries, and datastores (for a full list, see Compatibility and requirements). It also has a significant feature set. However, there are always additional requests for functionality and instrumentation of new libraries. The Java agent provides extension modules for this purpose. Extension modules fall into three general categories: Incubator instrumentation modules: Experimental new support to collect data from specific libraries Archived instrumentation modules: Instrumentation for libraries that the original company or author no longer maintains or updates. Feature extension modules: Code that adds new behavior to the agent, independent of any specific library. If your library isn't covered by the automatic instrumentation or by an instrumentation module, you can still collect data with custom instrumentation. Tip If you have feedback, questions, or problems with this instrumentation, create a post in New Relic's Explorers Hub, and tag your post with java_incubator. Install extension modules We recommend updating to the latest Java agent version before installing an extension module. To install an extension module: Download the appropriate .jar file from module lists below. Locate the directory that contains your newrelic.jar and newrelic.yml files. In that directory, create a sub-directory named extensions (if there is not already one there). Copy the .jar extension module you downloaded into the extensions directory. For Feature extension modules, update your newrelic.yml with feature-specific configuration. Restart your server. Send some traffic to the server or host that will exercise the feature or instrumentation. Tip Java agent extension modules are subject to the New Relic Java agent licenses, which are included in each module jar's LICENSE file. Feature extension modules Extension modules are additional libraries that add commonly-requested functionality. To use the an extension module, download it and put it in the Extensions Directory. Class Histogram Download link Download the module The Class Histogram extension runs jmap periodically and generates ClassHistogramRowEvent and ClassHistogramStatsEvent data that you can query and chart. Querying this data can be useful when troubleshooting memory leaks as you can see the values over time. You configure the Class Histogram extension the same way you configure the Java agent: using environment variables, system properties, or newrelic.yml. Here are available properties, with defaults: extensions: class_histogram: enabled: true # true is the default if the extension is present classes_per_histogram: 50 # 50 is the default, and memory leak issues are usually in the highest 50 classes by bytes jmap_path: /your/jdk/bin # The folder where the jmap binary lives. The default is $JAVA_HOME/bin. delay_between_calls_seconds: 60 # Length of the delay between executions to avoid frequent pauses Copy Incubator instrumentation modules Incubator modules are experimental instrumentation, which we may build into the agent's automatic instrumentation in the future. These are the incubator modules that are currently available: Apache Camel 2.12 Download link Download the module This instrumentation module intercepts the following: org.apache.camel.component.http.CamelServlet.resolve Copy To name the transaction so that web transactions have a finer grained name than the Camel servlet name, it uses this: org.apache.camel.component.http.HttpConsumer.getPath() Copy To view the bytecode, use this terminal command: javap -verbose -cp camel-2.12-FILENAME.jar org.apache.camel.component.http.CamelServlet Copy C3P0 database connection pools Download link Download the module Java agent version 3.12.0 or higher This instrumentation module samples C3P0 connection pools and reports busy and idle counts in metrics that start with this: Custom/Database Connection/C3P0/METRIC_NAME Copy You can view the metrics with the metric explorer. Coda Hale's Metrics 2 Download link Download the module This instrumentation module integrates with the MetricRegistry and begins sampling the registered metrics every minute. Reported metrics are prefixed with this: Custom/CodaHale/Metrics2/METRIC_NAME Copy You can view the metrics with the metric explorer. Coda Hale's Metrics 3 Download link Download the module This instrumentation module integrates with the MetricRegistry and begins sampling the registered metrics every minute. Reported metrics are prefixed with this: Custom/CodaHale/Metrics3/METRIC_NAME Copy You can view the metrics with the metric explorer. HikariCP 2.3.0 - 2.3.8 Download link Download the module Java agent version 3.12.0 or higher This instrumentation module samples HikariCP database connection pools and reports busy and idle counts in metrics that start with this: Custom/Database Connection/HikariCP/METRIC_NAME Copy You can view the metrics with the metric explorer. HikariCP 2.4.0 or higher Download link Download the module Java agent version 3.12.0 or higher This instrumentation module samples HikariCP database connection pools and reports busy and idle counts in metrics that start with this: Custom/Database Connection/HikariCP/METRIC_NAME Copy You can view the metrics with the metric explorer. Lettuce 4.0 - 5.0 Download link Download the module Java agent version 5.8.0 or higher This instrumentation package instruments the Lettuce 4.x Redis driver. It enables calls to Redis to show up as datastore calls. Lettuce 5.0 or higher Download link Download the module Java agent version 5.8.0 or higher This instrumentation package instruments the Lettuce 5.x Redis driver. It enables calls to Redis to show up as datastore calls. Ratpack 1.4.0 or higher Download link Download the module Java agent version 3.29 or higher This instrumentation module adds support for async linking of Ratpack's execution primitives. It also monitors handler execution. You must name the transactions manually by using the Java agent API. Ratpack Http Client 1.4.0 or higher Download link Download the module This instrumentation captures Ratpack's HTTP client requests and responses. Archived instrumentation modules Archived modules are instrumentation for libraries that are no longer maintained by the original company or author. Because the target library isn't being updated, our support for archived modules has designated end dates. These are the archived modules that are currently available: Akka [2.0] Download link Download the module Java agent version 3.22.1 or higher Support ends on December 2019 This module provides link instrumentation between actors that send and receive messages. It also traces messages broadcast by or forwarded to actors. In order to avoid over-instrumentation, this instrumentation does not start transactions. If you would like a given actor call to mark the beginning of a transaction, use the @Trace(dispatcher=true) annotation, or some other form of custom instrumentation. Akka [2.1] Download link Download the module Java agent version 3.22.1 or higher Support ends on December 2019 This module provides link instrumentation between actors that send and receive messages. It also traces messages broadcast by or forwarded to actors. In order to avoid over-instrumentation, this instrumentation does not start transactions. If you would like a given actor call to mark the beginning of a transaction, use the @Trace(dispatcher=true) annotation, or some other form of custom instrumentation. Akka HTTP [1.0] Download link Download the module Java agent version 3.24.1 or higher Support ends on December 2019 This module creates transactions from Akka HTTP calls. It also instruments hand-offs between Akka actors, and calls from Akka to other databases and services. For calling systems, this instrumentation collects cross application traces. If you're using a supported Akka version, you can view activity from your Akka HTTP apps from transactions all the way through your actor systems. Akka HTTP [2.0 – 2.4.1] Download link Download the module Java agent version 3.24.1 or higher Support ends on December 2019 This module creates transactions from Akka HTTP calls. It also instruments hand-offs between Akka actors, and calls from Akka to other databases and services. For calling systems, this instrumentation collects cross application traces. If you're using a supported Akka version, you can view activity from your Akka HTTP apps from transactions all the way through your actor systems. Akka HTTP [2.4.2 – 2.4.4] Download link Download the module Java agent version 3.24.1 or higher Support ends on December 2019 This module creates transactions from Akka HTTP calls. It also instruments hand-offs between Akka actors, and calls from Akka to other databases and services. For calling systems, this instrumentation collects cross application traces. You can use this instrumentation together with our built previously released support for Akka, to view activity from your Akka HTTP apps from transactions all the way through to your actor systems. Hystrix [1.0.2 – 1.1.7] Download link Download the module Java agent version 3.23.0 or higher Support ends on December 2019 This module provides timing information related to each Hystrix command. The agent will link chained Hystrix commands into one transaction. Hystrix [1.2.0 – 1.2.18] Download link Download the module Java agent version 3.23.0 or higher Support ends on December 2019 This module provides timing information related to each Hystrix command. The agent will link chained Hystrix commands into one transaction. Hystrix [1.3.0 – 1.3.13] Download link Download the module Java agent version 3.23.0 or higher Support ends on December 2019 This module provides timing information related to each Hystrix command. The agent will link chained Hystrix commands into one transaction. Play [2.0] Download link Download the module Java agent version 3.24.1 or higher Support ends on December 2019 This module creates and names transactions based on your Play controller classes. Play [2.1] Download link Download the module Java agent version 3.24.1 or higher Support ends on December 2019 This module creates and names transactions based on your Play controller classes. Play [2.2] Download link Download the module Java agent version 3.24.1 or higher Support ends on December 2019 This module creates and names transactions based on your Play controller classes. Solr [3.1.0 – 3.4.0] Download link Download the module Java agent version 3.34.0 or higher Support ends on December 2019 This module instruments database calls to Solr servers, and collects detailed information about the Solr server itself. It also provides the database server and database name for the queries displayed in transaction traces and slow query traces. Solr [3.5.0] Download link Download the module Java agent version 3.34.0 or higher Support ends on December 2019 This module instruments database calls to Solr servers, and collects detailed information about the Solr server itself. It also provides the database server and database name for the queries displayed in transaction traces and slow query traces. Solr [3.6.0 – 3.6.2] Download link Download the module Java agent version 3.34.0 or higher Support ends on December 2019 This module instruments database calls to Solr servers, and collects detailed information about the Solr server itself. It also provides the database server and database name for the queries displayed in transaction traces and slow query traces.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.16783,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Extension and additional <em>instrumentation</em> modules",
        "sections": "Extension and additional <em>instrumentation</em> modules",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " and <em>instrumentation</em> of new libraries. The <em>Java</em> <em>agent</em> provides extension modules for this purpose. Extension modules fall into three general categories: Incubator <em>instrumentation</em> modules: Experimental new support to collect data from specific libraries Archived <em>instrumentation</em> modules"
      },
      "id": "603eb6b5e7b9d293c92a07eb"
    },
    {
      "sections": [
        "Ignore specific transactions",
        "Important",
        "Ignore web transactions with ServletRequest",
        "Ignore transactions with annotation",
        "Ignore apdex but not traces"
      ],
      "title": "Ignore specific transactions",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Instrumentation"
      ],
      "external_id": "030d29891f4c8ad625a3eb46adca8f371add7adc",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/instrumentation/ignore-transactions-using-api/",
      "published_at": "2021-05-05T07:02:42Z",
      "updated_at": "2021-03-16T14:48:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic for Java gives you multiple methods to ignore specific transactions. This document explains how to use the Java agent API annotations and ServletRequest to ignore transactions. It is also possible to use the ignoreTransaction() API call and XML instrumentation files to ignore transactions. Important Ignoring transactions involves changing your application's source code and recompiling your application in all cases unless you use an XML instrumentation file. If you cannot manipulate your code, use XML to ignore transactions. Ignore web transactions with ServletRequest To ignore a web transaction, set a ServletRequest attribute named com.newrelic.agent.IGNORE to true during the request: request.setAttribute(\"com.newrelic.agent.IGNORE\", true); Copy To specify URLs to ignore, create a servlet filter which sets that attribute and apply the filter to the servlet you want to ignore. The filter will have access to the request URI if you need to ignore specific URLs. Ignore transactions with annotation To tell the Java agent to ignore transactions using annotations: Define an annotation called NewRelicIgnoreTransaction in your application's code or a library you can integrate with your application: @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface NewRelicIgnoreTransaction { } Copy Apply the annotation to the methods or classes you want to ignore. For example: @NewRelicIgnoreTransaction public void methodToBeIgnored() { } Copy If a transaction calls a method or class annotated with @NewRelicIgnoreTransaction, the transaction is ignored. This means it does not contribute to the overall Apdex score; and the transaction trace and performance data is not reported. Ignore apdex but not traces You can also prevent the transaction from contributing to the Apdex score but still be used in transaction. This can prevent one particularly lengthy transaction from skewing your Apdex score. To prevent a transaction from contributing to your Apdex score: Define an annotation called NewRelicIgnoreApdex in your application's code or a library you can integrate with your application: @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface NewRelicIgnoreApdex { } Copy Apply the annotation to the methods or classes you want to ignore. For example: @NewRelicIgnoreApdex public void ignoreApdexOfThisMethod() { } Copy If a transaction calls a method or class annotated with @NewRelicIgnoreApdex, the transaction is reported, but does not contribute to the overall Apdex score.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.16759,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "New Relic for <em>Java</em> gives you multiple methods to ignore specific transactions. This document explains how to use the <em>Java</em> <em>agent</em> API annotations and ServletRequest to ignore transactions. It is also possible to use the ignoreTransaction() API call and XML <em>instrumentation</em> files to ignore transactions"
      },
      "id": "603eb7db64441f3cf84e8841"
    },
    {
      "sections": [
        "Java agent: Instrument Kafka message queues",
        "Tip",
        "View Kafka metrics",
        "Enable Kafka event collection",
        "Important",
        "Enable Kafka distributed traces",
        "1. Enable distributed tracing in the config file",
        "2. Instrument the Kafka producer",
        "3. Instrument the Kafka consumer"
      ],
      "title": "Java agent: Instrument Kafka message queues",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Instrumentation"
      ],
      "external_id": "05644cd866713698034d5419961a40af31d06b90",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/instrumentation/java-agent-instrument-kafka-message-queues/",
      "published_at": "2021-05-05T07:06:37Z",
      "updated_at": "2021-03-16T14:45:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent automatically collects data from Kafka's Java clients library. Because Kafka is a high-performance messaging system that generates a lot of data, you can customize the agent for your app's specific throughput and use cases. This document explains how to collect and view three types of Kafka data: Kafka metrics Kafka events Kafka distributed traces Kafka instrumentation is available in Java agent versions 4.12.0 or higher. For supported Kafka client versions, see Java compatibility and requirements. Tip For our Kafka integration, see Kafka monitoring integration. View Kafka metrics After installation, the agent automatically reports rich Kafka metrics with information about messaging rates, latency, lag, and more. The Java agent collects all Kafka consumer and producer metrics (but not connect or stream metrics). To view these metrics, create a custom dashboard: Go to the New Relic metric explorer. Use the metric explorer to locate your metrics. You can find Kafka metrics in this metric folder: MessageBroker/Kafka/Internal/KafkaMetricName Copy For example, the request-rate metric is located at: MessageBroker/Kafka/Internal/consumer-metrics/request-rate Copy Tip For a full list of Kafka consumer and producer metrics, see the Kafka documentation. Add the metrics you want to monitor to a dashboard by clicking Add to dashboard. Enable Kafka event collection You can configure the agent to collect event data instead of metric timeslice data (for the difference between metric timeslice and event data, see data collection). This allows you to use NRQL to filter and facet the default Kafka metrics. When enabled, the agent collects one Kafka event every 30 seconds. This event contains all of the the data from Kafka consumer and produce metrics captured since the previous event. Important The agent records up to 2000 events per harvest cycle, though you can change this value with max_samples_stored. Kafka event data is included in this pool. If you use the recordCustomEvent() API call to send custom events to New Relic and you send more than 2000 events, the agent will discard some Kafka or custom events. To enable Kafka event collection: Add the kafka.metrics.as_events.enabled element to your newrelic.yml config file: kafka.metrics.as_events.enabled: true Copy Restart your JVM. Use the event explorer to view your Kafka events, located in the KafkaMetrics event type. Or, use NRQL to query your events directly. For example: SELECT average('producer-metrics.record-send-rate') from KafkaMetrics SINCE 30 minutes ago timeseries Copy Enable Kafka distributed traces The Java agent can also collect distributed traces from Kafka clients. Enabling traces doesn't affect the agent's normal operations: it will still report metric or event data from Kafka. Impacts and requirements to consider before enabling: The instrumentation adds a 150 to 200 byte payload to message headers. If your Kafka messages are very small, traces can add significant processing and storage overhead. This additional payload size could cause Kafka to drop messages if they exceed your Kafka messaging size limit. For this reason, we recommend testing out Kafka distributed traces in a dev environment before enabling them in production. Distributed tracing is only available for Kafka client versions 0.11.0.0 or higher. If you have not enabled distributed tracing for your app before, read the Transition guide before enabling. To propagate W3C trace context via Kafka message headers, see the distributed tracing API usage guide for details on APIs that were released in Java agent 6.4.0. Note that adding additional headers to Kafka messages will further increase the payload size. To see these APIs in action, see Using Java agent trace APIs with Kafka. The complete process of enabling this is below but at a high level it involves these basic steps: 1) enable tracing via the agent config, and 2) calling the Java agent API to instrument transactions on both the producer and consumer side. To collect distributed traces from Kafka: 1. Enable distributed tracing in the config file If you have not enabled distributed tracing for your app before, read the distributed tracing transition guide before you enable it. To enable Kafka distributed tracings, enable two settings in your newrelic.yml config file: Set the distributed_tracing element to true: distributed_tracing: enabled: true Copy Enable the Kafka-specific distributed tracing features by adding the following to your config file: class_transformer: kafka-clients-spans: enabled: true Copy 2. Instrument the Kafka producer To instrument your Kafka producer, you'll need to start a transaction before any calls to Producer.send(ProducerRecord<K, V> record). To do this, add the Java agent @Trace(dispatcher = true) annotation to the method. For example: @Trace(dispatcher = true) public static void createAndSend(KafkaProducer<String, String> producer){ ProducerRecord<String, String> data = new ProducerRecord<String, String>(\"topic\", \"key\", \"value\"); producer.send(data); } Copy 3. Instrument the Kafka consumer To instrument your Kafka consumer, you'll need to start a transaction when the message is being processed. The agent stores the distributed tracing payload header under the newrelic key. Retrieve the header, then call the New Relic transaction API to accept the payload. For example: @Trace(dispatcher = true) private static void processMessage(ConsumerRecord<String, String> rec){ Iterable<Header> headers = rec.headers().headers(\"newrelic\"); for(Header header: headers) { NewRelic.getAgent().getTransaction().acceptDistributedTracePayload(new String(header.value(), StandardCharsets.UTF_8)); } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.16709,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em>: <em>Instrument</em> Kafka message queues",
        "sections": "<em>Java</em> <em>agent</em>: <em>Instrument</em> Kafka message queues",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " three types of Kafka data: Kafka metrics Kafka events Kafka distributed traces Kafka <em>instrumentation</em> is available in <em>Java</em> <em>agent</em> versions 4.12.0 or higher. For supported Kafka client versions, see <em>Java</em> compatibility and requirements. Tip For our Kafka integration, see Kafka monitoring integration. View"
      },
      "id": "603ebc2464441f7ce84e8885"
    }
  ],
  "/docs/agents/java-agent/instrumentation/transaction-naming-protocol": [
    {
      "sections": [
        "Extension and additional instrumentation modules",
        "Tip",
        "Install extension modules",
        "Feature extension modules",
        "Class Histogram",
        "Incubator instrumentation modules",
        "Apache Camel 2.12",
        "C3P0 database connection pools",
        "Coda Hale's Metrics 2",
        "Coda Hale's Metrics 3",
        "HikariCP 2.3.0 - 2.3.8",
        "HikariCP 2.4.0 or higher",
        "Lettuce 4.0 - 5.0",
        "Lettuce 5.0 or higher",
        "Ratpack 1.4.0 or higher",
        "Ratpack Http Client 1.4.0 or higher",
        "Archived instrumentation modules",
        "Akka [2.0]",
        "Akka [2.1]",
        "Akka HTTP [1.0]",
        "Akka HTTP [2.0 – 2.4.1]",
        "Akka HTTP [2.4.2 – 2.4.4]",
        "Hystrix [1.0.2 – 1.1.7]",
        "Hystrix [1.2.0 – 1.2.18]",
        "Hystrix [1.3.0 – 1.3.13]",
        "Play [2.0]",
        "Play [2.1]",
        "Play [2.2]",
        "Solr [3.1.0 – 3.4.0]",
        "Solr [3.5.0]",
        "Solr [3.6.0 – 3.6.2]"
      ],
      "title": "Extension and additional instrumentation modules",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Instrumentation"
      ],
      "external_id": "7428cba4d64b06cc620b7407e87f510a3b42905c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/instrumentation/extension-additional-instrumentation-modules/",
      "published_at": "2021-05-05T07:02:44Z",
      "updated_at": "2021-03-16T14:49:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Java agent is a fully-featured library that automatically collects data from many popular servers, frameworks, libraries, and datastores (for a full list, see Compatibility and requirements). It also has a significant feature set. However, there are always additional requests for functionality and instrumentation of new libraries. The Java agent provides extension modules for this purpose. Extension modules fall into three general categories: Incubator instrumentation modules: Experimental new support to collect data from specific libraries Archived instrumentation modules: Instrumentation for libraries that the original company or author no longer maintains or updates. Feature extension modules: Code that adds new behavior to the agent, independent of any specific library. If your library isn't covered by the automatic instrumentation or by an instrumentation module, you can still collect data with custom instrumentation. Tip If you have feedback, questions, or problems with this instrumentation, create a post in New Relic's Explorers Hub, and tag your post with java_incubator. Install extension modules We recommend updating to the latest Java agent version before installing an extension module. To install an extension module: Download the appropriate .jar file from module lists below. Locate the directory that contains your newrelic.jar and newrelic.yml files. In that directory, create a sub-directory named extensions (if there is not already one there). Copy the .jar extension module you downloaded into the extensions directory. For Feature extension modules, update your newrelic.yml with feature-specific configuration. Restart your server. Send some traffic to the server or host that will exercise the feature or instrumentation. Tip Java agent extension modules are subject to the New Relic Java agent licenses, which are included in each module jar's LICENSE file. Feature extension modules Extension modules are additional libraries that add commonly-requested functionality. To use the an extension module, download it and put it in the Extensions Directory. Class Histogram Download link Download the module The Class Histogram extension runs jmap periodically and generates ClassHistogramRowEvent and ClassHistogramStatsEvent data that you can query and chart. Querying this data can be useful when troubleshooting memory leaks as you can see the values over time. You configure the Class Histogram extension the same way you configure the Java agent: using environment variables, system properties, or newrelic.yml. Here are available properties, with defaults: extensions: class_histogram: enabled: true # true is the default if the extension is present classes_per_histogram: 50 # 50 is the default, and memory leak issues are usually in the highest 50 classes by bytes jmap_path: /your/jdk/bin # The folder where the jmap binary lives. The default is $JAVA_HOME/bin. delay_between_calls_seconds: 60 # Length of the delay between executions to avoid frequent pauses Copy Incubator instrumentation modules Incubator modules are experimental instrumentation, which we may build into the agent's automatic instrumentation in the future. These are the incubator modules that are currently available: Apache Camel 2.12 Download link Download the module This instrumentation module intercepts the following: org.apache.camel.component.http.CamelServlet.resolve Copy To name the transaction so that web transactions have a finer grained name than the Camel servlet name, it uses this: org.apache.camel.component.http.HttpConsumer.getPath() Copy To view the bytecode, use this terminal command: javap -verbose -cp camel-2.12-FILENAME.jar org.apache.camel.component.http.CamelServlet Copy C3P0 database connection pools Download link Download the module Java agent version 3.12.0 or higher This instrumentation module samples C3P0 connection pools and reports busy and idle counts in metrics that start with this: Custom/Database Connection/C3P0/METRIC_NAME Copy You can view the metrics with the metric explorer. Coda Hale's Metrics 2 Download link Download the module This instrumentation module integrates with the MetricRegistry and begins sampling the registered metrics every minute. Reported metrics are prefixed with this: Custom/CodaHale/Metrics2/METRIC_NAME Copy You can view the metrics with the metric explorer. Coda Hale's Metrics 3 Download link Download the module This instrumentation module integrates with the MetricRegistry and begins sampling the registered metrics every minute. Reported metrics are prefixed with this: Custom/CodaHale/Metrics3/METRIC_NAME Copy You can view the metrics with the metric explorer. HikariCP 2.3.0 - 2.3.8 Download link Download the module Java agent version 3.12.0 or higher This instrumentation module samples HikariCP database connection pools and reports busy and idle counts in metrics that start with this: Custom/Database Connection/HikariCP/METRIC_NAME Copy You can view the metrics with the metric explorer. HikariCP 2.4.0 or higher Download link Download the module Java agent version 3.12.0 or higher This instrumentation module samples HikariCP database connection pools and reports busy and idle counts in metrics that start with this: Custom/Database Connection/HikariCP/METRIC_NAME Copy You can view the metrics with the metric explorer. Lettuce 4.0 - 5.0 Download link Download the module Java agent version 5.8.0 or higher This instrumentation package instruments the Lettuce 4.x Redis driver. It enables calls to Redis to show up as datastore calls. Lettuce 5.0 or higher Download link Download the module Java agent version 5.8.0 or higher This instrumentation package instruments the Lettuce 5.x Redis driver. It enables calls to Redis to show up as datastore calls. Ratpack 1.4.0 or higher Download link Download the module Java agent version 3.29 or higher This instrumentation module adds support for async linking of Ratpack's execution primitives. It also monitors handler execution. You must name the transactions manually by using the Java agent API. Ratpack Http Client 1.4.0 or higher Download link Download the module This instrumentation captures Ratpack's HTTP client requests and responses. Archived instrumentation modules Archived modules are instrumentation for libraries that are no longer maintained by the original company or author. Because the target library isn't being updated, our support for archived modules has designated end dates. These are the archived modules that are currently available: Akka [2.0] Download link Download the module Java agent version 3.22.1 or higher Support ends on December 2019 This module provides link instrumentation between actors that send and receive messages. It also traces messages broadcast by or forwarded to actors. In order to avoid over-instrumentation, this instrumentation does not start transactions. If you would like a given actor call to mark the beginning of a transaction, use the @Trace(dispatcher=true) annotation, or some other form of custom instrumentation. Akka [2.1] Download link Download the module Java agent version 3.22.1 or higher Support ends on December 2019 This module provides link instrumentation between actors that send and receive messages. It also traces messages broadcast by or forwarded to actors. In order to avoid over-instrumentation, this instrumentation does not start transactions. If you would like a given actor call to mark the beginning of a transaction, use the @Trace(dispatcher=true) annotation, or some other form of custom instrumentation. Akka HTTP [1.0] Download link Download the module Java agent version 3.24.1 or higher Support ends on December 2019 This module creates transactions from Akka HTTP calls. It also instruments hand-offs between Akka actors, and calls from Akka to other databases and services. For calling systems, this instrumentation collects cross application traces. If you're using a supported Akka version, you can view activity from your Akka HTTP apps from transactions all the way through your actor systems. Akka HTTP [2.0 – 2.4.1] Download link Download the module Java agent version 3.24.1 or higher Support ends on December 2019 This module creates transactions from Akka HTTP calls. It also instruments hand-offs between Akka actors, and calls from Akka to other databases and services. For calling systems, this instrumentation collects cross application traces. If you're using a supported Akka version, you can view activity from your Akka HTTP apps from transactions all the way through your actor systems. Akka HTTP [2.4.2 – 2.4.4] Download link Download the module Java agent version 3.24.1 or higher Support ends on December 2019 This module creates transactions from Akka HTTP calls. It also instruments hand-offs between Akka actors, and calls from Akka to other databases and services. For calling systems, this instrumentation collects cross application traces. You can use this instrumentation together with our built previously released support for Akka, to view activity from your Akka HTTP apps from transactions all the way through to your actor systems. Hystrix [1.0.2 – 1.1.7] Download link Download the module Java agent version 3.23.0 or higher Support ends on December 2019 This module provides timing information related to each Hystrix command. The agent will link chained Hystrix commands into one transaction. Hystrix [1.2.0 – 1.2.18] Download link Download the module Java agent version 3.23.0 or higher Support ends on December 2019 This module provides timing information related to each Hystrix command. The agent will link chained Hystrix commands into one transaction. Hystrix [1.3.0 – 1.3.13] Download link Download the module Java agent version 3.23.0 or higher Support ends on December 2019 This module provides timing information related to each Hystrix command. The agent will link chained Hystrix commands into one transaction. Play [2.0] Download link Download the module Java agent version 3.24.1 or higher Support ends on December 2019 This module creates and names transactions based on your Play controller classes. Play [2.1] Download link Download the module Java agent version 3.24.1 or higher Support ends on December 2019 This module creates and names transactions based on your Play controller classes. Play [2.2] Download link Download the module Java agent version 3.24.1 or higher Support ends on December 2019 This module creates and names transactions based on your Play controller classes. Solr [3.1.0 – 3.4.0] Download link Download the module Java agent version 3.34.0 or higher Support ends on December 2019 This module instruments database calls to Solr servers, and collects detailed information about the Solr server itself. It also provides the database server and database name for the queries displayed in transaction traces and slow query traces. Solr [3.5.0] Download link Download the module Java agent version 3.34.0 or higher Support ends on December 2019 This module instruments database calls to Solr servers, and collects detailed information about the Solr server itself. It also provides the database server and database name for the queries displayed in transaction traces and slow query traces. Solr [3.6.0 – 3.6.2] Download link Download the module Java agent version 3.34.0 or higher Support ends on December 2019 This module instruments database calls to Solr servers, and collects detailed information about the Solr server itself. It also provides the database server and database name for the queries displayed in transaction traces and slow query traces.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.16783,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Extension and additional <em>instrumentation</em> modules",
        "sections": "Extension and additional <em>instrumentation</em> modules",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " and <em>instrumentation</em> of new libraries. The <em>Java</em> <em>agent</em> provides extension modules for this purpose. Extension modules fall into three general categories: Incubator <em>instrumentation</em> modules: Experimental new support to collect data from specific libraries Archived <em>instrumentation</em> modules"
      },
      "id": "603eb6b5e7b9d293c92a07eb"
    },
    {
      "sections": [
        "Ignore specific transactions",
        "Important",
        "Ignore web transactions with ServletRequest",
        "Ignore transactions with annotation",
        "Ignore apdex but not traces"
      ],
      "title": "Ignore specific transactions",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Instrumentation"
      ],
      "external_id": "030d29891f4c8ad625a3eb46adca8f371add7adc",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/instrumentation/ignore-transactions-using-api/",
      "published_at": "2021-05-05T07:02:42Z",
      "updated_at": "2021-03-16T14:48:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic for Java gives you multiple methods to ignore specific transactions. This document explains how to use the Java agent API annotations and ServletRequest to ignore transactions. It is also possible to use the ignoreTransaction() API call and XML instrumentation files to ignore transactions. Important Ignoring transactions involves changing your application's source code and recompiling your application in all cases unless you use an XML instrumentation file. If you cannot manipulate your code, use XML to ignore transactions. Ignore web transactions with ServletRequest To ignore a web transaction, set a ServletRequest attribute named com.newrelic.agent.IGNORE to true during the request: request.setAttribute(\"com.newrelic.agent.IGNORE\", true); Copy To specify URLs to ignore, create a servlet filter which sets that attribute and apply the filter to the servlet you want to ignore. The filter will have access to the request URI if you need to ignore specific URLs. Ignore transactions with annotation To tell the Java agent to ignore transactions using annotations: Define an annotation called NewRelicIgnoreTransaction in your application's code or a library you can integrate with your application: @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface NewRelicIgnoreTransaction { } Copy Apply the annotation to the methods or classes you want to ignore. For example: @NewRelicIgnoreTransaction public void methodToBeIgnored() { } Copy If a transaction calls a method or class annotated with @NewRelicIgnoreTransaction, the transaction is ignored. This means it does not contribute to the overall Apdex score; and the transaction trace and performance data is not reported. Ignore apdex but not traces You can also prevent the transaction from contributing to the Apdex score but still be used in transaction. This can prevent one particularly lengthy transaction from skewing your Apdex score. To prevent a transaction from contributing to your Apdex score: Define an annotation called NewRelicIgnoreApdex in your application's code or a library you can integrate with your application: @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface NewRelicIgnoreApdex { } Copy Apply the annotation to the methods or classes you want to ignore. For example: @NewRelicIgnoreApdex public void ignoreApdexOfThisMethod() { } Copy If a transaction calls a method or class annotated with @NewRelicIgnoreApdex, the transaction is reported, but does not contribute to the overall Apdex score.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.16759,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "New Relic for <em>Java</em> gives you multiple methods to ignore specific transactions. This document explains how to use the <em>Java</em> <em>agent</em> API annotations and ServletRequest to ignore transactions. It is also possible to use the ignoreTransaction() API call and XML <em>instrumentation</em> files to ignore transactions"
      },
      "id": "603eb7db64441f3cf84e8841"
    },
    {
      "sections": [
        "Java agent: Instrument Kafka message queues",
        "Tip",
        "View Kafka metrics",
        "Enable Kafka event collection",
        "Important",
        "Enable Kafka distributed traces",
        "1. Enable distributed tracing in the config file",
        "2. Instrument the Kafka producer",
        "3. Instrument the Kafka consumer"
      ],
      "title": "Java agent: Instrument Kafka message queues",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Instrumentation"
      ],
      "external_id": "05644cd866713698034d5419961a40af31d06b90",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/instrumentation/java-agent-instrument-kafka-message-queues/",
      "published_at": "2021-05-05T07:06:37Z",
      "updated_at": "2021-03-16T14:45:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent automatically collects data from Kafka's Java clients library. Because Kafka is a high-performance messaging system that generates a lot of data, you can customize the agent for your app's specific throughput and use cases. This document explains how to collect and view three types of Kafka data: Kafka metrics Kafka events Kafka distributed traces Kafka instrumentation is available in Java agent versions 4.12.0 or higher. For supported Kafka client versions, see Java compatibility and requirements. Tip For our Kafka integration, see Kafka monitoring integration. View Kafka metrics After installation, the agent automatically reports rich Kafka metrics with information about messaging rates, latency, lag, and more. The Java agent collects all Kafka consumer and producer metrics (but not connect or stream metrics). To view these metrics, create a custom dashboard: Go to the New Relic metric explorer. Use the metric explorer to locate your metrics. You can find Kafka metrics in this metric folder: MessageBroker/Kafka/Internal/KafkaMetricName Copy For example, the request-rate metric is located at: MessageBroker/Kafka/Internal/consumer-metrics/request-rate Copy Tip For a full list of Kafka consumer and producer metrics, see the Kafka documentation. Add the metrics you want to monitor to a dashboard by clicking Add to dashboard. Enable Kafka event collection You can configure the agent to collect event data instead of metric timeslice data (for the difference between metric timeslice and event data, see data collection). This allows you to use NRQL to filter and facet the default Kafka metrics. When enabled, the agent collects one Kafka event every 30 seconds. This event contains all of the the data from Kafka consumer and produce metrics captured since the previous event. Important The agent records up to 2000 events per harvest cycle, though you can change this value with max_samples_stored. Kafka event data is included in this pool. If you use the recordCustomEvent() API call to send custom events to New Relic and you send more than 2000 events, the agent will discard some Kafka or custom events. To enable Kafka event collection: Add the kafka.metrics.as_events.enabled element to your newrelic.yml config file: kafka.metrics.as_events.enabled: true Copy Restart your JVM. Use the event explorer to view your Kafka events, located in the KafkaMetrics event type. Or, use NRQL to query your events directly. For example: SELECT average('producer-metrics.record-send-rate') from KafkaMetrics SINCE 30 minutes ago timeseries Copy Enable Kafka distributed traces The Java agent can also collect distributed traces from Kafka clients. Enabling traces doesn't affect the agent's normal operations: it will still report metric or event data from Kafka. Impacts and requirements to consider before enabling: The instrumentation adds a 150 to 200 byte payload to message headers. If your Kafka messages are very small, traces can add significant processing and storage overhead. This additional payload size could cause Kafka to drop messages if they exceed your Kafka messaging size limit. For this reason, we recommend testing out Kafka distributed traces in a dev environment before enabling them in production. Distributed tracing is only available for Kafka client versions 0.11.0.0 or higher. If you have not enabled distributed tracing for your app before, read the Transition guide before enabling. To propagate W3C trace context via Kafka message headers, see the distributed tracing API usage guide for details on APIs that were released in Java agent 6.4.0. Note that adding additional headers to Kafka messages will further increase the payload size. To see these APIs in action, see Using Java agent trace APIs with Kafka. The complete process of enabling this is below but at a high level it involves these basic steps: 1) enable tracing via the agent config, and 2) calling the Java agent API to instrument transactions on both the producer and consumer side. To collect distributed traces from Kafka: 1. Enable distributed tracing in the config file If you have not enabled distributed tracing for your app before, read the distributed tracing transition guide before you enable it. To enable Kafka distributed tracings, enable two settings in your newrelic.yml config file: Set the distributed_tracing element to true: distributed_tracing: enabled: true Copy Enable the Kafka-specific distributed tracing features by adding the following to your config file: class_transformer: kafka-clients-spans: enabled: true Copy 2. Instrument the Kafka producer To instrument your Kafka producer, you'll need to start a transaction before any calls to Producer.send(ProducerRecord<K, V> record). To do this, add the Java agent @Trace(dispatcher = true) annotation to the method. For example: @Trace(dispatcher = true) public static void createAndSend(KafkaProducer<String, String> producer){ ProducerRecord<String, String> data = new ProducerRecord<String, String>(\"topic\", \"key\", \"value\"); producer.send(data); } Copy 3. Instrument the Kafka consumer To instrument your Kafka consumer, you'll need to start a transaction when the message is being processed. The agent stores the distributed tracing payload header under the newrelic key. Retrieve the header, then call the New Relic transaction API to accept the payload. For example: @Trace(dispatcher = true) private static void processMessage(ConsumerRecord<String, String> rec){ Iterable<Header> headers = rec.headers().headers(\"newrelic\"); for(Header header: headers) { NewRelic.getAgent().getTransaction().acceptDistributedTracePayload(new String(header.value(), StandardCharsets.UTF_8)); } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.16709,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em>: <em>Instrument</em> Kafka message queues",
        "sections": "<em>Java</em> <em>agent</em>: <em>Instrument</em> Kafka message queues",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " three types of Kafka data: Kafka metrics Kafka events Kafka distributed traces Kafka <em>instrumentation</em> is available in <em>Java</em> <em>agent</em> versions 4.12.0 or higher. For supported Kafka client versions, see <em>Java</em> compatibility and requirements. Tip For our Kafka integration, see Kafka monitoring integration. View"
      },
      "id": "603ebc2464441f7ce84e8885"
    }
  ],
  "/docs/agents/java-agent/instrumentation/use-rabbitmq-or-jms-message-queues": [
    {
      "sections": [
        "Extension and additional instrumentation modules",
        "Tip",
        "Install extension modules",
        "Feature extension modules",
        "Class Histogram",
        "Incubator instrumentation modules",
        "Apache Camel 2.12",
        "C3P0 database connection pools",
        "Coda Hale's Metrics 2",
        "Coda Hale's Metrics 3",
        "HikariCP 2.3.0 - 2.3.8",
        "HikariCP 2.4.0 or higher",
        "Lettuce 4.0 - 5.0",
        "Lettuce 5.0 or higher",
        "Ratpack 1.4.0 or higher",
        "Ratpack Http Client 1.4.0 or higher",
        "Archived instrumentation modules",
        "Akka [2.0]",
        "Akka [2.1]",
        "Akka HTTP [1.0]",
        "Akka HTTP [2.0 – 2.4.1]",
        "Akka HTTP [2.4.2 – 2.4.4]",
        "Hystrix [1.0.2 – 1.1.7]",
        "Hystrix [1.2.0 – 1.2.18]",
        "Hystrix [1.3.0 – 1.3.13]",
        "Play [2.0]",
        "Play [2.1]",
        "Play [2.2]",
        "Solr [3.1.0 – 3.4.0]",
        "Solr [3.5.0]",
        "Solr [3.6.0 – 3.6.2]"
      ],
      "title": "Extension and additional instrumentation modules",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Instrumentation"
      ],
      "external_id": "7428cba4d64b06cc620b7407e87f510a3b42905c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/instrumentation/extension-additional-instrumentation-modules/",
      "published_at": "2021-05-05T07:02:44Z",
      "updated_at": "2021-03-16T14:49:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Java agent is a fully-featured library that automatically collects data from many popular servers, frameworks, libraries, and datastores (for a full list, see Compatibility and requirements). It also has a significant feature set. However, there are always additional requests for functionality and instrumentation of new libraries. The Java agent provides extension modules for this purpose. Extension modules fall into three general categories: Incubator instrumentation modules: Experimental new support to collect data from specific libraries Archived instrumentation modules: Instrumentation for libraries that the original company or author no longer maintains or updates. Feature extension modules: Code that adds new behavior to the agent, independent of any specific library. If your library isn't covered by the automatic instrumentation or by an instrumentation module, you can still collect data with custom instrumentation. Tip If you have feedback, questions, or problems with this instrumentation, create a post in New Relic's Explorers Hub, and tag your post with java_incubator. Install extension modules We recommend updating to the latest Java agent version before installing an extension module. To install an extension module: Download the appropriate .jar file from module lists below. Locate the directory that contains your newrelic.jar and newrelic.yml files. In that directory, create a sub-directory named extensions (if there is not already one there). Copy the .jar extension module you downloaded into the extensions directory. For Feature extension modules, update your newrelic.yml with feature-specific configuration. Restart your server. Send some traffic to the server or host that will exercise the feature or instrumentation. Tip Java agent extension modules are subject to the New Relic Java agent licenses, which are included in each module jar's LICENSE file. Feature extension modules Extension modules are additional libraries that add commonly-requested functionality. To use the an extension module, download it and put it in the Extensions Directory. Class Histogram Download link Download the module The Class Histogram extension runs jmap periodically and generates ClassHistogramRowEvent and ClassHistogramStatsEvent data that you can query and chart. Querying this data can be useful when troubleshooting memory leaks as you can see the values over time. You configure the Class Histogram extension the same way you configure the Java agent: using environment variables, system properties, or newrelic.yml. Here are available properties, with defaults: extensions: class_histogram: enabled: true # true is the default if the extension is present classes_per_histogram: 50 # 50 is the default, and memory leak issues are usually in the highest 50 classes by bytes jmap_path: /your/jdk/bin # The folder where the jmap binary lives. The default is $JAVA_HOME/bin. delay_between_calls_seconds: 60 # Length of the delay between executions to avoid frequent pauses Copy Incubator instrumentation modules Incubator modules are experimental instrumentation, which we may build into the agent's automatic instrumentation in the future. These are the incubator modules that are currently available: Apache Camel 2.12 Download link Download the module This instrumentation module intercepts the following: org.apache.camel.component.http.CamelServlet.resolve Copy To name the transaction so that web transactions have a finer grained name than the Camel servlet name, it uses this: org.apache.camel.component.http.HttpConsumer.getPath() Copy To view the bytecode, use this terminal command: javap -verbose -cp camel-2.12-FILENAME.jar org.apache.camel.component.http.CamelServlet Copy C3P0 database connection pools Download link Download the module Java agent version 3.12.0 or higher This instrumentation module samples C3P0 connection pools and reports busy and idle counts in metrics that start with this: Custom/Database Connection/C3P0/METRIC_NAME Copy You can view the metrics with the metric explorer. Coda Hale's Metrics 2 Download link Download the module This instrumentation module integrates with the MetricRegistry and begins sampling the registered metrics every minute. Reported metrics are prefixed with this: Custom/CodaHale/Metrics2/METRIC_NAME Copy You can view the metrics with the metric explorer. Coda Hale's Metrics 3 Download link Download the module This instrumentation module integrates with the MetricRegistry and begins sampling the registered metrics every minute. Reported metrics are prefixed with this: Custom/CodaHale/Metrics3/METRIC_NAME Copy You can view the metrics with the metric explorer. HikariCP 2.3.0 - 2.3.8 Download link Download the module Java agent version 3.12.0 or higher This instrumentation module samples HikariCP database connection pools and reports busy and idle counts in metrics that start with this: Custom/Database Connection/HikariCP/METRIC_NAME Copy You can view the metrics with the metric explorer. HikariCP 2.4.0 or higher Download link Download the module Java agent version 3.12.0 or higher This instrumentation module samples HikariCP database connection pools and reports busy and idle counts in metrics that start with this: Custom/Database Connection/HikariCP/METRIC_NAME Copy You can view the metrics with the metric explorer. Lettuce 4.0 - 5.0 Download link Download the module Java agent version 5.8.0 or higher This instrumentation package instruments the Lettuce 4.x Redis driver. It enables calls to Redis to show up as datastore calls. Lettuce 5.0 or higher Download link Download the module Java agent version 5.8.0 or higher This instrumentation package instruments the Lettuce 5.x Redis driver. It enables calls to Redis to show up as datastore calls. Ratpack 1.4.0 or higher Download link Download the module Java agent version 3.29 or higher This instrumentation module adds support for async linking of Ratpack's execution primitives. It also monitors handler execution. You must name the transactions manually by using the Java agent API. Ratpack Http Client 1.4.0 or higher Download link Download the module This instrumentation captures Ratpack's HTTP client requests and responses. Archived instrumentation modules Archived modules are instrumentation for libraries that are no longer maintained by the original company or author. Because the target library isn't being updated, our support for archived modules has designated end dates. These are the archived modules that are currently available: Akka [2.0] Download link Download the module Java agent version 3.22.1 or higher Support ends on December 2019 This module provides link instrumentation between actors that send and receive messages. It also traces messages broadcast by or forwarded to actors. In order to avoid over-instrumentation, this instrumentation does not start transactions. If you would like a given actor call to mark the beginning of a transaction, use the @Trace(dispatcher=true) annotation, or some other form of custom instrumentation. Akka [2.1] Download link Download the module Java agent version 3.22.1 or higher Support ends on December 2019 This module provides link instrumentation between actors that send and receive messages. It also traces messages broadcast by or forwarded to actors. In order to avoid over-instrumentation, this instrumentation does not start transactions. If you would like a given actor call to mark the beginning of a transaction, use the @Trace(dispatcher=true) annotation, or some other form of custom instrumentation. Akka HTTP [1.0] Download link Download the module Java agent version 3.24.1 or higher Support ends on December 2019 This module creates transactions from Akka HTTP calls. It also instruments hand-offs between Akka actors, and calls from Akka to other databases and services. For calling systems, this instrumentation collects cross application traces. If you're using a supported Akka version, you can view activity from your Akka HTTP apps from transactions all the way through your actor systems. Akka HTTP [2.0 – 2.4.1] Download link Download the module Java agent version 3.24.1 or higher Support ends on December 2019 This module creates transactions from Akka HTTP calls. It also instruments hand-offs between Akka actors, and calls from Akka to other databases and services. For calling systems, this instrumentation collects cross application traces. If you're using a supported Akka version, you can view activity from your Akka HTTP apps from transactions all the way through your actor systems. Akka HTTP [2.4.2 – 2.4.4] Download link Download the module Java agent version 3.24.1 or higher Support ends on December 2019 This module creates transactions from Akka HTTP calls. It also instruments hand-offs between Akka actors, and calls from Akka to other databases and services. For calling systems, this instrumentation collects cross application traces. You can use this instrumentation together with our built previously released support for Akka, to view activity from your Akka HTTP apps from transactions all the way through to your actor systems. Hystrix [1.0.2 – 1.1.7] Download link Download the module Java agent version 3.23.0 or higher Support ends on December 2019 This module provides timing information related to each Hystrix command. The agent will link chained Hystrix commands into one transaction. Hystrix [1.2.0 – 1.2.18] Download link Download the module Java agent version 3.23.0 or higher Support ends on December 2019 This module provides timing information related to each Hystrix command. The agent will link chained Hystrix commands into one transaction. Hystrix [1.3.0 – 1.3.13] Download link Download the module Java agent version 3.23.0 or higher Support ends on December 2019 This module provides timing information related to each Hystrix command. The agent will link chained Hystrix commands into one transaction. Play [2.0] Download link Download the module Java agent version 3.24.1 or higher Support ends on December 2019 This module creates and names transactions based on your Play controller classes. Play [2.1] Download link Download the module Java agent version 3.24.1 or higher Support ends on December 2019 This module creates and names transactions based on your Play controller classes. Play [2.2] Download link Download the module Java agent version 3.24.1 or higher Support ends on December 2019 This module creates and names transactions based on your Play controller classes. Solr [3.1.0 – 3.4.0] Download link Download the module Java agent version 3.34.0 or higher Support ends on December 2019 This module instruments database calls to Solr servers, and collects detailed information about the Solr server itself. It also provides the database server and database name for the queries displayed in transaction traces and slow query traces. Solr [3.5.0] Download link Download the module Java agent version 3.34.0 or higher Support ends on December 2019 This module instruments database calls to Solr servers, and collects detailed information about the Solr server itself. It also provides the database server and database name for the queries displayed in transaction traces and slow query traces. Solr [3.6.0 – 3.6.2] Download link Download the module Java agent version 3.34.0 or higher Support ends on December 2019 This module instruments database calls to Solr servers, and collects detailed information about the Solr server itself. It also provides the database server and database name for the queries displayed in transaction traces and slow query traces.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.16783,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Extension and additional <em>instrumentation</em> modules",
        "sections": "Extension and additional <em>instrumentation</em> modules",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " and <em>instrumentation</em> of new libraries. The <em>Java</em> <em>agent</em> provides extension modules for this purpose. Extension modules fall into three general categories: Incubator <em>instrumentation</em> modules: Experimental new support to collect data from specific libraries Archived <em>instrumentation</em> modules"
      },
      "id": "603eb6b5e7b9d293c92a07eb"
    },
    {
      "sections": [
        "Ignore specific transactions",
        "Important",
        "Ignore web transactions with ServletRequest",
        "Ignore transactions with annotation",
        "Ignore apdex but not traces"
      ],
      "title": "Ignore specific transactions",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Instrumentation"
      ],
      "external_id": "030d29891f4c8ad625a3eb46adca8f371add7adc",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/instrumentation/ignore-transactions-using-api/",
      "published_at": "2021-05-05T07:02:42Z",
      "updated_at": "2021-03-16T14:48:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic for Java gives you multiple methods to ignore specific transactions. This document explains how to use the Java agent API annotations and ServletRequest to ignore transactions. It is also possible to use the ignoreTransaction() API call and XML instrumentation files to ignore transactions. Important Ignoring transactions involves changing your application's source code and recompiling your application in all cases unless you use an XML instrumentation file. If you cannot manipulate your code, use XML to ignore transactions. Ignore web transactions with ServletRequest To ignore a web transaction, set a ServletRequest attribute named com.newrelic.agent.IGNORE to true during the request: request.setAttribute(\"com.newrelic.agent.IGNORE\", true); Copy To specify URLs to ignore, create a servlet filter which sets that attribute and apply the filter to the servlet you want to ignore. The filter will have access to the request URI if you need to ignore specific URLs. Ignore transactions with annotation To tell the Java agent to ignore transactions using annotations: Define an annotation called NewRelicIgnoreTransaction in your application's code or a library you can integrate with your application: @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface NewRelicIgnoreTransaction { } Copy Apply the annotation to the methods or classes you want to ignore. For example: @NewRelicIgnoreTransaction public void methodToBeIgnored() { } Copy If a transaction calls a method or class annotated with @NewRelicIgnoreTransaction, the transaction is ignored. This means it does not contribute to the overall Apdex score; and the transaction trace and performance data is not reported. Ignore apdex but not traces You can also prevent the transaction from contributing to the Apdex score but still be used in transaction. This can prevent one particularly lengthy transaction from skewing your Apdex score. To prevent a transaction from contributing to your Apdex score: Define an annotation called NewRelicIgnoreApdex in your application's code or a library you can integrate with your application: @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface NewRelicIgnoreApdex { } Copy Apply the annotation to the methods or classes you want to ignore. For example: @NewRelicIgnoreApdex public void ignoreApdexOfThisMethod() { } Copy If a transaction calls a method or class annotated with @NewRelicIgnoreApdex, the transaction is reported, but does not contribute to the overall Apdex score.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.16759,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "New Relic for <em>Java</em> gives you multiple methods to ignore specific transactions. This document explains how to use the <em>Java</em> <em>agent</em> API annotations and ServletRequest to ignore transactions. It is also possible to use the ignoreTransaction() API call and XML <em>instrumentation</em> files to ignore transactions"
      },
      "id": "603eb7db64441f3cf84e8841"
    },
    {
      "sections": [
        "Java agent: Instrument Kafka message queues",
        "Tip",
        "View Kafka metrics",
        "Enable Kafka event collection",
        "Important",
        "Enable Kafka distributed traces",
        "1. Enable distributed tracing in the config file",
        "2. Instrument the Kafka producer",
        "3. Instrument the Kafka consumer"
      ],
      "title": "Java agent: Instrument Kafka message queues",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Instrumentation"
      ],
      "external_id": "05644cd866713698034d5419961a40af31d06b90",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/instrumentation/java-agent-instrument-kafka-message-queues/",
      "published_at": "2021-05-05T07:06:37Z",
      "updated_at": "2021-03-16T14:45:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent automatically collects data from Kafka's Java clients library. Because Kafka is a high-performance messaging system that generates a lot of data, you can customize the agent for your app's specific throughput and use cases. This document explains how to collect and view three types of Kafka data: Kafka metrics Kafka events Kafka distributed traces Kafka instrumentation is available in Java agent versions 4.12.0 or higher. For supported Kafka client versions, see Java compatibility and requirements. Tip For our Kafka integration, see Kafka monitoring integration. View Kafka metrics After installation, the agent automatically reports rich Kafka metrics with information about messaging rates, latency, lag, and more. The Java agent collects all Kafka consumer and producer metrics (but not connect or stream metrics). To view these metrics, create a custom dashboard: Go to the New Relic metric explorer. Use the metric explorer to locate your metrics. You can find Kafka metrics in this metric folder: MessageBroker/Kafka/Internal/KafkaMetricName Copy For example, the request-rate metric is located at: MessageBroker/Kafka/Internal/consumer-metrics/request-rate Copy Tip For a full list of Kafka consumer and producer metrics, see the Kafka documentation. Add the metrics you want to monitor to a dashboard by clicking Add to dashboard. Enable Kafka event collection You can configure the agent to collect event data instead of metric timeslice data (for the difference between metric timeslice and event data, see data collection). This allows you to use NRQL to filter and facet the default Kafka metrics. When enabled, the agent collects one Kafka event every 30 seconds. This event contains all of the the data from Kafka consumer and produce metrics captured since the previous event. Important The agent records up to 2000 events per harvest cycle, though you can change this value with max_samples_stored. Kafka event data is included in this pool. If you use the recordCustomEvent() API call to send custom events to New Relic and you send more than 2000 events, the agent will discard some Kafka or custom events. To enable Kafka event collection: Add the kafka.metrics.as_events.enabled element to your newrelic.yml config file: kafka.metrics.as_events.enabled: true Copy Restart your JVM. Use the event explorer to view your Kafka events, located in the KafkaMetrics event type. Or, use NRQL to query your events directly. For example: SELECT average('producer-metrics.record-send-rate') from KafkaMetrics SINCE 30 minutes ago timeseries Copy Enable Kafka distributed traces The Java agent can also collect distributed traces from Kafka clients. Enabling traces doesn't affect the agent's normal operations: it will still report metric or event data from Kafka. Impacts and requirements to consider before enabling: The instrumentation adds a 150 to 200 byte payload to message headers. If your Kafka messages are very small, traces can add significant processing and storage overhead. This additional payload size could cause Kafka to drop messages if they exceed your Kafka messaging size limit. For this reason, we recommend testing out Kafka distributed traces in a dev environment before enabling them in production. Distributed tracing is only available for Kafka client versions 0.11.0.0 or higher. If you have not enabled distributed tracing for your app before, read the Transition guide before enabling. To propagate W3C trace context via Kafka message headers, see the distributed tracing API usage guide for details on APIs that were released in Java agent 6.4.0. Note that adding additional headers to Kafka messages will further increase the payload size. To see these APIs in action, see Using Java agent trace APIs with Kafka. The complete process of enabling this is below but at a high level it involves these basic steps: 1) enable tracing via the agent config, and 2) calling the Java agent API to instrument transactions on both the producer and consumer side. To collect distributed traces from Kafka: 1. Enable distributed tracing in the config file If you have not enabled distributed tracing for your app before, read the distributed tracing transition guide before you enable it. To enable Kafka distributed tracings, enable two settings in your newrelic.yml config file: Set the distributed_tracing element to true: distributed_tracing: enabled: true Copy Enable the Kafka-specific distributed tracing features by adding the following to your config file: class_transformer: kafka-clients-spans: enabled: true Copy 2. Instrument the Kafka producer To instrument your Kafka producer, you'll need to start a transaction before any calls to Producer.send(ProducerRecord<K, V> record). To do this, add the Java agent @Trace(dispatcher = true) annotation to the method. For example: @Trace(dispatcher = true) public static void createAndSend(KafkaProducer<String, String> producer){ ProducerRecord<String, String> data = new ProducerRecord<String, String>(\"topic\", \"key\", \"value\"); producer.send(data); } Copy 3. Instrument the Kafka consumer To instrument your Kafka consumer, you'll need to start a transaction when the message is being processed. The agent stores the distributed tracing payload header under the newrelic key. Retrieve the header, then call the New Relic transaction API to accept the payload. For example: @Trace(dispatcher = true) private static void processMessage(ConsumerRecord<String, String> rec){ Iterable<Header> headers = rec.headers().headers(\"newrelic\"); for(Header header: headers) { NewRelic.getAgent().getTransaction().acceptDistributedTracePayload(new String(header.value(), StandardCharsets.UTF_8)); } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.16708,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em>: <em>Instrument</em> Kafka message queues",
        "sections": "<em>Java</em> <em>agent</em>: <em>Instrument</em> Kafka message queues",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " three types of Kafka data: Kafka metrics Kafka events Kafka distributed traces Kafka <em>instrumentation</em> is available in <em>Java</em> <em>agent</em> versions 4.12.0 or higher. For supported Kafka client versions, see <em>Java</em> compatibility and requirements. Tip For our Kafka integration, see Kafka monitoring integration. View"
      },
      "id": "603ebc2464441f7ce84e8885"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/all-hosts-appear-localhost": [
    {
      "sections": [
        "Generate debug logs for troubleshooting (Java)",
        "Requirements",
        "Generate log files",
        "Examine log files",
        "Important",
        "For more help"
      ],
      "title": "Generate debug logs for troubleshooting (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "9ce3ec94630795156f9effc1f3c07c15a73f8b77",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/generate-debug-logs-troubleshooting-java/",
      "published_at": "2021-05-05T06:58:46Z",
      "updated_at": "2021-03-16T14:48:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When troubleshooting your New Relic Java agent, generate finest logs to find and investigate errors. When finished troubleshooting, be sure to set the log file back to a less verbose setting, such as info. Requirements If you only change the log file setting in your newrelic.yml file, you do not need to restart the server or JVM. However, if you make any other changes, you must restart your server or JVM. Be sure you keep the original line indentation in your newrelic.yml file. YAML is \"space sensitive\" and requires proper indentation. The audit_mode setting (when set to true ) will also log communication between the Java agent and New Relic to the log file. New Relic Support may occasionally request audit mode logs for additional troubleshooting. Generate log files To generate detailed finest log files: Edit your newrelic.yml file, and change the log_level to finest. Be sure to keep these lines indented two spaces. # The agent uses its own log file to keep its logging # separate from that of your application. Specify the log level here. # This setting is dynamic, so changes do not require restarting your application. # The levels in increasing order of verboseness are: # off, severe, warning, info, fine, finer, finest # Default is info. log_level: finest # Log all data sent to and from New Relic in plain text. # This setting is dynamic, so changes do not require restarting your application. # Default is false. audit_mode: false Copy Exercise your web application for about five minutes to generate sufficient logging data. After testing, change the log_level to a less verbose level, such as info (default). Open your log files and examine them for errors. Examine log files Important The finest log setting is a highly verbose logging level. To reduce disk space consumption after testing, return the log_level to its original setting. By default, log files are stored in a logs sub-directory, inside the same directory as newrelic.jar. If necessary, follow the troubleshooting procedures if no log files appear. For more help For logging on all New Relic agents, see New Relic agent logs and troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.562935,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Generate debug logs for <em>troubleshooting</em> (<em>Java</em>)",
        "sections": "Generate debug logs for <em>troubleshooting</em> (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "When <em>troubleshooting</em> your New Relic <em>Java</em> <em>agent</em>, generate finest logs to find and investigate errors. When finished <em>troubleshooting</em>, be sure to set the log file back to a less verbose setting, such as info. Requirements If you only change the log file setting in your newrelic.yml file, you do"
      },
      "id": "603eb64ae7b9d2e15e2a07e7"
    },
    {
      "sections": [
        "SSL or connection errors (Java)",
        "Problem A: SSL/connection errors in logs",
        "Tip",
        "Solution A",
        "Problem B: logs show exception",
        "Solution B"
      ],
      "title": "SSL or connection errors (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "0e5af5c4f29a8e7b75f4c4c61235952f91624fc1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/ssl-or-connection-errors-java/",
      "published_at": "2021-05-05T06:44:58Z",
      "updated_at": "2021-04-05T10:48:22Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem A: SSL/connection errors in logs Your New Relic Java agent's log data shows SSL or connection errors. Tip See Configuring your SSL certificates for instructions on how to communicate with the New Relic collector over HTTPS. Solution A Failures to connect via SSL typically appear early in the Java agent's log files. For example: PKIX path building failed: java.security.cert.CertPathBuilderException: PKIXCertPathBuilderImpl could not build a valid CertPath Copy INFO: connection error: java.net.SocketException: java.lang.ClassNotFoundException: Cannot find the specified class com.ibm.websphere.ssl.protocol.SSLSocketFactory Copy If you see either of these errors, your JDK instance probably is using a customized trust store. Recommendation: Add the DigiCert Global Root Certificate Authority (CA), from which New Relic's certificate is derived, to your trust store. You can download the DigiCert Global Root CA from DigiCert (choose the \"Download PEM\" option). To import the cert to your trust store, use this command, or see Oracle's Java SE documentation for keytool: keytool -importcert -alias ca_alias -file ca_file.pem -keystore truststore.ts -storepass ts_password Copy Parameters include: Parameter Description ca_alias The alias you want to use in your trust store for the imported cert. ca_file The file containing the cert you are adding. truststore.ts The trust store to which the cert will be added. ts_password The password used by truststore.ts. Problem B: logs show exception Your New Relic Java agent's log data shows the following CertificateException. java.security.cert.CertificateException: Could not parse certificate: java.io.IOException: Illegal header: -----BEGIN CERTIFICATE----- Copy This is most likely related to this JDK issue. Solution B Examine and validate that the header and footer of your certificates do not have trailing whitespaces. If they do, edit or use different certificates.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 92.03758,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "SSL or connection errors (<em>Java</em>)",
        "sections": "SSL or connection errors (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Problem A: SSL&#x2F;connection errors in logs Your New Relic <em>Java</em> <em>agent</em>&#x27;s log data shows SSL or connection errors. Tip See Configuring your SSL certificates for instructions on how to communicate with the New Relic collector over HTTPS. Solution A Failures to connect via SSL typically appear early"
      },
      "id": "603e870428ccbc75adeba789"
    },
    {
      "sections": [
        "NullPointerException issues (Java)",
        "Problem",
        "Solution",
        "Cause"
      ],
      "title": "NullPointerException issues (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "63e8344e80548a51ddea70754c273d5c4e2c3a09",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/nullpointerexception-issues-java/",
      "published_at": "2021-05-05T07:06:37Z",
      "updated_at": "2021-03-16T09:15:49Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem If your log data shows SEVERE: or ERROR: with NullPointerException issues, there may be issues that are interfering with reporting. Solution Before you begin these troubleshooting tips, make sure you have the most recent version of New Relic's Java agent. Use case-sensitive searches of your Java agent log file for lines with SEVERE: and ERROR: NullPointerException. If you find any lines with these messages, gather troubleshooting information to get support at New Relic. Cause New Relic's Java agent between versions 3.0.0 and 3.2.3 would incorrectly log the error messages. For example: ERROR: javax/servlet/ServletOutputStream is marked as a weaved class, but no methods are matched to be weaved. Copy This was entirely erroneous and is not a cause for concern. However, do not use these versions. Instead, update to the most recent version of New Relic's Java agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 91.611465,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "NullPointerException issues (<em>Java</em>)",
        "sections": "NullPointerException issues (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Problem If your log data shows SEVERE: or ERROR: with NullPointerException issues, there may be issues that are interfering with reporting. Solution Before you begin these <em>troubleshooting</em> tips, make sure you have the most recent version of New Relic&#x27;s <em>Java</em> <em>agent</em>. Use case-sensitive searches of your"
      },
      "id": "603e869f64441ff9774e889e"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/application-server-jmx-setup": [
    {
      "sections": [
        "Generate debug logs for troubleshooting (Java)",
        "Requirements",
        "Generate log files",
        "Examine log files",
        "Important",
        "For more help"
      ],
      "title": "Generate debug logs for troubleshooting (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "9ce3ec94630795156f9effc1f3c07c15a73f8b77",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/generate-debug-logs-troubleshooting-java/",
      "published_at": "2021-05-05T06:58:46Z",
      "updated_at": "2021-03-16T14:48:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When troubleshooting your New Relic Java agent, generate finest logs to find and investigate errors. When finished troubleshooting, be sure to set the log file back to a less verbose setting, such as info. Requirements If you only change the log file setting in your newrelic.yml file, you do not need to restart the server or JVM. However, if you make any other changes, you must restart your server or JVM. Be sure you keep the original line indentation in your newrelic.yml file. YAML is \"space sensitive\" and requires proper indentation. The audit_mode setting (when set to true ) will also log communication between the Java agent and New Relic to the log file. New Relic Support may occasionally request audit mode logs for additional troubleshooting. Generate log files To generate detailed finest log files: Edit your newrelic.yml file, and change the log_level to finest. Be sure to keep these lines indented two spaces. # The agent uses its own log file to keep its logging # separate from that of your application. Specify the log level here. # This setting is dynamic, so changes do not require restarting your application. # The levels in increasing order of verboseness are: # off, severe, warning, info, fine, finer, finest # Default is info. log_level: finest # Log all data sent to and from New Relic in plain text. # This setting is dynamic, so changes do not require restarting your application. # Default is false. audit_mode: false Copy Exercise your web application for about five minutes to generate sufficient logging data. After testing, change the log_level to a less verbose level, such as info (default). Open your log files and examine them for errors. Examine log files Important The finest log setting is a highly verbose logging level. To reduce disk space consumption after testing, return the log_level to its original setting. By default, log files are stored in a logs sub-directory, inside the same directory as newrelic.jar. If necessary, follow the troubleshooting procedures if no log files appear. For more help For logging on all New Relic agents, see New Relic agent logs and troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.56293,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Generate debug logs for <em>troubleshooting</em> (<em>Java</em>)",
        "sections": "Generate debug logs for <em>troubleshooting</em> (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "When <em>troubleshooting</em> your New Relic <em>Java</em> <em>agent</em>, generate finest logs to find and investigate errors. When finished <em>troubleshooting</em>, be sure to set the log file back to a less verbose setting, such as info. Requirements If you only change the log file setting in your newrelic.yml file, you do"
      },
      "id": "603eb64ae7b9d2e15e2a07e7"
    },
    {
      "sections": [
        "SSL or connection errors (Java)",
        "Problem A: SSL/connection errors in logs",
        "Tip",
        "Solution A",
        "Problem B: logs show exception",
        "Solution B"
      ],
      "title": "SSL or connection errors (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "0e5af5c4f29a8e7b75f4c4c61235952f91624fc1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/ssl-or-connection-errors-java/",
      "published_at": "2021-05-05T06:44:58Z",
      "updated_at": "2021-04-05T10:48:22Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem A: SSL/connection errors in logs Your New Relic Java agent's log data shows SSL or connection errors. Tip See Configuring your SSL certificates for instructions on how to communicate with the New Relic collector over HTTPS. Solution A Failures to connect via SSL typically appear early in the Java agent's log files. For example: PKIX path building failed: java.security.cert.CertPathBuilderException: PKIXCertPathBuilderImpl could not build a valid CertPath Copy INFO: connection error: java.net.SocketException: java.lang.ClassNotFoundException: Cannot find the specified class com.ibm.websphere.ssl.protocol.SSLSocketFactory Copy If you see either of these errors, your JDK instance probably is using a customized trust store. Recommendation: Add the DigiCert Global Root Certificate Authority (CA), from which New Relic's certificate is derived, to your trust store. You can download the DigiCert Global Root CA from DigiCert (choose the \"Download PEM\" option). To import the cert to your trust store, use this command, or see Oracle's Java SE documentation for keytool: keytool -importcert -alias ca_alias -file ca_file.pem -keystore truststore.ts -storepass ts_password Copy Parameters include: Parameter Description ca_alias The alias you want to use in your trust store for the imported cert. ca_file The file containing the cert you are adding. truststore.ts The trust store to which the cert will be added. ts_password The password used by truststore.ts. Problem B: logs show exception Your New Relic Java agent's log data shows the following CertificateException. java.security.cert.CertificateException: Could not parse certificate: java.io.IOException: Illegal header: -----BEGIN CERTIFICATE----- Copy This is most likely related to this JDK issue. Solution B Examine and validate that the header and footer of your certificates do not have trailing whitespaces. If they do, edit or use different certificates.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 92.037575,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "SSL or connection errors (<em>Java</em>)",
        "sections": "SSL or connection errors (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Problem A: SSL&#x2F;connection errors in logs Your New Relic <em>Java</em> <em>agent</em>&#x27;s log data shows SSL or connection errors. Tip See Configuring your SSL certificates for instructions on how to communicate with the New Relic collector over HTTPS. Solution A Failures to connect via SSL typically appear early"
      },
      "id": "603e870428ccbc75adeba789"
    },
    {
      "sections": [
        "NullPointerException issues (Java)",
        "Problem",
        "Solution",
        "Cause"
      ],
      "title": "NullPointerException issues (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "63e8344e80548a51ddea70754c273d5c4e2c3a09",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/nullpointerexception-issues-java/",
      "published_at": "2021-05-05T07:06:37Z",
      "updated_at": "2021-03-16T09:15:49Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem If your log data shows SEVERE: or ERROR: with NullPointerException issues, there may be issues that are interfering with reporting. Solution Before you begin these troubleshooting tips, make sure you have the most recent version of New Relic's Java agent. Use case-sensitive searches of your Java agent log file for lines with SEVERE: and ERROR: NullPointerException. If you find any lines with these messages, gather troubleshooting information to get support at New Relic. Cause New Relic's Java agent between versions 3.0.0 and 3.2.3 would incorrectly log the error messages. For example: ERROR: javax/servlet/ServletOutputStream is marked as a weaved class, but no methods are matched to be weaved. Copy This was entirely erroneous and is not a cause for concern. However, do not use these versions. Instead, update to the most recent version of New Relic's Java agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 91.611465,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "NullPointerException issues (<em>Java</em>)",
        "sections": "NullPointerException issues (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Problem If your log data shows SEVERE: or ERROR: with NullPointerException issues, there may be issues that are interfering with reporting. Solution Before you begin these <em>troubleshooting</em> tips, make sure you have the most recent version of New Relic&#x27;s <em>Java</em> <em>agent</em>. Use case-sensitive searches of your"
      },
      "id": "603e869f64441ff9774e889e"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/determine-permissions-requirements-java": [
    {
      "sections": [
        "Generate debug logs for troubleshooting (Java)",
        "Requirements",
        "Generate log files",
        "Examine log files",
        "Important",
        "For more help"
      ],
      "title": "Generate debug logs for troubleshooting (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "9ce3ec94630795156f9effc1f3c07c15a73f8b77",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/generate-debug-logs-troubleshooting-java/",
      "published_at": "2021-05-05T06:58:46Z",
      "updated_at": "2021-03-16T14:48:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When troubleshooting your New Relic Java agent, generate finest logs to find and investigate errors. When finished troubleshooting, be sure to set the log file back to a less verbose setting, such as info. Requirements If you only change the log file setting in your newrelic.yml file, you do not need to restart the server or JVM. However, if you make any other changes, you must restart your server or JVM. Be sure you keep the original line indentation in your newrelic.yml file. YAML is \"space sensitive\" and requires proper indentation. The audit_mode setting (when set to true ) will also log communication between the Java agent and New Relic to the log file. New Relic Support may occasionally request audit mode logs for additional troubleshooting. Generate log files To generate detailed finest log files: Edit your newrelic.yml file, and change the log_level to finest. Be sure to keep these lines indented two spaces. # The agent uses its own log file to keep its logging # separate from that of your application. Specify the log level here. # This setting is dynamic, so changes do not require restarting your application. # The levels in increasing order of verboseness are: # off, severe, warning, info, fine, finer, finest # Default is info. log_level: finest # Log all data sent to and from New Relic in plain text. # This setting is dynamic, so changes do not require restarting your application. # Default is false. audit_mode: false Copy Exercise your web application for about five minutes to generate sufficient logging data. After testing, change the log_level to a less verbose level, such as info (default). Open your log files and examine them for errors. Examine log files Important The finest log setting is a highly verbose logging level. To reduce disk space consumption after testing, return the log_level to its original setting. By default, log files are stored in a logs sub-directory, inside the same directory as newrelic.jar. If necessary, follow the troubleshooting procedures if no log files appear. For more help For logging on all New Relic agents, see New Relic agent logs and troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.56293,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Generate debug logs for <em>troubleshooting</em> (<em>Java</em>)",
        "sections": "Generate debug logs for <em>troubleshooting</em> (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "When <em>troubleshooting</em> your New Relic <em>Java</em> <em>agent</em>, generate finest logs to find and investigate errors. When finished <em>troubleshooting</em>, be sure to set the log file back to a less verbose setting, such as info. Requirements If you only change the log file setting in your newrelic.yml file, you do"
      },
      "id": "603eb64ae7b9d2e15e2a07e7"
    },
    {
      "sections": [
        "SSL or connection errors (Java)",
        "Problem A: SSL/connection errors in logs",
        "Tip",
        "Solution A",
        "Problem B: logs show exception",
        "Solution B"
      ],
      "title": "SSL or connection errors (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "0e5af5c4f29a8e7b75f4c4c61235952f91624fc1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/ssl-or-connection-errors-java/",
      "published_at": "2021-05-05T06:44:58Z",
      "updated_at": "2021-04-05T10:48:22Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem A: SSL/connection errors in logs Your New Relic Java agent's log data shows SSL or connection errors. Tip See Configuring your SSL certificates for instructions on how to communicate with the New Relic collector over HTTPS. Solution A Failures to connect via SSL typically appear early in the Java agent's log files. For example: PKIX path building failed: java.security.cert.CertPathBuilderException: PKIXCertPathBuilderImpl could not build a valid CertPath Copy INFO: connection error: java.net.SocketException: java.lang.ClassNotFoundException: Cannot find the specified class com.ibm.websphere.ssl.protocol.SSLSocketFactory Copy If you see either of these errors, your JDK instance probably is using a customized trust store. Recommendation: Add the DigiCert Global Root Certificate Authority (CA), from which New Relic's certificate is derived, to your trust store. You can download the DigiCert Global Root CA from DigiCert (choose the \"Download PEM\" option). To import the cert to your trust store, use this command, or see Oracle's Java SE documentation for keytool: keytool -importcert -alias ca_alias -file ca_file.pem -keystore truststore.ts -storepass ts_password Copy Parameters include: Parameter Description ca_alias The alias you want to use in your trust store for the imported cert. ca_file The file containing the cert you are adding. truststore.ts The trust store to which the cert will be added. ts_password The password used by truststore.ts. Problem B: logs show exception Your New Relic Java agent's log data shows the following CertificateException. java.security.cert.CertificateException: Could not parse certificate: java.io.IOException: Illegal header: -----BEGIN CERTIFICATE----- Copy This is most likely related to this JDK issue. Solution B Examine and validate that the header and footer of your certificates do not have trailing whitespaces. If they do, edit or use different certificates.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 92.037575,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "SSL or connection errors (<em>Java</em>)",
        "sections": "SSL or connection errors (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Problem A: SSL&#x2F;connection errors in logs Your New Relic <em>Java</em> <em>agent</em>&#x27;s log data shows SSL or connection errors. Tip See Configuring your SSL certificates for instructions on how to communicate with the New Relic collector over HTTPS. Solution A Failures to connect via SSL typically appear early"
      },
      "id": "603e870428ccbc75adeba789"
    },
    {
      "sections": [
        "NullPointerException issues (Java)",
        "Problem",
        "Solution",
        "Cause"
      ],
      "title": "NullPointerException issues (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "63e8344e80548a51ddea70754c273d5c4e2c3a09",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/nullpointerexception-issues-java/",
      "published_at": "2021-05-05T07:06:37Z",
      "updated_at": "2021-03-16T09:15:49Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem If your log data shows SEVERE: or ERROR: with NullPointerException issues, there may be issues that are interfering with reporting. Solution Before you begin these troubleshooting tips, make sure you have the most recent version of New Relic's Java agent. Use case-sensitive searches of your Java agent log file for lines with SEVERE: and ERROR: NullPointerException. If you find any lines with these messages, gather troubleshooting information to get support at New Relic. Cause New Relic's Java agent between versions 3.0.0 and 3.2.3 would incorrectly log the error messages. For example: ERROR: javax/servlet/ServletOutputStream is marked as a weaved class, but no methods are matched to be weaved. Copy This was entirely erroneous and is not a cause for concern. However, do not use these versions. Instead, update to the most recent version of New Relic's Java agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 91.611465,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "NullPointerException issues (<em>Java</em>)",
        "sections": "NullPointerException issues (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Problem If your log data shows SEVERE: or ERROR: with NullPointerException issues, there may be issues that are interfering with reporting. Solution Before you begin these <em>troubleshooting</em> tips, make sure you have the most recent version of New Relic&#x27;s <em>Java</em> <em>agent</em>. Use case-sensitive searches of your"
      },
      "id": "603e869f64441ff9774e889e"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/error-bootstrapping-new-relic-java-agent": [
    {
      "sections": [
        "Generate debug logs for troubleshooting (Java)",
        "Requirements",
        "Generate log files",
        "Examine log files",
        "Important",
        "For more help"
      ],
      "title": "Generate debug logs for troubleshooting (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "9ce3ec94630795156f9effc1f3c07c15a73f8b77",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/generate-debug-logs-troubleshooting-java/",
      "published_at": "2021-05-05T06:58:46Z",
      "updated_at": "2021-03-16T14:48:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When troubleshooting your New Relic Java agent, generate finest logs to find and investigate errors. When finished troubleshooting, be sure to set the log file back to a less verbose setting, such as info. Requirements If you only change the log file setting in your newrelic.yml file, you do not need to restart the server or JVM. However, if you make any other changes, you must restart your server or JVM. Be sure you keep the original line indentation in your newrelic.yml file. YAML is \"space sensitive\" and requires proper indentation. The audit_mode setting (when set to true ) will also log communication between the Java agent and New Relic to the log file. New Relic Support may occasionally request audit mode logs for additional troubleshooting. Generate log files To generate detailed finest log files: Edit your newrelic.yml file, and change the log_level to finest. Be sure to keep these lines indented two spaces. # The agent uses its own log file to keep its logging # separate from that of your application. Specify the log level here. # This setting is dynamic, so changes do not require restarting your application. # The levels in increasing order of verboseness are: # off, severe, warning, info, fine, finer, finest # Default is info. log_level: finest # Log all data sent to and from New Relic in plain text. # This setting is dynamic, so changes do not require restarting your application. # Default is false. audit_mode: false Copy Exercise your web application for about five minutes to generate sufficient logging data. After testing, change the log_level to a less verbose level, such as info (default). Open your log files and examine them for errors. Examine log files Important The finest log setting is a highly verbose logging level. To reduce disk space consumption after testing, return the log_level to its original setting. By default, log files are stored in a logs sub-directory, inside the same directory as newrelic.jar. If necessary, follow the troubleshooting procedures if no log files appear. For more help For logging on all New Relic agents, see New Relic agent logs and troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.56293,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Generate debug logs for <em>troubleshooting</em> (<em>Java</em>)",
        "sections": "Generate debug logs for <em>troubleshooting</em> (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "When <em>troubleshooting</em> your New Relic <em>Java</em> <em>agent</em>, generate finest logs to find and investigate errors. When finished <em>troubleshooting</em>, be sure to set the log file back to a less verbose setting, such as info. Requirements If you only change the log file setting in your newrelic.yml file, you do"
      },
      "id": "603eb64ae7b9d2e15e2a07e7"
    },
    {
      "sections": [
        "SSL or connection errors (Java)",
        "Problem A: SSL/connection errors in logs",
        "Tip",
        "Solution A",
        "Problem B: logs show exception",
        "Solution B"
      ],
      "title": "SSL or connection errors (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "0e5af5c4f29a8e7b75f4c4c61235952f91624fc1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/ssl-or-connection-errors-java/",
      "published_at": "2021-05-05T06:44:58Z",
      "updated_at": "2021-04-05T10:48:22Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem A: SSL/connection errors in logs Your New Relic Java agent's log data shows SSL or connection errors. Tip See Configuring your SSL certificates for instructions on how to communicate with the New Relic collector over HTTPS. Solution A Failures to connect via SSL typically appear early in the Java agent's log files. For example: PKIX path building failed: java.security.cert.CertPathBuilderException: PKIXCertPathBuilderImpl could not build a valid CertPath Copy INFO: connection error: java.net.SocketException: java.lang.ClassNotFoundException: Cannot find the specified class com.ibm.websphere.ssl.protocol.SSLSocketFactory Copy If you see either of these errors, your JDK instance probably is using a customized trust store. Recommendation: Add the DigiCert Global Root Certificate Authority (CA), from which New Relic's certificate is derived, to your trust store. You can download the DigiCert Global Root CA from DigiCert (choose the \"Download PEM\" option). To import the cert to your trust store, use this command, or see Oracle's Java SE documentation for keytool: keytool -importcert -alias ca_alias -file ca_file.pem -keystore truststore.ts -storepass ts_password Copy Parameters include: Parameter Description ca_alias The alias you want to use in your trust store for the imported cert. ca_file The file containing the cert you are adding. truststore.ts The trust store to which the cert will be added. ts_password The password used by truststore.ts. Problem B: logs show exception Your New Relic Java agent's log data shows the following CertificateException. java.security.cert.CertificateException: Could not parse certificate: java.io.IOException: Illegal header: -----BEGIN CERTIFICATE----- Copy This is most likely related to this JDK issue. Solution B Examine and validate that the header and footer of your certificates do not have trailing whitespaces. If they do, edit or use different certificates.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 92.03757,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "SSL or connection errors (<em>Java</em>)",
        "sections": "SSL or connection errors (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Problem A: SSL&#x2F;connection errors in logs Your New Relic <em>Java</em> <em>agent</em>&#x27;s log data shows SSL or connection errors. Tip See Configuring your SSL certificates for instructions on how to communicate with the New Relic collector over HTTPS. Solution A Failures to connect via SSL typically appear early"
      },
      "id": "603e870428ccbc75adeba789"
    },
    {
      "sections": [
        "NullPointerException issues (Java)",
        "Problem",
        "Solution",
        "Cause"
      ],
      "title": "NullPointerException issues (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "63e8344e80548a51ddea70754c273d5c4e2c3a09",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/nullpointerexception-issues-java/",
      "published_at": "2021-05-05T07:06:37Z",
      "updated_at": "2021-03-16T09:15:49Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem If your log data shows SEVERE: or ERROR: with NullPointerException issues, there may be issues that are interfering with reporting. Solution Before you begin these troubleshooting tips, make sure you have the most recent version of New Relic's Java agent. Use case-sensitive searches of your Java agent log file for lines with SEVERE: and ERROR: NullPointerException. If you find any lines with these messages, gather troubleshooting information to get support at New Relic. Cause New Relic's Java agent between versions 3.0.0 and 3.2.3 would incorrectly log the error messages. For example: ERROR: javax/servlet/ServletOutputStream is marked as a weaved class, but no methods are matched to be weaved. Copy This was entirely erroneous and is not a cause for concern. However, do not use these versions. Instead, update to the most recent version of New Relic's Java agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 91.611465,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "NullPointerException issues (<em>Java</em>)",
        "sections": "NullPointerException issues (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Problem If your log data shows SEVERE: or ERROR: with NullPointerException issues, there may be issues that are interfering with reporting. Solution Before you begin these <em>troubleshooting</em> tips, make sure you have the most recent version of New Relic&#x27;s <em>Java</em> <em>agent</em>. Use case-sensitive searches of your"
      },
      "id": "603e869f64441ff9774e889e"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/errors-starting-java-app-server": [
    {
      "sections": [
        "Generate debug logs for troubleshooting (Java)",
        "Requirements",
        "Generate log files",
        "Examine log files",
        "Important",
        "For more help"
      ],
      "title": "Generate debug logs for troubleshooting (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "9ce3ec94630795156f9effc1f3c07c15a73f8b77",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/generate-debug-logs-troubleshooting-java/",
      "published_at": "2021-05-05T06:58:46Z",
      "updated_at": "2021-03-16T14:48:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When troubleshooting your New Relic Java agent, generate finest logs to find and investigate errors. When finished troubleshooting, be sure to set the log file back to a less verbose setting, such as info. Requirements If you only change the log file setting in your newrelic.yml file, you do not need to restart the server or JVM. However, if you make any other changes, you must restart your server or JVM. Be sure you keep the original line indentation in your newrelic.yml file. YAML is \"space sensitive\" and requires proper indentation. The audit_mode setting (when set to true ) will also log communication between the Java agent and New Relic to the log file. New Relic Support may occasionally request audit mode logs for additional troubleshooting. Generate log files To generate detailed finest log files: Edit your newrelic.yml file, and change the log_level to finest. Be sure to keep these lines indented two spaces. # The agent uses its own log file to keep its logging # separate from that of your application. Specify the log level here. # This setting is dynamic, so changes do not require restarting your application. # The levels in increasing order of verboseness are: # off, severe, warning, info, fine, finer, finest # Default is info. log_level: finest # Log all data sent to and from New Relic in plain text. # This setting is dynamic, so changes do not require restarting your application. # Default is false. audit_mode: false Copy Exercise your web application for about five minutes to generate sufficient logging data. After testing, change the log_level to a less verbose level, such as info (default). Open your log files and examine them for errors. Examine log files Important The finest log setting is a highly verbose logging level. To reduce disk space consumption after testing, return the log_level to its original setting. By default, log files are stored in a logs sub-directory, inside the same directory as newrelic.jar. If necessary, follow the troubleshooting procedures if no log files appear. For more help For logging on all New Relic agents, see New Relic agent logs and troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.56293,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Generate debug logs for <em>troubleshooting</em> (<em>Java</em>)",
        "sections": "Generate debug logs for <em>troubleshooting</em> (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "When <em>troubleshooting</em> your New Relic <em>Java</em> <em>agent</em>, generate finest logs to find and investigate errors. When finished <em>troubleshooting</em>, be sure to set the log file back to a less verbose setting, such as info. Requirements If you only change the log file setting in your newrelic.yml file, you do"
      },
      "id": "603eb64ae7b9d2e15e2a07e7"
    },
    {
      "sections": [
        "SSL or connection errors (Java)",
        "Problem A: SSL/connection errors in logs",
        "Tip",
        "Solution A",
        "Problem B: logs show exception",
        "Solution B"
      ],
      "title": "SSL or connection errors (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "0e5af5c4f29a8e7b75f4c4c61235952f91624fc1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/ssl-or-connection-errors-java/",
      "published_at": "2021-05-05T06:44:58Z",
      "updated_at": "2021-04-05T10:48:22Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem A: SSL/connection errors in logs Your New Relic Java agent's log data shows SSL or connection errors. Tip See Configuring your SSL certificates for instructions on how to communicate with the New Relic collector over HTTPS. Solution A Failures to connect via SSL typically appear early in the Java agent's log files. For example: PKIX path building failed: java.security.cert.CertPathBuilderException: PKIXCertPathBuilderImpl could not build a valid CertPath Copy INFO: connection error: java.net.SocketException: java.lang.ClassNotFoundException: Cannot find the specified class com.ibm.websphere.ssl.protocol.SSLSocketFactory Copy If you see either of these errors, your JDK instance probably is using a customized trust store. Recommendation: Add the DigiCert Global Root Certificate Authority (CA), from which New Relic's certificate is derived, to your trust store. You can download the DigiCert Global Root CA from DigiCert (choose the \"Download PEM\" option). To import the cert to your trust store, use this command, or see Oracle's Java SE documentation for keytool: keytool -importcert -alias ca_alias -file ca_file.pem -keystore truststore.ts -storepass ts_password Copy Parameters include: Parameter Description ca_alias The alias you want to use in your trust store for the imported cert. ca_file The file containing the cert you are adding. truststore.ts The trust store to which the cert will be added. ts_password The password used by truststore.ts. Problem B: logs show exception Your New Relic Java agent's log data shows the following CertificateException. java.security.cert.CertificateException: Could not parse certificate: java.io.IOException: Illegal header: -----BEGIN CERTIFICATE----- Copy This is most likely related to this JDK issue. Solution B Examine and validate that the header and footer of your certificates do not have trailing whitespaces. If they do, edit or use different certificates.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 92.03757,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "SSL or connection errors (<em>Java</em>)",
        "sections": "SSL or connection errors (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Problem A: SSL&#x2F;connection errors in logs Your New Relic <em>Java</em> <em>agent</em>&#x27;s log data shows SSL or connection errors. Tip See Configuring your SSL certificates for instructions on how to communicate with the New Relic collector over HTTPS. Solution A Failures to connect via SSL typically appear early"
      },
      "id": "603e870428ccbc75adeba789"
    },
    {
      "sections": [
        "NullPointerException issues (Java)",
        "Problem",
        "Solution",
        "Cause"
      ],
      "title": "NullPointerException issues (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "63e8344e80548a51ddea70754c273d5c4e2c3a09",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/nullpointerexception-issues-java/",
      "published_at": "2021-05-05T07:06:37Z",
      "updated_at": "2021-03-16T09:15:49Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem If your log data shows SEVERE: or ERROR: with NullPointerException issues, there may be issues that are interfering with reporting. Solution Before you begin these troubleshooting tips, make sure you have the most recent version of New Relic's Java agent. Use case-sensitive searches of your Java agent log file for lines with SEVERE: and ERROR: NullPointerException. If you find any lines with these messages, gather troubleshooting information to get support at New Relic. Cause New Relic's Java agent between versions 3.0.0 and 3.2.3 would incorrectly log the error messages. For example: ERROR: javax/servlet/ServletOutputStream is marked as a weaved class, but no methods are matched to be weaved. Copy This was entirely erroneous and is not a cause for concern. However, do not use these versions. Instead, update to the most recent version of New Relic's Java agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 91.611465,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "NullPointerException issues (<em>Java</em>)",
        "sections": "NullPointerException issues (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Problem If your log data shows SEVERE: or ERROR: with NullPointerException issues, there may be issues that are interfering with reporting. Solution Before you begin these <em>troubleshooting</em> tips, make sure you have the most recent version of New Relic&#x27;s <em>Java</em> <em>agent</em>. Use case-sensitive searches of your"
      },
      "id": "603e869f64441ff9774e889e"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/firewall-or-traffic-connectivity-failures": [
    {
      "sections": [
        "Generate debug logs for troubleshooting (Java)",
        "Requirements",
        "Generate log files",
        "Examine log files",
        "Important",
        "For more help"
      ],
      "title": "Generate debug logs for troubleshooting (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "9ce3ec94630795156f9effc1f3c07c15a73f8b77",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/generate-debug-logs-troubleshooting-java/",
      "published_at": "2021-05-05T06:58:46Z",
      "updated_at": "2021-03-16T14:48:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When troubleshooting your New Relic Java agent, generate finest logs to find and investigate errors. When finished troubleshooting, be sure to set the log file back to a less verbose setting, such as info. Requirements If you only change the log file setting in your newrelic.yml file, you do not need to restart the server or JVM. However, if you make any other changes, you must restart your server or JVM. Be sure you keep the original line indentation in your newrelic.yml file. YAML is \"space sensitive\" and requires proper indentation. The audit_mode setting (when set to true ) will also log communication between the Java agent and New Relic to the log file. New Relic Support may occasionally request audit mode logs for additional troubleshooting. Generate log files To generate detailed finest log files: Edit your newrelic.yml file, and change the log_level to finest. Be sure to keep these lines indented two spaces. # The agent uses its own log file to keep its logging # separate from that of your application. Specify the log level here. # This setting is dynamic, so changes do not require restarting your application. # The levels in increasing order of verboseness are: # off, severe, warning, info, fine, finer, finest # Default is info. log_level: finest # Log all data sent to and from New Relic in plain text. # This setting is dynamic, so changes do not require restarting your application. # Default is false. audit_mode: false Copy Exercise your web application for about five minutes to generate sufficient logging data. After testing, change the log_level to a less verbose level, such as info (default). Open your log files and examine them for errors. Examine log files Important The finest log setting is a highly verbose logging level. To reduce disk space consumption after testing, return the log_level to its original setting. By default, log files are stored in a logs sub-directory, inside the same directory as newrelic.jar. If necessary, follow the troubleshooting procedures if no log files appear. For more help For logging on all New Relic agents, see New Relic agent logs and troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.56293,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Generate debug logs for <em>troubleshooting</em> (<em>Java</em>)",
        "sections": "Generate debug logs for <em>troubleshooting</em> (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "When <em>troubleshooting</em> your New Relic <em>Java</em> <em>agent</em>, generate finest logs to find and investigate errors. When finished <em>troubleshooting</em>, be sure to set the log file back to a less verbose setting, such as info. Requirements If you only change the log file setting in your newrelic.yml file, you do"
      },
      "id": "603eb64ae7b9d2e15e2a07e7"
    },
    {
      "sections": [
        "SSL or connection errors (Java)",
        "Problem A: SSL/connection errors in logs",
        "Tip",
        "Solution A",
        "Problem B: logs show exception",
        "Solution B"
      ],
      "title": "SSL or connection errors (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "0e5af5c4f29a8e7b75f4c4c61235952f91624fc1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/ssl-or-connection-errors-java/",
      "published_at": "2021-05-05T06:44:58Z",
      "updated_at": "2021-04-05T10:48:22Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem A: SSL/connection errors in logs Your New Relic Java agent's log data shows SSL or connection errors. Tip See Configuring your SSL certificates for instructions on how to communicate with the New Relic collector over HTTPS. Solution A Failures to connect via SSL typically appear early in the Java agent's log files. For example: PKIX path building failed: java.security.cert.CertPathBuilderException: PKIXCertPathBuilderImpl could not build a valid CertPath Copy INFO: connection error: java.net.SocketException: java.lang.ClassNotFoundException: Cannot find the specified class com.ibm.websphere.ssl.protocol.SSLSocketFactory Copy If you see either of these errors, your JDK instance probably is using a customized trust store. Recommendation: Add the DigiCert Global Root Certificate Authority (CA), from which New Relic's certificate is derived, to your trust store. You can download the DigiCert Global Root CA from DigiCert (choose the \"Download PEM\" option). To import the cert to your trust store, use this command, or see Oracle's Java SE documentation for keytool: keytool -importcert -alias ca_alias -file ca_file.pem -keystore truststore.ts -storepass ts_password Copy Parameters include: Parameter Description ca_alias The alias you want to use in your trust store for the imported cert. ca_file The file containing the cert you are adding. truststore.ts The trust store to which the cert will be added. ts_password The password used by truststore.ts. Problem B: logs show exception Your New Relic Java agent's log data shows the following CertificateException. java.security.cert.CertificateException: Could not parse certificate: java.io.IOException: Illegal header: -----BEGIN CERTIFICATE----- Copy This is most likely related to this JDK issue. Solution B Examine and validate that the header and footer of your certificates do not have trailing whitespaces. If they do, edit or use different certificates.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 92.03757,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "SSL or connection errors (<em>Java</em>)",
        "sections": "SSL or connection errors (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Problem A: SSL&#x2F;connection errors in logs Your New Relic <em>Java</em> <em>agent</em>&#x27;s log data shows SSL or connection errors. Tip See Configuring your SSL certificates for instructions on how to communicate with the New Relic collector over HTTPS. Solution A Failures to connect via SSL typically appear early"
      },
      "id": "603e870428ccbc75adeba789"
    },
    {
      "sections": [
        "NullPointerException issues (Java)",
        "Problem",
        "Solution",
        "Cause"
      ],
      "title": "NullPointerException issues (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "63e8344e80548a51ddea70754c273d5c4e2c3a09",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/nullpointerexception-issues-java/",
      "published_at": "2021-05-05T07:06:37Z",
      "updated_at": "2021-03-16T09:15:49Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem If your log data shows SEVERE: or ERROR: with NullPointerException issues, there may be issues that are interfering with reporting. Solution Before you begin these troubleshooting tips, make sure you have the most recent version of New Relic's Java agent. Use case-sensitive searches of your Java agent log file for lines with SEVERE: and ERROR: NullPointerException. If you find any lines with these messages, gather troubleshooting information to get support at New Relic. Cause New Relic's Java agent between versions 3.0.0 and 3.2.3 would incorrectly log the error messages. For example: ERROR: javax/servlet/ServletOutputStream is marked as a weaved class, but no methods are matched to be weaved. Copy This was entirely erroneous and is not a cause for concern. However, do not use these versions. Instead, update to the most recent version of New Relic's Java agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 91.61146,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "NullPointerException issues (<em>Java</em>)",
        "sections": "NullPointerException issues (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Problem If your log data shows SEVERE: or ERROR: with NullPointerException issues, there may be issues that are interfering with reporting. Solution Before you begin these <em>troubleshooting</em> tips, make sure you have the most recent version of New Relic&#x27;s <em>Java</em> <em>agent</em>. Use case-sensitive searches of your"
      },
      "id": "603e869f64441ff9774e889e"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/gather-troubleshooting-information-java": [
    {
      "sections": [
        "Generate debug logs for troubleshooting (Java)",
        "Requirements",
        "Generate log files",
        "Examine log files",
        "Important",
        "For more help"
      ],
      "title": "Generate debug logs for troubleshooting (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "9ce3ec94630795156f9effc1f3c07c15a73f8b77",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/generate-debug-logs-troubleshooting-java/",
      "published_at": "2021-05-05T06:58:46Z",
      "updated_at": "2021-03-16T14:48:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When troubleshooting your New Relic Java agent, generate finest logs to find and investigate errors. When finished troubleshooting, be sure to set the log file back to a less verbose setting, such as info. Requirements If you only change the log file setting in your newrelic.yml file, you do not need to restart the server or JVM. However, if you make any other changes, you must restart your server or JVM. Be sure you keep the original line indentation in your newrelic.yml file. YAML is \"space sensitive\" and requires proper indentation. The audit_mode setting (when set to true ) will also log communication between the Java agent and New Relic to the log file. New Relic Support may occasionally request audit mode logs for additional troubleshooting. Generate log files To generate detailed finest log files: Edit your newrelic.yml file, and change the log_level to finest. Be sure to keep these lines indented two spaces. # The agent uses its own log file to keep its logging # separate from that of your application. Specify the log level here. # This setting is dynamic, so changes do not require restarting your application. # The levels in increasing order of verboseness are: # off, severe, warning, info, fine, finer, finest # Default is info. log_level: finest # Log all data sent to and from New Relic in plain text. # This setting is dynamic, so changes do not require restarting your application. # Default is false. audit_mode: false Copy Exercise your web application for about five minutes to generate sufficient logging data. After testing, change the log_level to a less verbose level, such as info (default). Open your log files and examine them for errors. Examine log files Important The finest log setting is a highly verbose logging level. To reduce disk space consumption after testing, return the log_level to its original setting. By default, log files are stored in a logs sub-directory, inside the same directory as newrelic.jar. If necessary, follow the troubleshooting procedures if no log files appear. For more help For logging on all New Relic agents, see New Relic agent logs and troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.56293,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Generate debug logs for <em>troubleshooting</em> (<em>Java</em>)",
        "sections": "Generate debug logs for <em>troubleshooting</em> (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "When <em>troubleshooting</em> your New Relic <em>Java</em> <em>agent</em>, generate finest logs to find and investigate errors. When finished <em>troubleshooting</em>, be sure to set the log file back to a less verbose setting, such as info. Requirements If you only change the log file setting in your newrelic.yml file, you do"
      },
      "id": "603eb64ae7b9d2e15e2a07e7"
    },
    {
      "sections": [
        "SSL or connection errors (Java)",
        "Problem A: SSL/connection errors in logs",
        "Tip",
        "Solution A",
        "Problem B: logs show exception",
        "Solution B"
      ],
      "title": "SSL or connection errors (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "0e5af5c4f29a8e7b75f4c4c61235952f91624fc1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/ssl-or-connection-errors-java/",
      "published_at": "2021-05-05T06:44:58Z",
      "updated_at": "2021-04-05T10:48:22Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem A: SSL/connection errors in logs Your New Relic Java agent's log data shows SSL or connection errors. Tip See Configuring your SSL certificates for instructions on how to communicate with the New Relic collector over HTTPS. Solution A Failures to connect via SSL typically appear early in the Java agent's log files. For example: PKIX path building failed: java.security.cert.CertPathBuilderException: PKIXCertPathBuilderImpl could not build a valid CertPath Copy INFO: connection error: java.net.SocketException: java.lang.ClassNotFoundException: Cannot find the specified class com.ibm.websphere.ssl.protocol.SSLSocketFactory Copy If you see either of these errors, your JDK instance probably is using a customized trust store. Recommendation: Add the DigiCert Global Root Certificate Authority (CA), from which New Relic's certificate is derived, to your trust store. You can download the DigiCert Global Root CA from DigiCert (choose the \"Download PEM\" option). To import the cert to your trust store, use this command, or see Oracle's Java SE documentation for keytool: keytool -importcert -alias ca_alias -file ca_file.pem -keystore truststore.ts -storepass ts_password Copy Parameters include: Parameter Description ca_alias The alias you want to use in your trust store for the imported cert. ca_file The file containing the cert you are adding. truststore.ts The trust store to which the cert will be added. ts_password The password used by truststore.ts. Problem B: logs show exception Your New Relic Java agent's log data shows the following CertificateException. java.security.cert.CertificateException: Could not parse certificate: java.io.IOException: Illegal header: -----BEGIN CERTIFICATE----- Copy This is most likely related to this JDK issue. Solution B Examine and validate that the header and footer of your certificates do not have trailing whitespaces. If they do, edit or use different certificates.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 92.03757,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "SSL or connection errors (<em>Java</em>)",
        "sections": "SSL or connection errors (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Problem A: SSL&#x2F;connection errors in logs Your New Relic <em>Java</em> <em>agent</em>&#x27;s log data shows SSL or connection errors. Tip See Configuring your SSL certificates for instructions on how to communicate with the New Relic collector over HTTPS. Solution A Failures to connect via SSL typically appear early"
      },
      "id": "603e870428ccbc75adeba789"
    },
    {
      "sections": [
        "NullPointerException issues (Java)",
        "Problem",
        "Solution",
        "Cause"
      ],
      "title": "NullPointerException issues (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "63e8344e80548a51ddea70754c273d5c4e2c3a09",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/nullpointerexception-issues-java/",
      "published_at": "2021-05-05T07:06:37Z",
      "updated_at": "2021-03-16T09:15:49Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem If your log data shows SEVERE: or ERROR: with NullPointerException issues, there may be issues that are interfering with reporting. Solution Before you begin these troubleshooting tips, make sure you have the most recent version of New Relic's Java agent. Use case-sensitive searches of your Java agent log file for lines with SEVERE: and ERROR: NullPointerException. If you find any lines with these messages, gather troubleshooting information to get support at New Relic. Cause New Relic's Java agent between versions 3.0.0 and 3.2.3 would incorrectly log the error messages. For example: ERROR: javax/servlet/ServletOutputStream is marked as a weaved class, but no methods are matched to be weaved. Copy This was entirely erroneous and is not a cause for concern. However, do not use these versions. Instead, update to the most recent version of New Relic's Java agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 91.61146,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "NullPointerException issues (<em>Java</em>)",
        "sections": "NullPointerException issues (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Problem If your log data shows SEVERE: or ERROR: with NullPointerException issues, there may be issues that are interfering with reporting. Solution Before you begin these <em>troubleshooting</em> tips, make sure you have the most recent version of New Relic&#x27;s <em>Java</em> <em>agent</em>. Use case-sensitive searches of your"
      },
      "id": "603e869f64441ff9774e889e"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/generate-debug-logs-troubleshooting-java": [
    {
      "sections": [
        "SSL or connection errors (Java)",
        "Problem A: SSL/connection errors in logs",
        "Tip",
        "Solution A",
        "Problem B: logs show exception",
        "Solution B"
      ],
      "title": "SSL or connection errors (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "0e5af5c4f29a8e7b75f4c4c61235952f91624fc1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/ssl-or-connection-errors-java/",
      "published_at": "2021-05-05T06:44:58Z",
      "updated_at": "2021-04-05T10:48:22Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem A: SSL/connection errors in logs Your New Relic Java agent's log data shows SSL or connection errors. Tip See Configuring your SSL certificates for instructions on how to communicate with the New Relic collector over HTTPS. Solution A Failures to connect via SSL typically appear early in the Java agent's log files. For example: PKIX path building failed: java.security.cert.CertPathBuilderException: PKIXCertPathBuilderImpl could not build a valid CertPath Copy INFO: connection error: java.net.SocketException: java.lang.ClassNotFoundException: Cannot find the specified class com.ibm.websphere.ssl.protocol.SSLSocketFactory Copy If you see either of these errors, your JDK instance probably is using a customized trust store. Recommendation: Add the DigiCert Global Root Certificate Authority (CA), from which New Relic's certificate is derived, to your trust store. You can download the DigiCert Global Root CA from DigiCert (choose the \"Download PEM\" option). To import the cert to your trust store, use this command, or see Oracle's Java SE documentation for keytool: keytool -importcert -alias ca_alias -file ca_file.pem -keystore truststore.ts -storepass ts_password Copy Parameters include: Parameter Description ca_alias The alias you want to use in your trust store for the imported cert. ca_file The file containing the cert you are adding. truststore.ts The trust store to which the cert will be added. ts_password The password used by truststore.ts. Problem B: logs show exception Your New Relic Java agent's log data shows the following CertificateException. java.security.cert.CertificateException: Could not parse certificate: java.io.IOException: Illegal header: -----BEGIN CERTIFICATE----- Copy This is most likely related to this JDK issue. Solution B Examine and validate that the header and footer of your certificates do not have trailing whitespaces. If they do, edit or use different certificates.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 92.03756,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "SSL or connection errors (<em>Java</em>)",
        "sections": "SSL or connection errors (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Problem A: SSL&#x2F;connection errors in logs Your New Relic <em>Java</em> <em>agent</em>&#x27;s log data shows SSL or connection errors. Tip See Configuring your SSL certificates for instructions on how to communicate with the New Relic collector over HTTPS. Solution A Failures to connect via SSL typically appear early"
      },
      "id": "603e870428ccbc75adeba789"
    },
    {
      "sections": [
        "NullPointerException issues (Java)",
        "Problem",
        "Solution",
        "Cause"
      ],
      "title": "NullPointerException issues (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "63e8344e80548a51ddea70754c273d5c4e2c3a09",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/nullpointerexception-issues-java/",
      "published_at": "2021-05-05T07:06:37Z",
      "updated_at": "2021-03-16T09:15:49Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem If your log data shows SEVERE: or ERROR: with NullPointerException issues, there may be issues that are interfering with reporting. Solution Before you begin these troubleshooting tips, make sure you have the most recent version of New Relic's Java agent. Use case-sensitive searches of your Java agent log file for lines with SEVERE: and ERROR: NullPointerException. If you find any lines with these messages, gather troubleshooting information to get support at New Relic. Cause New Relic's Java agent between versions 3.0.0 and 3.2.3 would incorrectly log the error messages. For example: ERROR: javax/servlet/ServletOutputStream is marked as a weaved class, but no methods are matched to be weaved. Copy This was entirely erroneous and is not a cause for concern. However, do not use these versions. Instead, update to the most recent version of New Relic's Java agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 91.61146,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "NullPointerException issues (<em>Java</em>)",
        "sections": "NullPointerException issues (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Problem If your log data shows SEVERE: or ERROR: with NullPointerException issues, there may be issues that are interfering with reporting. Solution Before you begin these <em>troubleshooting</em> tips, make sure you have the most recent version of New Relic&#x27;s <em>Java</em> <em>agent</em>. Use case-sensitive searches of your"
      },
      "id": "603e869f64441ff9774e889e"
    },
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Requirements",
        "Important",
        "Installation",
        "Tip",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-05-05T07:03:34Z",
      "updated_at": "2021-03-30T15:01:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The New Relic JFR daemon runs as its own Java process and monitors a JVM for JFR events over remote JMX. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. On startup the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic Java agent. If the Java agent is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the agent will then report to the same APM entity. If the the Java agent is not detected, then the daemon will report as a unique entity under the app name that you configured for it. Requirements Requirements include: Java 8 (version 8u262+) or higher for both the JFR daemon process, and the application process An Insights insert API key or an APM license key. JFR daemon jar. Required for flamegraphs, otherwise optional but recommended: Install of New Relic Java agent version 6.1.0 or higher on your JVM. The JFR daemon can run without a Java agent being included, but if the Java agent is present it will combine agent and daemon data into a single APM application. Important Apps running with the JFR daemon should expect the JFR subsystem to use about 150MB of additional memory. Installation The application that you wish to monitor with the JFR daemon must be configured to expose JFR data over remote JMX by adding the following system properties: -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false Copy Tip By default, the JFR daemon will connect via JMX to localhost on port 1099 and send data to New Relic's US production metric and event ingest endpoints. Additionally, if you need the JFR daemon to report through a proxy that will require special configuration settings. To configure the JFR daemon's behavior, please see the fully documented configuration options. To use the JFR daemon: Download the latest version of the JFR daemon jar: jfr-daemon-n.n.n.jar. Register an Insert API key or an APM license key for publishing data to New Relic. Required: Assign your key to the INSIGHTS_INSERT_KEY environment variable. If you are using an APM license key then you will also need to set the USE_LICENSE_KEY=true environment variable. Recommended: Set the name of the application being monitored to the NEW_RELIC_APP_NAME environment variable. If this is not set, then the default app name will be used instead. Start your application and the JFR daemon: java -jar jfr-daemon-n.n.n.jar Copy Optional (but recommended): Include the Java agent: Install Java agent version 6.1.0 or higher to monitor your application. Configure the Java agent to allow it to communicate with the JMX daemon by adding the following configuration to the newrelic.yml configuration file: jmx: enabled: true linkingMetadataMBean: true Copy Tip Enabling linkingMetadataMBean allows the JFR daemon to acquire the entity GUID that was generated by the Java agent for the application. If the entity GUID is successfully acquired, then data collected by the daemon will be reported to the same application as the Java agent. Any name configured for the daemon using NEW_RELIC_APP_NAMEwould be overridden in favor of the name specified by the agent. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Requirements: Early access to our flamegraphs feature is available upon request. All other real-time profiling features are available by default. To request this early access, please email flamegraph@newrelic.com. At this time, this requires deployment of both the JFR daemon and Java agent and the daemon must be reporting as the same entity as the agent. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your application’s overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 89.83125,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where you’re wasting resources When"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/host-links-missing-java-apps-apm-summary": [
    {
      "sections": [
        "Generate debug logs for troubleshooting (Java)",
        "Requirements",
        "Generate log files",
        "Examine log files",
        "Important",
        "For more help"
      ],
      "title": "Generate debug logs for troubleshooting (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "9ce3ec94630795156f9effc1f3c07c15a73f8b77",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/generate-debug-logs-troubleshooting-java/",
      "published_at": "2021-05-05T06:58:46Z",
      "updated_at": "2021-03-16T14:48:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When troubleshooting your New Relic Java agent, generate finest logs to find and investigate errors. When finished troubleshooting, be sure to set the log file back to a less verbose setting, such as info. Requirements If you only change the log file setting in your newrelic.yml file, you do not need to restart the server or JVM. However, if you make any other changes, you must restart your server or JVM. Be sure you keep the original line indentation in your newrelic.yml file. YAML is \"space sensitive\" and requires proper indentation. The audit_mode setting (when set to true ) will also log communication between the Java agent and New Relic to the log file. New Relic Support may occasionally request audit mode logs for additional troubleshooting. Generate log files To generate detailed finest log files: Edit your newrelic.yml file, and change the log_level to finest. Be sure to keep these lines indented two spaces. # The agent uses its own log file to keep its logging # separate from that of your application. Specify the log level here. # This setting is dynamic, so changes do not require restarting your application. # The levels in increasing order of verboseness are: # off, severe, warning, info, fine, finer, finest # Default is info. log_level: finest # Log all data sent to and from New Relic in plain text. # This setting is dynamic, so changes do not require restarting your application. # Default is false. audit_mode: false Copy Exercise your web application for about five minutes to generate sufficient logging data. After testing, change the log_level to a less verbose level, such as info (default). Open your log files and examine them for errors. Examine log files Important The finest log setting is a highly verbose logging level. To reduce disk space consumption after testing, return the log_level to its original setting. By default, log files are stored in a logs sub-directory, inside the same directory as newrelic.jar. If necessary, follow the troubleshooting procedures if no log files appear. For more help For logging on all New Relic agents, see New Relic agent logs and troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.56292,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Generate debug logs for <em>troubleshooting</em> (<em>Java</em>)",
        "sections": "Generate debug logs for <em>troubleshooting</em> (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "When <em>troubleshooting</em> your New Relic <em>Java</em> <em>agent</em>, generate finest logs to find and investigate errors. When finished <em>troubleshooting</em>, be sure to set the log file back to a less verbose setting, such as info. Requirements If you only change the log file setting in your newrelic.yml file, you do"
      },
      "id": "603eb64ae7b9d2e15e2a07e7"
    },
    {
      "sections": [
        "SSL or connection errors (Java)",
        "Problem A: SSL/connection errors in logs",
        "Tip",
        "Solution A",
        "Problem B: logs show exception",
        "Solution B"
      ],
      "title": "SSL or connection errors (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "0e5af5c4f29a8e7b75f4c4c61235952f91624fc1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/ssl-or-connection-errors-java/",
      "published_at": "2021-05-05T06:44:58Z",
      "updated_at": "2021-04-05T10:48:22Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem A: SSL/connection errors in logs Your New Relic Java agent's log data shows SSL or connection errors. Tip See Configuring your SSL certificates for instructions on how to communicate with the New Relic collector over HTTPS. Solution A Failures to connect via SSL typically appear early in the Java agent's log files. For example: PKIX path building failed: java.security.cert.CertPathBuilderException: PKIXCertPathBuilderImpl could not build a valid CertPath Copy INFO: connection error: java.net.SocketException: java.lang.ClassNotFoundException: Cannot find the specified class com.ibm.websphere.ssl.protocol.SSLSocketFactory Copy If you see either of these errors, your JDK instance probably is using a customized trust store. Recommendation: Add the DigiCert Global Root Certificate Authority (CA), from which New Relic's certificate is derived, to your trust store. You can download the DigiCert Global Root CA from DigiCert (choose the \"Download PEM\" option). To import the cert to your trust store, use this command, or see Oracle's Java SE documentation for keytool: keytool -importcert -alias ca_alias -file ca_file.pem -keystore truststore.ts -storepass ts_password Copy Parameters include: Parameter Description ca_alias The alias you want to use in your trust store for the imported cert. ca_file The file containing the cert you are adding. truststore.ts The trust store to which the cert will be added. ts_password The password used by truststore.ts. Problem B: logs show exception Your New Relic Java agent's log data shows the following CertificateException. java.security.cert.CertificateException: Could not parse certificate: java.io.IOException: Illegal header: -----BEGIN CERTIFICATE----- Copy This is most likely related to this JDK issue. Solution B Examine and validate that the header and footer of your certificates do not have trailing whitespaces. If they do, edit or use different certificates.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 92.03756,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "SSL or connection errors (<em>Java</em>)",
        "sections": "SSL or connection errors (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Problem A: SSL&#x2F;connection errors in logs Your New Relic <em>Java</em> <em>agent</em>&#x27;s log data shows SSL or connection errors. Tip See Configuring your SSL certificates for instructions on how to communicate with the New Relic collector over HTTPS. Solution A Failures to connect via SSL typically appear early"
      },
      "id": "603e870428ccbc75adeba789"
    },
    {
      "sections": [
        "NullPointerException issues (Java)",
        "Problem",
        "Solution",
        "Cause"
      ],
      "title": "NullPointerException issues (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "63e8344e80548a51ddea70754c273d5c4e2c3a09",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/nullpointerexception-issues-java/",
      "published_at": "2021-05-05T07:06:37Z",
      "updated_at": "2021-03-16T09:15:49Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem If your log data shows SEVERE: or ERROR: with NullPointerException issues, there may be issues that are interfering with reporting. Solution Before you begin these troubleshooting tips, make sure you have the most recent version of New Relic's Java agent. Use case-sensitive searches of your Java agent log file for lines with SEVERE: and ERROR: NullPointerException. If you find any lines with these messages, gather troubleshooting information to get support at New Relic. Cause New Relic's Java agent between versions 3.0.0 and 3.2.3 would incorrectly log the error messages. For example: ERROR: javax/servlet/ServletOutputStream is marked as a weaved class, but no methods are matched to be weaved. Copy This was entirely erroneous and is not a cause for concern. However, do not use these versions. Instead, update to the most recent version of New Relic's Java agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 91.61146,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "NullPointerException issues (<em>Java</em>)",
        "sections": "NullPointerException issues (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Problem If your log data shows SEVERE: or ERROR: with NullPointerException issues, there may be issues that are interfering with reporting. Solution Before you begin these <em>troubleshooting</em> tips, make sure you have the most recent version of New Relic&#x27;s <em>Java</em> <em>agent</em>. Use case-sensitive searches of your"
      },
      "id": "603e869f64441ff9774e889e"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/java-solr-data-does-not-appear": [
    {
      "sections": [
        "Generate debug logs for troubleshooting (Java)",
        "Requirements",
        "Generate log files",
        "Examine log files",
        "Important",
        "For more help"
      ],
      "title": "Generate debug logs for troubleshooting (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "9ce3ec94630795156f9effc1f3c07c15a73f8b77",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/generate-debug-logs-troubleshooting-java/",
      "published_at": "2021-05-05T06:58:46Z",
      "updated_at": "2021-03-16T14:48:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When troubleshooting your New Relic Java agent, generate finest logs to find and investigate errors. When finished troubleshooting, be sure to set the log file back to a less verbose setting, such as info. Requirements If you only change the log file setting in your newrelic.yml file, you do not need to restart the server or JVM. However, if you make any other changes, you must restart your server or JVM. Be sure you keep the original line indentation in your newrelic.yml file. YAML is \"space sensitive\" and requires proper indentation. The audit_mode setting (when set to true ) will also log communication between the Java agent and New Relic to the log file. New Relic Support may occasionally request audit mode logs for additional troubleshooting. Generate log files To generate detailed finest log files: Edit your newrelic.yml file, and change the log_level to finest. Be sure to keep these lines indented two spaces. # The agent uses its own log file to keep its logging # separate from that of your application. Specify the log level here. # This setting is dynamic, so changes do not require restarting your application. # The levels in increasing order of verboseness are: # off, severe, warning, info, fine, finer, finest # Default is info. log_level: finest # Log all data sent to and from New Relic in plain text. # This setting is dynamic, so changes do not require restarting your application. # Default is false. audit_mode: false Copy Exercise your web application for about five minutes to generate sufficient logging data. After testing, change the log_level to a less verbose level, such as info (default). Open your log files and examine them for errors. Examine log files Important The finest log setting is a highly verbose logging level. To reduce disk space consumption after testing, return the log_level to its original setting. By default, log files are stored in a logs sub-directory, inside the same directory as newrelic.jar. If necessary, follow the troubleshooting procedures if no log files appear. For more help For logging on all New Relic agents, see New Relic agent logs and troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.56292,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Generate debug logs for <em>troubleshooting</em> (<em>Java</em>)",
        "sections": "Generate debug logs for <em>troubleshooting</em> (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "When <em>troubleshooting</em> your New Relic <em>Java</em> <em>agent</em>, generate finest logs to find and investigate errors. When finished <em>troubleshooting</em>, be sure to set the log file back to a less verbose setting, such as info. Requirements If you only change the log file setting in your newrelic.yml file, you do"
      },
      "id": "603eb64ae7b9d2e15e2a07e7"
    },
    {
      "sections": [
        "SSL or connection errors (Java)",
        "Problem A: SSL/connection errors in logs",
        "Tip",
        "Solution A",
        "Problem B: logs show exception",
        "Solution B"
      ],
      "title": "SSL or connection errors (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "0e5af5c4f29a8e7b75f4c4c61235952f91624fc1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/ssl-or-connection-errors-java/",
      "published_at": "2021-05-05T06:44:58Z",
      "updated_at": "2021-04-05T10:48:22Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem A: SSL/connection errors in logs Your New Relic Java agent's log data shows SSL or connection errors. Tip See Configuring your SSL certificates for instructions on how to communicate with the New Relic collector over HTTPS. Solution A Failures to connect via SSL typically appear early in the Java agent's log files. For example: PKIX path building failed: java.security.cert.CertPathBuilderException: PKIXCertPathBuilderImpl could not build a valid CertPath Copy INFO: connection error: java.net.SocketException: java.lang.ClassNotFoundException: Cannot find the specified class com.ibm.websphere.ssl.protocol.SSLSocketFactory Copy If you see either of these errors, your JDK instance probably is using a customized trust store. Recommendation: Add the DigiCert Global Root Certificate Authority (CA), from which New Relic's certificate is derived, to your trust store. You can download the DigiCert Global Root CA from DigiCert (choose the \"Download PEM\" option). To import the cert to your trust store, use this command, or see Oracle's Java SE documentation for keytool: keytool -importcert -alias ca_alias -file ca_file.pem -keystore truststore.ts -storepass ts_password Copy Parameters include: Parameter Description ca_alias The alias you want to use in your trust store for the imported cert. ca_file The file containing the cert you are adding. truststore.ts The trust store to which the cert will be added. ts_password The password used by truststore.ts. Problem B: logs show exception Your New Relic Java agent's log data shows the following CertificateException. java.security.cert.CertificateException: Could not parse certificate: java.io.IOException: Illegal header: -----BEGIN CERTIFICATE----- Copy This is most likely related to this JDK issue. Solution B Examine and validate that the header and footer of your certificates do not have trailing whitespaces. If they do, edit or use different certificates.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 92.03755,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "SSL or connection errors (<em>Java</em>)",
        "sections": "SSL or connection errors (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Problem A: SSL&#x2F;connection errors in logs Your New Relic <em>Java</em> <em>agent</em>&#x27;s log data shows SSL or connection errors. Tip See Configuring your SSL certificates for instructions on how to communicate with the New Relic collector over HTTPS. Solution A Failures to connect via SSL typically appear early"
      },
      "id": "603e870428ccbc75adeba789"
    },
    {
      "sections": [
        "NullPointerException issues (Java)",
        "Problem",
        "Solution",
        "Cause"
      ],
      "title": "NullPointerException issues (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "63e8344e80548a51ddea70754c273d5c4e2c3a09",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/nullpointerexception-issues-java/",
      "published_at": "2021-05-05T07:06:37Z",
      "updated_at": "2021-03-16T09:15:49Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem If your log data shows SEVERE: or ERROR: with NullPointerException issues, there may be issues that are interfering with reporting. Solution Before you begin these troubleshooting tips, make sure you have the most recent version of New Relic's Java agent. Use case-sensitive searches of your Java agent log file for lines with SEVERE: and ERROR: NullPointerException. If you find any lines with these messages, gather troubleshooting information to get support at New Relic. Cause New Relic's Java agent between versions 3.0.0 and 3.2.3 would incorrectly log the error messages. For example: ERROR: javax/servlet/ServletOutputStream is marked as a weaved class, but no methods are matched to be weaved. Copy This was entirely erroneous and is not a cause for concern. However, do not use these versions. Instead, update to the most recent version of New Relic's Java agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 91.61145,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "NullPointerException issues (<em>Java</em>)",
        "sections": "NullPointerException issues (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Problem If your log data shows SEVERE: or ERROR: with NullPointerException issues, there may be issues that are interfering with reporting. Solution Before you begin these <em>troubleshooting</em> tips, make sure you have the most recent version of New Relic&#x27;s <em>Java</em> <em>agent</em>. Use case-sensitive searches of your"
      },
      "id": "603e869f64441ff9774e889e"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/large-number-false-positive-security-vulnerabilities": [
    {
      "sections": [
        "Generate debug logs for troubleshooting (Java)",
        "Requirements",
        "Generate log files",
        "Examine log files",
        "Important",
        "For more help"
      ],
      "title": "Generate debug logs for troubleshooting (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "9ce3ec94630795156f9effc1f3c07c15a73f8b77",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/generate-debug-logs-troubleshooting-java/",
      "published_at": "2021-05-05T06:58:46Z",
      "updated_at": "2021-03-16T14:48:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When troubleshooting your New Relic Java agent, generate finest logs to find and investigate errors. When finished troubleshooting, be sure to set the log file back to a less verbose setting, such as info. Requirements If you only change the log file setting in your newrelic.yml file, you do not need to restart the server or JVM. However, if you make any other changes, you must restart your server or JVM. Be sure you keep the original line indentation in your newrelic.yml file. YAML is \"space sensitive\" and requires proper indentation. The audit_mode setting (when set to true ) will also log communication between the Java agent and New Relic to the log file. New Relic Support may occasionally request audit mode logs for additional troubleshooting. Generate log files To generate detailed finest log files: Edit your newrelic.yml file, and change the log_level to finest. Be sure to keep these lines indented two spaces. # The agent uses its own log file to keep its logging # separate from that of your application. Specify the log level here. # This setting is dynamic, so changes do not require restarting your application. # The levels in increasing order of verboseness are: # off, severe, warning, info, fine, finer, finest # Default is info. log_level: finest # Log all data sent to and from New Relic in plain text. # This setting is dynamic, so changes do not require restarting your application. # Default is false. audit_mode: false Copy Exercise your web application for about five minutes to generate sufficient logging data. After testing, change the log_level to a less verbose level, such as info (default). Open your log files and examine them for errors. Examine log files Important The finest log setting is a highly verbose logging level. To reduce disk space consumption after testing, return the log_level to its original setting. By default, log files are stored in a logs sub-directory, inside the same directory as newrelic.jar. If necessary, follow the troubleshooting procedures if no log files appear. For more help For logging on all New Relic agents, see New Relic agent logs and troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.56292,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Generate debug logs for <em>troubleshooting</em> (<em>Java</em>)",
        "sections": "Generate debug logs for <em>troubleshooting</em> (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "When <em>troubleshooting</em> your New Relic <em>Java</em> <em>agent</em>, generate finest logs to find and investigate errors. When finished <em>troubleshooting</em>, be sure to set the log file back to a less verbose setting, such as info. Requirements If you only change the log file setting in your newrelic.yml file, you do"
      },
      "id": "603eb64ae7b9d2e15e2a07e7"
    },
    {
      "sections": [
        "SSL or connection errors (Java)",
        "Problem A: SSL/connection errors in logs",
        "Tip",
        "Solution A",
        "Problem B: logs show exception",
        "Solution B"
      ],
      "title": "SSL or connection errors (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "0e5af5c4f29a8e7b75f4c4c61235952f91624fc1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/ssl-or-connection-errors-java/",
      "published_at": "2021-05-05T06:44:58Z",
      "updated_at": "2021-04-05T10:48:22Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem A: SSL/connection errors in logs Your New Relic Java agent's log data shows SSL or connection errors. Tip See Configuring your SSL certificates for instructions on how to communicate with the New Relic collector over HTTPS. Solution A Failures to connect via SSL typically appear early in the Java agent's log files. For example: PKIX path building failed: java.security.cert.CertPathBuilderException: PKIXCertPathBuilderImpl could not build a valid CertPath Copy INFO: connection error: java.net.SocketException: java.lang.ClassNotFoundException: Cannot find the specified class com.ibm.websphere.ssl.protocol.SSLSocketFactory Copy If you see either of these errors, your JDK instance probably is using a customized trust store. Recommendation: Add the DigiCert Global Root Certificate Authority (CA), from which New Relic's certificate is derived, to your trust store. You can download the DigiCert Global Root CA from DigiCert (choose the \"Download PEM\" option). To import the cert to your trust store, use this command, or see Oracle's Java SE documentation for keytool: keytool -importcert -alias ca_alias -file ca_file.pem -keystore truststore.ts -storepass ts_password Copy Parameters include: Parameter Description ca_alias The alias you want to use in your trust store for the imported cert. ca_file The file containing the cert you are adding. truststore.ts The trust store to which the cert will be added. ts_password The password used by truststore.ts. Problem B: logs show exception Your New Relic Java agent's log data shows the following CertificateException. java.security.cert.CertificateException: Could not parse certificate: java.io.IOException: Illegal header: -----BEGIN CERTIFICATE----- Copy This is most likely related to this JDK issue. Solution B Examine and validate that the header and footer of your certificates do not have trailing whitespaces. If they do, edit or use different certificates.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 92.03755,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "SSL or connection errors (<em>Java</em>)",
        "sections": "SSL or connection errors (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Problem A: SSL&#x2F;connection errors in logs Your New Relic <em>Java</em> <em>agent</em>&#x27;s log data shows SSL or connection errors. Tip See Configuring your SSL certificates for instructions on how to communicate with the New Relic collector over HTTPS. Solution A Failures to connect via SSL typically appear early"
      },
      "id": "603e870428ccbc75adeba789"
    },
    {
      "sections": [
        "NullPointerException issues (Java)",
        "Problem",
        "Solution",
        "Cause"
      ],
      "title": "NullPointerException issues (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "63e8344e80548a51ddea70754c273d5c4e2c3a09",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/nullpointerexception-issues-java/",
      "published_at": "2021-05-05T07:06:37Z",
      "updated_at": "2021-03-16T09:15:49Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem If your log data shows SEVERE: or ERROR: with NullPointerException issues, there may be issues that are interfering with reporting. Solution Before you begin these troubleshooting tips, make sure you have the most recent version of New Relic's Java agent. Use case-sensitive searches of your Java agent log file for lines with SEVERE: and ERROR: NullPointerException. If you find any lines with these messages, gather troubleshooting information to get support at New Relic. Cause New Relic's Java agent between versions 3.0.0 and 3.2.3 would incorrectly log the error messages. For example: ERROR: javax/servlet/ServletOutputStream is marked as a weaved class, but no methods are matched to be weaved. Copy This was entirely erroneous and is not a cause for concern. However, do not use these versions. Instead, update to the most recent version of New Relic's Java agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 91.61145,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "NullPointerException issues (<em>Java</em>)",
        "sections": "NullPointerException issues (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Problem If your log data shows SEVERE: or ERROR: with NullPointerException issues, there may be issues that are interfering with reporting. Solution Before you begin these <em>troubleshooting</em> tips, make sure you have the most recent version of New Relic&#x27;s <em>Java</em> <em>agent</em>. Use case-sensitive searches of your"
      },
      "id": "603e869f64441ff9774e889e"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/no-browser-data-appears-java": [
    {
      "sections": [
        "Generate debug logs for troubleshooting (Java)",
        "Requirements",
        "Generate log files",
        "Examine log files",
        "Important",
        "For more help"
      ],
      "title": "Generate debug logs for troubleshooting (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "9ce3ec94630795156f9effc1f3c07c15a73f8b77",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/generate-debug-logs-troubleshooting-java/",
      "published_at": "2021-05-05T06:58:46Z",
      "updated_at": "2021-03-16T14:48:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When troubleshooting your New Relic Java agent, generate finest logs to find and investigate errors. When finished troubleshooting, be sure to set the log file back to a less verbose setting, such as info. Requirements If you only change the log file setting in your newrelic.yml file, you do not need to restart the server or JVM. However, if you make any other changes, you must restart your server or JVM. Be sure you keep the original line indentation in your newrelic.yml file. YAML is \"space sensitive\" and requires proper indentation. The audit_mode setting (when set to true ) will also log communication between the Java agent and New Relic to the log file. New Relic Support may occasionally request audit mode logs for additional troubleshooting. Generate log files To generate detailed finest log files: Edit your newrelic.yml file, and change the log_level to finest. Be sure to keep these lines indented two spaces. # The agent uses its own log file to keep its logging # separate from that of your application. Specify the log level here. # This setting is dynamic, so changes do not require restarting your application. # The levels in increasing order of verboseness are: # off, severe, warning, info, fine, finer, finest # Default is info. log_level: finest # Log all data sent to and from New Relic in plain text. # This setting is dynamic, so changes do not require restarting your application. # Default is false. audit_mode: false Copy Exercise your web application for about five minutes to generate sufficient logging data. After testing, change the log_level to a less verbose level, such as info (default). Open your log files and examine them for errors. Examine log files Important The finest log setting is a highly verbose logging level. To reduce disk space consumption after testing, return the log_level to its original setting. By default, log files are stored in a logs sub-directory, inside the same directory as newrelic.jar. If necessary, follow the troubleshooting procedures if no log files appear. For more help For logging on all New Relic agents, see New Relic agent logs and troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.56292,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Generate debug logs for <em>troubleshooting</em> (<em>Java</em>)",
        "sections": "Generate debug logs for <em>troubleshooting</em> (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "When <em>troubleshooting</em> your New Relic <em>Java</em> <em>agent</em>, generate finest logs to find and investigate errors. When finished <em>troubleshooting</em>, be sure to set the log file back to a less verbose setting, such as info. Requirements If you only change the log file setting in your newrelic.yml file, you do"
      },
      "id": "603eb64ae7b9d2e15e2a07e7"
    },
    {
      "sections": [
        "SSL or connection errors (Java)",
        "Problem A: SSL/connection errors in logs",
        "Tip",
        "Solution A",
        "Problem B: logs show exception",
        "Solution B"
      ],
      "title": "SSL or connection errors (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "0e5af5c4f29a8e7b75f4c4c61235952f91624fc1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/ssl-or-connection-errors-java/",
      "published_at": "2021-05-05T06:44:58Z",
      "updated_at": "2021-04-05T10:48:22Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem A: SSL/connection errors in logs Your New Relic Java agent's log data shows SSL or connection errors. Tip See Configuring your SSL certificates for instructions on how to communicate with the New Relic collector over HTTPS. Solution A Failures to connect via SSL typically appear early in the Java agent's log files. For example: PKIX path building failed: java.security.cert.CertPathBuilderException: PKIXCertPathBuilderImpl could not build a valid CertPath Copy INFO: connection error: java.net.SocketException: java.lang.ClassNotFoundException: Cannot find the specified class com.ibm.websphere.ssl.protocol.SSLSocketFactory Copy If you see either of these errors, your JDK instance probably is using a customized trust store. Recommendation: Add the DigiCert Global Root Certificate Authority (CA), from which New Relic's certificate is derived, to your trust store. You can download the DigiCert Global Root CA from DigiCert (choose the \"Download PEM\" option). To import the cert to your trust store, use this command, or see Oracle's Java SE documentation for keytool: keytool -importcert -alias ca_alias -file ca_file.pem -keystore truststore.ts -storepass ts_password Copy Parameters include: Parameter Description ca_alias The alias you want to use in your trust store for the imported cert. ca_file The file containing the cert you are adding. truststore.ts The trust store to which the cert will be added. ts_password The password used by truststore.ts. Problem B: logs show exception Your New Relic Java agent's log data shows the following CertificateException. java.security.cert.CertificateException: Could not parse certificate: java.io.IOException: Illegal header: -----BEGIN CERTIFICATE----- Copy This is most likely related to this JDK issue. Solution B Examine and validate that the header and footer of your certificates do not have trailing whitespaces. If they do, edit or use different certificates.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 92.03755,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "SSL or connection errors (<em>Java</em>)",
        "sections": "SSL or connection errors (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Problem A: SSL&#x2F;connection errors in logs Your New Relic <em>Java</em> <em>agent</em>&#x27;s log data shows SSL or connection errors. Tip See Configuring your SSL certificates for instructions on how to communicate with the New Relic collector over HTTPS. Solution A Failures to connect via SSL typically appear early"
      },
      "id": "603e870428ccbc75adeba789"
    },
    {
      "sections": [
        "NullPointerException issues (Java)",
        "Problem",
        "Solution",
        "Cause"
      ],
      "title": "NullPointerException issues (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "63e8344e80548a51ddea70754c273d5c4e2c3a09",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/nullpointerexception-issues-java/",
      "published_at": "2021-05-05T07:06:37Z",
      "updated_at": "2021-03-16T09:15:49Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem If your log data shows SEVERE: or ERROR: with NullPointerException issues, there may be issues that are interfering with reporting. Solution Before you begin these troubleshooting tips, make sure you have the most recent version of New Relic's Java agent. Use case-sensitive searches of your Java agent log file for lines with SEVERE: and ERROR: NullPointerException. If you find any lines with these messages, gather troubleshooting information to get support at New Relic. Cause New Relic's Java agent between versions 3.0.0 and 3.2.3 would incorrectly log the error messages. For example: ERROR: javax/servlet/ServletOutputStream is marked as a weaved class, but no methods are matched to be weaved. Copy This was entirely erroneous and is not a cause for concern. However, do not use these versions. Instead, update to the most recent version of New Relic's Java agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 91.61145,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "NullPointerException issues (<em>Java</em>)",
        "sections": "NullPointerException issues (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Problem If your log data shows SEVERE: or ERROR: with NullPointerException issues, there may be issues that are interfering with reporting. Solution Before you begin these <em>troubleshooting</em> tips, make sure you have the most recent version of New Relic&#x27;s <em>Java</em> <em>agent</em>. Use case-sensitive searches of your"
      },
      "id": "603e869f64441ff9774e889e"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/no-data-appears-java": [
    {
      "sections": [
        "Generate debug logs for troubleshooting (Java)",
        "Requirements",
        "Generate log files",
        "Examine log files",
        "Important",
        "For more help"
      ],
      "title": "Generate debug logs for troubleshooting (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "9ce3ec94630795156f9effc1f3c07c15a73f8b77",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/generate-debug-logs-troubleshooting-java/",
      "published_at": "2021-05-05T06:58:46Z",
      "updated_at": "2021-03-16T14:48:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When troubleshooting your New Relic Java agent, generate finest logs to find and investigate errors. When finished troubleshooting, be sure to set the log file back to a less verbose setting, such as info. Requirements If you only change the log file setting in your newrelic.yml file, you do not need to restart the server or JVM. However, if you make any other changes, you must restart your server or JVM. Be sure you keep the original line indentation in your newrelic.yml file. YAML is \"space sensitive\" and requires proper indentation. The audit_mode setting (when set to true ) will also log communication between the Java agent and New Relic to the log file. New Relic Support may occasionally request audit mode logs for additional troubleshooting. Generate log files To generate detailed finest log files: Edit your newrelic.yml file, and change the log_level to finest. Be sure to keep these lines indented two spaces. # The agent uses its own log file to keep its logging # separate from that of your application. Specify the log level here. # This setting is dynamic, so changes do not require restarting your application. # The levels in increasing order of verboseness are: # off, severe, warning, info, fine, finer, finest # Default is info. log_level: finest # Log all data sent to and from New Relic in plain text. # This setting is dynamic, so changes do not require restarting your application. # Default is false. audit_mode: false Copy Exercise your web application for about five minutes to generate sufficient logging data. After testing, change the log_level to a less verbose level, such as info (default). Open your log files and examine them for errors. Examine log files Important The finest log setting is a highly verbose logging level. To reduce disk space consumption after testing, return the log_level to its original setting. By default, log files are stored in a logs sub-directory, inside the same directory as newrelic.jar. If necessary, follow the troubleshooting procedures if no log files appear. For more help For logging on all New Relic agents, see New Relic agent logs and troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.56291,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Generate debug logs for <em>troubleshooting</em> (<em>Java</em>)",
        "sections": "Generate debug logs for <em>troubleshooting</em> (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "When <em>troubleshooting</em> your New Relic <em>Java</em> <em>agent</em>, generate finest logs to find and investigate errors. When finished <em>troubleshooting</em>, be sure to set the log file back to a less verbose setting, such as info. Requirements If you only change the log file setting in your newrelic.yml file, you do"
      },
      "id": "603eb64ae7b9d2e15e2a07e7"
    },
    {
      "sections": [
        "SSL or connection errors (Java)",
        "Problem A: SSL/connection errors in logs",
        "Tip",
        "Solution A",
        "Problem B: logs show exception",
        "Solution B"
      ],
      "title": "SSL or connection errors (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "0e5af5c4f29a8e7b75f4c4c61235952f91624fc1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/ssl-or-connection-errors-java/",
      "published_at": "2021-05-05T06:44:58Z",
      "updated_at": "2021-04-05T10:48:22Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem A: SSL/connection errors in logs Your New Relic Java agent's log data shows SSL or connection errors. Tip See Configuring your SSL certificates for instructions on how to communicate with the New Relic collector over HTTPS. Solution A Failures to connect via SSL typically appear early in the Java agent's log files. For example: PKIX path building failed: java.security.cert.CertPathBuilderException: PKIXCertPathBuilderImpl could not build a valid CertPath Copy INFO: connection error: java.net.SocketException: java.lang.ClassNotFoundException: Cannot find the specified class com.ibm.websphere.ssl.protocol.SSLSocketFactory Copy If you see either of these errors, your JDK instance probably is using a customized trust store. Recommendation: Add the DigiCert Global Root Certificate Authority (CA), from which New Relic's certificate is derived, to your trust store. You can download the DigiCert Global Root CA from DigiCert (choose the \"Download PEM\" option). To import the cert to your trust store, use this command, or see Oracle's Java SE documentation for keytool: keytool -importcert -alias ca_alias -file ca_file.pem -keystore truststore.ts -storepass ts_password Copy Parameters include: Parameter Description ca_alias The alias you want to use in your trust store for the imported cert. ca_file The file containing the cert you are adding. truststore.ts The trust store to which the cert will be added. ts_password The password used by truststore.ts. Problem B: logs show exception Your New Relic Java agent's log data shows the following CertificateException. java.security.cert.CertificateException: Could not parse certificate: java.io.IOException: Illegal header: -----BEGIN CERTIFICATE----- Copy This is most likely related to this JDK issue. Solution B Examine and validate that the header and footer of your certificates do not have trailing whitespaces. If they do, edit or use different certificates.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 92.03755,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "SSL or connection errors (<em>Java</em>)",
        "sections": "SSL or connection errors (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Problem A: SSL&#x2F;connection errors in logs Your New Relic <em>Java</em> <em>agent</em>&#x27;s log data shows SSL or connection errors. Tip See Configuring your SSL certificates for instructions on how to communicate with the New Relic collector over HTTPS. Solution A Failures to connect via SSL typically appear early"
      },
      "id": "603e870428ccbc75adeba789"
    },
    {
      "sections": [
        "NullPointerException issues (Java)",
        "Problem",
        "Solution",
        "Cause"
      ],
      "title": "NullPointerException issues (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "63e8344e80548a51ddea70754c273d5c4e2c3a09",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/nullpointerexception-issues-java/",
      "published_at": "2021-05-05T07:06:37Z",
      "updated_at": "2021-03-16T09:15:49Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem If your log data shows SEVERE: or ERROR: with NullPointerException issues, there may be issues that are interfering with reporting. Solution Before you begin these troubleshooting tips, make sure you have the most recent version of New Relic's Java agent. Use case-sensitive searches of your Java agent log file for lines with SEVERE: and ERROR: NullPointerException. If you find any lines with these messages, gather troubleshooting information to get support at New Relic. Cause New Relic's Java agent between versions 3.0.0 and 3.2.3 would incorrectly log the error messages. For example: ERROR: javax/servlet/ServletOutputStream is marked as a weaved class, but no methods are matched to be weaved. Copy This was entirely erroneous and is not a cause for concern. However, do not use these versions. Instead, update to the most recent version of New Relic's Java agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 91.61145,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "NullPointerException issues (<em>Java</em>)",
        "sections": "NullPointerException issues (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Problem If your log data shows SEVERE: or ERROR: with NullPointerException issues, there may be issues that are interfering with reporting. Solution Before you begin these <em>troubleshooting</em> tips, make sure you have the most recent version of New Relic&#x27;s <em>Java</em> <em>agent</em>. Use case-sensitive searches of your"
      },
      "id": "603e869f64441ff9774e889e"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/no-log-file-java": [
    {
      "sections": [
        "Generate debug logs for troubleshooting (Java)",
        "Requirements",
        "Generate log files",
        "Examine log files",
        "Important",
        "For more help"
      ],
      "title": "Generate debug logs for troubleshooting (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "9ce3ec94630795156f9effc1f3c07c15a73f8b77",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/generate-debug-logs-troubleshooting-java/",
      "published_at": "2021-05-05T06:58:46Z",
      "updated_at": "2021-03-16T14:48:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When troubleshooting your New Relic Java agent, generate finest logs to find and investigate errors. When finished troubleshooting, be sure to set the log file back to a less verbose setting, such as info. Requirements If you only change the log file setting in your newrelic.yml file, you do not need to restart the server or JVM. However, if you make any other changes, you must restart your server or JVM. Be sure you keep the original line indentation in your newrelic.yml file. YAML is \"space sensitive\" and requires proper indentation. The audit_mode setting (when set to true ) will also log communication between the Java agent and New Relic to the log file. New Relic Support may occasionally request audit mode logs for additional troubleshooting. Generate log files To generate detailed finest log files: Edit your newrelic.yml file, and change the log_level to finest. Be sure to keep these lines indented two spaces. # The agent uses its own log file to keep its logging # separate from that of your application. Specify the log level here. # This setting is dynamic, so changes do not require restarting your application. # The levels in increasing order of verboseness are: # off, severe, warning, info, fine, finer, finest # Default is info. log_level: finest # Log all data sent to and from New Relic in plain text. # This setting is dynamic, so changes do not require restarting your application. # Default is false. audit_mode: false Copy Exercise your web application for about five minutes to generate sufficient logging data. After testing, change the log_level to a less verbose level, such as info (default). Open your log files and examine them for errors. Examine log files Important The finest log setting is a highly verbose logging level. To reduce disk space consumption after testing, return the log_level to its original setting. By default, log files are stored in a logs sub-directory, inside the same directory as newrelic.jar. If necessary, follow the troubleshooting procedures if no log files appear. For more help For logging on all New Relic agents, see New Relic agent logs and troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.56291,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Generate debug logs for <em>troubleshooting</em> (<em>Java</em>)",
        "sections": "Generate debug logs for <em>troubleshooting</em> (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "When <em>troubleshooting</em> your New Relic <em>Java</em> <em>agent</em>, generate finest logs to find and investigate errors. When finished <em>troubleshooting</em>, be sure to set the log file back to a less verbose setting, such as info. Requirements If you only change the log file setting in your newrelic.yml file, you do"
      },
      "id": "603eb64ae7b9d2e15e2a07e7"
    },
    {
      "sections": [
        "SSL or connection errors (Java)",
        "Problem A: SSL/connection errors in logs",
        "Tip",
        "Solution A",
        "Problem B: logs show exception",
        "Solution B"
      ],
      "title": "SSL or connection errors (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "0e5af5c4f29a8e7b75f4c4c61235952f91624fc1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/ssl-or-connection-errors-java/",
      "published_at": "2021-05-05T06:44:58Z",
      "updated_at": "2021-04-05T10:48:22Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem A: SSL/connection errors in logs Your New Relic Java agent's log data shows SSL or connection errors. Tip See Configuring your SSL certificates for instructions on how to communicate with the New Relic collector over HTTPS. Solution A Failures to connect via SSL typically appear early in the Java agent's log files. For example: PKIX path building failed: java.security.cert.CertPathBuilderException: PKIXCertPathBuilderImpl could not build a valid CertPath Copy INFO: connection error: java.net.SocketException: java.lang.ClassNotFoundException: Cannot find the specified class com.ibm.websphere.ssl.protocol.SSLSocketFactory Copy If you see either of these errors, your JDK instance probably is using a customized trust store. Recommendation: Add the DigiCert Global Root Certificate Authority (CA), from which New Relic's certificate is derived, to your trust store. You can download the DigiCert Global Root CA from DigiCert (choose the \"Download PEM\" option). To import the cert to your trust store, use this command, or see Oracle's Java SE documentation for keytool: keytool -importcert -alias ca_alias -file ca_file.pem -keystore truststore.ts -storepass ts_password Copy Parameters include: Parameter Description ca_alias The alias you want to use in your trust store for the imported cert. ca_file The file containing the cert you are adding. truststore.ts The trust store to which the cert will be added. ts_password The password used by truststore.ts. Problem B: logs show exception Your New Relic Java agent's log data shows the following CertificateException. java.security.cert.CertificateException: Could not parse certificate: java.io.IOException: Illegal header: -----BEGIN CERTIFICATE----- Copy This is most likely related to this JDK issue. Solution B Examine and validate that the header and footer of your certificates do not have trailing whitespaces. If they do, edit or use different certificates.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 92.03755,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "SSL or connection errors (<em>Java</em>)",
        "sections": "SSL or connection errors (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Problem A: SSL&#x2F;connection errors in logs Your New Relic <em>Java</em> <em>agent</em>&#x27;s log data shows SSL or connection errors. Tip See Configuring your SSL certificates for instructions on how to communicate with the New Relic collector over HTTPS. Solution A Failures to connect via SSL typically appear early"
      },
      "id": "603e870428ccbc75adeba789"
    },
    {
      "sections": [
        "NullPointerException issues (Java)",
        "Problem",
        "Solution",
        "Cause"
      ],
      "title": "NullPointerException issues (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "63e8344e80548a51ddea70754c273d5c4e2c3a09",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/nullpointerexception-issues-java/",
      "published_at": "2021-05-05T07:06:37Z",
      "updated_at": "2021-03-16T09:15:49Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem If your log data shows SEVERE: or ERROR: with NullPointerException issues, there may be issues that are interfering with reporting. Solution Before you begin these troubleshooting tips, make sure you have the most recent version of New Relic's Java agent. Use case-sensitive searches of your Java agent log file for lines with SEVERE: and ERROR: NullPointerException. If you find any lines with these messages, gather troubleshooting information to get support at New Relic. Cause New Relic's Java agent between versions 3.0.0 and 3.2.3 would incorrectly log the error messages. For example: ERROR: javax/servlet/ServletOutputStream is marked as a weaved class, but no methods are matched to be weaved. Copy This was entirely erroneous and is not a cause for concern. However, do not use these versions. Instead, update to the most recent version of New Relic's Java agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 91.61145,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "NullPointerException issues (<em>Java</em>)",
        "sections": "NullPointerException issues (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Problem If your log data shows SEVERE: or ERROR: with NullPointerException issues, there may be issues that are interfering with reporting. Solution Before you begin these <em>troubleshooting</em> tips, make sure you have the most recent version of New Relic&#x27;s <em>Java</em> <em>agent</em>. Use case-sensitive searches of your"
      },
      "id": "603e869f64441ff9774e889e"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/no-stack-traces-java": [
    {
      "sections": [
        "Generate debug logs for troubleshooting (Java)",
        "Requirements",
        "Generate log files",
        "Examine log files",
        "Important",
        "For more help"
      ],
      "title": "Generate debug logs for troubleshooting (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "9ce3ec94630795156f9effc1f3c07c15a73f8b77",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/generate-debug-logs-troubleshooting-java/",
      "published_at": "2021-05-05T06:58:46Z",
      "updated_at": "2021-03-16T14:48:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When troubleshooting your New Relic Java agent, generate finest logs to find and investigate errors. When finished troubleshooting, be sure to set the log file back to a less verbose setting, such as info. Requirements If you only change the log file setting in your newrelic.yml file, you do not need to restart the server or JVM. However, if you make any other changes, you must restart your server or JVM. Be sure you keep the original line indentation in your newrelic.yml file. YAML is \"space sensitive\" and requires proper indentation. The audit_mode setting (when set to true ) will also log communication between the Java agent and New Relic to the log file. New Relic Support may occasionally request audit mode logs for additional troubleshooting. Generate log files To generate detailed finest log files: Edit your newrelic.yml file, and change the log_level to finest. Be sure to keep these lines indented two spaces. # The agent uses its own log file to keep its logging # separate from that of your application. Specify the log level here. # This setting is dynamic, so changes do not require restarting your application. # The levels in increasing order of verboseness are: # off, severe, warning, info, fine, finer, finest # Default is info. log_level: finest # Log all data sent to and from New Relic in plain text. # This setting is dynamic, so changes do not require restarting your application. # Default is false. audit_mode: false Copy Exercise your web application for about five minutes to generate sufficient logging data. After testing, change the log_level to a less verbose level, such as info (default). Open your log files and examine them for errors. Examine log files Important The finest log setting is a highly verbose logging level. To reduce disk space consumption after testing, return the log_level to its original setting. By default, log files are stored in a logs sub-directory, inside the same directory as newrelic.jar. If necessary, follow the troubleshooting procedures if no log files appear. For more help For logging on all New Relic agents, see New Relic agent logs and troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.56291,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Generate debug logs for <em>troubleshooting</em> (<em>Java</em>)",
        "sections": "Generate debug logs for <em>troubleshooting</em> (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "When <em>troubleshooting</em> your New Relic <em>Java</em> <em>agent</em>, generate finest logs to find and investigate errors. When finished <em>troubleshooting</em>, be sure to set the log file back to a less verbose setting, such as info. Requirements If you only change the log file setting in your newrelic.yml file, you do"
      },
      "id": "603eb64ae7b9d2e15e2a07e7"
    },
    {
      "sections": [
        "SSL or connection errors (Java)",
        "Problem A: SSL/connection errors in logs",
        "Tip",
        "Solution A",
        "Problem B: logs show exception",
        "Solution B"
      ],
      "title": "SSL or connection errors (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "0e5af5c4f29a8e7b75f4c4c61235952f91624fc1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/ssl-or-connection-errors-java/",
      "published_at": "2021-05-05T06:44:58Z",
      "updated_at": "2021-04-05T10:48:22Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem A: SSL/connection errors in logs Your New Relic Java agent's log data shows SSL or connection errors. Tip See Configuring your SSL certificates for instructions on how to communicate with the New Relic collector over HTTPS. Solution A Failures to connect via SSL typically appear early in the Java agent's log files. For example: PKIX path building failed: java.security.cert.CertPathBuilderException: PKIXCertPathBuilderImpl could not build a valid CertPath Copy INFO: connection error: java.net.SocketException: java.lang.ClassNotFoundException: Cannot find the specified class com.ibm.websphere.ssl.protocol.SSLSocketFactory Copy If you see either of these errors, your JDK instance probably is using a customized trust store. Recommendation: Add the DigiCert Global Root Certificate Authority (CA), from which New Relic's certificate is derived, to your trust store. You can download the DigiCert Global Root CA from DigiCert (choose the \"Download PEM\" option). To import the cert to your trust store, use this command, or see Oracle's Java SE documentation for keytool: keytool -importcert -alias ca_alias -file ca_file.pem -keystore truststore.ts -storepass ts_password Copy Parameters include: Parameter Description ca_alias The alias you want to use in your trust store for the imported cert. ca_file The file containing the cert you are adding. truststore.ts The trust store to which the cert will be added. ts_password The password used by truststore.ts. Problem B: logs show exception Your New Relic Java agent's log data shows the following CertificateException. java.security.cert.CertificateException: Could not parse certificate: java.io.IOException: Illegal header: -----BEGIN CERTIFICATE----- Copy This is most likely related to this JDK issue. Solution B Examine and validate that the header and footer of your certificates do not have trailing whitespaces. If they do, edit or use different certificates.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 92.037544,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "SSL or connection errors (<em>Java</em>)",
        "sections": "SSL or connection errors (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Problem A: SSL&#x2F;connection errors in logs Your New Relic <em>Java</em> <em>agent</em>&#x27;s log data shows SSL or connection errors. Tip See Configuring your SSL certificates for instructions on how to communicate with the New Relic collector over HTTPS. Solution A Failures to connect via SSL typically appear early"
      },
      "id": "603e870428ccbc75adeba789"
    },
    {
      "sections": [
        "NullPointerException issues (Java)",
        "Problem",
        "Solution",
        "Cause"
      ],
      "title": "NullPointerException issues (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "63e8344e80548a51ddea70754c273d5c4e2c3a09",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/nullpointerexception-issues-java/",
      "published_at": "2021-05-05T07:06:37Z",
      "updated_at": "2021-03-16T09:15:49Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem If your log data shows SEVERE: or ERROR: with NullPointerException issues, there may be issues that are interfering with reporting. Solution Before you begin these troubleshooting tips, make sure you have the most recent version of New Relic's Java agent. Use case-sensitive searches of your Java agent log file for lines with SEVERE: and ERROR: NullPointerException. If you find any lines with these messages, gather troubleshooting information to get support at New Relic. Cause New Relic's Java agent between versions 3.0.0 and 3.2.3 would incorrectly log the error messages. For example: ERROR: javax/servlet/ServletOutputStream is marked as a weaved class, but no methods are matched to be weaved. Copy This was entirely erroneous and is not a cause for concern. However, do not use these versions. Instead, update to the most recent version of New Relic's Java agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 91.61145,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "NullPointerException issues (<em>Java</em>)",
        "sections": "NullPointerException issues (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Problem If your log data shows SEVERE: or ERROR: with NullPointerException issues, there may be issues that are interfering with reporting. Solution Before you begin these <em>troubleshooting</em> tips, make sure you have the most recent version of New Relic&#x27;s <em>Java</em> <em>agent</em>. Use case-sensitive searches of your"
      },
      "id": "603e869f64441ff9774e889e"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/nullpointerexception-issues-java": [
    {
      "sections": [
        "Generate debug logs for troubleshooting (Java)",
        "Requirements",
        "Generate log files",
        "Examine log files",
        "Important",
        "For more help"
      ],
      "title": "Generate debug logs for troubleshooting (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "9ce3ec94630795156f9effc1f3c07c15a73f8b77",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/generate-debug-logs-troubleshooting-java/",
      "published_at": "2021-05-05T06:58:46Z",
      "updated_at": "2021-03-16T14:48:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When troubleshooting your New Relic Java agent, generate finest logs to find and investigate errors. When finished troubleshooting, be sure to set the log file back to a less verbose setting, such as info. Requirements If you only change the log file setting in your newrelic.yml file, you do not need to restart the server or JVM. However, if you make any other changes, you must restart your server or JVM. Be sure you keep the original line indentation in your newrelic.yml file. YAML is \"space sensitive\" and requires proper indentation. The audit_mode setting (when set to true ) will also log communication between the Java agent and New Relic to the log file. New Relic Support may occasionally request audit mode logs for additional troubleshooting. Generate log files To generate detailed finest log files: Edit your newrelic.yml file, and change the log_level to finest. Be sure to keep these lines indented two spaces. # The agent uses its own log file to keep its logging # separate from that of your application. Specify the log level here. # This setting is dynamic, so changes do not require restarting your application. # The levels in increasing order of verboseness are: # off, severe, warning, info, fine, finer, finest # Default is info. log_level: finest # Log all data sent to and from New Relic in plain text. # This setting is dynamic, so changes do not require restarting your application. # Default is false. audit_mode: false Copy Exercise your web application for about five minutes to generate sufficient logging data. After testing, change the log_level to a less verbose level, such as info (default). Open your log files and examine them for errors. Examine log files Important The finest log setting is a highly verbose logging level. To reduce disk space consumption after testing, return the log_level to its original setting. By default, log files are stored in a logs sub-directory, inside the same directory as newrelic.jar. If necessary, follow the troubleshooting procedures if no log files appear. For more help For logging on all New Relic agents, see New Relic agent logs and troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.56291,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Generate debug logs for <em>troubleshooting</em> (<em>Java</em>)",
        "sections": "Generate debug logs for <em>troubleshooting</em> (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "When <em>troubleshooting</em> your New Relic <em>Java</em> <em>agent</em>, generate finest logs to find and investigate errors. When finished <em>troubleshooting</em>, be sure to set the log file back to a less verbose setting, such as info. Requirements If you only change the log file setting in your newrelic.yml file, you do"
      },
      "id": "603eb64ae7b9d2e15e2a07e7"
    },
    {
      "sections": [
        "SSL or connection errors (Java)",
        "Problem A: SSL/connection errors in logs",
        "Tip",
        "Solution A",
        "Problem B: logs show exception",
        "Solution B"
      ],
      "title": "SSL or connection errors (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "0e5af5c4f29a8e7b75f4c4c61235952f91624fc1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/ssl-or-connection-errors-java/",
      "published_at": "2021-05-05T06:44:58Z",
      "updated_at": "2021-04-05T10:48:22Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem A: SSL/connection errors in logs Your New Relic Java agent's log data shows SSL or connection errors. Tip See Configuring your SSL certificates for instructions on how to communicate with the New Relic collector over HTTPS. Solution A Failures to connect via SSL typically appear early in the Java agent's log files. For example: PKIX path building failed: java.security.cert.CertPathBuilderException: PKIXCertPathBuilderImpl could not build a valid CertPath Copy INFO: connection error: java.net.SocketException: java.lang.ClassNotFoundException: Cannot find the specified class com.ibm.websphere.ssl.protocol.SSLSocketFactory Copy If you see either of these errors, your JDK instance probably is using a customized trust store. Recommendation: Add the DigiCert Global Root Certificate Authority (CA), from which New Relic's certificate is derived, to your trust store. You can download the DigiCert Global Root CA from DigiCert (choose the \"Download PEM\" option). To import the cert to your trust store, use this command, or see Oracle's Java SE documentation for keytool: keytool -importcert -alias ca_alias -file ca_file.pem -keystore truststore.ts -storepass ts_password Copy Parameters include: Parameter Description ca_alias The alias you want to use in your trust store for the imported cert. ca_file The file containing the cert you are adding. truststore.ts The trust store to which the cert will be added. ts_password The password used by truststore.ts. Problem B: logs show exception Your New Relic Java agent's log data shows the following CertificateException. java.security.cert.CertificateException: Could not parse certificate: java.io.IOException: Illegal header: -----BEGIN CERTIFICATE----- Copy This is most likely related to this JDK issue. Solution B Examine and validate that the header and footer of your certificates do not have trailing whitespaces. If they do, edit or use different certificates.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 92.037544,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "SSL or connection errors (<em>Java</em>)",
        "sections": "SSL or connection errors (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Problem A: SSL&#x2F;connection errors in logs Your New Relic <em>Java</em> <em>agent</em>&#x27;s log data shows SSL or connection errors. Tip See Configuring your SSL certificates for instructions on how to communicate with the New Relic collector over HTTPS. Solution A Failures to connect via SSL typically appear early"
      },
      "id": "603e870428ccbc75adeba789"
    },
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Requirements",
        "Important",
        "Installation",
        "Tip",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-05-05T07:03:34Z",
      "updated_at": "2021-03-30T15:01:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The New Relic JFR daemon runs as its own Java process and monitors a JVM for JFR events over remote JMX. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. On startup the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic Java agent. If the Java agent is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the agent will then report to the same APM entity. If the the Java agent is not detected, then the daemon will report as a unique entity under the app name that you configured for it. Requirements Requirements include: Java 8 (version 8u262+) or higher for both the JFR daemon process, and the application process An Insights insert API key or an APM license key. JFR daemon jar. Required for flamegraphs, otherwise optional but recommended: Install of New Relic Java agent version 6.1.0 or higher on your JVM. The JFR daemon can run without a Java agent being included, but if the Java agent is present it will combine agent and daemon data into a single APM application. Important Apps running with the JFR daemon should expect the JFR subsystem to use about 150MB of additional memory. Installation The application that you wish to monitor with the JFR daemon must be configured to expose JFR data over remote JMX by adding the following system properties: -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false Copy Tip By default, the JFR daemon will connect via JMX to localhost on port 1099 and send data to New Relic's US production metric and event ingest endpoints. Additionally, if you need the JFR daemon to report through a proxy that will require special configuration settings. To configure the JFR daemon's behavior, please see the fully documented configuration options. To use the JFR daemon: Download the latest version of the JFR daemon jar: jfr-daemon-n.n.n.jar. Register an Insert API key or an APM license key for publishing data to New Relic. Required: Assign your key to the INSIGHTS_INSERT_KEY environment variable. If you are using an APM license key then you will also need to set the USE_LICENSE_KEY=true environment variable. Recommended: Set the name of the application being monitored to the NEW_RELIC_APP_NAME environment variable. If this is not set, then the default app name will be used instead. Start your application and the JFR daemon: java -jar jfr-daemon-n.n.n.jar Copy Optional (but recommended): Include the Java agent: Install Java agent version 6.1.0 or higher to monitor your application. Configure the Java agent to allow it to communicate with the JMX daemon by adding the following configuration to the newrelic.yml configuration file: jmx: enabled: true linkingMetadataMBean: true Copy Tip Enabling linkingMetadataMBean allows the JFR daemon to acquire the entity GUID that was generated by the Java agent for the application. If the entity GUID is successfully acquired, then data collected by the daemon will be reported to the same application as the Java agent. Any name configured for the daemon using NEW_RELIC_APP_NAMEwould be overridden in favor of the name specified by the agent. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Requirements: Early access to our flamegraphs feature is available upon request. All other real-time profiling features are available by default. To request this early access, please email flamegraph@newrelic.com. At this time, this requires deployment of both the JFR daemon and Java agent and the daemon must be reporting as the same entity as the agent. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your application’s overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 89.831245,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where you’re wasting resources When"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/resolve-metric-grouping-issues-java-apps": [
    {
      "sections": [
        "Generate debug logs for troubleshooting (Java)",
        "Requirements",
        "Generate log files",
        "Examine log files",
        "Important",
        "For more help"
      ],
      "title": "Generate debug logs for troubleshooting (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "9ce3ec94630795156f9effc1f3c07c15a73f8b77",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/generate-debug-logs-troubleshooting-java/",
      "published_at": "2021-05-05T06:58:46Z",
      "updated_at": "2021-03-16T14:48:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When troubleshooting your New Relic Java agent, generate finest logs to find and investigate errors. When finished troubleshooting, be sure to set the log file back to a less verbose setting, such as info. Requirements If you only change the log file setting in your newrelic.yml file, you do not need to restart the server or JVM. However, if you make any other changes, you must restart your server or JVM. Be sure you keep the original line indentation in your newrelic.yml file. YAML is \"space sensitive\" and requires proper indentation. The audit_mode setting (when set to true ) will also log communication between the Java agent and New Relic to the log file. New Relic Support may occasionally request audit mode logs for additional troubleshooting. Generate log files To generate detailed finest log files: Edit your newrelic.yml file, and change the log_level to finest. Be sure to keep these lines indented two spaces. # The agent uses its own log file to keep its logging # separate from that of your application. Specify the log level here. # This setting is dynamic, so changes do not require restarting your application. # The levels in increasing order of verboseness are: # off, severe, warning, info, fine, finer, finest # Default is info. log_level: finest # Log all data sent to and from New Relic in plain text. # This setting is dynamic, so changes do not require restarting your application. # Default is false. audit_mode: false Copy Exercise your web application for about five minutes to generate sufficient logging data. After testing, change the log_level to a less verbose level, such as info (default). Open your log files and examine them for errors. Examine log files Important The finest log setting is a highly verbose logging level. To reduce disk space consumption after testing, return the log_level to its original setting. By default, log files are stored in a logs sub-directory, inside the same directory as newrelic.jar. If necessary, follow the troubleshooting procedures if no log files appear. For more help For logging on all New Relic agents, see New Relic agent logs and troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.56291,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Generate debug logs for <em>troubleshooting</em> (<em>Java</em>)",
        "sections": "Generate debug logs for <em>troubleshooting</em> (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "When <em>troubleshooting</em> your New Relic <em>Java</em> <em>agent</em>, generate finest logs to find and investigate errors. When finished <em>troubleshooting</em>, be sure to set the log file back to a less verbose setting, such as info. Requirements If you only change the log file setting in your newrelic.yml file, you do"
      },
      "id": "603eb64ae7b9d2e15e2a07e7"
    },
    {
      "sections": [
        "SSL or connection errors (Java)",
        "Problem A: SSL/connection errors in logs",
        "Tip",
        "Solution A",
        "Problem B: logs show exception",
        "Solution B"
      ],
      "title": "SSL or connection errors (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "0e5af5c4f29a8e7b75f4c4c61235952f91624fc1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/ssl-or-connection-errors-java/",
      "published_at": "2021-05-05T06:44:58Z",
      "updated_at": "2021-04-05T10:48:22Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem A: SSL/connection errors in logs Your New Relic Java agent's log data shows SSL or connection errors. Tip See Configuring your SSL certificates for instructions on how to communicate with the New Relic collector over HTTPS. Solution A Failures to connect via SSL typically appear early in the Java agent's log files. For example: PKIX path building failed: java.security.cert.CertPathBuilderException: PKIXCertPathBuilderImpl could not build a valid CertPath Copy INFO: connection error: java.net.SocketException: java.lang.ClassNotFoundException: Cannot find the specified class com.ibm.websphere.ssl.protocol.SSLSocketFactory Copy If you see either of these errors, your JDK instance probably is using a customized trust store. Recommendation: Add the DigiCert Global Root Certificate Authority (CA), from which New Relic's certificate is derived, to your trust store. You can download the DigiCert Global Root CA from DigiCert (choose the \"Download PEM\" option). To import the cert to your trust store, use this command, or see Oracle's Java SE documentation for keytool: keytool -importcert -alias ca_alias -file ca_file.pem -keystore truststore.ts -storepass ts_password Copy Parameters include: Parameter Description ca_alias The alias you want to use in your trust store for the imported cert. ca_file The file containing the cert you are adding. truststore.ts The trust store to which the cert will be added. ts_password The password used by truststore.ts. Problem B: logs show exception Your New Relic Java agent's log data shows the following CertificateException. java.security.cert.CertificateException: Could not parse certificate: java.io.IOException: Illegal header: -----BEGIN CERTIFICATE----- Copy This is most likely related to this JDK issue. Solution B Examine and validate that the header and footer of your certificates do not have trailing whitespaces. If they do, edit or use different certificates.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 92.03754,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "SSL or connection errors (<em>Java</em>)",
        "sections": "SSL or connection errors (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Problem A: SSL&#x2F;connection errors in logs Your New Relic <em>Java</em> <em>agent</em>&#x27;s log data shows SSL or connection errors. Tip See Configuring your SSL certificates for instructions on how to communicate with the New Relic collector over HTTPS. Solution A Failures to connect via SSL typically appear early"
      },
      "id": "603e870428ccbc75adeba789"
    },
    {
      "sections": [
        "NullPointerException issues (Java)",
        "Problem",
        "Solution",
        "Cause"
      ],
      "title": "NullPointerException issues (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "63e8344e80548a51ddea70754c273d5c4e2c3a09",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/nullpointerexception-issues-java/",
      "published_at": "2021-05-05T07:06:37Z",
      "updated_at": "2021-03-16T09:15:49Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem If your log data shows SEVERE: or ERROR: with NullPointerException issues, there may be issues that are interfering with reporting. Solution Before you begin these troubleshooting tips, make sure you have the most recent version of New Relic's Java agent. Use case-sensitive searches of your Java agent log file for lines with SEVERE: and ERROR: NullPointerException. If you find any lines with these messages, gather troubleshooting information to get support at New Relic. Cause New Relic's Java agent between versions 3.0.0 and 3.2.3 would incorrectly log the error messages. For example: ERROR: javax/servlet/ServletOutputStream is marked as a weaved class, but no methods are matched to be weaved. Copy This was entirely erroneous and is not a cause for concern. However, do not use these versions. Instead, update to the most recent version of New Relic's Java agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 91.61144,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "NullPointerException issues (<em>Java</em>)",
        "sections": "NullPointerException issues (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Problem If your log data shows SEVERE: or ERROR: with NullPointerException issues, there may be issues that are interfering with reporting. Solution Before you begin these <em>troubleshooting</em> tips, make sure you have the most recent version of New Relic&#x27;s <em>Java</em> <em>agent</em>. Use case-sensitive searches of your"
      },
      "id": "603e869f64441ff9774e889e"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/ssl-or-connection-errors-java": [
    {
      "sections": [
        "Generate debug logs for troubleshooting (Java)",
        "Requirements",
        "Generate log files",
        "Examine log files",
        "Important",
        "For more help"
      ],
      "title": "Generate debug logs for troubleshooting (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "9ce3ec94630795156f9effc1f3c07c15a73f8b77",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/generate-debug-logs-troubleshooting-java/",
      "published_at": "2021-05-05T06:58:46Z",
      "updated_at": "2021-03-16T14:48:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When troubleshooting your New Relic Java agent, generate finest logs to find and investigate errors. When finished troubleshooting, be sure to set the log file back to a less verbose setting, such as info. Requirements If you only change the log file setting in your newrelic.yml file, you do not need to restart the server or JVM. However, if you make any other changes, you must restart your server or JVM. Be sure you keep the original line indentation in your newrelic.yml file. YAML is \"space sensitive\" and requires proper indentation. The audit_mode setting (when set to true ) will also log communication between the Java agent and New Relic to the log file. New Relic Support may occasionally request audit mode logs for additional troubleshooting. Generate log files To generate detailed finest log files: Edit your newrelic.yml file, and change the log_level to finest. Be sure to keep these lines indented two spaces. # The agent uses its own log file to keep its logging # separate from that of your application. Specify the log level here. # This setting is dynamic, so changes do not require restarting your application. # The levels in increasing order of verboseness are: # off, severe, warning, info, fine, finer, finest # Default is info. log_level: finest # Log all data sent to and from New Relic in plain text. # This setting is dynamic, so changes do not require restarting your application. # Default is false. audit_mode: false Copy Exercise your web application for about five minutes to generate sufficient logging data. After testing, change the log_level to a less verbose level, such as info (default). Open your log files and examine them for errors. Examine log files Important The finest log setting is a highly verbose logging level. To reduce disk space consumption after testing, return the log_level to its original setting. By default, log files are stored in a logs sub-directory, inside the same directory as newrelic.jar. If necessary, follow the troubleshooting procedures if no log files appear. For more help For logging on all New Relic agents, see New Relic agent logs and troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.56291,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Generate debug logs for <em>troubleshooting</em> (<em>Java</em>)",
        "sections": "Generate debug logs for <em>troubleshooting</em> (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "When <em>troubleshooting</em> your New Relic <em>Java</em> <em>agent</em>, generate finest logs to find and investigate errors. When finished <em>troubleshooting</em>, be sure to set the log file back to a less verbose setting, such as info. Requirements If you only change the log file setting in your newrelic.yml file, you do"
      },
      "id": "603eb64ae7b9d2e15e2a07e7"
    },
    {
      "sections": [
        "NullPointerException issues (Java)",
        "Problem",
        "Solution",
        "Cause"
      ],
      "title": "NullPointerException issues (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "63e8344e80548a51ddea70754c273d5c4e2c3a09",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/nullpointerexception-issues-java/",
      "published_at": "2021-05-05T07:06:37Z",
      "updated_at": "2021-03-16T09:15:49Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem If your log data shows SEVERE: or ERROR: with NullPointerException issues, there may be issues that are interfering with reporting. Solution Before you begin these troubleshooting tips, make sure you have the most recent version of New Relic's Java agent. Use case-sensitive searches of your Java agent log file for lines with SEVERE: and ERROR: NullPointerException. If you find any lines with these messages, gather troubleshooting information to get support at New Relic. Cause New Relic's Java agent between versions 3.0.0 and 3.2.3 would incorrectly log the error messages. For example: ERROR: javax/servlet/ServletOutputStream is marked as a weaved class, but no methods are matched to be weaved. Copy This was entirely erroneous and is not a cause for concern. However, do not use these versions. Instead, update to the most recent version of New Relic's Java agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 91.61144,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "NullPointerException issues (<em>Java</em>)",
        "sections": "NullPointerException issues (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Problem If your log data shows SEVERE: or ERROR: with NullPointerException issues, there may be issues that are interfering with reporting. Solution Before you begin these <em>troubleshooting</em> tips, make sure you have the most recent version of New Relic&#x27;s <em>Java</em> <em>agent</em>. Use case-sensitive searches of your"
      },
      "id": "603e869f64441ff9774e889e"
    },
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Requirements",
        "Important",
        "Installation",
        "Tip",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-05-05T07:03:34Z",
      "updated_at": "2021-03-30T15:01:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The New Relic JFR daemon runs as its own Java process and monitors a JVM for JFR events over remote JMX. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. On startup the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic Java agent. If the Java agent is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the agent will then report to the same APM entity. If the the Java agent is not detected, then the daemon will report as a unique entity under the app name that you configured for it. Requirements Requirements include: Java 8 (version 8u262+) or higher for both the JFR daemon process, and the application process An Insights insert API key or an APM license key. JFR daemon jar. Required for flamegraphs, otherwise optional but recommended: Install of New Relic Java agent version 6.1.0 or higher on your JVM. The JFR daemon can run without a Java agent being included, but if the Java agent is present it will combine agent and daemon data into a single APM application. Important Apps running with the JFR daemon should expect the JFR subsystem to use about 150MB of additional memory. Installation The application that you wish to monitor with the JFR daemon must be configured to expose JFR data over remote JMX by adding the following system properties: -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false Copy Tip By default, the JFR daemon will connect via JMX to localhost on port 1099 and send data to New Relic's US production metric and event ingest endpoints. Additionally, if you need the JFR daemon to report through a proxy that will require special configuration settings. To configure the JFR daemon's behavior, please see the fully documented configuration options. To use the JFR daemon: Download the latest version of the JFR daemon jar: jfr-daemon-n.n.n.jar. Register an Insert API key or an APM license key for publishing data to New Relic. Required: Assign your key to the INSIGHTS_INSERT_KEY environment variable. If you are using an APM license key then you will also need to set the USE_LICENSE_KEY=true environment variable. Recommended: Set the name of the application being monitored to the NEW_RELIC_APP_NAME environment variable. If this is not set, then the default app name will be used instead. Start your application and the JFR daemon: java -jar jfr-daemon-n.n.n.jar Copy Optional (but recommended): Include the Java agent: Install Java agent version 6.1.0 or higher to monitor your application. Configure the Java agent to allow it to communicate with the JMX daemon by adding the following configuration to the newrelic.yml configuration file: jmx: enabled: true linkingMetadataMBean: true Copy Tip Enabling linkingMetadataMBean allows the JFR daemon to acquire the entity GUID that was generated by the Java agent for the application. If the entity GUID is successfully acquired, then data collected by the daemon will be reported to the same application as the Java agent. Any name configured for the daemon using NEW_RELIC_APP_NAMEwould be overridden in favor of the name specified by the agent. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Requirements: Early access to our flamegraphs feature is available upon request. All other real-time profiling features are available by default. To request this early access, please email flamegraph@newrelic.com. At this time, this requires deployment of both the JFR daemon and Java agent and the daemon must be reporting as the same entity as the agent. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your application’s overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 89.83124,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where you’re wasting resources When"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/update-java-config-legacy-agent-versions": [
    {
      "sections": [
        "Generate debug logs for troubleshooting (Java)",
        "Requirements",
        "Generate log files",
        "Examine log files",
        "Important",
        "For more help"
      ],
      "title": "Generate debug logs for troubleshooting (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "9ce3ec94630795156f9effc1f3c07c15a73f8b77",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/generate-debug-logs-troubleshooting-java/",
      "published_at": "2021-05-05T06:58:46Z",
      "updated_at": "2021-03-16T14:48:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When troubleshooting your New Relic Java agent, generate finest logs to find and investigate errors. When finished troubleshooting, be sure to set the log file back to a less verbose setting, such as info. Requirements If you only change the log file setting in your newrelic.yml file, you do not need to restart the server or JVM. However, if you make any other changes, you must restart your server or JVM. Be sure you keep the original line indentation in your newrelic.yml file. YAML is \"space sensitive\" and requires proper indentation. The audit_mode setting (when set to true ) will also log communication between the Java agent and New Relic to the log file. New Relic Support may occasionally request audit mode logs for additional troubleshooting. Generate log files To generate detailed finest log files: Edit your newrelic.yml file, and change the log_level to finest. Be sure to keep these lines indented two spaces. # The agent uses its own log file to keep its logging # separate from that of your application. Specify the log level here. # This setting is dynamic, so changes do not require restarting your application. # The levels in increasing order of verboseness are: # off, severe, warning, info, fine, finer, finest # Default is info. log_level: finest # Log all data sent to and from New Relic in plain text. # This setting is dynamic, so changes do not require restarting your application. # Default is false. audit_mode: false Copy Exercise your web application for about five minutes to generate sufficient logging data. After testing, change the log_level to a less verbose level, such as info (default). Open your log files and examine them for errors. Examine log files Important The finest log setting is a highly verbose logging level. To reduce disk space consumption after testing, return the log_level to its original setting. By default, log files are stored in a logs sub-directory, inside the same directory as newrelic.jar. If necessary, follow the troubleshooting procedures if no log files appear. For more help For logging on all New Relic agents, see New Relic agent logs and troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.56291,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Generate debug logs for <em>troubleshooting</em> (<em>Java</em>)",
        "sections": "Generate debug logs for <em>troubleshooting</em> (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "When <em>troubleshooting</em> your New Relic <em>Java</em> <em>agent</em>, generate finest logs to find and investigate errors. When finished <em>troubleshooting</em>, be sure to set the log file back to a less verbose setting, such as info. Requirements If you only change the log file setting in your newrelic.yml file, you do"
      },
      "id": "603eb64ae7b9d2e15e2a07e7"
    },
    {
      "sections": [
        "SSL or connection errors (Java)",
        "Problem A: SSL/connection errors in logs",
        "Tip",
        "Solution A",
        "Problem B: logs show exception",
        "Solution B"
      ],
      "title": "SSL or connection errors (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "0e5af5c4f29a8e7b75f4c4c61235952f91624fc1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/ssl-or-connection-errors-java/",
      "published_at": "2021-05-05T06:44:58Z",
      "updated_at": "2021-04-05T10:48:22Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem A: SSL/connection errors in logs Your New Relic Java agent's log data shows SSL or connection errors. Tip See Configuring your SSL certificates for instructions on how to communicate with the New Relic collector over HTTPS. Solution A Failures to connect via SSL typically appear early in the Java agent's log files. For example: PKIX path building failed: java.security.cert.CertPathBuilderException: PKIXCertPathBuilderImpl could not build a valid CertPath Copy INFO: connection error: java.net.SocketException: java.lang.ClassNotFoundException: Cannot find the specified class com.ibm.websphere.ssl.protocol.SSLSocketFactory Copy If you see either of these errors, your JDK instance probably is using a customized trust store. Recommendation: Add the DigiCert Global Root Certificate Authority (CA), from which New Relic's certificate is derived, to your trust store. You can download the DigiCert Global Root CA from DigiCert (choose the \"Download PEM\" option). To import the cert to your trust store, use this command, or see Oracle's Java SE documentation for keytool: keytool -importcert -alias ca_alias -file ca_file.pem -keystore truststore.ts -storepass ts_password Copy Parameters include: Parameter Description ca_alias The alias you want to use in your trust store for the imported cert. ca_file The file containing the cert you are adding. truststore.ts The trust store to which the cert will be added. ts_password The password used by truststore.ts. Problem B: logs show exception Your New Relic Java agent's log data shows the following CertificateException. java.security.cert.CertificateException: Could not parse certificate: java.io.IOException: Illegal header: -----BEGIN CERTIFICATE----- Copy This is most likely related to this JDK issue. Solution B Examine and validate that the header and footer of your certificates do not have trailing whitespaces. If they do, edit or use different certificates.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 92.03753,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "SSL or connection errors (<em>Java</em>)",
        "sections": "SSL or connection errors (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Problem A: SSL&#x2F;connection errors in logs Your New Relic <em>Java</em> <em>agent</em>&#x27;s log data shows SSL or connection errors. Tip See Configuring your SSL certificates for instructions on how to communicate with the New Relic collector over HTTPS. Solution A Failures to connect via SSL typically appear early"
      },
      "id": "603e870428ccbc75adeba789"
    },
    {
      "sections": [
        "NullPointerException issues (Java)",
        "Problem",
        "Solution",
        "Cause"
      ],
      "title": "NullPointerException issues (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "63e8344e80548a51ddea70754c273d5c4e2c3a09",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/nullpointerexception-issues-java/",
      "published_at": "2021-05-05T07:06:37Z",
      "updated_at": "2021-03-16T09:15:49Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem If your log data shows SEVERE: or ERROR: with NullPointerException issues, there may be issues that are interfering with reporting. Solution Before you begin these troubleshooting tips, make sure you have the most recent version of New Relic's Java agent. Use case-sensitive searches of your Java agent log file for lines with SEVERE: and ERROR: NullPointerException. If you find any lines with these messages, gather troubleshooting information to get support at New Relic. Cause New Relic's Java agent between versions 3.0.0 and 3.2.3 would incorrectly log the error messages. For example: ERROR: javax/servlet/ServletOutputStream is marked as a weaved class, but no methods are matched to be weaved. Copy This was entirely erroneous and is not a cause for concern. However, do not use these versions. Instead, update to the most recent version of New Relic's Java agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 91.61144,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "NullPointerException issues (<em>Java</em>)",
        "sections": "NullPointerException issues (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Problem If your log data shows SEVERE: or ERROR: with NullPointerException issues, there may be issues that are interfering with reporting. Solution Before you begin these <em>troubleshooting</em> tips, make sure you have the most recent version of New Relic&#x27;s <em>Java</em> <em>agent</em>. Use case-sensitive searches of your"
      },
      "id": "603e869f64441ff9774e889e"
    }
  ],
  "/docs/agents/manage-apm-agents/agent-data/agent-attributes": [
    {
      "sections": [
        "Server-side agent configuration",
        "Centralization and security",
        "Server-side configuration precedence",
        "Enable server-side configuration",
        "Tip",
        "View or change server-side configuration settings",
        "Disable server-side configuration"
      ],
      "title": "Server-side agent configuration",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Configuration"
      ],
      "external_id": "928ff211d9e5aa0e02dc64ed344e8cbbd3ea91b5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/configuration/server-side-agent-configuration/",
      "published_at": "2021-05-05T06:35:22Z",
      "updated_at": "2021-05-05T06:35:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Server-side configuration transitions some core settings from your language agent's configuration file to the New Relic collector. Depending on the language agent, available settings may include: Transaction tracing SQL recording and logging SQL query plans Error collection Thread profiling Distributed tracing Cross application tracing Centralization and security Server-side configuration provides an easy way to manage the available settings from the New Relic UI. Centralized configuration settings can also help you ensure standards compliance and security management for your settings. Any change automatically applies to all New Relic APM agents, even if they run across multiple hosts. The agent still follows the local configurations for any settings not available from the UI. Server-side configuration precedence This feature provides the convenience of managing the available configuration settings directly within the New Relic UI, without the need for deployments or restarts. Available options to change settings, and the order of precedence they take when you utilize environment variables or other configuration options, will depend on the language agent used. For more information about the hierarchy of settings, see the illustration for the specific agent: C SDK configuration: A hierarchy is not applicable, because configuration values come from API calls. Also, server-side configuration is not supported. However, you can change the app name from the UI or from the C SDK configuration settings. Go hierarchy Java hierarchy .NET hierarchy Node.js hierarchy PHP hierarchy (server-side configuration not supported) Python hierarchy Ruby hierarchy Enable server-side configuration Tip Owner, Admins, or Add-on Managers The C SDK and PHP agent do not support server-side configuration. To enable server-side configuration settings for apps that use other New Relic agents: Go to rpm.newrelic.com/apm > (select an app) > Settings > Application > Server-side agent configuration. OR Go to rpm.newrelic.com/apm. Next, from the index of applications, select the app's gear icon, then select View settings > Server-side agent configuration. Set the Server-side configuration enabled toggle to On. Select Save server-side configuration. After you enable server-side configuration, you can view and change the available settings through the UI. View or change server-side configuration settings Tip Owner, Admins, or Add-on Managers If you use server-side configuration, you must still include your license_key and app_name in the local config file. These settings are required for the agent to communicate with the New Relic collector. The C SDK and PHP agent do not support server-side configuration. To view or change the available server-side configuration settings through the UI for apps that use other New Relic agents: Go to rpm.newrelic.com/apm > (select an app) > Settings > Application > Server-side agent configuration. OR Go to rpm.newrelic.com/apm. Next, from the index of applications, select the app's gear icon, then select View settings > Server-side agent configuration. View or change the available configuration settings for your agent. If you make changes, select Save server-side configuration. Once you set any of these options from the UI, they will override any conflicting options in the agent's configuration file. Disable server-side configuration Once you enable server-side configuration for an account, server-side configuration cannot be turned off without assistance from New Relic Support. This helps mitigate issues that could arise from conflicts with configuration settings if you need to transition back to a local configuration setup.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 172.61519,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Server-side <em>agent</em> configuration",
        "sections": "Server-side <em>agent</em> configuration",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " change automatically applies to all New Relic <em>APM</em> <em>agents</em>, even if they run across multiple hosts. The <em>agent</em> still follows the local configurations for any settings not available from the UI. Server-side configuration precedence This feature provides the convenience of managing the available"
      },
      "id": "6043c83b64441fc5d6378ed1"
    },
    {
      "sections": [
        "Real time streaming",
        "Why it matters",
        "Agent version to automatically enable",
        "Caution",
        "Query real time streaming data",
        "Create real time streaming charts"
      ],
      "title": "Real time streaming",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "ead7b5f2e74d1096a9ba796f3001be0b663941e0",
      "image": "https://docs.newrelic.com/static/5edbc3948f29fe9b1202aa05c9645b6a/c1b63/RTS.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/real-time-streaming/",
      "published_at": "2021-05-04T16:26:06Z",
      "updated_at": "2021-03-16T14:50:31Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With real time streaming, your APM event data is sent to New Relic every five seconds. You can query and visualize your data for transactions, errors, and custom events in near real time. The smaller payloads result in faster chart refreshes and faster queries of data that is the most important to you. No configuration is needed to take advantage of real time streaming. All you need to do is ensure your APM agent version is up to date. Why it matters Real time streaming doesn't result in more events being sent. The combination of more frequent posts, with a smaller number of events per post, results in approximately the same number of events per minute as there would be without real time streaming. The following image shows a comparison between data sent to New Relic with and without real time streaming. Note that 10,000 is an example number of events; some agents have lower default limits. The overall limits on how many events can be sent per minute haven't changed. Also, non-event data (spans, traces, and metrics) are unaffected; they're still sent every minute. Use real time streaming to quickly understand the impact when something has changed, such as deploying a new app version. Examine key performance indicators (throughput, error rates, charting, etc.) in near real time. Respond quickly to failure conditions and anomalies. Get the most out of New Relic One dashboards. Reduce mean time to detection with APM events reporting every five seconds. Agent version to automatically enable To enable real time streaming, update to the latest New Relic APM agent. You don't need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all APM agents. Here are the minimum agent versions: C SDK: v1.3.0 or higher Go: v2.8.0 or higher Java: v5.5.0 or higher .NET: v8.23.107.0 or higher Node.js: v5.13.0 or higher PHP: v9.5.0.252 or higher Python: v5.2.0.127 or higher Ruby: v6.7.0.359 or higher Caution If Transaction event reporting is disabled, this can affect some UI elements throughout New Relic. You may see some empty charts on some UI pages that rely on this data. Query real time streaming data When building charts, include the following in your NRQL query: NRQL clause Comments SINCE 5 minutes ago Be sure to add a SINCE 5 minutes ago clause to your NRQL query in order to take advantage of the 5 second chart refresh interval. This is because the chart's refresh interval is based on the time window. TIMESERIES bucket To set the refresh interval for time series charts, you can also specify the bucket size as an optional argument to the TIMESERIES clause. For example, SINCE 30 minutes ago TIMESERIES 5 seconds will display a 30 minute window at a 5 second resolution. You can have a maximum of 366 buckets. Create real time streaming charts You can visualize the results of your NRQL query in New Relic One: Go to one.newrelic.com, and at the top of the page, select Query your data. Use the chart builder to start building a chart. Select the advanced (NRQL) mode. (If you start with basic mode, switch to advanced mode to complete the next step.) In your NRQL query, adjust the SINCE and TIMESERIES clauses to take advantage of the 5 second refresh intervals.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.05658,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Agent</em> version to automatically enable",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " to automatically enable To enable real time streaming, update to the latest New Relic <em>APM</em> <em>agent</em>. You don&#x27;t need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all <em>APM</em> <em>agents</em>. Here are the minimum <em>agent</em> versions: C SDK: v1.3.0"
      },
      "id": "603e9d27196a678e41a83db1"
    },
    {
      "sections": [
        "Custom instrumentation",
        "Important",
        "When to use custom instrumentation",
        "Implement custom instrumentation",
        "C SDK custom instrumentation",
        "Go custom instrumentation",
        "Java custom instrumentation",
        ".NET custom instrumentation",
        "Node.js custom instrumentation",
        "PHP custom instrumentation",
        "Python custom instrumentation",
        "Ruby custom instrumentation",
        "Grouping issues"
      ],
      "title": "Custom instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "2e6cd68b3d93f9ed716ca25b96aac87d4520de75",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/custom-instrumentation/",
      "published_at": "2021-05-05T01:44:05Z",
      "updated_at": "2021-03-16T13:49:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic collects and reports information on web transactions and non-web transactions, such as background tasks. New Relic normally produces complete information automatically, without any need to modify your application code. However, if you are not using a supported framework, you may need to add custom instrumentation. Custom instrumentation is also useful to: Add detail to your transaction traces. Block instrumentation on selected transactions you do not want instrumented. Instrument a part of your code that New Relic simply is not picking up. Custom instrumentation that creates a new transaction collects both metric timeslice and event data. Custom instrumentation for already instrumented transactions collects only metric timeslice data. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. When to use custom instrumentation Custom instrumentation allows you to track interactions that are not captured by New Relic's automatic instrumentation. Custom instrumentation can also add detail to your transaction traces, to help you identify key issues. New Relic collects data from many frameworks automatically. If you are using a supported framework, you should not need custom instrumentation to collect metric timeslices, events, and traces. However, if you encounter any of these situations, you may need custom instrumentation: Transactions do not appear in the UI. Transaction traces include large blocks of application code time without full detail. If you are using a supported framework, but are not seeing transaction on the New Relic APM Transactions page, get support at support.newrelic.com to ensure the framework instrumentation is working. Implement custom instrumentation Each agent implements custom instrumentation differently: C SDK custom instrumentation For applications monitored by the C SDK, you must manually instrument transactions, segments, and errors. For more information, see the C SDK instrumentation procedures. Go custom instrumentation Because Golang apps run from a compiled, native binary file, all New Relic instrumentation must be done manually. See Instrument Go transactions and Instrument Go segments for how to set up instrumentation in your Go app. Java custom instrumentation New Relic's Java agent supports two methods of custom instrumentation: Annotation: Add @Trace annotations to your code to ensure New Relic instruments specific methods. Annotation is easy to implement, if you are instrumenting only a few methods. For more complex instrumentation, or if you are unable to modify your code, use XML. XML: Define the methods you want New Relic to monitor in an XML file. XML instrumentation is flexible and doesn't require editing your code, but is more difficult to troubleshoot than annotation. For more information, see Java custom instrumentation. .NET custom instrumentation New Relic's .NET agent supports two methods of custom instrumentation: Attributes: Annotate your code with agent API calls to instrument specific methods. Annotation is easy to implement, but requires editing your source code. XML: Define the methods you want New Relic to instrument in an XML file. XML instrumentation does not require modifying your source code, but is more complicated to create and keep updated than attribute instrumentation. For more information, see Introduction to .NET custom instrumentation. Node.js custom instrumentation New Relic's Node.js agent uses API calls for custom instrumentation. For more information, see Node.js custom instrumentation. PHP custom instrumentation New Relic's PHP agent uses API calls for custom instrumentation. For more information, see PHP custom instrumentation. Python custom instrumentation New Relic's Python agent supports two methods of custom instrumentation: Configuration file: Use the agent configuration file to specify the functions and methods you want instrumented. The agent configuration file is easy to set up, and it does not require you to modify your code. However, it is less flexible than API calls. API calls: Edit your code to call the New Relic Python API. The API is more flexible than instrumentation via the configuration file, but it requires you to modify your code. For more information, see Python custom instrumentation. Ruby custom instrumentation New Relic's Ruby agent uses API calls to define target methods and add transaction tracers to them. For more information, see Ruby custom instrumentation. Grouping issues A metric grouping issue occurs when an account sends too many differently-named metric timeslices to New Relic, and those individual web transactions are not properly aggregated. For example, rather than a single /user/controlpanel/ metric name, you might see /user/controlpanel/alice, /user/controlpanel/bob, and /user/controlpanel/carol. Custom instrumentation can cause metric grouping issues if you introduce too many uniquely-named metric timeslices that New Relic cannot effectively group. If you send thousands of metrics, New Relic may apply rules to reduce the number of transactions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.04034,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " transaction collects both metric timeslice and event <em>data</em>. Custom instrumentation for already instrumented transactions collects only metric timeslice <em>data</em>. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use"
      },
      "id": "603eb8b928ccbc1a79eba78c"
    }
  ],
  "/docs/agents/manage-apm-agents/agent-data/collect-custom-metrics": [
    {
      "sections": [
        "Server-side agent configuration",
        "Centralization and security",
        "Server-side configuration precedence",
        "Enable server-side configuration",
        "Tip",
        "View or change server-side configuration settings",
        "Disable server-side configuration"
      ],
      "title": "Server-side agent configuration",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Configuration"
      ],
      "external_id": "928ff211d9e5aa0e02dc64ed344e8cbbd3ea91b5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/configuration/server-side-agent-configuration/",
      "published_at": "2021-05-05T06:35:22Z",
      "updated_at": "2021-05-05T06:35:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Server-side configuration transitions some core settings from your language agent's configuration file to the New Relic collector. Depending on the language agent, available settings may include: Transaction tracing SQL recording and logging SQL query plans Error collection Thread profiling Distributed tracing Cross application tracing Centralization and security Server-side configuration provides an easy way to manage the available settings from the New Relic UI. Centralized configuration settings can also help you ensure standards compliance and security management for your settings. Any change automatically applies to all New Relic APM agents, even if they run across multiple hosts. The agent still follows the local configurations for any settings not available from the UI. Server-side configuration precedence This feature provides the convenience of managing the available configuration settings directly within the New Relic UI, without the need for deployments or restarts. Available options to change settings, and the order of precedence they take when you utilize environment variables or other configuration options, will depend on the language agent used. For more information about the hierarchy of settings, see the illustration for the specific agent: C SDK configuration: A hierarchy is not applicable, because configuration values come from API calls. Also, server-side configuration is not supported. However, you can change the app name from the UI or from the C SDK configuration settings. Go hierarchy Java hierarchy .NET hierarchy Node.js hierarchy PHP hierarchy (server-side configuration not supported) Python hierarchy Ruby hierarchy Enable server-side configuration Tip Owner, Admins, or Add-on Managers The C SDK and PHP agent do not support server-side configuration. To enable server-side configuration settings for apps that use other New Relic agents: Go to rpm.newrelic.com/apm > (select an app) > Settings > Application > Server-side agent configuration. OR Go to rpm.newrelic.com/apm. Next, from the index of applications, select the app's gear icon, then select View settings > Server-side agent configuration. Set the Server-side configuration enabled toggle to On. Select Save server-side configuration. After you enable server-side configuration, you can view and change the available settings through the UI. View or change server-side configuration settings Tip Owner, Admins, or Add-on Managers If you use server-side configuration, you must still include your license_key and app_name in the local config file. These settings are required for the agent to communicate with the New Relic collector. The C SDK and PHP agent do not support server-side configuration. To view or change the available server-side configuration settings through the UI for apps that use other New Relic agents: Go to rpm.newrelic.com/apm > (select an app) > Settings > Application > Server-side agent configuration. OR Go to rpm.newrelic.com/apm. Next, from the index of applications, select the app's gear icon, then select View settings > Server-side agent configuration. View or change the available configuration settings for your agent. If you make changes, select Save server-side configuration. Once you set any of these options from the UI, they will override any conflicting options in the agent's configuration file. Disable server-side configuration Once you enable server-side configuration for an account, server-side configuration cannot be turned off without assistance from New Relic Support. This helps mitigate issues that could arise from conflicts with configuration settings if you need to transition back to a local configuration setup.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 172.61519,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Server-side <em>agent</em> configuration",
        "sections": "Server-side <em>agent</em> configuration",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " change automatically applies to all New Relic <em>APM</em> <em>agents</em>, even if they run across multiple hosts. The <em>agent</em> still follows the local configurations for any settings not available from the UI. Server-side configuration precedence This feature provides the convenience of managing the available"
      },
      "id": "6043c83b64441fc5d6378ed1"
    },
    {
      "sections": [
        "Real time streaming",
        "Why it matters",
        "Agent version to automatically enable",
        "Caution",
        "Query real time streaming data",
        "Create real time streaming charts"
      ],
      "title": "Real time streaming",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "ead7b5f2e74d1096a9ba796f3001be0b663941e0",
      "image": "https://docs.newrelic.com/static/5edbc3948f29fe9b1202aa05c9645b6a/c1b63/RTS.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/real-time-streaming/",
      "published_at": "2021-05-04T16:26:06Z",
      "updated_at": "2021-03-16T14:50:31Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With real time streaming, your APM event data is sent to New Relic every five seconds. You can query and visualize your data for transactions, errors, and custom events in near real time. The smaller payloads result in faster chart refreshes and faster queries of data that is the most important to you. No configuration is needed to take advantage of real time streaming. All you need to do is ensure your APM agent version is up to date. Why it matters Real time streaming doesn't result in more events being sent. The combination of more frequent posts, with a smaller number of events per post, results in approximately the same number of events per minute as there would be without real time streaming. The following image shows a comparison between data sent to New Relic with and without real time streaming. Note that 10,000 is an example number of events; some agents have lower default limits. The overall limits on how many events can be sent per minute haven't changed. Also, non-event data (spans, traces, and metrics) are unaffected; they're still sent every minute. Use real time streaming to quickly understand the impact when something has changed, such as deploying a new app version. Examine key performance indicators (throughput, error rates, charting, etc.) in near real time. Respond quickly to failure conditions and anomalies. Get the most out of New Relic One dashboards. Reduce mean time to detection with APM events reporting every five seconds. Agent version to automatically enable To enable real time streaming, update to the latest New Relic APM agent. You don't need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all APM agents. Here are the minimum agent versions: C SDK: v1.3.0 or higher Go: v2.8.0 or higher Java: v5.5.0 or higher .NET: v8.23.107.0 or higher Node.js: v5.13.0 or higher PHP: v9.5.0.252 or higher Python: v5.2.0.127 or higher Ruby: v6.7.0.359 or higher Caution If Transaction event reporting is disabled, this can affect some UI elements throughout New Relic. You may see some empty charts on some UI pages that rely on this data. Query real time streaming data When building charts, include the following in your NRQL query: NRQL clause Comments SINCE 5 minutes ago Be sure to add a SINCE 5 minutes ago clause to your NRQL query in order to take advantage of the 5 second chart refresh interval. This is because the chart's refresh interval is based on the time window. TIMESERIES bucket To set the refresh interval for time series charts, you can also specify the bucket size as an optional argument to the TIMESERIES clause. For example, SINCE 30 minutes ago TIMESERIES 5 seconds will display a 30 minute window at a 5 second resolution. You can have a maximum of 366 buckets. Create real time streaming charts You can visualize the results of your NRQL query in New Relic One: Go to one.newrelic.com, and at the top of the page, select Query your data. Use the chart builder to start building a chart. Select the advanced (NRQL) mode. (If you start with basic mode, switch to advanced mode to complete the next step.) In your NRQL query, adjust the SINCE and TIMESERIES clauses to take advantage of the 5 second refresh intervals.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.05658,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Agent</em> version to automatically enable",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " to automatically enable To enable real time streaming, update to the latest New Relic <em>APM</em> <em>agent</em>. You don&#x27;t need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all <em>APM</em> <em>agents</em>. Here are the minimum <em>agent</em> versions: C SDK: v1.3.0"
      },
      "id": "603e9d27196a678e41a83db1"
    },
    {
      "sections": [
        "Custom instrumentation",
        "Important",
        "When to use custom instrumentation",
        "Implement custom instrumentation",
        "C SDK custom instrumentation",
        "Go custom instrumentation",
        "Java custom instrumentation",
        ".NET custom instrumentation",
        "Node.js custom instrumentation",
        "PHP custom instrumentation",
        "Python custom instrumentation",
        "Ruby custom instrumentation",
        "Grouping issues"
      ],
      "title": "Custom instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "2e6cd68b3d93f9ed716ca25b96aac87d4520de75",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/custom-instrumentation/",
      "published_at": "2021-05-05T01:44:05Z",
      "updated_at": "2021-03-16T13:49:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic collects and reports information on web transactions and non-web transactions, such as background tasks. New Relic normally produces complete information automatically, without any need to modify your application code. However, if you are not using a supported framework, you may need to add custom instrumentation. Custom instrumentation is also useful to: Add detail to your transaction traces. Block instrumentation on selected transactions you do not want instrumented. Instrument a part of your code that New Relic simply is not picking up. Custom instrumentation that creates a new transaction collects both metric timeslice and event data. Custom instrumentation for already instrumented transactions collects only metric timeslice data. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. When to use custom instrumentation Custom instrumentation allows you to track interactions that are not captured by New Relic's automatic instrumentation. Custom instrumentation can also add detail to your transaction traces, to help you identify key issues. New Relic collects data from many frameworks automatically. If you are using a supported framework, you should not need custom instrumentation to collect metric timeslices, events, and traces. However, if you encounter any of these situations, you may need custom instrumentation: Transactions do not appear in the UI. Transaction traces include large blocks of application code time without full detail. If you are using a supported framework, but are not seeing transaction on the New Relic APM Transactions page, get support at support.newrelic.com to ensure the framework instrumentation is working. Implement custom instrumentation Each agent implements custom instrumentation differently: C SDK custom instrumentation For applications monitored by the C SDK, you must manually instrument transactions, segments, and errors. For more information, see the C SDK instrumentation procedures. Go custom instrumentation Because Golang apps run from a compiled, native binary file, all New Relic instrumentation must be done manually. See Instrument Go transactions and Instrument Go segments for how to set up instrumentation in your Go app. Java custom instrumentation New Relic's Java agent supports two methods of custom instrumentation: Annotation: Add @Trace annotations to your code to ensure New Relic instruments specific methods. Annotation is easy to implement, if you are instrumenting only a few methods. For more complex instrumentation, or if you are unable to modify your code, use XML. XML: Define the methods you want New Relic to monitor in an XML file. XML instrumentation is flexible and doesn't require editing your code, but is more difficult to troubleshoot than annotation. For more information, see Java custom instrumentation. .NET custom instrumentation New Relic's .NET agent supports two methods of custom instrumentation: Attributes: Annotate your code with agent API calls to instrument specific methods. Annotation is easy to implement, but requires editing your source code. XML: Define the methods you want New Relic to instrument in an XML file. XML instrumentation does not require modifying your source code, but is more complicated to create and keep updated than attribute instrumentation. For more information, see Introduction to .NET custom instrumentation. Node.js custom instrumentation New Relic's Node.js agent uses API calls for custom instrumentation. For more information, see Node.js custom instrumentation. PHP custom instrumentation New Relic's PHP agent uses API calls for custom instrumentation. For more information, see PHP custom instrumentation. Python custom instrumentation New Relic's Python agent supports two methods of custom instrumentation: Configuration file: Use the agent configuration file to specify the functions and methods you want instrumented. The agent configuration file is easy to set up, and it does not require you to modify your code. However, it is less flexible than API calls. API calls: Edit your code to call the New Relic Python API. The API is more flexible than instrumentation via the configuration file, but it requires you to modify your code. For more information, see Python custom instrumentation. Ruby custom instrumentation New Relic's Ruby agent uses API calls to define target methods and add transaction tracers to them. For more information, see Ruby custom instrumentation. Grouping issues A metric grouping issue occurs when an account sends too many differently-named metric timeslices to New Relic, and those individual web transactions are not properly aggregated. For example, rather than a single /user/controlpanel/ metric name, you might see /user/controlpanel/alice, /user/controlpanel/bob, and /user/controlpanel/carol. Custom instrumentation can cause metric grouping issues if you introduce too many uniquely-named metric timeslices that New Relic cannot effectively group. If you send thousands of metrics, New Relic may apply rules to reduce the number of transactions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.04034,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " transaction collects both metric timeslice and event <em>data</em>. Custom instrumentation for already instrumented transactions collects only metric timeslice <em>data</em>. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use"
      },
      "id": "603eb8b928ccbc1a79eba78c"
    }
  ],
  "/docs/agents/manage-apm-agents/agent-data/custom-instrumentation": [
    {
      "sections": [
        "Server-side agent configuration",
        "Centralization and security",
        "Server-side configuration precedence",
        "Enable server-side configuration",
        "Tip",
        "View or change server-side configuration settings",
        "Disable server-side configuration"
      ],
      "title": "Server-side agent configuration",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Configuration"
      ],
      "external_id": "928ff211d9e5aa0e02dc64ed344e8cbbd3ea91b5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/configuration/server-side-agent-configuration/",
      "published_at": "2021-05-05T06:35:22Z",
      "updated_at": "2021-05-05T06:35:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Server-side configuration transitions some core settings from your language agent's configuration file to the New Relic collector. Depending on the language agent, available settings may include: Transaction tracing SQL recording and logging SQL query plans Error collection Thread profiling Distributed tracing Cross application tracing Centralization and security Server-side configuration provides an easy way to manage the available settings from the New Relic UI. Centralized configuration settings can also help you ensure standards compliance and security management for your settings. Any change automatically applies to all New Relic APM agents, even if they run across multiple hosts. The agent still follows the local configurations for any settings not available from the UI. Server-side configuration precedence This feature provides the convenience of managing the available configuration settings directly within the New Relic UI, without the need for deployments or restarts. Available options to change settings, and the order of precedence they take when you utilize environment variables or other configuration options, will depend on the language agent used. For more information about the hierarchy of settings, see the illustration for the specific agent: C SDK configuration: A hierarchy is not applicable, because configuration values come from API calls. Also, server-side configuration is not supported. However, you can change the app name from the UI or from the C SDK configuration settings. Go hierarchy Java hierarchy .NET hierarchy Node.js hierarchy PHP hierarchy (server-side configuration not supported) Python hierarchy Ruby hierarchy Enable server-side configuration Tip Owner, Admins, or Add-on Managers The C SDK and PHP agent do not support server-side configuration. To enable server-side configuration settings for apps that use other New Relic agents: Go to rpm.newrelic.com/apm > (select an app) > Settings > Application > Server-side agent configuration. OR Go to rpm.newrelic.com/apm. Next, from the index of applications, select the app's gear icon, then select View settings > Server-side agent configuration. Set the Server-side configuration enabled toggle to On. Select Save server-side configuration. After you enable server-side configuration, you can view and change the available settings through the UI. View or change server-side configuration settings Tip Owner, Admins, or Add-on Managers If you use server-side configuration, you must still include your license_key and app_name in the local config file. These settings are required for the agent to communicate with the New Relic collector. The C SDK and PHP agent do not support server-side configuration. To view or change the available server-side configuration settings through the UI for apps that use other New Relic agents: Go to rpm.newrelic.com/apm > (select an app) > Settings > Application > Server-side agent configuration. OR Go to rpm.newrelic.com/apm. Next, from the index of applications, select the app's gear icon, then select View settings > Server-side agent configuration. View or change the available configuration settings for your agent. If you make changes, select Save server-side configuration. Once you set any of these options from the UI, they will override any conflicting options in the agent's configuration file. Disable server-side configuration Once you enable server-side configuration for an account, server-side configuration cannot be turned off without assistance from New Relic Support. This helps mitigate issues that could arise from conflicts with configuration settings if you need to transition back to a local configuration setup.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 172.61508,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Server-side <em>agent</em> configuration",
        "sections": "Server-side <em>agent</em> configuration",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " change automatically applies to all New Relic <em>APM</em> <em>agents</em>, even if they run across multiple hosts. The <em>agent</em> still follows the local configurations for any settings not available from the UI. Server-side configuration precedence This feature provides the convenience of managing the available"
      },
      "id": "6043c83b64441fc5d6378ed1"
    },
    {
      "sections": [
        "Real time streaming",
        "Why it matters",
        "Agent version to automatically enable",
        "Caution",
        "Query real time streaming data",
        "Create real time streaming charts"
      ],
      "title": "Real time streaming",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "ead7b5f2e74d1096a9ba796f3001be0b663941e0",
      "image": "https://docs.newrelic.com/static/5edbc3948f29fe9b1202aa05c9645b6a/c1b63/RTS.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/real-time-streaming/",
      "published_at": "2021-05-04T16:26:06Z",
      "updated_at": "2021-03-16T14:50:31Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With real time streaming, your APM event data is sent to New Relic every five seconds. You can query and visualize your data for transactions, errors, and custom events in near real time. The smaller payloads result in faster chart refreshes and faster queries of data that is the most important to you. No configuration is needed to take advantage of real time streaming. All you need to do is ensure your APM agent version is up to date. Why it matters Real time streaming doesn't result in more events being sent. The combination of more frequent posts, with a smaller number of events per post, results in approximately the same number of events per minute as there would be without real time streaming. The following image shows a comparison between data sent to New Relic with and without real time streaming. Note that 10,000 is an example number of events; some agents have lower default limits. The overall limits on how many events can be sent per minute haven't changed. Also, non-event data (spans, traces, and metrics) are unaffected; they're still sent every minute. Use real time streaming to quickly understand the impact when something has changed, such as deploying a new app version. Examine key performance indicators (throughput, error rates, charting, etc.) in near real time. Respond quickly to failure conditions and anomalies. Get the most out of New Relic One dashboards. Reduce mean time to detection with APM events reporting every five seconds. Agent version to automatically enable To enable real time streaming, update to the latest New Relic APM agent. You don't need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all APM agents. Here are the minimum agent versions: C SDK: v1.3.0 or higher Go: v2.8.0 or higher Java: v5.5.0 or higher .NET: v8.23.107.0 or higher Node.js: v5.13.0 or higher PHP: v9.5.0.252 or higher Python: v5.2.0.127 or higher Ruby: v6.7.0.359 or higher Caution If Transaction event reporting is disabled, this can affect some UI elements throughout New Relic. You may see some empty charts on some UI pages that rely on this data. Query real time streaming data When building charts, include the following in your NRQL query: NRQL clause Comments SINCE 5 minutes ago Be sure to add a SINCE 5 minutes ago clause to your NRQL query in order to take advantage of the 5 second chart refresh interval. This is because the chart's refresh interval is based on the time window. TIMESERIES bucket To set the refresh interval for time series charts, you can also specify the bucket size as an optional argument to the TIMESERIES clause. For example, SINCE 30 minutes ago TIMESERIES 5 seconds will display a 30 minute window at a 5 second resolution. You can have a maximum of 366 buckets. Create real time streaming charts You can visualize the results of your NRQL query in New Relic One: Go to one.newrelic.com, and at the top of the page, select Query your data. Use the chart builder to start building a chart. Select the advanced (NRQL) mode. (If you start with basic mode, switch to advanced mode to complete the next step.) In your NRQL query, adjust the SINCE and TIMESERIES clauses to take advantage of the 5 second refresh intervals.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.05658,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Agent</em> version to automatically enable",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " to automatically enable To enable real time streaming, update to the latest New Relic <em>APM</em> <em>agent</em>. You don&#x27;t need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all <em>APM</em> <em>agents</em>. Here are the minimum <em>agent</em> versions: C SDK: v1.3.0"
      },
      "id": "603e9d27196a678e41a83db1"
    },
    {
      "sections": [
        "Link your applications to Kubernetes"
      ],
      "title": "Link your applications to Kubernetes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "bcd540ade6ba7dc78cfe28db96b5bb18ee576fb7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/link-your-applications-kubernetes/",
      "published_at": "2021-05-05T02:11:01Z",
      "updated_at": "2021-03-16T13:49:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Agents can be configured to collect Kubernetes-related environment variables and add them to Transaction events to provide context between your Kubernetes cluster and your services. For details on the benefits see this blog post. For more information on agent compatibility and installation instructions, see our Kubernetes documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.04033,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": "<em>Agents</em> can be configured to collect Kubernetes-related environment variables and add them to Transaction events to provide context between your Kubernetes cluster and your services. For details on the benefits see this blog post. For more information on <em>agent</em> compatibility and installation instructions, see our Kubernetes documentation."
      },
      "id": "603ebbed196a67b1c8a83de6"
    }
  ],
  "/docs/agents/manage-apm-agents/agent-data/link-your-applications-kubernetes": [
    {
      "sections": [
        "Server-side agent configuration",
        "Centralization and security",
        "Server-side configuration precedence",
        "Enable server-side configuration",
        "Tip",
        "View or change server-side configuration settings",
        "Disable server-side configuration"
      ],
      "title": "Server-side agent configuration",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Configuration"
      ],
      "external_id": "928ff211d9e5aa0e02dc64ed344e8cbbd3ea91b5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/configuration/server-side-agent-configuration/",
      "published_at": "2021-05-05T06:35:22Z",
      "updated_at": "2021-05-05T06:35:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Server-side configuration transitions some core settings from your language agent's configuration file to the New Relic collector. Depending on the language agent, available settings may include: Transaction tracing SQL recording and logging SQL query plans Error collection Thread profiling Distributed tracing Cross application tracing Centralization and security Server-side configuration provides an easy way to manage the available settings from the New Relic UI. Centralized configuration settings can also help you ensure standards compliance and security management for your settings. Any change automatically applies to all New Relic APM agents, even if they run across multiple hosts. The agent still follows the local configurations for any settings not available from the UI. Server-side configuration precedence This feature provides the convenience of managing the available configuration settings directly within the New Relic UI, without the need for deployments or restarts. Available options to change settings, and the order of precedence they take when you utilize environment variables or other configuration options, will depend on the language agent used. For more information about the hierarchy of settings, see the illustration for the specific agent: C SDK configuration: A hierarchy is not applicable, because configuration values come from API calls. Also, server-side configuration is not supported. However, you can change the app name from the UI or from the C SDK configuration settings. Go hierarchy Java hierarchy .NET hierarchy Node.js hierarchy PHP hierarchy (server-side configuration not supported) Python hierarchy Ruby hierarchy Enable server-side configuration Tip Owner, Admins, or Add-on Managers The C SDK and PHP agent do not support server-side configuration. To enable server-side configuration settings for apps that use other New Relic agents: Go to rpm.newrelic.com/apm > (select an app) > Settings > Application > Server-side agent configuration. OR Go to rpm.newrelic.com/apm. Next, from the index of applications, select the app's gear icon, then select View settings > Server-side agent configuration. Set the Server-side configuration enabled toggle to On. Select Save server-side configuration. After you enable server-side configuration, you can view and change the available settings through the UI. View or change server-side configuration settings Tip Owner, Admins, or Add-on Managers If you use server-side configuration, you must still include your license_key and app_name in the local config file. These settings are required for the agent to communicate with the New Relic collector. The C SDK and PHP agent do not support server-side configuration. To view or change the available server-side configuration settings through the UI for apps that use other New Relic agents: Go to rpm.newrelic.com/apm > (select an app) > Settings > Application > Server-side agent configuration. OR Go to rpm.newrelic.com/apm. Next, from the index of applications, select the app's gear icon, then select View settings > Server-side agent configuration. View or change the available configuration settings for your agent. If you make changes, select Save server-side configuration. Once you set any of these options from the UI, they will override any conflicting options in the agent's configuration file. Disable server-side configuration Once you enable server-side configuration for an account, server-side configuration cannot be turned off without assistance from New Relic Support. This helps mitigate issues that could arise from conflicts with configuration settings if you need to transition back to a local configuration setup.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 172.61508,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Server-side <em>agent</em> configuration",
        "sections": "Server-side <em>agent</em> configuration",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " change automatically applies to all New Relic <em>APM</em> <em>agents</em>, even if they run across multiple hosts. The <em>agent</em> still follows the local configurations for any settings not available from the UI. Server-side configuration precedence This feature provides the convenience of managing the available"
      },
      "id": "6043c83b64441fc5d6378ed1"
    },
    {
      "sections": [
        "Real time streaming",
        "Why it matters",
        "Agent version to automatically enable",
        "Caution",
        "Query real time streaming data",
        "Create real time streaming charts"
      ],
      "title": "Real time streaming",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "ead7b5f2e74d1096a9ba796f3001be0b663941e0",
      "image": "https://docs.newrelic.com/static/5edbc3948f29fe9b1202aa05c9645b6a/c1b63/RTS.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/real-time-streaming/",
      "published_at": "2021-05-04T16:26:06Z",
      "updated_at": "2021-03-16T14:50:31Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With real time streaming, your APM event data is sent to New Relic every five seconds. You can query and visualize your data for transactions, errors, and custom events in near real time. The smaller payloads result in faster chart refreshes and faster queries of data that is the most important to you. No configuration is needed to take advantage of real time streaming. All you need to do is ensure your APM agent version is up to date. Why it matters Real time streaming doesn't result in more events being sent. The combination of more frequent posts, with a smaller number of events per post, results in approximately the same number of events per minute as there would be without real time streaming. The following image shows a comparison between data sent to New Relic with and without real time streaming. Note that 10,000 is an example number of events; some agents have lower default limits. The overall limits on how many events can be sent per minute haven't changed. Also, non-event data (spans, traces, and metrics) are unaffected; they're still sent every minute. Use real time streaming to quickly understand the impact when something has changed, such as deploying a new app version. Examine key performance indicators (throughput, error rates, charting, etc.) in near real time. Respond quickly to failure conditions and anomalies. Get the most out of New Relic One dashboards. Reduce mean time to detection with APM events reporting every five seconds. Agent version to automatically enable To enable real time streaming, update to the latest New Relic APM agent. You don't need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all APM agents. Here are the minimum agent versions: C SDK: v1.3.0 or higher Go: v2.8.0 or higher Java: v5.5.0 or higher .NET: v8.23.107.0 or higher Node.js: v5.13.0 or higher PHP: v9.5.0.252 or higher Python: v5.2.0.127 or higher Ruby: v6.7.0.359 or higher Caution If Transaction event reporting is disabled, this can affect some UI elements throughout New Relic. You may see some empty charts on some UI pages that rely on this data. Query real time streaming data When building charts, include the following in your NRQL query: NRQL clause Comments SINCE 5 minutes ago Be sure to add a SINCE 5 minutes ago clause to your NRQL query in order to take advantage of the 5 second chart refresh interval. This is because the chart's refresh interval is based on the time window. TIMESERIES bucket To set the refresh interval for time series charts, you can also specify the bucket size as an optional argument to the TIMESERIES clause. For example, SINCE 30 minutes ago TIMESERIES 5 seconds will display a 30 minute window at a 5 second resolution. You can have a maximum of 366 buckets. Create real time streaming charts You can visualize the results of your NRQL query in New Relic One: Go to one.newrelic.com, and at the top of the page, select Query your data. Use the chart builder to start building a chart. Select the advanced (NRQL) mode. (If you start with basic mode, switch to advanced mode to complete the next step.) In your NRQL query, adjust the SINCE and TIMESERIES clauses to take advantage of the 5 second refresh intervals.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.05658,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Agent</em> version to automatically enable",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " to automatically enable To enable real time streaming, update to the latest New Relic <em>APM</em> <em>agent</em>. You don&#x27;t need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all <em>APM</em> <em>agents</em>. Here are the minimum <em>agent</em> versions: C SDK: v1.3.0"
      },
      "id": "603e9d27196a678e41a83db1"
    },
    {
      "sections": [
        "Custom instrumentation",
        "Important",
        "When to use custom instrumentation",
        "Implement custom instrumentation",
        "C SDK custom instrumentation",
        "Go custom instrumentation",
        "Java custom instrumentation",
        ".NET custom instrumentation",
        "Node.js custom instrumentation",
        "PHP custom instrumentation",
        "Python custom instrumentation",
        "Ruby custom instrumentation",
        "Grouping issues"
      ],
      "title": "Custom instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "2e6cd68b3d93f9ed716ca25b96aac87d4520de75",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/custom-instrumentation/",
      "published_at": "2021-05-05T01:44:05Z",
      "updated_at": "2021-03-16T13:49:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic collects and reports information on web transactions and non-web transactions, such as background tasks. New Relic normally produces complete information automatically, without any need to modify your application code. However, if you are not using a supported framework, you may need to add custom instrumentation. Custom instrumentation is also useful to: Add detail to your transaction traces. Block instrumentation on selected transactions you do not want instrumented. Instrument a part of your code that New Relic simply is not picking up. Custom instrumentation that creates a new transaction collects both metric timeslice and event data. Custom instrumentation for already instrumented transactions collects only metric timeslice data. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. When to use custom instrumentation Custom instrumentation allows you to track interactions that are not captured by New Relic's automatic instrumentation. Custom instrumentation can also add detail to your transaction traces, to help you identify key issues. New Relic collects data from many frameworks automatically. If you are using a supported framework, you should not need custom instrumentation to collect metric timeslices, events, and traces. However, if you encounter any of these situations, you may need custom instrumentation: Transactions do not appear in the UI. Transaction traces include large blocks of application code time without full detail. If you are using a supported framework, but are not seeing transaction on the New Relic APM Transactions page, get support at support.newrelic.com to ensure the framework instrumentation is working. Implement custom instrumentation Each agent implements custom instrumentation differently: C SDK custom instrumentation For applications monitored by the C SDK, you must manually instrument transactions, segments, and errors. For more information, see the C SDK instrumentation procedures. Go custom instrumentation Because Golang apps run from a compiled, native binary file, all New Relic instrumentation must be done manually. See Instrument Go transactions and Instrument Go segments for how to set up instrumentation in your Go app. Java custom instrumentation New Relic's Java agent supports two methods of custom instrumentation: Annotation: Add @Trace annotations to your code to ensure New Relic instruments specific methods. Annotation is easy to implement, if you are instrumenting only a few methods. For more complex instrumentation, or if you are unable to modify your code, use XML. XML: Define the methods you want New Relic to monitor in an XML file. XML instrumentation is flexible and doesn't require editing your code, but is more difficult to troubleshoot than annotation. For more information, see Java custom instrumentation. .NET custom instrumentation New Relic's .NET agent supports two methods of custom instrumentation: Attributes: Annotate your code with agent API calls to instrument specific methods. Annotation is easy to implement, but requires editing your source code. XML: Define the methods you want New Relic to instrument in an XML file. XML instrumentation does not require modifying your source code, but is more complicated to create and keep updated than attribute instrumentation. For more information, see Introduction to .NET custom instrumentation. Node.js custom instrumentation New Relic's Node.js agent uses API calls for custom instrumentation. For more information, see Node.js custom instrumentation. PHP custom instrumentation New Relic's PHP agent uses API calls for custom instrumentation. For more information, see PHP custom instrumentation. Python custom instrumentation New Relic's Python agent supports two methods of custom instrumentation: Configuration file: Use the agent configuration file to specify the functions and methods you want instrumented. The agent configuration file is easy to set up, and it does not require you to modify your code. However, it is less flexible than API calls. API calls: Edit your code to call the New Relic Python API. The API is more flexible than instrumentation via the configuration file, but it requires you to modify your code. For more information, see Python custom instrumentation. Ruby custom instrumentation New Relic's Ruby agent uses API calls to define target methods and add transaction tracers to them. For more information, see Ruby custom instrumentation. Grouping issues A metric grouping issue occurs when an account sends too many differently-named metric timeslices to New Relic, and those individual web transactions are not properly aggregated. For example, rather than a single /user/controlpanel/ metric name, you might see /user/controlpanel/alice, /user/controlpanel/bob, and /user/controlpanel/carol. Custom instrumentation can cause metric grouping issues if you introduce too many uniquely-named metric timeslices that New Relic cannot effectively group. If you send thousands of metrics, New Relic may apply rules to reduce the number of transactions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.04034,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " transaction collects both metric timeslice and event <em>data</em>. Custom instrumentation for already instrumented transactions collects only metric timeslice <em>data</em>. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use"
      },
      "id": "603eb8b928ccbc1a79eba78c"
    }
  ],
  "/docs/agents/manage-apm-agents/agent-data/manage-errors-apm-collect-ignore-or-mark-expected": [
    {
      "sections": [
        "Server-side agent configuration",
        "Centralization and security",
        "Server-side configuration precedence",
        "Enable server-side configuration",
        "Tip",
        "View or change server-side configuration settings",
        "Disable server-side configuration"
      ],
      "title": "Server-side agent configuration",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Configuration"
      ],
      "external_id": "928ff211d9e5aa0e02dc64ed344e8cbbd3ea91b5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/configuration/server-side-agent-configuration/",
      "published_at": "2021-05-05T06:35:22Z",
      "updated_at": "2021-05-05T06:35:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Server-side configuration transitions some core settings from your language agent's configuration file to the New Relic collector. Depending on the language agent, available settings may include: Transaction tracing SQL recording and logging SQL query plans Error collection Thread profiling Distributed tracing Cross application tracing Centralization and security Server-side configuration provides an easy way to manage the available settings from the New Relic UI. Centralized configuration settings can also help you ensure standards compliance and security management for your settings. Any change automatically applies to all New Relic APM agents, even if they run across multiple hosts. The agent still follows the local configurations for any settings not available from the UI. Server-side configuration precedence This feature provides the convenience of managing the available configuration settings directly within the New Relic UI, without the need for deployments or restarts. Available options to change settings, and the order of precedence they take when you utilize environment variables or other configuration options, will depend on the language agent used. For more information about the hierarchy of settings, see the illustration for the specific agent: C SDK configuration: A hierarchy is not applicable, because configuration values come from API calls. Also, server-side configuration is not supported. However, you can change the app name from the UI or from the C SDK configuration settings. Go hierarchy Java hierarchy .NET hierarchy Node.js hierarchy PHP hierarchy (server-side configuration not supported) Python hierarchy Ruby hierarchy Enable server-side configuration Tip Owner, Admins, or Add-on Managers The C SDK and PHP agent do not support server-side configuration. To enable server-side configuration settings for apps that use other New Relic agents: Go to rpm.newrelic.com/apm > (select an app) > Settings > Application > Server-side agent configuration. OR Go to rpm.newrelic.com/apm. Next, from the index of applications, select the app's gear icon, then select View settings > Server-side agent configuration. Set the Server-side configuration enabled toggle to On. Select Save server-side configuration. After you enable server-side configuration, you can view and change the available settings through the UI. View or change server-side configuration settings Tip Owner, Admins, or Add-on Managers If you use server-side configuration, you must still include your license_key and app_name in the local config file. These settings are required for the agent to communicate with the New Relic collector. The C SDK and PHP agent do not support server-side configuration. To view or change the available server-side configuration settings through the UI for apps that use other New Relic agents: Go to rpm.newrelic.com/apm > (select an app) > Settings > Application > Server-side agent configuration. OR Go to rpm.newrelic.com/apm. Next, from the index of applications, select the app's gear icon, then select View settings > Server-side agent configuration. View or change the available configuration settings for your agent. If you make changes, select Save server-side configuration. Once you set any of these options from the UI, they will override any conflicting options in the agent's configuration file. Disable server-side configuration Once you enable server-side configuration for an account, server-side configuration cannot be turned off without assistance from New Relic Support. This helps mitigate issues that could arise from conflicts with configuration settings if you need to transition back to a local configuration setup.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 172.61499,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Server-side <em>agent</em> configuration",
        "sections": "Server-side <em>agent</em> configuration",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " change automatically applies to all New Relic <em>APM</em> <em>agents</em>, even if they run across multiple hosts. The <em>agent</em> still follows the local configurations for any settings not available from the UI. Server-side configuration precedence This feature provides the convenience of managing the available"
      },
      "id": "6043c83b64441fc5d6378ed1"
    },
    {
      "sections": [
        "Real time streaming",
        "Why it matters",
        "Agent version to automatically enable",
        "Caution",
        "Query real time streaming data",
        "Create real time streaming charts"
      ],
      "title": "Real time streaming",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "ead7b5f2e74d1096a9ba796f3001be0b663941e0",
      "image": "https://docs.newrelic.com/static/5edbc3948f29fe9b1202aa05c9645b6a/c1b63/RTS.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/real-time-streaming/",
      "published_at": "2021-05-04T16:26:06Z",
      "updated_at": "2021-03-16T14:50:31Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With real time streaming, your APM event data is sent to New Relic every five seconds. You can query and visualize your data for transactions, errors, and custom events in near real time. The smaller payloads result in faster chart refreshes and faster queries of data that is the most important to you. No configuration is needed to take advantage of real time streaming. All you need to do is ensure your APM agent version is up to date. Why it matters Real time streaming doesn't result in more events being sent. The combination of more frequent posts, with a smaller number of events per post, results in approximately the same number of events per minute as there would be without real time streaming. The following image shows a comparison between data sent to New Relic with and without real time streaming. Note that 10,000 is an example number of events; some agents have lower default limits. The overall limits on how many events can be sent per minute haven't changed. Also, non-event data (spans, traces, and metrics) are unaffected; they're still sent every minute. Use real time streaming to quickly understand the impact when something has changed, such as deploying a new app version. Examine key performance indicators (throughput, error rates, charting, etc.) in near real time. Respond quickly to failure conditions and anomalies. Get the most out of New Relic One dashboards. Reduce mean time to detection with APM events reporting every five seconds. Agent version to automatically enable To enable real time streaming, update to the latest New Relic APM agent. You don't need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all APM agents. Here are the minimum agent versions: C SDK: v1.3.0 or higher Go: v2.8.0 or higher Java: v5.5.0 or higher .NET: v8.23.107.0 or higher Node.js: v5.13.0 or higher PHP: v9.5.0.252 or higher Python: v5.2.0.127 or higher Ruby: v6.7.0.359 or higher Caution If Transaction event reporting is disabled, this can affect some UI elements throughout New Relic. You may see some empty charts on some UI pages that rely on this data. Query real time streaming data When building charts, include the following in your NRQL query: NRQL clause Comments SINCE 5 minutes ago Be sure to add a SINCE 5 minutes ago clause to your NRQL query in order to take advantage of the 5 second chart refresh interval. This is because the chart's refresh interval is based on the time window. TIMESERIES bucket To set the refresh interval for time series charts, you can also specify the bucket size as an optional argument to the TIMESERIES clause. For example, SINCE 30 minutes ago TIMESERIES 5 seconds will display a 30 minute window at a 5 second resolution. You can have a maximum of 366 buckets. Create real time streaming charts You can visualize the results of your NRQL query in New Relic One: Go to one.newrelic.com, and at the top of the page, select Query your data. Use the chart builder to start building a chart. Select the advanced (NRQL) mode. (If you start with basic mode, switch to advanced mode to complete the next step.) In your NRQL query, adjust the SINCE and TIMESERIES clauses to take advantage of the 5 second refresh intervals.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.05658,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Agent</em> version to automatically enable",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " to automatically enable To enable real time streaming, update to the latest New Relic <em>APM</em> <em>agent</em>. You don&#x27;t need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all <em>APM</em> <em>agents</em>. Here are the minimum <em>agent</em> versions: C SDK: v1.3.0"
      },
      "id": "603e9d27196a678e41a83db1"
    },
    {
      "sections": [
        "Custom instrumentation",
        "Important",
        "When to use custom instrumentation",
        "Implement custom instrumentation",
        "C SDK custom instrumentation",
        "Go custom instrumentation",
        "Java custom instrumentation",
        ".NET custom instrumentation",
        "Node.js custom instrumentation",
        "PHP custom instrumentation",
        "Python custom instrumentation",
        "Ruby custom instrumentation",
        "Grouping issues"
      ],
      "title": "Custom instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "2e6cd68b3d93f9ed716ca25b96aac87d4520de75",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/custom-instrumentation/",
      "published_at": "2021-05-05T01:44:05Z",
      "updated_at": "2021-03-16T13:49:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic collects and reports information on web transactions and non-web transactions, such as background tasks. New Relic normally produces complete information automatically, without any need to modify your application code. However, if you are not using a supported framework, you may need to add custom instrumentation. Custom instrumentation is also useful to: Add detail to your transaction traces. Block instrumentation on selected transactions you do not want instrumented. Instrument a part of your code that New Relic simply is not picking up. Custom instrumentation that creates a new transaction collects both metric timeslice and event data. Custom instrumentation for already instrumented transactions collects only metric timeslice data. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. When to use custom instrumentation Custom instrumentation allows you to track interactions that are not captured by New Relic's automatic instrumentation. Custom instrumentation can also add detail to your transaction traces, to help you identify key issues. New Relic collects data from many frameworks automatically. If you are using a supported framework, you should not need custom instrumentation to collect metric timeslices, events, and traces. However, if you encounter any of these situations, you may need custom instrumentation: Transactions do not appear in the UI. Transaction traces include large blocks of application code time without full detail. If you are using a supported framework, but are not seeing transaction on the New Relic APM Transactions page, get support at support.newrelic.com to ensure the framework instrumentation is working. Implement custom instrumentation Each agent implements custom instrumentation differently: C SDK custom instrumentation For applications monitored by the C SDK, you must manually instrument transactions, segments, and errors. For more information, see the C SDK instrumentation procedures. Go custom instrumentation Because Golang apps run from a compiled, native binary file, all New Relic instrumentation must be done manually. See Instrument Go transactions and Instrument Go segments for how to set up instrumentation in your Go app. Java custom instrumentation New Relic's Java agent supports two methods of custom instrumentation: Annotation: Add @Trace annotations to your code to ensure New Relic instruments specific methods. Annotation is easy to implement, if you are instrumenting only a few methods. For more complex instrumentation, or if you are unable to modify your code, use XML. XML: Define the methods you want New Relic to monitor in an XML file. XML instrumentation is flexible and doesn't require editing your code, but is more difficult to troubleshoot than annotation. For more information, see Java custom instrumentation. .NET custom instrumentation New Relic's .NET agent supports two methods of custom instrumentation: Attributes: Annotate your code with agent API calls to instrument specific methods. Annotation is easy to implement, but requires editing your source code. XML: Define the methods you want New Relic to instrument in an XML file. XML instrumentation does not require modifying your source code, but is more complicated to create and keep updated than attribute instrumentation. For more information, see Introduction to .NET custom instrumentation. Node.js custom instrumentation New Relic's Node.js agent uses API calls for custom instrumentation. For more information, see Node.js custom instrumentation. PHP custom instrumentation New Relic's PHP agent uses API calls for custom instrumentation. For more information, see PHP custom instrumentation. Python custom instrumentation New Relic's Python agent supports two methods of custom instrumentation: Configuration file: Use the agent configuration file to specify the functions and methods you want instrumented. The agent configuration file is easy to set up, and it does not require you to modify your code. However, it is less flexible than API calls. API calls: Edit your code to call the New Relic Python API. The API is more flexible than instrumentation via the configuration file, but it requires you to modify your code. For more information, see Python custom instrumentation. Ruby custom instrumentation New Relic's Ruby agent uses API calls to define target methods and add transaction tracers to them. For more information, see Ruby custom instrumentation. Grouping issues A metric grouping issue occurs when an account sends too many differently-named metric timeslices to New Relic, and those individual web transactions are not properly aggregated. For example, rather than a single /user/controlpanel/ metric name, you might see /user/controlpanel/alice, /user/controlpanel/bob, and /user/controlpanel/carol. Custom instrumentation can cause metric grouping issues if you introduce too many uniquely-named metric timeslices that New Relic cannot effectively group. If you send thousands of metrics, New Relic may apply rules to reduce the number of transactions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.04033,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " transaction collects both metric timeslice and event <em>data</em>. Custom instrumentation for already instrumented transactions collects only metric timeslice <em>data</em>. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use"
      },
      "id": "603eb8b928ccbc1a79eba78c"
    }
  ],
  "/docs/agents/manage-apm-agents/agent-data/real-time-streaming": [
    {
      "sections": [
        "Server-side agent configuration",
        "Centralization and security",
        "Server-side configuration precedence",
        "Enable server-side configuration",
        "Tip",
        "View or change server-side configuration settings",
        "Disable server-side configuration"
      ],
      "title": "Server-side agent configuration",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Configuration"
      ],
      "external_id": "928ff211d9e5aa0e02dc64ed344e8cbbd3ea91b5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/configuration/server-side-agent-configuration/",
      "published_at": "2021-05-05T06:35:22Z",
      "updated_at": "2021-05-05T06:35:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Server-side configuration transitions some core settings from your language agent's configuration file to the New Relic collector. Depending on the language agent, available settings may include: Transaction tracing SQL recording and logging SQL query plans Error collection Thread profiling Distributed tracing Cross application tracing Centralization and security Server-side configuration provides an easy way to manage the available settings from the New Relic UI. Centralized configuration settings can also help you ensure standards compliance and security management for your settings. Any change automatically applies to all New Relic APM agents, even if they run across multiple hosts. The agent still follows the local configurations for any settings not available from the UI. Server-side configuration precedence This feature provides the convenience of managing the available configuration settings directly within the New Relic UI, without the need for deployments or restarts. Available options to change settings, and the order of precedence they take when you utilize environment variables or other configuration options, will depend on the language agent used. For more information about the hierarchy of settings, see the illustration for the specific agent: C SDK configuration: A hierarchy is not applicable, because configuration values come from API calls. Also, server-side configuration is not supported. However, you can change the app name from the UI or from the C SDK configuration settings. Go hierarchy Java hierarchy .NET hierarchy Node.js hierarchy PHP hierarchy (server-side configuration not supported) Python hierarchy Ruby hierarchy Enable server-side configuration Tip Owner, Admins, or Add-on Managers The C SDK and PHP agent do not support server-side configuration. To enable server-side configuration settings for apps that use other New Relic agents: Go to rpm.newrelic.com/apm > (select an app) > Settings > Application > Server-side agent configuration. OR Go to rpm.newrelic.com/apm. Next, from the index of applications, select the app's gear icon, then select View settings > Server-side agent configuration. Set the Server-side configuration enabled toggle to On. Select Save server-side configuration. After you enable server-side configuration, you can view and change the available settings through the UI. View or change server-side configuration settings Tip Owner, Admins, or Add-on Managers If you use server-side configuration, you must still include your license_key and app_name in the local config file. These settings are required for the agent to communicate with the New Relic collector. The C SDK and PHP agent do not support server-side configuration. To view or change the available server-side configuration settings through the UI for apps that use other New Relic agents: Go to rpm.newrelic.com/apm > (select an app) > Settings > Application > Server-side agent configuration. OR Go to rpm.newrelic.com/apm. Next, from the index of applications, select the app's gear icon, then select View settings > Server-side agent configuration. View or change the available configuration settings for your agent. If you make changes, select Save server-side configuration. Once you set any of these options from the UI, they will override any conflicting options in the agent's configuration file. Disable server-side configuration Once you enable server-side configuration for an account, server-side configuration cannot be turned off without assistance from New Relic Support. This helps mitigate issues that could arise from conflicts with configuration settings if you need to transition back to a local configuration setup.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 172.61499,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Server-side <em>agent</em> configuration",
        "sections": "Server-side <em>agent</em> configuration",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " change automatically applies to all New Relic <em>APM</em> <em>agents</em>, even if they run across multiple hosts. The <em>agent</em> still follows the local configurations for any settings not available from the UI. Server-side configuration precedence This feature provides the convenience of managing the available"
      },
      "id": "6043c83b64441fc5d6378ed1"
    },
    {
      "sections": [
        "Custom instrumentation",
        "Important",
        "When to use custom instrumentation",
        "Implement custom instrumentation",
        "C SDK custom instrumentation",
        "Go custom instrumentation",
        "Java custom instrumentation",
        ".NET custom instrumentation",
        "Node.js custom instrumentation",
        "PHP custom instrumentation",
        "Python custom instrumentation",
        "Ruby custom instrumentation",
        "Grouping issues"
      ],
      "title": "Custom instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "2e6cd68b3d93f9ed716ca25b96aac87d4520de75",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/custom-instrumentation/",
      "published_at": "2021-05-05T01:44:05Z",
      "updated_at": "2021-03-16T13:49:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic collects and reports information on web transactions and non-web transactions, such as background tasks. New Relic normally produces complete information automatically, without any need to modify your application code. However, if you are not using a supported framework, you may need to add custom instrumentation. Custom instrumentation is also useful to: Add detail to your transaction traces. Block instrumentation on selected transactions you do not want instrumented. Instrument a part of your code that New Relic simply is not picking up. Custom instrumentation that creates a new transaction collects both metric timeslice and event data. Custom instrumentation for already instrumented transactions collects only metric timeslice data. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. When to use custom instrumentation Custom instrumentation allows you to track interactions that are not captured by New Relic's automatic instrumentation. Custom instrumentation can also add detail to your transaction traces, to help you identify key issues. New Relic collects data from many frameworks automatically. If you are using a supported framework, you should not need custom instrumentation to collect metric timeslices, events, and traces. However, if you encounter any of these situations, you may need custom instrumentation: Transactions do not appear in the UI. Transaction traces include large blocks of application code time without full detail. If you are using a supported framework, but are not seeing transaction on the New Relic APM Transactions page, get support at support.newrelic.com to ensure the framework instrumentation is working. Implement custom instrumentation Each agent implements custom instrumentation differently: C SDK custom instrumentation For applications monitored by the C SDK, you must manually instrument transactions, segments, and errors. For more information, see the C SDK instrumentation procedures. Go custom instrumentation Because Golang apps run from a compiled, native binary file, all New Relic instrumentation must be done manually. See Instrument Go transactions and Instrument Go segments for how to set up instrumentation in your Go app. Java custom instrumentation New Relic's Java agent supports two methods of custom instrumentation: Annotation: Add @Trace annotations to your code to ensure New Relic instruments specific methods. Annotation is easy to implement, if you are instrumenting only a few methods. For more complex instrumentation, or if you are unable to modify your code, use XML. XML: Define the methods you want New Relic to monitor in an XML file. XML instrumentation is flexible and doesn't require editing your code, but is more difficult to troubleshoot than annotation. For more information, see Java custom instrumentation. .NET custom instrumentation New Relic's .NET agent supports two methods of custom instrumentation: Attributes: Annotate your code with agent API calls to instrument specific methods. Annotation is easy to implement, but requires editing your source code. XML: Define the methods you want New Relic to instrument in an XML file. XML instrumentation does not require modifying your source code, but is more complicated to create and keep updated than attribute instrumentation. For more information, see Introduction to .NET custom instrumentation. Node.js custom instrumentation New Relic's Node.js agent uses API calls for custom instrumentation. For more information, see Node.js custom instrumentation. PHP custom instrumentation New Relic's PHP agent uses API calls for custom instrumentation. For more information, see PHP custom instrumentation. Python custom instrumentation New Relic's Python agent supports two methods of custom instrumentation: Configuration file: Use the agent configuration file to specify the functions and methods you want instrumented. The agent configuration file is easy to set up, and it does not require you to modify your code. However, it is less flexible than API calls. API calls: Edit your code to call the New Relic Python API. The API is more flexible than instrumentation via the configuration file, but it requires you to modify your code. For more information, see Python custom instrumentation. Ruby custom instrumentation New Relic's Ruby agent uses API calls to define target methods and add transaction tracers to them. For more information, see Ruby custom instrumentation. Grouping issues A metric grouping issue occurs when an account sends too many differently-named metric timeslices to New Relic, and those individual web transactions are not properly aggregated. For example, rather than a single /user/controlpanel/ metric name, you might see /user/controlpanel/alice, /user/controlpanel/bob, and /user/controlpanel/carol. Custom instrumentation can cause metric grouping issues if you introduce too many uniquely-named metric timeslices that New Relic cannot effectively group. If you send thousands of metrics, New Relic may apply rules to reduce the number of transactions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.04033,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " transaction collects both metric timeslice and event <em>data</em>. Custom instrumentation for already instrumented transactions collects only metric timeslice <em>data</em>. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use"
      },
      "id": "603eb8b928ccbc1a79eba78c"
    },
    {
      "sections": [
        "Link your applications to Kubernetes"
      ],
      "title": "Link your applications to Kubernetes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "bcd540ade6ba7dc78cfe28db96b5bb18ee576fb7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/link-your-applications-kubernetes/",
      "published_at": "2021-05-05T02:11:01Z",
      "updated_at": "2021-03-16T13:49:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Agents can be configured to collect Kubernetes-related environment variables and add them to Transaction events to provide context between your Kubernetes cluster and your services. For details on the benefits see this blog post. For more information on agent compatibility and installation instructions, see our Kubernetes documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.04033,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": "<em>Agents</em> can be configured to collect Kubernetes-related environment variables and add them to Transaction events to provide context between your Kubernetes cluster and your services. For details on the benefits see this blog post. For more information on <em>agent</em> compatibility and installation instructions, see our Kubernetes documentation."
      },
      "id": "603ebbed196a67b1c8a83de6"
    }
  ],
  "/docs/agents/manage-apm-agents/app-naming/name-your-application": [
    {
      "sections": [
        "Use multiple names for an app",
        "Important",
        "Roll up app data",
        "Prevent duplicate transaction events",
        "Roll up Browser data",
        "Define app names from most to least specific",
        "Name app instances via agent config file",
        "Examples",
        "One app, three clusters",
        "Two instances of one app",
        "Other options to organize your apps"
      ],
      "title": "Use multiple names for an app",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "App naming"
      ],
      "external_id": "af78a44c170729aac326233d6468b0b61b6cdff2",
      "image": "https://docs.newrelic.com/static/67c256b1f08164be39b8eeb2ca8ff4e6/8c557/Insights-ToggleOnOff.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/app-naming/use-multiple-names-app/",
      "published_at": "2021-05-05T16:36:25Z",
      "updated_at": "2021-04-16T06:55:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When working with your data in New Relic, you may want to view aggregated data for an application across clusters, environments, or data centers, while at the same time be able to view each of your application instance's data individually. Important If you use multiple names for an app, the last name assigned is the least specific name New Relic uses to roll up the data. For best results to view both instance-level and aggregated data, set the order of your app's rollup names from most specific to least specific in your configuration file. Roll up app data Normally, when two instances report with the same app name, agent language, and license key, New Relic aggregates their data into a single app within the New Relic user interface. You can also view data for the individual hosts and instances from the app's New Relic APM Overview page. To segment your app in a different way, or to work with each instance as an individual app while maintaining the overall view of the data, use your New Relic agent's config file to give an app up to three different rollup names. New Relic will then report the app's data separately to each app listed in the config file. For example, you might want to separate the data collected for your app running in development, staging, and production environments, but also have a common view of the app in every environment. Or, if you have two data centers running the same code, you could name one app EastCoastApp;AggregateApp and the second app WestCoastApp;AggregateApp. Prevent duplicate transaction events By default, an app with multiple names will generate multiple Insights events for transactions (a duplicate transaction for each name). For example, if you give your app three names, that's three times the number of Insights events for transactions. To avoid duplicate Insights events, disable collection for each of the duplicate app names: Go to one.newrelic.com or one.eu.newrelic.com > More > Manage Insights Data. Toggle data collection on/off for duplicate app names, then save. To prevent duplicate events from being collected for an app with multiple names, go to insights.newrelic.com > Manage data > Configure data sources. Roll up Browser data When you use multiple names to report application data, any Browser monitoring data from that application will also be grouped into multiple applications using the same configuration. Important Session trace data will only report to the first application listed. Other Browser data will populate into each of the up to three applications, but session trace data will be limited to the most specific application. Define app names from most to least specific You can give each app up to three names, which New Relic uses to aggregate data from most to least specific. You can then use the New Relic UI to view data for each app name individually, as well as in aggregate for overall application performance. When doing so, the order in which you specify the app names is important. Using multiple names Comments Most specific A unique rollup name. Less specific A shared rollup name to aggregate data in the New Relic UI. This provides more general organization. Optional, least specific An additional, shared rollup name. If used, this is the most general name New Relic uses to aggregate data into a single app. Name app instances via agent config file The naming convention you use in your configuration file depends on your New Relic agent. Set the order of your app's names so that the first rollup name is the most unique. The second and third names can be unique, or they can be the same. The second name is more general for aggregate data, and the third name (if used) is the most general. Agent Configuration file value C Identify a maximum of three names separated by a semicolon ; in your newrelic_app_config_t * config;. Go Set AppName to a maximum of three names separated by a semicolon. Java Set app_name to a maximum of three names separated by a semicolon. .NET Use any of the available options to name your .NET app. Node.js Set app_name to a maximum of three names separated by a comma. Enclose the string of names with single or double quotes. (Or, change the environment variable NEW_RELIC_APP_NAME.) PHP Use any of the available options to name your PHP application. Use three names separated by a semicolon. Python Set app_name to a maximum of three names separated by a semicolon. Do not add a space after the semicolon, or the next name will be interpreted as a comment. Ruby Set app_name to a maximum of three names separated by a semicolon. For more information, refer to the configuration file documentation for your agent. Examples Here are examples of how you could use multiple rollup names for a single app. One app, three clusters A Java app collecting survey data runs on three clusters. Change the value for the app name in your agent config file by giving it three different names, one for each cluster. Cluster 1: app_name: SurveyCluster1;Survey Data Copy Cluster 2: app_name: SurveyCluster2;Survey Data Copy Cluster 3: app_name: SurveyCluster3;Survey Data Copy This will report four applications in New Relic APM: The app name for aggregate data from all three clusters is Survey Data. Three individual applications named SurveyCluster1, SurveyCluster2, and SurveyCluster3. Two instances of one app A PHP agent is monitoring an e-commerce application running on two clusters in each of two data centers, and you want to view data for each subgroup as well as the overall aggregated data. Cluster A: newrelic.appname=\"EcomClusterA;EcomEast;EcomAll\" Copy Cluster B: newrelic.appname=\"EcomClusterB;EcomEast;EcomAll\" Copy Cluster C: newrelic.appname=\"EcomClusterC;EcomWest;EcomAll\" Copy Cluster D: newrelic.appname=\"EcomClusterD;EcomWest;EcomAll\" Copy This example configuration will report seven applications in the New Relic APM UI: Four apps: One for each of the four clusters (A B C D) Two apps: One for each datacenter (East and West) One app for the overall data across clusters and data centers (EcomAll) Other options to organize your apps If you do not want to apply multiple names to your apps, you can organize them with labels and categories. This allows you to easily sort, filter, and page through them from their product index pages in the New Relic UI. You can also set distinct performance thresholds for each environment with alert conditions and key transactions. These thresholds will apply to the individual apps, while the overall app will not have its own thresholds. The overall app will treat incoming data according to the threshold for the relevant enviroment.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 201.24977,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use multiple <em>names</em> for an <em>app</em>",
        "sections": "<em>Name</em> <em>app</em> instances via <em>agent</em> config file",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " with the same <em>app</em> <em>name</em>, <em>agent</em> language, and license key, New Relic aggregates their data into a single <em>app</em> within the New Relic user interface. You can also view data for the individual hosts and instances from the <em>app</em>&#x27;s New Relic <em>APM</em> Overview page. To segment your <em>app</em> in a different way, or to work"
      },
      "id": "603ebde1196a677dbaa83dec"
    },
    {
      "sections": [
        "Server-side agent configuration",
        "Centralization and security",
        "Server-side configuration precedence",
        "Enable server-side configuration",
        "Tip",
        "View or change server-side configuration settings",
        "Disable server-side configuration"
      ],
      "title": "Server-side agent configuration",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Configuration"
      ],
      "external_id": "928ff211d9e5aa0e02dc64ed344e8cbbd3ea91b5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/configuration/server-side-agent-configuration/",
      "published_at": "2021-05-05T06:35:22Z",
      "updated_at": "2021-05-05T06:35:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Server-side configuration transitions some core settings from your language agent's configuration file to the New Relic collector. Depending on the language agent, available settings may include: Transaction tracing SQL recording and logging SQL query plans Error collection Thread profiling Distributed tracing Cross application tracing Centralization and security Server-side configuration provides an easy way to manage the available settings from the New Relic UI. Centralized configuration settings can also help you ensure standards compliance and security management for your settings. Any change automatically applies to all New Relic APM agents, even if they run across multiple hosts. The agent still follows the local configurations for any settings not available from the UI. Server-side configuration precedence This feature provides the convenience of managing the available configuration settings directly within the New Relic UI, without the need for deployments or restarts. Available options to change settings, and the order of precedence they take when you utilize environment variables or other configuration options, will depend on the language agent used. For more information about the hierarchy of settings, see the illustration for the specific agent: C SDK configuration: A hierarchy is not applicable, because configuration values come from API calls. Also, server-side configuration is not supported. However, you can change the app name from the UI or from the C SDK configuration settings. Go hierarchy Java hierarchy .NET hierarchy Node.js hierarchy PHP hierarchy (server-side configuration not supported) Python hierarchy Ruby hierarchy Enable server-side configuration Tip Owner, Admins, or Add-on Managers The C SDK and PHP agent do not support server-side configuration. To enable server-side configuration settings for apps that use other New Relic agents: Go to rpm.newrelic.com/apm > (select an app) > Settings > Application > Server-side agent configuration. OR Go to rpm.newrelic.com/apm. Next, from the index of applications, select the app's gear icon, then select View settings > Server-side agent configuration. Set the Server-side configuration enabled toggle to On. Select Save server-side configuration. After you enable server-side configuration, you can view and change the available settings through the UI. View or change server-side configuration settings Tip Owner, Admins, or Add-on Managers If you use server-side configuration, you must still include your license_key and app_name in the local config file. These settings are required for the agent to communicate with the New Relic collector. The C SDK and PHP agent do not support server-side configuration. To view or change the available server-side configuration settings through the UI for apps that use other New Relic agents: Go to rpm.newrelic.com/apm > (select an app) > Settings > Application > Server-side agent configuration. OR Go to rpm.newrelic.com/apm. Next, from the index of applications, select the app's gear icon, then select View settings > Server-side agent configuration. View or change the available configuration settings for your agent. If you make changes, select Save server-side configuration. Once you set any of these options from the UI, they will override any conflicting options in the agent's configuration file. Disable server-side configuration Once you enable server-side configuration for an account, server-side configuration cannot be turned off without assistance from New Relic Support. This helps mitigate issues that could arise from conflicts with configuration settings if you need to transition back to a local configuration setup.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.89888,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Server-side <em>agent</em> configuration",
        "sections": "Server-side <em>agent</em> configuration",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " configuration. To enable server-side configuration settings for apps that use other New Relic <em>agents</em>: Go to rpm.newrelic.com&#x2F;<em>apm</em> &gt; (select an <em>app</em>) &gt; Settings &gt; Application &gt; Server-side <em>agent</em> configuration. OR Go to rpm.newrelic.com&#x2F;<em>apm</em>. Next, from the index of applications, select the <em>app</em>&#x27;s gear icon"
      },
      "id": "6043c83b64441fc5d6378ed1"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/update-left-navigation-pane/",
      "sections": [
        "Update left-navigation pane",
        "The configuration file",
        "Configuration file options",
        "Tip"
      ],
      "published_at": "2021-05-06T04:14:47Z",
      "title": "Update left-navigation pane",
      "updated_at": "2021-03-30T14:21:04Z",
      "type": "docs",
      "external_id": "a05e38602a1eb152749923691d251ef2c99f05a9",
      "document_type": "page",
      "popularity": 1,
      "body": "Navigation for docs.newrelic.com is stored in YAML files located in the /src/nav/ directory. Each top-level navigation should have its own configuration file. You'll most likely edit a version of this file in your branch and merge it into the develop branch. The configuration file As an example, here's a snippet of the agents.yml navigation configuration. Note that the file has indentation that corresponds to the level of the navigation hierarchy. Be sure to imitate the same spacing when you make changes: title: Agents path: /docs/agents pages: - title: Manage APM agents pages: - title: Agent data pages: - title: Real time streaming path: /docs/agents/manage-apm-agents/agent-data/real-time-streaming - title: Custom instrumentation path: /docs/agents/manage-apm-agents/agent-data/custom-instrumentation - title: Agent attributes path: /docs/agents/manage-apm-agents/agent-data/agent-attributes - title: Custom events path: /docs/agents/manage-apm-agents/agent-data/collect-custom-events - title: Custom metrics path: /docs/agents/manage-apm-agents/agent-data/collect-custom-metrics - title: Manage errors path: /docs/agents/manage-apm-agents/agent-data/manage-errors-apm-collect-ignore-or-mark-expected - title: Link Kubernetes path: /docs/agents/manage-apm-agents/agent-data/link-your-applications-kubernetes - title: App naming pages: - title: Name your application path: /docs/agents/manage-apm-agents/app-naming/name-your-application - title: Use multiple names for an app path: /docs/agents/manage-apm-agents/app-naming/use-multiple-names-app Copy Configuration file options When you're changing the navigation, keep in mind that each node in the .yml configuration file can have the following properties: Key Required? Description title yes The text that is shown in the navigation. path no The URL path to the page. children no Any sub-navigation nodes. When the user goes to a page, we determine which section of the site they are on and load the appropriate .yml file to populate the sidebar navigation. The navigation for the homepage is an aggregate of all the top-level pages. Tip Each category has its own index.md page (list of pages for that category). When updating the navigation, you may also want to update these pages to reflect the new information architecture more correctly.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 160.38745,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "-or-mark-expected - title: Link Kubernetes path: &#x2F;docs&#x2F;<em>agents</em>&#x2F;<em>manage</em>-<em>apm</em>-<em>agents</em>&#x2F;<em>agent</em>-data&#x2F;link-your-applications-kubernetes - title: <em>App</em> <em>naming</em> pages: - title: <em>Name</em> your application path: &#x2F;docs&#x2F;<em>agents</em>&#x2F;<em>manage</em>-<em>apm</em>-<em>agents</em>&#x2F;<em>app</em>-<em>naming</em>&#x2F;<em>name</em>-your-application - title: Use multiple names for an <em>app</em> path: &#x2F;docs"
      },
      "id": "60422077196a67ad56a83dc8"
    }
  ],
  "/docs/agents/manage-apm-agents/app-naming/use-multiple-names-app": [
    {
      "sections": [
        "Name or change the name of your application",
        "Important",
        "Changing the name vs. the alias",
        "Give each app a descriptive name",
        "Assign the name in your config file",
        "Change the application's alias",
        "Tip",
        "Using multiple names for an app"
      ],
      "title": "Name or change the name of your application",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "App naming"
      ],
      "external_id": "bfd84f5a7908a84cbe4fa4e8ccb44be94997c85b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/app-naming/name-your-application/",
      "published_at": "2021-05-05T04:44:24Z",
      "updated_at": "2021-03-16T14:51:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic connects metrics to individual applications using your license key and the primary application name. You can change the app's name in your config file, or assign an alias to the app to change how it appears in the New Relic UI. Important If you do not specify the app name in your New Relic configuration file, most New Relic agents provide a generic application name by default. To ensure all aggregated data for the same app is reported accurately, make sure you give each app a descriptive name. Changing the name vs. the alias You can assign a new app name or change the app alias. These have two different effects: Term How to change it Effect Name Assign the name in your config file Changing the app name in the agent's configuration file will cause the application to report to a new heading in the New Relic user interface, with a total discontinuity of data. This is useful, for example, if you want to start over and report new data. If no other agents are reporting to the old app name, the old app name will appear gray and can be deleted. Alias Change the alias in the APM Settings UI Creating an alias for the app name only changes how the app name appears in the New Relic UI. Changing the alias does not affect how data is reported. It simply helps you keep track of your data with a useful alias. Give each app a descriptive name By default, most New Relic agents provide a default application name, such as My Application or PHP Application, for each app that is linked to your account. Important We recommend changing the default name of an app to a more descriptive name before deployment, and it can be up to 128 characters long. Each unique app name creates a new application record in your New Relic UI, which allows you to: Run an application on more than one host, and have all the data aggregated (collected) under the same name. Run multiple applications on a single host, and have all the data aggregated (collected) under different names. Assign the name in your config file To change the app name, set the app name value in the agent's configuration file. If you have deployed an app via one APM agent, and then deploy another app with the same name via a different APM agent, New Relic will automatically append the agent language name to the end of the second app's name. For example, if you deploy a Node.js app named New-App, and then deploy a .NET app named New-App, New Relic will automatically append the second app name as New-App (DOTNET). Agent Configuration file value C Identify a maximum of three names separated by a semicolon ;in your newrelic_app_config_t* config;. Go Set AppName to a maximum of three names separated by a semicolon. Java See the options for naming your Java application. .NET Use any of the available options to name your .NET app. Node.js Set app_name to a maximum of three names separated by a comma. Enclose the names with single or double quotes. (Or, change the environment variable NEW_RELIC_APP_NAME.) PHP See the options for naming your PHP application. Python Set app_name to a maximum of three names separated by a semicolon. Do not add a space after the semicolon, or the next name will be interpreted as a comment. Ruby Set app_name to a maximum of three names separated by a semicolon. Change the application's alias The application name you set in the New Relic user interface is a human-readable alias. If you rename your app, the visible name is updated everywhere in the New Relic site, including New Relic Browser. Initially, this alias is the same as the app's identifier name in the New Relic agent configuration file. However, changing the UI alias does not affect the underlying app name used for data rollup, which is set in the agent config file. The application must be actively reporting data to change the alias. Changing the UI alias will cause all agents that report under the app identifier to restart themselves. To change the alias for your application's name in the New Relic user interface: Go to one.newrelic.com > APM > (select an app) > Settings > Application. In the Application alias field, type a new name (alias) for the selected app. Select Save application settings. Tip You can also change the app's alias with the New Relic REST API. Using multiple names for an app By giving your app multiple names, you can aggregate metrics for multiple agents across an entire app or service. Important If you use multiple names for an app, the last name assigned is the least specific name New Relic uses to roll up the data. For best results to view both instance-level and aggregated data, set the order of your app's rollup names from most specific to least specific in your configuration file.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.10689,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Name</em> or change the <em>name</em> of your <em>application</em>",
        "sections": "<em>Name</em> or change the <em>name</em> of your <em>application</em>",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": ", for example, if you want to start over and report new data. If no other <em>agents</em> are reporting to the old <em>app</em> <em>name</em>, the old <em>app</em> <em>name</em> will appear gray and can be deleted. Alias Change the alias in the <em>APM</em> Settings UI Creating an alias for the <em>app</em> <em>name</em> only changes how the <em>app</em> <em>name</em> appears in the New Relic"
      },
      "id": "603eb81264441fa6a74e889a"
    },
    {
      "sections": [
        "Server-side agent configuration",
        "Centralization and security",
        "Server-side configuration precedence",
        "Enable server-side configuration",
        "Tip",
        "View or change server-side configuration settings",
        "Disable server-side configuration"
      ],
      "title": "Server-side agent configuration",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Configuration"
      ],
      "external_id": "928ff211d9e5aa0e02dc64ed344e8cbbd3ea91b5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/configuration/server-side-agent-configuration/",
      "published_at": "2021-05-05T06:35:22Z",
      "updated_at": "2021-05-05T06:35:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Server-side configuration transitions some core settings from your language agent's configuration file to the New Relic collector. Depending on the language agent, available settings may include: Transaction tracing SQL recording and logging SQL query plans Error collection Thread profiling Distributed tracing Cross application tracing Centralization and security Server-side configuration provides an easy way to manage the available settings from the New Relic UI. Centralized configuration settings can also help you ensure standards compliance and security management for your settings. Any change automatically applies to all New Relic APM agents, even if they run across multiple hosts. The agent still follows the local configurations for any settings not available from the UI. Server-side configuration precedence This feature provides the convenience of managing the available configuration settings directly within the New Relic UI, without the need for deployments or restarts. Available options to change settings, and the order of precedence they take when you utilize environment variables or other configuration options, will depend on the language agent used. For more information about the hierarchy of settings, see the illustration for the specific agent: C SDK configuration: A hierarchy is not applicable, because configuration values come from API calls. Also, server-side configuration is not supported. However, you can change the app name from the UI or from the C SDK configuration settings. Go hierarchy Java hierarchy .NET hierarchy Node.js hierarchy PHP hierarchy (server-side configuration not supported) Python hierarchy Ruby hierarchy Enable server-side configuration Tip Owner, Admins, or Add-on Managers The C SDK and PHP agent do not support server-side configuration. To enable server-side configuration settings for apps that use other New Relic agents: Go to rpm.newrelic.com/apm > (select an app) > Settings > Application > Server-side agent configuration. OR Go to rpm.newrelic.com/apm. Next, from the index of applications, select the app's gear icon, then select View settings > Server-side agent configuration. Set the Server-side configuration enabled toggle to On. Select Save server-side configuration. After you enable server-side configuration, you can view and change the available settings through the UI. View or change server-side configuration settings Tip Owner, Admins, or Add-on Managers If you use server-side configuration, you must still include your license_key and app_name in the local config file. These settings are required for the agent to communicate with the New Relic collector. The C SDK and PHP agent do not support server-side configuration. To view or change the available server-side configuration settings through the UI for apps that use other New Relic agents: Go to rpm.newrelic.com/apm > (select an app) > Settings > Application > Server-side agent configuration. OR Go to rpm.newrelic.com/apm. Next, from the index of applications, select the app's gear icon, then select View settings > Server-side agent configuration. View or change the available configuration settings for your agent. If you make changes, select Save server-side configuration. Once you set any of these options from the UI, they will override any conflicting options in the agent's configuration file. Disable server-side configuration Once you enable server-side configuration for an account, server-side configuration cannot be turned off without assistance from New Relic Support. This helps mitigate issues that could arise from conflicts with configuration settings if you need to transition back to a local configuration setup.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.89888,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Server-side <em>agent</em> configuration",
        "sections": "Server-side <em>agent</em> configuration",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " configuration. To enable server-side configuration settings for apps that use other New Relic <em>agents</em>: Go to rpm.newrelic.com&#x2F;<em>apm</em> &gt; (select an <em>app</em>) &gt; Settings &gt; Application &gt; Server-side <em>agent</em> configuration. OR Go to rpm.newrelic.com&#x2F;<em>apm</em>. Next, from the index of applications, select the <em>app</em>&#x27;s gear icon"
      },
      "id": "6043c83b64441fc5d6378ed1"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/update-left-navigation-pane/",
      "sections": [
        "Update left-navigation pane",
        "The configuration file",
        "Configuration file options",
        "Tip"
      ],
      "published_at": "2021-05-06T04:14:47Z",
      "title": "Update left-navigation pane",
      "updated_at": "2021-03-30T14:21:04Z",
      "type": "docs",
      "external_id": "a05e38602a1eb152749923691d251ef2c99f05a9",
      "document_type": "page",
      "popularity": 1,
      "body": "Navigation for docs.newrelic.com is stored in YAML files located in the /src/nav/ directory. Each top-level navigation should have its own configuration file. You'll most likely edit a version of this file in your branch and merge it into the develop branch. The configuration file As an example, here's a snippet of the agents.yml navigation configuration. Note that the file has indentation that corresponds to the level of the navigation hierarchy. Be sure to imitate the same spacing when you make changes: title: Agents path: /docs/agents pages: - title: Manage APM agents pages: - title: Agent data pages: - title: Real time streaming path: /docs/agents/manage-apm-agents/agent-data/real-time-streaming - title: Custom instrumentation path: /docs/agents/manage-apm-agents/agent-data/custom-instrumentation - title: Agent attributes path: /docs/agents/manage-apm-agents/agent-data/agent-attributes - title: Custom events path: /docs/agents/manage-apm-agents/agent-data/collect-custom-events - title: Custom metrics path: /docs/agents/manage-apm-agents/agent-data/collect-custom-metrics - title: Manage errors path: /docs/agents/manage-apm-agents/agent-data/manage-errors-apm-collect-ignore-or-mark-expected - title: Link Kubernetes path: /docs/agents/manage-apm-agents/agent-data/link-your-applications-kubernetes - title: App naming pages: - title: Name your application path: /docs/agents/manage-apm-agents/app-naming/name-your-application - title: Use multiple names for an app path: /docs/agents/manage-apm-agents/app-naming/use-multiple-names-app Copy Configuration file options When you're changing the navigation, keep in mind that each node in the .yml configuration file can have the following properties: Key Required? Description title yes The text that is shown in the navigation. path no The URL path to the page. children no Any sub-navigation nodes. When the user goes to a page, we determine which section of the site they are on and load the appropriate .yml file to populate the sidebar navigation. The navigation for the homepage is an aggregate of all the top-level pages. Tip Each category has its own index.md page (list of pages for that category). When updating the navigation, you may also want to update these pages to reflect the new information architecture more correctly.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 160.38745,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "-or-mark-expected - title: Link Kubernetes path: &#x2F;docs&#x2F;<em>agents</em>&#x2F;<em>manage</em>-<em>apm</em>-<em>agents</em>&#x2F;<em>agent</em>-data&#x2F;link-your-applications-kubernetes - title: <em>App</em> <em>naming</em> pages: - title: <em>Name</em> your application path: &#x2F;docs&#x2F;<em>agents</em>&#x2F;<em>manage</em>-<em>apm</em>-<em>agents</em>&#x2F;<em>app</em>-<em>naming</em>&#x2F;<em>name</em>-your-application - title: Use multiple names for an <em>app</em> path: &#x2F;docs"
      },
      "id": "60422077196a67ad56a83dc8"
    }
  ],
  "/docs/agents/manage-apm-agents/configuration/add-rename-remove-hosts": [
    {
      "sections": [
        "Server-side agent configuration",
        "Centralization and security",
        "Server-side configuration precedence",
        "Enable server-side configuration",
        "Tip",
        "View or change server-side configuration settings",
        "Disable server-side configuration"
      ],
      "title": "Server-side agent configuration",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Configuration"
      ],
      "external_id": "928ff211d9e5aa0e02dc64ed344e8cbbd3ea91b5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/configuration/server-side-agent-configuration/",
      "published_at": "2021-05-05T06:35:22Z",
      "updated_at": "2021-05-05T06:35:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Server-side configuration transitions some core settings from your language agent's configuration file to the New Relic collector. Depending on the language agent, available settings may include: Transaction tracing SQL recording and logging SQL query plans Error collection Thread profiling Distributed tracing Cross application tracing Centralization and security Server-side configuration provides an easy way to manage the available settings from the New Relic UI. Centralized configuration settings can also help you ensure standards compliance and security management for your settings. Any change automatically applies to all New Relic APM agents, even if they run across multiple hosts. The agent still follows the local configurations for any settings not available from the UI. Server-side configuration precedence This feature provides the convenience of managing the available configuration settings directly within the New Relic UI, without the need for deployments or restarts. Available options to change settings, and the order of precedence they take when you utilize environment variables or other configuration options, will depend on the language agent used. For more information about the hierarchy of settings, see the illustration for the specific agent: C SDK configuration: A hierarchy is not applicable, because configuration values come from API calls. Also, server-side configuration is not supported. However, you can change the app name from the UI or from the C SDK configuration settings. Go hierarchy Java hierarchy .NET hierarchy Node.js hierarchy PHP hierarchy (server-side configuration not supported) Python hierarchy Ruby hierarchy Enable server-side configuration Tip Owner, Admins, or Add-on Managers The C SDK and PHP agent do not support server-side configuration. To enable server-side configuration settings for apps that use other New Relic agents: Go to rpm.newrelic.com/apm > (select an app) > Settings > Application > Server-side agent configuration. OR Go to rpm.newrelic.com/apm. Next, from the index of applications, select the app's gear icon, then select View settings > Server-side agent configuration. Set the Server-side configuration enabled toggle to On. Select Save server-side configuration. After you enable server-side configuration, you can view and change the available settings through the UI. View or change server-side configuration settings Tip Owner, Admins, or Add-on Managers If you use server-side configuration, you must still include your license_key and app_name in the local config file. These settings are required for the agent to communicate with the New Relic collector. The C SDK and PHP agent do not support server-side configuration. To view or change the available server-side configuration settings through the UI for apps that use other New Relic agents: Go to rpm.newrelic.com/apm > (select an app) > Settings > Application > Server-side agent configuration. OR Go to rpm.newrelic.com/apm. Next, from the index of applications, select the app's gear icon, then select View settings > Server-side agent configuration. View or change the available configuration settings for your agent. If you make changes, select Save server-side configuration. Once you set any of these options from the UI, they will override any conflicting options in the agent's configuration file. Disable server-side configuration Once you enable server-side configuration for an account, server-side configuration cannot be turned off without assistance from New Relic Support. This helps mitigate issues that could arise from conflicts with configuration settings if you need to transition back to a local configuration setup.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 233.48058,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Server-side <em>agent</em> <em>configuration</em>",
        "sections": "Server-side <em>agent</em> <em>configuration</em>",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " change automatically applies to all New Relic <em>APM</em> <em>agents</em>, even if they run across multiple hosts. The <em>agent</em> still follows the local configurations for any settings not available from the UI. Server-side <em>configuration</em> precedence This feature provides the convenience of managing the available"
      },
      "id": "6043c83b64441fc5d6378ed1"
    },
    {
      "sections": [
        "Use multiple names for an app",
        "Important",
        "Roll up app data",
        "Prevent duplicate transaction events",
        "Roll up Browser data",
        "Define app names from most to least specific",
        "Name app instances via agent config file",
        "Examples",
        "One app, three clusters",
        "Two instances of one app",
        "Other options to organize your apps"
      ],
      "title": "Use multiple names for an app",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "App naming"
      ],
      "external_id": "af78a44c170729aac326233d6468b0b61b6cdff2",
      "image": "https://docs.newrelic.com/static/67c256b1f08164be39b8eeb2ca8ff4e6/8c557/Insights-ToggleOnOff.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/app-naming/use-multiple-names-app/",
      "published_at": "2021-05-05T16:36:25Z",
      "updated_at": "2021-04-16T06:55:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When working with your data in New Relic, you may want to view aggregated data for an application across clusters, environments, or data centers, while at the same time be able to view each of your application instance's data individually. Important If you use multiple names for an app, the last name assigned is the least specific name New Relic uses to roll up the data. For best results to view both instance-level and aggregated data, set the order of your app's rollup names from most specific to least specific in your configuration file. Roll up app data Normally, when two instances report with the same app name, agent language, and license key, New Relic aggregates their data into a single app within the New Relic user interface. You can also view data for the individual hosts and instances from the app's New Relic APM Overview page. To segment your app in a different way, or to work with each instance as an individual app while maintaining the overall view of the data, use your New Relic agent's config file to give an app up to three different rollup names. New Relic will then report the app's data separately to each app listed in the config file. For example, you might want to separate the data collected for your app running in development, staging, and production environments, but also have a common view of the app in every environment. Or, if you have two data centers running the same code, you could name one app EastCoastApp;AggregateApp and the second app WestCoastApp;AggregateApp. Prevent duplicate transaction events By default, an app with multiple names will generate multiple Insights events for transactions (a duplicate transaction for each name). For example, if you give your app three names, that's three times the number of Insights events for transactions. To avoid duplicate Insights events, disable collection for each of the duplicate app names: Go to one.newrelic.com or one.eu.newrelic.com > More > Manage Insights Data. Toggle data collection on/off for duplicate app names, then save. To prevent duplicate events from being collected for an app with multiple names, go to insights.newrelic.com > Manage data > Configure data sources. Roll up Browser data When you use multiple names to report application data, any Browser monitoring data from that application will also be grouped into multiple applications using the same configuration. Important Session trace data will only report to the first application listed. Other Browser data will populate into each of the up to three applications, but session trace data will be limited to the most specific application. Define app names from most to least specific You can give each app up to three names, which New Relic uses to aggregate data from most to least specific. You can then use the New Relic UI to view data for each app name individually, as well as in aggregate for overall application performance. When doing so, the order in which you specify the app names is important. Using multiple names Comments Most specific A unique rollup name. Less specific A shared rollup name to aggregate data in the New Relic UI. This provides more general organization. Optional, least specific An additional, shared rollup name. If used, this is the most general name New Relic uses to aggregate data into a single app. Name app instances via agent config file The naming convention you use in your configuration file depends on your New Relic agent. Set the order of your app's names so that the first rollup name is the most unique. The second and third names can be unique, or they can be the same. The second name is more general for aggregate data, and the third name (if used) is the most general. Agent Configuration file value C Identify a maximum of three names separated by a semicolon ; in your newrelic_app_config_t * config;. Go Set AppName to a maximum of three names separated by a semicolon. Java Set app_name to a maximum of three names separated by a semicolon. .NET Use any of the available options to name your .NET app. Node.js Set app_name to a maximum of three names separated by a comma. Enclose the string of names with single or double quotes. (Or, change the environment variable NEW_RELIC_APP_NAME.) PHP Use any of the available options to name your PHP application. Use three names separated by a semicolon. Python Set app_name to a maximum of three names separated by a semicolon. Do not add a space after the semicolon, or the next name will be interpreted as a comment. Ruby Set app_name to a maximum of three names separated by a semicolon. For more information, refer to the configuration file documentation for your agent. Examples Here are examples of how you could use multiple rollup names for a single app. One app, three clusters A Java app collecting survey data runs on three clusters. Change the value for the app name in your agent config file by giving it three different names, one for each cluster. Cluster 1: app_name: SurveyCluster1;Survey Data Copy Cluster 2: app_name: SurveyCluster2;Survey Data Copy Cluster 3: app_name: SurveyCluster3;Survey Data Copy This will report four applications in New Relic APM: The app name for aggregate data from all three clusters is Survey Data. Three individual applications named SurveyCluster1, SurveyCluster2, and SurveyCluster3. Two instances of one app A PHP agent is monitoring an e-commerce application running on two clusters in each of two data centers, and you want to view data for each subgroup as well as the overall aggregated data. Cluster A: newrelic.appname=\"EcomClusterA;EcomEast;EcomAll\" Copy Cluster B: newrelic.appname=\"EcomClusterB;EcomEast;EcomAll\" Copy Cluster C: newrelic.appname=\"EcomClusterC;EcomWest;EcomAll\" Copy Cluster D: newrelic.appname=\"EcomClusterD;EcomWest;EcomAll\" Copy This example configuration will report seven applications in the New Relic APM UI: Four apps: One for each of the four clusters (A B C D) Two apps: One for each datacenter (East and West) One app for the overall data across clusters and data centers (EcomAll) Other options to organize your apps If you do not want to apply multiple names to your apps, you can organize them with labels and categories. This allows you to easily sort, filter, and page through them from their product index pages in the New Relic UI. You can also set distinct performance thresholds for each environment with alert conditions and key transactions. These thresholds will apply to the individual apps, while the overall app will not have its own thresholds. The overall app will treat incoming data according to the threshold for the relevant enviroment.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.20662,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Name app instances via <em>agent</em> config file",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " with the same app name, <em>agent</em> language, and license key, New Relic aggregates their data into a single app within the New Relic user interface. You can also view data for the individual hosts and instances from the app&#x27;s New Relic <em>APM</em> Overview page. To segment your app in a different way, or to work"
      },
      "id": "603ebde1196a677dbaa83dec"
    },
    {
      "sections": [
        "View config values for your app",
        "Problem",
        "Solution",
        "Tip"
      ],
      "title": "View config values for your app",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Configuration"
      ],
      "external_id": "fe57f2d9748b60e439dd57d54ad49ebe4cbccc77",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/configuration/view-config-values-your-app/",
      "published_at": "2021-05-05T22:20:55Z",
      "updated_at": "2021-03-16T14:52:45Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem You need an easy way to get information about your application's configuration settings. Solution Tip Owner, Admins, or Add-on managers If you do not want to view your configuration file itself, you can view the configuration settings in the APM UI, go to rpm.newrelic.com > (select an app) > Settings > Environment > Agent initialization.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 131.79071,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": "Problem You need an easy way to get information about your application&#x27;s <em>configuration</em> settings. Solution Tip Owner, Admins, or Add-on managers If you do not want to view your <em>configuration</em> file itself, you can view the <em>configuration</em> settings in the <em>APM</em> UI, go to rpm.newrelic.com &gt; (select an app) &gt; Settings &gt; Environment &gt; <em>Agent</em> initialization."
      },
      "id": "603e7f60e7b9d2969a2a07e4"
    }
  ],
  "/docs/agents/manage-apm-agents/configuration/enable-configurable-security-policies": [
    {
      "sections": [
        "Server-side agent configuration",
        "Centralization and security",
        "Server-side configuration precedence",
        "Enable server-side configuration",
        "Tip",
        "View or change server-side configuration settings",
        "Disable server-side configuration"
      ],
      "title": "Server-side agent configuration",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Configuration"
      ],
      "external_id": "928ff211d9e5aa0e02dc64ed344e8cbbd3ea91b5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/configuration/server-side-agent-configuration/",
      "published_at": "2021-05-05T06:35:22Z",
      "updated_at": "2021-05-05T06:35:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Server-side configuration transitions some core settings from your language agent's configuration file to the New Relic collector. Depending on the language agent, available settings may include: Transaction tracing SQL recording and logging SQL query plans Error collection Thread profiling Distributed tracing Cross application tracing Centralization and security Server-side configuration provides an easy way to manage the available settings from the New Relic UI. Centralized configuration settings can also help you ensure standards compliance and security management for your settings. Any change automatically applies to all New Relic APM agents, even if they run across multiple hosts. The agent still follows the local configurations for any settings not available from the UI. Server-side configuration precedence This feature provides the convenience of managing the available configuration settings directly within the New Relic UI, without the need for deployments or restarts. Available options to change settings, and the order of precedence they take when you utilize environment variables or other configuration options, will depend on the language agent used. For more information about the hierarchy of settings, see the illustration for the specific agent: C SDK configuration: A hierarchy is not applicable, because configuration values come from API calls. Also, server-side configuration is not supported. However, you can change the app name from the UI or from the C SDK configuration settings. Go hierarchy Java hierarchy .NET hierarchy Node.js hierarchy PHP hierarchy (server-side configuration not supported) Python hierarchy Ruby hierarchy Enable server-side configuration Tip Owner, Admins, or Add-on Managers The C SDK and PHP agent do not support server-side configuration. To enable server-side configuration settings for apps that use other New Relic agents: Go to rpm.newrelic.com/apm > (select an app) > Settings > Application > Server-side agent configuration. OR Go to rpm.newrelic.com/apm. Next, from the index of applications, select the app's gear icon, then select View settings > Server-side agent configuration. Set the Server-side configuration enabled toggle to On. Select Save server-side configuration. After you enable server-side configuration, you can view and change the available settings through the UI. View or change server-side configuration settings Tip Owner, Admins, or Add-on Managers If you use server-side configuration, you must still include your license_key and app_name in the local config file. These settings are required for the agent to communicate with the New Relic collector. The C SDK and PHP agent do not support server-side configuration. To view or change the available server-side configuration settings through the UI for apps that use other New Relic agents: Go to rpm.newrelic.com/apm > (select an app) > Settings > Application > Server-side agent configuration. OR Go to rpm.newrelic.com/apm. Next, from the index of applications, select the app's gear icon, then select View settings > Server-side agent configuration. View or change the available configuration settings for your agent. If you make changes, select Save server-side configuration. Once you set any of these options from the UI, they will override any conflicting options in the agent's configuration file. Disable server-side configuration Once you enable server-side configuration for an account, server-side configuration cannot be turned off without assistance from New Relic Support. This helps mitigate issues that could arise from conflicts with configuration settings if you need to transition back to a local configuration setup.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 233.48058,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Server-side <em>agent</em> <em>configuration</em>",
        "sections": "Server-side <em>agent</em> <em>configuration</em>",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " change automatically applies to all New Relic <em>APM</em> <em>agents</em>, even if they run across multiple hosts. The <em>agent</em> still follows the local configurations for any settings not available from the UI. Server-side <em>configuration</em> precedence This feature provides the convenience of managing the available"
      },
      "id": "6043c83b64441fc5d6378ed1"
    },
    {
      "sections": [
        "Use multiple names for an app",
        "Important",
        "Roll up app data",
        "Prevent duplicate transaction events",
        "Roll up Browser data",
        "Define app names from most to least specific",
        "Name app instances via agent config file",
        "Examples",
        "One app, three clusters",
        "Two instances of one app",
        "Other options to organize your apps"
      ],
      "title": "Use multiple names for an app",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "App naming"
      ],
      "external_id": "af78a44c170729aac326233d6468b0b61b6cdff2",
      "image": "https://docs.newrelic.com/static/67c256b1f08164be39b8eeb2ca8ff4e6/8c557/Insights-ToggleOnOff.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/app-naming/use-multiple-names-app/",
      "published_at": "2021-05-05T16:36:25Z",
      "updated_at": "2021-04-16T06:55:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When working with your data in New Relic, you may want to view aggregated data for an application across clusters, environments, or data centers, while at the same time be able to view each of your application instance's data individually. Important If you use multiple names for an app, the last name assigned is the least specific name New Relic uses to roll up the data. For best results to view both instance-level and aggregated data, set the order of your app's rollup names from most specific to least specific in your configuration file. Roll up app data Normally, when two instances report with the same app name, agent language, and license key, New Relic aggregates their data into a single app within the New Relic user interface. You can also view data for the individual hosts and instances from the app's New Relic APM Overview page. To segment your app in a different way, or to work with each instance as an individual app while maintaining the overall view of the data, use your New Relic agent's config file to give an app up to three different rollup names. New Relic will then report the app's data separately to each app listed in the config file. For example, you might want to separate the data collected for your app running in development, staging, and production environments, but also have a common view of the app in every environment. Or, if you have two data centers running the same code, you could name one app EastCoastApp;AggregateApp and the second app WestCoastApp;AggregateApp. Prevent duplicate transaction events By default, an app with multiple names will generate multiple Insights events for transactions (a duplicate transaction for each name). For example, if you give your app three names, that's three times the number of Insights events for transactions. To avoid duplicate Insights events, disable collection for each of the duplicate app names: Go to one.newrelic.com or one.eu.newrelic.com > More > Manage Insights Data. Toggle data collection on/off for duplicate app names, then save. To prevent duplicate events from being collected for an app with multiple names, go to insights.newrelic.com > Manage data > Configure data sources. Roll up Browser data When you use multiple names to report application data, any Browser monitoring data from that application will also be grouped into multiple applications using the same configuration. Important Session trace data will only report to the first application listed. Other Browser data will populate into each of the up to three applications, but session trace data will be limited to the most specific application. Define app names from most to least specific You can give each app up to three names, which New Relic uses to aggregate data from most to least specific. You can then use the New Relic UI to view data for each app name individually, as well as in aggregate for overall application performance. When doing so, the order in which you specify the app names is important. Using multiple names Comments Most specific A unique rollup name. Less specific A shared rollup name to aggregate data in the New Relic UI. This provides more general organization. Optional, least specific An additional, shared rollup name. If used, this is the most general name New Relic uses to aggregate data into a single app. Name app instances via agent config file The naming convention you use in your configuration file depends on your New Relic agent. Set the order of your app's names so that the first rollup name is the most unique. The second and third names can be unique, or they can be the same. The second name is more general for aggregate data, and the third name (if used) is the most general. Agent Configuration file value C Identify a maximum of three names separated by a semicolon ; in your newrelic_app_config_t * config;. Go Set AppName to a maximum of three names separated by a semicolon. Java Set app_name to a maximum of three names separated by a semicolon. .NET Use any of the available options to name your .NET app. Node.js Set app_name to a maximum of three names separated by a comma. Enclose the string of names with single or double quotes. (Or, change the environment variable NEW_RELIC_APP_NAME.) PHP Use any of the available options to name your PHP application. Use three names separated by a semicolon. Python Set app_name to a maximum of three names separated by a semicolon. Do not add a space after the semicolon, or the next name will be interpreted as a comment. Ruby Set app_name to a maximum of three names separated by a semicolon. For more information, refer to the configuration file documentation for your agent. Examples Here are examples of how you could use multiple rollup names for a single app. One app, three clusters A Java app collecting survey data runs on three clusters. Change the value for the app name in your agent config file by giving it three different names, one for each cluster. Cluster 1: app_name: SurveyCluster1;Survey Data Copy Cluster 2: app_name: SurveyCluster2;Survey Data Copy Cluster 3: app_name: SurveyCluster3;Survey Data Copy This will report four applications in New Relic APM: The app name for aggregate data from all three clusters is Survey Data. Three individual applications named SurveyCluster1, SurveyCluster2, and SurveyCluster3. Two instances of one app A PHP agent is monitoring an e-commerce application running on two clusters in each of two data centers, and you want to view data for each subgroup as well as the overall aggregated data. Cluster A: newrelic.appname=\"EcomClusterA;EcomEast;EcomAll\" Copy Cluster B: newrelic.appname=\"EcomClusterB;EcomEast;EcomAll\" Copy Cluster C: newrelic.appname=\"EcomClusterC;EcomWest;EcomAll\" Copy Cluster D: newrelic.appname=\"EcomClusterD;EcomWest;EcomAll\" Copy This example configuration will report seven applications in the New Relic APM UI: Four apps: One for each of the four clusters (A B C D) Two apps: One for each datacenter (East and West) One app for the overall data across clusters and data centers (EcomAll) Other options to organize your apps If you do not want to apply multiple names to your apps, you can organize them with labels and categories. This allows you to easily sort, filter, and page through them from their product index pages in the New Relic UI. You can also set distinct performance thresholds for each environment with alert conditions and key transactions. These thresholds will apply to the individual apps, while the overall app will not have its own thresholds. The overall app will treat incoming data according to the threshold for the relevant enviroment.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.20662,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Name app instances via <em>agent</em> config file",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " with the same app name, <em>agent</em> language, and license key, New Relic aggregates their data into a single app within the New Relic user interface. You can also view data for the individual hosts and instances from the app&#x27;s New Relic <em>APM</em> Overview page. To segment your app in a different way, or to work"
      },
      "id": "603ebde1196a677dbaa83dec"
    },
    {
      "sections": [
        "View config values for your app",
        "Problem",
        "Solution",
        "Tip"
      ],
      "title": "View config values for your app",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Configuration"
      ],
      "external_id": "fe57f2d9748b60e439dd57d54ad49ebe4cbccc77",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/configuration/view-config-values-your-app/",
      "published_at": "2021-05-05T22:20:55Z",
      "updated_at": "2021-03-16T14:52:45Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem You need an easy way to get information about your application's configuration settings. Solution Tip Owner, Admins, or Add-on managers If you do not want to view your configuration file itself, you can view the configuration settings in the APM UI, go to rpm.newrelic.com > (select an app) > Settings > Environment > Agent initialization.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 131.79071,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": "Problem You need an easy way to get information about your application&#x27;s <em>configuration</em> settings. Solution Tip Owner, Admins, or Add-on managers If you do not want to view your <em>configuration</em> file itself, you can view the <em>configuration</em> settings in the <em>APM</em> UI, go to rpm.newrelic.com &gt; (select an app) &gt; Settings &gt; Environment &gt; <em>Agent</em> initialization."
      },
      "id": "603e7f60e7b9d2969a2a07e4"
    }
  ],
  "/docs/agents/manage-apm-agents/configuration/high-security-mode": [
    {
      "sections": [
        "Server-side agent configuration",
        "Centralization and security",
        "Server-side configuration precedence",
        "Enable server-side configuration",
        "Tip",
        "View or change server-side configuration settings",
        "Disable server-side configuration"
      ],
      "title": "Server-side agent configuration",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Configuration"
      ],
      "external_id": "928ff211d9e5aa0e02dc64ed344e8cbbd3ea91b5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/configuration/server-side-agent-configuration/",
      "published_at": "2021-05-05T06:35:22Z",
      "updated_at": "2021-05-05T06:35:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Server-side configuration transitions some core settings from your language agent's configuration file to the New Relic collector. Depending on the language agent, available settings may include: Transaction tracing SQL recording and logging SQL query plans Error collection Thread profiling Distributed tracing Cross application tracing Centralization and security Server-side configuration provides an easy way to manage the available settings from the New Relic UI. Centralized configuration settings can also help you ensure standards compliance and security management for your settings. Any change automatically applies to all New Relic APM agents, even if they run across multiple hosts. The agent still follows the local configurations for any settings not available from the UI. Server-side configuration precedence This feature provides the convenience of managing the available configuration settings directly within the New Relic UI, without the need for deployments or restarts. Available options to change settings, and the order of precedence they take when you utilize environment variables or other configuration options, will depend on the language agent used. For more information about the hierarchy of settings, see the illustration for the specific agent: C SDK configuration: A hierarchy is not applicable, because configuration values come from API calls. Also, server-side configuration is not supported. However, you can change the app name from the UI or from the C SDK configuration settings. Go hierarchy Java hierarchy .NET hierarchy Node.js hierarchy PHP hierarchy (server-side configuration not supported) Python hierarchy Ruby hierarchy Enable server-side configuration Tip Owner, Admins, or Add-on Managers The C SDK and PHP agent do not support server-side configuration. To enable server-side configuration settings for apps that use other New Relic agents: Go to rpm.newrelic.com/apm > (select an app) > Settings > Application > Server-side agent configuration. OR Go to rpm.newrelic.com/apm. Next, from the index of applications, select the app's gear icon, then select View settings > Server-side agent configuration. Set the Server-side configuration enabled toggle to On. Select Save server-side configuration. After you enable server-side configuration, you can view and change the available settings through the UI. View or change server-side configuration settings Tip Owner, Admins, or Add-on Managers If you use server-side configuration, you must still include your license_key and app_name in the local config file. These settings are required for the agent to communicate with the New Relic collector. The C SDK and PHP agent do not support server-side configuration. To view or change the available server-side configuration settings through the UI for apps that use other New Relic agents: Go to rpm.newrelic.com/apm > (select an app) > Settings > Application > Server-side agent configuration. OR Go to rpm.newrelic.com/apm. Next, from the index of applications, select the app's gear icon, then select View settings > Server-side agent configuration. View or change the available configuration settings for your agent. If you make changes, select Save server-side configuration. Once you set any of these options from the UI, they will override any conflicting options in the agent's configuration file. Disable server-side configuration Once you enable server-side configuration for an account, server-side configuration cannot be turned off without assistance from New Relic Support. This helps mitigate issues that could arise from conflicts with configuration settings if you need to transition back to a local configuration setup.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 233.48044,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Server-side <em>agent</em> <em>configuration</em>",
        "sections": "Server-side <em>agent</em> <em>configuration</em>",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " change automatically applies to all New Relic <em>APM</em> <em>agents</em>, even if they run across multiple hosts. The <em>agent</em> still follows the local configurations for any settings not available from the UI. Server-side <em>configuration</em> precedence This feature provides the convenience of managing the available"
      },
      "id": "6043c83b64441fc5d6378ed1"
    },
    {
      "sections": [
        "Use multiple names for an app",
        "Important",
        "Roll up app data",
        "Prevent duplicate transaction events",
        "Roll up Browser data",
        "Define app names from most to least specific",
        "Name app instances via agent config file",
        "Examples",
        "One app, three clusters",
        "Two instances of one app",
        "Other options to organize your apps"
      ],
      "title": "Use multiple names for an app",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "App naming"
      ],
      "external_id": "af78a44c170729aac326233d6468b0b61b6cdff2",
      "image": "https://docs.newrelic.com/static/67c256b1f08164be39b8eeb2ca8ff4e6/8c557/Insights-ToggleOnOff.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/app-naming/use-multiple-names-app/",
      "published_at": "2021-05-05T16:36:25Z",
      "updated_at": "2021-04-16T06:55:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When working with your data in New Relic, you may want to view aggregated data for an application across clusters, environments, or data centers, while at the same time be able to view each of your application instance's data individually. Important If you use multiple names for an app, the last name assigned is the least specific name New Relic uses to roll up the data. For best results to view both instance-level and aggregated data, set the order of your app's rollup names from most specific to least specific in your configuration file. Roll up app data Normally, when two instances report with the same app name, agent language, and license key, New Relic aggregates their data into a single app within the New Relic user interface. You can also view data for the individual hosts and instances from the app's New Relic APM Overview page. To segment your app in a different way, or to work with each instance as an individual app while maintaining the overall view of the data, use your New Relic agent's config file to give an app up to three different rollup names. New Relic will then report the app's data separately to each app listed in the config file. For example, you might want to separate the data collected for your app running in development, staging, and production environments, but also have a common view of the app in every environment. Or, if you have two data centers running the same code, you could name one app EastCoastApp;AggregateApp and the second app WestCoastApp;AggregateApp. Prevent duplicate transaction events By default, an app with multiple names will generate multiple Insights events for transactions (a duplicate transaction for each name). For example, if you give your app three names, that's three times the number of Insights events for transactions. To avoid duplicate Insights events, disable collection for each of the duplicate app names: Go to one.newrelic.com or one.eu.newrelic.com > More > Manage Insights Data. Toggle data collection on/off for duplicate app names, then save. To prevent duplicate events from being collected for an app with multiple names, go to insights.newrelic.com > Manage data > Configure data sources. Roll up Browser data When you use multiple names to report application data, any Browser monitoring data from that application will also be grouped into multiple applications using the same configuration. Important Session trace data will only report to the first application listed. Other Browser data will populate into each of the up to three applications, but session trace data will be limited to the most specific application. Define app names from most to least specific You can give each app up to three names, which New Relic uses to aggregate data from most to least specific. You can then use the New Relic UI to view data for each app name individually, as well as in aggregate for overall application performance. When doing so, the order in which you specify the app names is important. Using multiple names Comments Most specific A unique rollup name. Less specific A shared rollup name to aggregate data in the New Relic UI. This provides more general organization. Optional, least specific An additional, shared rollup name. If used, this is the most general name New Relic uses to aggregate data into a single app. Name app instances via agent config file The naming convention you use in your configuration file depends on your New Relic agent. Set the order of your app's names so that the first rollup name is the most unique. The second and third names can be unique, or they can be the same. The second name is more general for aggregate data, and the third name (if used) is the most general. Agent Configuration file value C Identify a maximum of three names separated by a semicolon ; in your newrelic_app_config_t * config;. Go Set AppName to a maximum of three names separated by a semicolon. Java Set app_name to a maximum of three names separated by a semicolon. .NET Use any of the available options to name your .NET app. Node.js Set app_name to a maximum of three names separated by a comma. Enclose the string of names with single or double quotes. (Or, change the environment variable NEW_RELIC_APP_NAME.) PHP Use any of the available options to name your PHP application. Use three names separated by a semicolon. Python Set app_name to a maximum of three names separated by a semicolon. Do not add a space after the semicolon, or the next name will be interpreted as a comment. Ruby Set app_name to a maximum of three names separated by a semicolon. For more information, refer to the configuration file documentation for your agent. Examples Here are examples of how you could use multiple rollup names for a single app. One app, three clusters A Java app collecting survey data runs on three clusters. Change the value for the app name in your agent config file by giving it three different names, one for each cluster. Cluster 1: app_name: SurveyCluster1;Survey Data Copy Cluster 2: app_name: SurveyCluster2;Survey Data Copy Cluster 3: app_name: SurveyCluster3;Survey Data Copy This will report four applications in New Relic APM: The app name for aggregate data from all three clusters is Survey Data. Three individual applications named SurveyCluster1, SurveyCluster2, and SurveyCluster3. Two instances of one app A PHP agent is monitoring an e-commerce application running on two clusters in each of two data centers, and you want to view data for each subgroup as well as the overall aggregated data. Cluster A: newrelic.appname=\"EcomClusterA;EcomEast;EcomAll\" Copy Cluster B: newrelic.appname=\"EcomClusterB;EcomEast;EcomAll\" Copy Cluster C: newrelic.appname=\"EcomClusterC;EcomWest;EcomAll\" Copy Cluster D: newrelic.appname=\"EcomClusterD;EcomWest;EcomAll\" Copy This example configuration will report seven applications in the New Relic APM UI: Four apps: One for each of the four clusters (A B C D) Two apps: One for each datacenter (East and West) One app for the overall data across clusters and data centers (EcomAll) Other options to organize your apps If you do not want to apply multiple names to your apps, you can organize them with labels and categories. This allows you to easily sort, filter, and page through them from their product index pages in the New Relic UI. You can also set distinct performance thresholds for each environment with alert conditions and key transactions. These thresholds will apply to the individual apps, while the overall app will not have its own thresholds. The overall app will treat incoming data according to the threshold for the relevant enviroment.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.2066,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Name app instances via <em>agent</em> config file",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " with the same app name, <em>agent</em> language, and license key, New Relic aggregates their data into a single app within the New Relic user interface. You can also view data for the individual hosts and instances from the app&#x27;s New Relic <em>APM</em> Overview page. To segment your app in a different way, or to work"
      },
      "id": "603ebde1196a677dbaa83dec"
    },
    {
      "sections": [
        "View config values for your app",
        "Problem",
        "Solution",
        "Tip"
      ],
      "title": "View config values for your app",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Configuration"
      ],
      "external_id": "fe57f2d9748b60e439dd57d54ad49ebe4cbccc77",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/configuration/view-config-values-your-app/",
      "published_at": "2021-05-05T22:20:55Z",
      "updated_at": "2021-03-16T14:52:45Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem You need an easy way to get information about your application's configuration settings. Solution Tip Owner, Admins, or Add-on managers If you do not want to view your configuration file itself, you can view the configuration settings in the APM UI, go to rpm.newrelic.com > (select an app) > Settings > Environment > Agent initialization.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 131.79071,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": "Problem You need an easy way to get information about your application&#x27;s <em>configuration</em> settings. Solution Tip Owner, Admins, or Add-on managers If you do not want to view your <em>configuration</em> file itself, you can view the <em>configuration</em> settings in the <em>APM</em> UI, go to rpm.newrelic.com &gt; (select an app) &gt; Settings &gt; Environment &gt; <em>Agent</em> initialization."
      },
      "id": "603e7f60e7b9d2969a2a07e4"
    }
  ],
  "/docs/agents/manage-apm-agents/configuration/server-side-agent-configuration": [
    {
      "sections": [
        "Use multiple names for an app",
        "Important",
        "Roll up app data",
        "Prevent duplicate transaction events",
        "Roll up Browser data",
        "Define app names from most to least specific",
        "Name app instances via agent config file",
        "Examples",
        "One app, three clusters",
        "Two instances of one app",
        "Other options to organize your apps"
      ],
      "title": "Use multiple names for an app",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "App naming"
      ],
      "external_id": "af78a44c170729aac326233d6468b0b61b6cdff2",
      "image": "https://docs.newrelic.com/static/67c256b1f08164be39b8eeb2ca8ff4e6/8c557/Insights-ToggleOnOff.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/app-naming/use-multiple-names-app/",
      "published_at": "2021-05-05T16:36:25Z",
      "updated_at": "2021-04-16T06:55:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When working with your data in New Relic, you may want to view aggregated data for an application across clusters, environments, or data centers, while at the same time be able to view each of your application instance's data individually. Important If you use multiple names for an app, the last name assigned is the least specific name New Relic uses to roll up the data. For best results to view both instance-level and aggregated data, set the order of your app's rollup names from most specific to least specific in your configuration file. Roll up app data Normally, when two instances report with the same app name, agent language, and license key, New Relic aggregates their data into a single app within the New Relic user interface. You can also view data for the individual hosts and instances from the app's New Relic APM Overview page. To segment your app in a different way, or to work with each instance as an individual app while maintaining the overall view of the data, use your New Relic agent's config file to give an app up to three different rollup names. New Relic will then report the app's data separately to each app listed in the config file. For example, you might want to separate the data collected for your app running in development, staging, and production environments, but also have a common view of the app in every environment. Or, if you have two data centers running the same code, you could name one app EastCoastApp;AggregateApp and the second app WestCoastApp;AggregateApp. Prevent duplicate transaction events By default, an app with multiple names will generate multiple Insights events for transactions (a duplicate transaction for each name). For example, if you give your app three names, that's three times the number of Insights events for transactions. To avoid duplicate Insights events, disable collection for each of the duplicate app names: Go to one.newrelic.com or one.eu.newrelic.com > More > Manage Insights Data. Toggle data collection on/off for duplicate app names, then save. To prevent duplicate events from being collected for an app with multiple names, go to insights.newrelic.com > Manage data > Configure data sources. Roll up Browser data When you use multiple names to report application data, any Browser monitoring data from that application will also be grouped into multiple applications using the same configuration. Important Session trace data will only report to the first application listed. Other Browser data will populate into each of the up to three applications, but session trace data will be limited to the most specific application. Define app names from most to least specific You can give each app up to three names, which New Relic uses to aggregate data from most to least specific. You can then use the New Relic UI to view data for each app name individually, as well as in aggregate for overall application performance. When doing so, the order in which you specify the app names is important. Using multiple names Comments Most specific A unique rollup name. Less specific A shared rollup name to aggregate data in the New Relic UI. This provides more general organization. Optional, least specific An additional, shared rollup name. If used, this is the most general name New Relic uses to aggregate data into a single app. Name app instances via agent config file The naming convention you use in your configuration file depends on your New Relic agent. Set the order of your app's names so that the first rollup name is the most unique. The second and third names can be unique, or they can be the same. The second name is more general for aggregate data, and the third name (if used) is the most general. Agent Configuration file value C Identify a maximum of three names separated by a semicolon ; in your newrelic_app_config_t * config;. Go Set AppName to a maximum of three names separated by a semicolon. Java Set app_name to a maximum of three names separated by a semicolon. .NET Use any of the available options to name your .NET app. Node.js Set app_name to a maximum of three names separated by a comma. Enclose the string of names with single or double quotes. (Or, change the environment variable NEW_RELIC_APP_NAME.) PHP Use any of the available options to name your PHP application. Use three names separated by a semicolon. Python Set app_name to a maximum of three names separated by a semicolon. Do not add a space after the semicolon, or the next name will be interpreted as a comment. Ruby Set app_name to a maximum of three names separated by a semicolon. For more information, refer to the configuration file documentation for your agent. Examples Here are examples of how you could use multiple rollup names for a single app. One app, three clusters A Java app collecting survey data runs on three clusters. Change the value for the app name in your agent config file by giving it three different names, one for each cluster. Cluster 1: app_name: SurveyCluster1;Survey Data Copy Cluster 2: app_name: SurveyCluster2;Survey Data Copy Cluster 3: app_name: SurveyCluster3;Survey Data Copy This will report four applications in New Relic APM: The app name for aggregate data from all three clusters is Survey Data. Three individual applications named SurveyCluster1, SurveyCluster2, and SurveyCluster3. Two instances of one app A PHP agent is monitoring an e-commerce application running on two clusters in each of two data centers, and you want to view data for each subgroup as well as the overall aggregated data. Cluster A: newrelic.appname=\"EcomClusterA;EcomEast;EcomAll\" Copy Cluster B: newrelic.appname=\"EcomClusterB;EcomEast;EcomAll\" Copy Cluster C: newrelic.appname=\"EcomClusterC;EcomWest;EcomAll\" Copy Cluster D: newrelic.appname=\"EcomClusterD;EcomWest;EcomAll\" Copy This example configuration will report seven applications in the New Relic APM UI: Four apps: One for each of the four clusters (A B C D) Two apps: One for each datacenter (East and West) One app for the overall data across clusters and data centers (EcomAll) Other options to organize your apps If you do not want to apply multiple names to your apps, you can organize them with labels and categories. This allows you to easily sort, filter, and page through them from their product index pages in the New Relic UI. You can also set distinct performance thresholds for each environment with alert conditions and key transactions. These thresholds will apply to the individual apps, while the overall app will not have its own thresholds. The overall app will treat incoming data according to the threshold for the relevant enviroment.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.2066,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Name app instances via <em>agent</em> config file",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " with the same app name, <em>agent</em> language, and license key, New Relic aggregates their data into a single app within the New Relic user interface. You can also view data for the individual hosts and instances from the app&#x27;s New Relic <em>APM</em> Overview page. To segment your app in a different way, or to work"
      },
      "id": "603ebde1196a677dbaa83dec"
    },
    {
      "sections": [
        "View config values for your app",
        "Problem",
        "Solution",
        "Tip"
      ],
      "title": "View config values for your app",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Configuration"
      ],
      "external_id": "fe57f2d9748b60e439dd57d54ad49ebe4cbccc77",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/configuration/view-config-values-your-app/",
      "published_at": "2021-05-05T22:20:55Z",
      "updated_at": "2021-03-16T14:52:45Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem You need an easy way to get information about your application's configuration settings. Solution Tip Owner, Admins, or Add-on managers If you do not want to view your configuration file itself, you can view the configuration settings in the APM UI, go to rpm.newrelic.com > (select an app) > Settings > Environment > Agent initialization.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 131.79071,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": "Problem You need an easy way to get information about your application&#x27;s <em>configuration</em> settings. Solution Tip Owner, Admins, or Add-on managers If you do not want to view your <em>configuration</em> file itself, you can view the <em>configuration</em> settings in the <em>APM</em> UI, go to rpm.newrelic.com &gt; (select an app) &gt; Settings &gt; Environment &gt; <em>Agent</em> initialization."
      },
      "id": "603e7f60e7b9d2969a2a07e4"
    },
    {
      "sections": [
        "Add, rename, and remove hosts",
        "Add hosts",
        "Rename hosts",
        "Change display name of hosts",
        "Remove hosts"
      ],
      "title": "Add, rename, and remove hosts",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Configuration"
      ],
      "external_id": "23ed2b3adaf3d2c57b400a728afeab7837023f6a",
      "image": "https://docs.newrelic.com/static/efbee2c69c42d1addaaa92e4e351bf96/e2c15/crop-display-host-name_0.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/configuration/add-rename-remove-hosts/",
      "published_at": "2021-05-05T22:21:39Z",
      "updated_at": "2021-03-11T03:43:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can add and remove hosts for your applications. You cannot rename an existing host, but you can create applications named after a host or cluster. You can also assign a cosmetic label to the host, to differentiate hosts without changing the underlying hostname setting. Add hosts To add a host for monitoring, install the agent and start up your application. The host running the application will be identified to New Relic and will automatically appear on the site after a few minutes. Rename hosts It is not possible to change the hostname. However, you can create applications named after a host or cluster. For example, if hosts ey01-s00057 and ey01-s00058 are both part of a production tier, you can create an application called App - Production and have those two hosts report to it. Change display name of hosts You can also assign a display name to a host, to easily distinguish dynamically assigned hosts. This display name does not affect the link between an app and its parent host. The display name appears in the APM UI to decorate the automatically assigned host:port name. In the following example, QA Server and Local Dev Server are display names: To set a display name: New Relic agent Set the host display name C SDK Edit the newrelic_datastore_segment_params_t::host datastore segment. Go Edit the Go agent HostDisplayName configuration setting. Java Edit your config file or environment variables. However, if the Java agent detects an instance name, APM uses that name instead of the display name. .NET Edit displayName attribute in the processHost element of the .NET agent config file or environment variables. Node.js Edit display_name in the process_host section of your config file. PHP Edit process_host.display_name in your newrelic.ini file. Python Edit process_host.display_name in your config file. Ruby Edit process_host.display_name in your config file. Remove hosts To remove a host, use either option: Uninstall the agent. Disable it by editing or removing the agent configuration file. Make sure that all application host instances (Passenger, Jetty, etc.) have been fully restarted after disabling the agent. Occasionally, rogue application server processes will continue reporting data. In this situation your app's health status indicator will appear green, even though you shut the agent down and verified that no data is reporting. Check your web server for stray processes, or get support at support.newrelic.com. Once all reporting applications are shut down on the old host, it may take up to ten minutes for the old host to disappear from the New Relic list and the new one to appear.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 130.0708,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " Relic <em>agent</em> Set the host display name C SDK Edit the newrelic_datastore_segment_params_t::host datastore segment. Go Edit the Go <em>agent</em> HostDisplayName <em>configuration</em> setting. Java Edit your config file or environment variables. However, if the Java <em>agent</em> detects an instance name, <em>APM</em> uses that name"
      },
      "id": "6043d56364441f96f2378f37"
    }
  ],
  "/docs/agents/manage-apm-agents/configuration/view-config-values-your-app": [
    {
      "sections": [
        "Server-side agent configuration",
        "Centralization and security",
        "Server-side configuration precedence",
        "Enable server-side configuration",
        "Tip",
        "View or change server-side configuration settings",
        "Disable server-side configuration"
      ],
      "title": "Server-side agent configuration",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Configuration"
      ],
      "external_id": "928ff211d9e5aa0e02dc64ed344e8cbbd3ea91b5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/configuration/server-side-agent-configuration/",
      "published_at": "2021-05-05T06:35:22Z",
      "updated_at": "2021-05-05T06:35:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Server-side configuration transitions some core settings from your language agent's configuration file to the New Relic collector. Depending on the language agent, available settings may include: Transaction tracing SQL recording and logging SQL query plans Error collection Thread profiling Distributed tracing Cross application tracing Centralization and security Server-side configuration provides an easy way to manage the available settings from the New Relic UI. Centralized configuration settings can also help you ensure standards compliance and security management for your settings. Any change automatically applies to all New Relic APM agents, even if they run across multiple hosts. The agent still follows the local configurations for any settings not available from the UI. Server-side configuration precedence This feature provides the convenience of managing the available configuration settings directly within the New Relic UI, without the need for deployments or restarts. Available options to change settings, and the order of precedence they take when you utilize environment variables or other configuration options, will depend on the language agent used. For more information about the hierarchy of settings, see the illustration for the specific agent: C SDK configuration: A hierarchy is not applicable, because configuration values come from API calls. Also, server-side configuration is not supported. However, you can change the app name from the UI or from the C SDK configuration settings. Go hierarchy Java hierarchy .NET hierarchy Node.js hierarchy PHP hierarchy (server-side configuration not supported) Python hierarchy Ruby hierarchy Enable server-side configuration Tip Owner, Admins, or Add-on Managers The C SDK and PHP agent do not support server-side configuration. To enable server-side configuration settings for apps that use other New Relic agents: Go to rpm.newrelic.com/apm > (select an app) > Settings > Application > Server-side agent configuration. OR Go to rpm.newrelic.com/apm. Next, from the index of applications, select the app's gear icon, then select View settings > Server-side agent configuration. Set the Server-side configuration enabled toggle to On. Select Save server-side configuration. After you enable server-side configuration, you can view and change the available settings through the UI. View or change server-side configuration settings Tip Owner, Admins, or Add-on Managers If you use server-side configuration, you must still include your license_key and app_name in the local config file. These settings are required for the agent to communicate with the New Relic collector. The C SDK and PHP agent do not support server-side configuration. To view or change the available server-side configuration settings through the UI for apps that use other New Relic agents: Go to rpm.newrelic.com/apm > (select an app) > Settings > Application > Server-side agent configuration. OR Go to rpm.newrelic.com/apm. Next, from the index of applications, select the app's gear icon, then select View settings > Server-side agent configuration. View or change the available configuration settings for your agent. If you make changes, select Save server-side configuration. Once you set any of these options from the UI, they will override any conflicting options in the agent's configuration file. Disable server-side configuration Once you enable server-side configuration for an account, server-side configuration cannot be turned off without assistance from New Relic Support. This helps mitigate issues that could arise from conflicts with configuration settings if you need to transition back to a local configuration setup.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 233.48029,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Server-side <em>agent</em> <em>configuration</em>",
        "sections": "Server-side <em>agent</em> <em>configuration</em>",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " change automatically applies to all New Relic <em>APM</em> <em>agents</em>, even if they run across multiple hosts. The <em>agent</em> still follows the local configurations for any settings not available from the UI. Server-side <em>configuration</em> precedence This feature provides the convenience of managing the available"
      },
      "id": "6043c83b64441fc5d6378ed1"
    },
    {
      "sections": [
        "Use multiple names for an app",
        "Important",
        "Roll up app data",
        "Prevent duplicate transaction events",
        "Roll up Browser data",
        "Define app names from most to least specific",
        "Name app instances via agent config file",
        "Examples",
        "One app, three clusters",
        "Two instances of one app",
        "Other options to organize your apps"
      ],
      "title": "Use multiple names for an app",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "App naming"
      ],
      "external_id": "af78a44c170729aac326233d6468b0b61b6cdff2",
      "image": "https://docs.newrelic.com/static/67c256b1f08164be39b8eeb2ca8ff4e6/8c557/Insights-ToggleOnOff.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/app-naming/use-multiple-names-app/",
      "published_at": "2021-05-05T16:36:25Z",
      "updated_at": "2021-04-16T06:55:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When working with your data in New Relic, you may want to view aggregated data for an application across clusters, environments, or data centers, while at the same time be able to view each of your application instance's data individually. Important If you use multiple names for an app, the last name assigned is the least specific name New Relic uses to roll up the data. For best results to view both instance-level and aggregated data, set the order of your app's rollup names from most specific to least specific in your configuration file. Roll up app data Normally, when two instances report with the same app name, agent language, and license key, New Relic aggregates their data into a single app within the New Relic user interface. You can also view data for the individual hosts and instances from the app's New Relic APM Overview page. To segment your app in a different way, or to work with each instance as an individual app while maintaining the overall view of the data, use your New Relic agent's config file to give an app up to three different rollup names. New Relic will then report the app's data separately to each app listed in the config file. For example, you might want to separate the data collected for your app running in development, staging, and production environments, but also have a common view of the app in every environment. Or, if you have two data centers running the same code, you could name one app EastCoastApp;AggregateApp and the second app WestCoastApp;AggregateApp. Prevent duplicate transaction events By default, an app with multiple names will generate multiple Insights events for transactions (a duplicate transaction for each name). For example, if you give your app three names, that's three times the number of Insights events for transactions. To avoid duplicate Insights events, disable collection for each of the duplicate app names: Go to one.newrelic.com or one.eu.newrelic.com > More > Manage Insights Data. Toggle data collection on/off for duplicate app names, then save. To prevent duplicate events from being collected for an app with multiple names, go to insights.newrelic.com > Manage data > Configure data sources. Roll up Browser data When you use multiple names to report application data, any Browser monitoring data from that application will also be grouped into multiple applications using the same configuration. Important Session trace data will only report to the first application listed. Other Browser data will populate into each of the up to three applications, but session trace data will be limited to the most specific application. Define app names from most to least specific You can give each app up to three names, which New Relic uses to aggregate data from most to least specific. You can then use the New Relic UI to view data for each app name individually, as well as in aggregate for overall application performance. When doing so, the order in which you specify the app names is important. Using multiple names Comments Most specific A unique rollup name. Less specific A shared rollup name to aggregate data in the New Relic UI. This provides more general organization. Optional, least specific An additional, shared rollup name. If used, this is the most general name New Relic uses to aggregate data into a single app. Name app instances via agent config file The naming convention you use in your configuration file depends on your New Relic agent. Set the order of your app's names so that the first rollup name is the most unique. The second and third names can be unique, or they can be the same. The second name is more general for aggregate data, and the third name (if used) is the most general. Agent Configuration file value C Identify a maximum of three names separated by a semicolon ; in your newrelic_app_config_t * config;. Go Set AppName to a maximum of three names separated by a semicolon. Java Set app_name to a maximum of three names separated by a semicolon. .NET Use any of the available options to name your .NET app. Node.js Set app_name to a maximum of three names separated by a comma. Enclose the string of names with single or double quotes. (Or, change the environment variable NEW_RELIC_APP_NAME.) PHP Use any of the available options to name your PHP application. Use three names separated by a semicolon. Python Set app_name to a maximum of three names separated by a semicolon. Do not add a space after the semicolon, or the next name will be interpreted as a comment. Ruby Set app_name to a maximum of three names separated by a semicolon. For more information, refer to the configuration file documentation for your agent. Examples Here are examples of how you could use multiple rollup names for a single app. One app, three clusters A Java app collecting survey data runs on three clusters. Change the value for the app name in your agent config file by giving it three different names, one for each cluster. Cluster 1: app_name: SurveyCluster1;Survey Data Copy Cluster 2: app_name: SurveyCluster2;Survey Data Copy Cluster 3: app_name: SurveyCluster3;Survey Data Copy This will report four applications in New Relic APM: The app name for aggregate data from all three clusters is Survey Data. Three individual applications named SurveyCluster1, SurveyCluster2, and SurveyCluster3. Two instances of one app A PHP agent is monitoring an e-commerce application running on two clusters in each of two data centers, and you want to view data for each subgroup as well as the overall aggregated data. Cluster A: newrelic.appname=\"EcomClusterA;EcomEast;EcomAll\" Copy Cluster B: newrelic.appname=\"EcomClusterB;EcomEast;EcomAll\" Copy Cluster C: newrelic.appname=\"EcomClusterC;EcomWest;EcomAll\" Copy Cluster D: newrelic.appname=\"EcomClusterD;EcomWest;EcomAll\" Copy This example configuration will report seven applications in the New Relic APM UI: Four apps: One for each of the four clusters (A B C D) Two apps: One for each datacenter (East and West) One app for the overall data across clusters and data centers (EcomAll) Other options to organize your apps If you do not want to apply multiple names to your apps, you can organize them with labels and categories. This allows you to easily sort, filter, and page through them from their product index pages in the New Relic UI. You can also set distinct performance thresholds for each environment with alert conditions and key transactions. These thresholds will apply to the individual apps, while the overall app will not have its own thresholds. The overall app will treat incoming data according to the threshold for the relevant enviroment.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.20659,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Name app instances via <em>agent</em> config file",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " with the same app name, <em>agent</em> language, and license key, New Relic aggregates their data into a single app within the New Relic user interface. You can also view data for the individual hosts and instances from the app&#x27;s New Relic <em>APM</em> Overview page. To segment your app in a different way, or to work"
      },
      "id": "603ebde1196a677dbaa83dec"
    },
    {
      "sections": [
        "Add, rename, and remove hosts",
        "Add hosts",
        "Rename hosts",
        "Change display name of hosts",
        "Remove hosts"
      ],
      "title": "Add, rename, and remove hosts",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Configuration"
      ],
      "external_id": "23ed2b3adaf3d2c57b400a728afeab7837023f6a",
      "image": "https://docs.newrelic.com/static/efbee2c69c42d1addaaa92e4e351bf96/e2c15/crop-display-host-name_0.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/configuration/add-rename-remove-hosts/",
      "published_at": "2021-05-05T22:21:39Z",
      "updated_at": "2021-03-11T03:43:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can add and remove hosts for your applications. You cannot rename an existing host, but you can create applications named after a host or cluster. You can also assign a cosmetic label to the host, to differentiate hosts without changing the underlying hostname setting. Add hosts To add a host for monitoring, install the agent and start up your application. The host running the application will be identified to New Relic and will automatically appear on the site after a few minutes. Rename hosts It is not possible to change the hostname. However, you can create applications named after a host or cluster. For example, if hosts ey01-s00057 and ey01-s00058 are both part of a production tier, you can create an application called App - Production and have those two hosts report to it. Change display name of hosts You can also assign a display name to a host, to easily distinguish dynamically assigned hosts. This display name does not affect the link between an app and its parent host. The display name appears in the APM UI to decorate the automatically assigned host:port name. In the following example, QA Server and Local Dev Server are display names: To set a display name: New Relic agent Set the host display name C SDK Edit the newrelic_datastore_segment_params_t::host datastore segment. Go Edit the Go agent HostDisplayName configuration setting. Java Edit your config file or environment variables. However, if the Java agent detects an instance name, APM uses that name instead of the display name. .NET Edit displayName attribute in the processHost element of the .NET agent config file or environment variables. Node.js Edit display_name in the process_host section of your config file. PHP Edit process_host.display_name in your newrelic.ini file. Python Edit process_host.display_name in your config file. Ruby Edit process_host.display_name in your config file. Remove hosts To remove a host, use either option: Uninstall the agent. Disable it by editing or removing the agent configuration file. Make sure that all application host instances (Passenger, Jetty, etc.) have been fully restarted after disabling the agent. Occasionally, rogue application server processes will continue reporting data. In this situation your app's health status indicator will appear green, even though you shut the agent down and verified that no data is reporting. Check your web server for stray processes, or get support at support.newrelic.com. Once all reporting applications are shut down on the old host, it may take up to ten minutes for the old host to disappear from the New Relic list and the new one to appear.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 130.0708,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " Relic <em>agent</em> Set the host display name C SDK Edit the newrelic_datastore_segment_params_t::host datastore segment. Go Edit the Go <em>agent</em> HostDisplayName <em>configuration</em> setting. Java Edit your config file or environment variables. However, if the Java <em>agent</em> detects an instance name, <em>APM</em> uses that name"
      },
      "id": "6043d56364441f96f2378f37"
    }
  ],
  "/docs/agents/manage-apm-agents/troubleshooting/agent-nrintegrationerrors-appear-insights": [
    {
      "sections": [
        "Server-side agent configuration",
        "Centralization and security",
        "Server-side configuration precedence",
        "Enable server-side configuration",
        "Tip",
        "View or change server-side configuration settings",
        "Disable server-side configuration"
      ],
      "title": "Server-side agent configuration",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Configuration"
      ],
      "external_id": "928ff211d9e5aa0e02dc64ed344e8cbbd3ea91b5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/configuration/server-side-agent-configuration/",
      "published_at": "2021-05-05T06:35:22Z",
      "updated_at": "2021-05-05T06:35:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Server-side configuration transitions some core settings from your language agent's configuration file to the New Relic collector. Depending on the language agent, available settings may include: Transaction tracing SQL recording and logging SQL query plans Error collection Thread profiling Distributed tracing Cross application tracing Centralization and security Server-side configuration provides an easy way to manage the available settings from the New Relic UI. Centralized configuration settings can also help you ensure standards compliance and security management for your settings. Any change automatically applies to all New Relic APM agents, even if they run across multiple hosts. The agent still follows the local configurations for any settings not available from the UI. Server-side configuration precedence This feature provides the convenience of managing the available configuration settings directly within the New Relic UI, without the need for deployments or restarts. Available options to change settings, and the order of precedence they take when you utilize environment variables or other configuration options, will depend on the language agent used. For more information about the hierarchy of settings, see the illustration for the specific agent: C SDK configuration: A hierarchy is not applicable, because configuration values come from API calls. Also, server-side configuration is not supported. However, you can change the app name from the UI or from the C SDK configuration settings. Go hierarchy Java hierarchy .NET hierarchy Node.js hierarchy PHP hierarchy (server-side configuration not supported) Python hierarchy Ruby hierarchy Enable server-side configuration Tip Owner, Admins, or Add-on Managers The C SDK and PHP agent do not support server-side configuration. To enable server-side configuration settings for apps that use other New Relic agents: Go to rpm.newrelic.com/apm > (select an app) > Settings > Application > Server-side agent configuration. OR Go to rpm.newrelic.com/apm. Next, from the index of applications, select the app's gear icon, then select View settings > Server-side agent configuration. Set the Server-side configuration enabled toggle to On. Select Save server-side configuration. After you enable server-side configuration, you can view and change the available settings through the UI. View or change server-side configuration settings Tip Owner, Admins, or Add-on Managers If you use server-side configuration, you must still include your license_key and app_name in the local config file. These settings are required for the agent to communicate with the New Relic collector. The C SDK and PHP agent do not support server-side configuration. To view or change the available server-side configuration settings through the UI for apps that use other New Relic agents: Go to rpm.newrelic.com/apm > (select an app) > Settings > Application > Server-side agent configuration. OR Go to rpm.newrelic.com/apm. Next, from the index of applications, select the app's gear icon, then select View settings > Server-side agent configuration. View or change the available configuration settings for your agent. If you make changes, select Save server-side configuration. Once you set any of these options from the UI, they will override any conflicting options in the agent's configuration file. Disable server-side configuration Once you enable server-side configuration for an account, server-side configuration cannot be turned off without assistance from New Relic Support. This helps mitigate issues that could arise from conflicts with configuration settings if you need to transition back to a local configuration setup.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 172.61456,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Server-side <em>agent</em> configuration",
        "sections": "Server-side <em>agent</em> configuration",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " change automatically applies to all New Relic <em>APM</em> <em>agents</em>, even if they run across multiple hosts. The <em>agent</em> still follows the local configurations for any settings not available from the UI. Server-side configuration precedence This feature provides the convenience of managing the available"
      },
      "id": "6043c83b64441fc5d6378ed1"
    },
    {
      "sections": [
        "Get environment data about your APM app",
        "Problem",
        "Solution"
      ],
      "title": "Get environment data about your APM app",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Troubleshooting"
      ],
      "external_id": "9069ed185cb57e0fad63414989a52238f2c5378c",
      "image": "https://docs.newrelic.com/static/1a6d2627ddd9082d34cdd5b81cc29035/c1b63/troubleshooting-apm-environment.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/troubleshooting/get-environment-data-about-your-apm-app/",
      "published_at": "2021-05-05T18:31:14Z",
      "updated_at": "2021-03-30T14:19:25Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem You need an easy way to get information about your application's environment, such as: What services a particular agent version is using What apps have outdated agent versions What hosts use which agents What values apply to specific agent settings Solution To see which services and settings apply to an agent, or to see which agent uses a specific service or setting, go to rpm.newrelic.com > (select an app) > Settings > Environment > Environment snapshot. The Environment snapshot page helps you connect payloads from agents that include environment data, so you have a sense of what monitoring data is recorded. This also helps you more easily identify discrepancies across your services, and determine what might need to be updated. In the following example, the user mouses over the second agent on the list. Most of the settings for this agent are consistent with others, but it's easy to see specific host settings for logical processors, physical cores, and Ruby patch levels. Also notice that this agent is using an earlier Ruby version. rpm.newrelic.com > (select an app) > Settings > Environment > Environment snapshot: To see specific settings that apply to an agent and its services, or to see which of a setting's values apply to specific agents, mouse over any agent or value. Information on the Environment snapshot page depends on the APM agent you use. For example, apps using the Ruby agent show settings for gems, while apps using the Java agent show settings for jars.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.741005,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get environment data about your <em>APM</em> app",
        "sections": "Get environment data about your <em>APM</em> app",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " services, or to see which of a setting&#x27;s values apply to specific <em>agents</em>, mouse over any <em>agent</em> or value. Information on the Environment snapshot page depends on the <em>APM</em> <em>agent</em> you use. For example, apps using the Ruby <em>agent</em> show settings for gems, while apps using the Java <em>agent</em> show settings for jars."
      },
      "id": "603e7f6064441f5b464e888f"
    },
    {
      "sections": [
        "Use multiple names for an app",
        "Important",
        "Roll up app data",
        "Prevent duplicate transaction events",
        "Roll up Browser data",
        "Define app names from most to least specific",
        "Name app instances via agent config file",
        "Examples",
        "One app, three clusters",
        "Two instances of one app",
        "Other options to organize your apps"
      ],
      "title": "Use multiple names for an app",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "App naming"
      ],
      "external_id": "af78a44c170729aac326233d6468b0b61b6cdff2",
      "image": "https://docs.newrelic.com/static/67c256b1f08164be39b8eeb2ca8ff4e6/8c557/Insights-ToggleOnOff.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/app-naming/use-multiple-names-app/",
      "published_at": "2021-05-05T16:36:25Z",
      "updated_at": "2021-04-16T06:55:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When working with your data in New Relic, you may want to view aggregated data for an application across clusters, environments, or data centers, while at the same time be able to view each of your application instance's data individually. Important If you use multiple names for an app, the last name assigned is the least specific name New Relic uses to roll up the data. For best results to view both instance-level and aggregated data, set the order of your app's rollup names from most specific to least specific in your configuration file. Roll up app data Normally, when two instances report with the same app name, agent language, and license key, New Relic aggregates their data into a single app within the New Relic user interface. You can also view data for the individual hosts and instances from the app's New Relic APM Overview page. To segment your app in a different way, or to work with each instance as an individual app while maintaining the overall view of the data, use your New Relic agent's config file to give an app up to three different rollup names. New Relic will then report the app's data separately to each app listed in the config file. For example, you might want to separate the data collected for your app running in development, staging, and production environments, but also have a common view of the app in every environment. Or, if you have two data centers running the same code, you could name one app EastCoastApp;AggregateApp and the second app WestCoastApp;AggregateApp. Prevent duplicate transaction events By default, an app with multiple names will generate multiple Insights events for transactions (a duplicate transaction for each name). For example, if you give your app three names, that's three times the number of Insights events for transactions. To avoid duplicate Insights events, disable collection for each of the duplicate app names: Go to one.newrelic.com or one.eu.newrelic.com > More > Manage Insights Data. Toggle data collection on/off for duplicate app names, then save. To prevent duplicate events from being collected for an app with multiple names, go to insights.newrelic.com > Manage data > Configure data sources. Roll up Browser data When you use multiple names to report application data, any Browser monitoring data from that application will also be grouped into multiple applications using the same configuration. Important Session trace data will only report to the first application listed. Other Browser data will populate into each of the up to three applications, but session trace data will be limited to the most specific application. Define app names from most to least specific You can give each app up to three names, which New Relic uses to aggregate data from most to least specific. You can then use the New Relic UI to view data for each app name individually, as well as in aggregate for overall application performance. When doing so, the order in which you specify the app names is important. Using multiple names Comments Most specific A unique rollup name. Less specific A shared rollup name to aggregate data in the New Relic UI. This provides more general organization. Optional, least specific An additional, shared rollup name. If used, this is the most general name New Relic uses to aggregate data into a single app. Name app instances via agent config file The naming convention you use in your configuration file depends on your New Relic agent. Set the order of your app's names so that the first rollup name is the most unique. The second and third names can be unique, or they can be the same. The second name is more general for aggregate data, and the third name (if used) is the most general. Agent Configuration file value C Identify a maximum of three names separated by a semicolon ; in your newrelic_app_config_t * config;. Go Set AppName to a maximum of three names separated by a semicolon. Java Set app_name to a maximum of three names separated by a semicolon. .NET Use any of the available options to name your .NET app. Node.js Set app_name to a maximum of three names separated by a comma. Enclose the string of names with single or double quotes. (Or, change the environment variable NEW_RELIC_APP_NAME.) PHP Use any of the available options to name your PHP application. Use three names separated by a semicolon. Python Set app_name to a maximum of three names separated by a semicolon. Do not add a space after the semicolon, or the next name will be interpreted as a comment. Ruby Set app_name to a maximum of three names separated by a semicolon. For more information, refer to the configuration file documentation for your agent. Examples Here are examples of how you could use multiple rollup names for a single app. One app, three clusters A Java app collecting survey data runs on three clusters. Change the value for the app name in your agent config file by giving it three different names, one for each cluster. Cluster 1: app_name: SurveyCluster1;Survey Data Copy Cluster 2: app_name: SurveyCluster2;Survey Data Copy Cluster 3: app_name: SurveyCluster3;Survey Data Copy This will report four applications in New Relic APM: The app name for aggregate data from all three clusters is Survey Data. Three individual applications named SurveyCluster1, SurveyCluster2, and SurveyCluster3. Two instances of one app A PHP agent is monitoring an e-commerce application running on two clusters in each of two data centers, and you want to view data for each subgroup as well as the overall aggregated data. Cluster A: newrelic.appname=\"EcomClusterA;EcomEast;EcomAll\" Copy Cluster B: newrelic.appname=\"EcomClusterB;EcomEast;EcomAll\" Copy Cluster C: newrelic.appname=\"EcomClusterC;EcomWest;EcomAll\" Copy Cluster D: newrelic.appname=\"EcomClusterD;EcomWest;EcomAll\" Copy This example configuration will report seven applications in the New Relic APM UI: Four apps: One for each of the four clusters (A B C D) Two apps: One for each datacenter (East and West) One app for the overall data across clusters and data centers (EcomAll) Other options to organize your apps If you do not want to apply multiple names to your apps, you can organize them with labels and categories. This allows you to easily sort, filter, and page through them from their product index pages in the New Relic UI. You can also set distinct performance thresholds for each environment with alert conditions and key transactions. These thresholds will apply to the individual apps, while the overall app will not have its own thresholds. The overall app will treat incoming data according to the threshold for the relevant enviroment.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 111.752815,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Name app instances via <em>agent</em> config file",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " with the same app name, <em>agent</em> language, and license key, New Relic aggregates their data into a single app within the New Relic user interface. You can also view data for the individual hosts and instances from the app&#x27;s New Relic <em>APM</em> Overview page. To segment your app in a different way, or to work"
      },
      "id": "603ebde1196a677dbaa83dec"
    }
  ],
  "/docs/agents/manage-apm-agents/troubleshooting/get-environment-data-about-your-apm-app": [
    {
      "sections": [
        "Server-side agent configuration",
        "Centralization and security",
        "Server-side configuration precedence",
        "Enable server-side configuration",
        "Tip",
        "View or change server-side configuration settings",
        "Disable server-side configuration"
      ],
      "title": "Server-side agent configuration",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Configuration"
      ],
      "external_id": "928ff211d9e5aa0e02dc64ed344e8cbbd3ea91b5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/configuration/server-side-agent-configuration/",
      "published_at": "2021-05-05T06:35:22Z",
      "updated_at": "2021-05-05T06:35:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Server-side configuration transitions some core settings from your language agent's configuration file to the New Relic collector. Depending on the language agent, available settings may include: Transaction tracing SQL recording and logging SQL query plans Error collection Thread profiling Distributed tracing Cross application tracing Centralization and security Server-side configuration provides an easy way to manage the available settings from the New Relic UI. Centralized configuration settings can also help you ensure standards compliance and security management for your settings. Any change automatically applies to all New Relic APM agents, even if they run across multiple hosts. The agent still follows the local configurations for any settings not available from the UI. Server-side configuration precedence This feature provides the convenience of managing the available configuration settings directly within the New Relic UI, without the need for deployments or restarts. Available options to change settings, and the order of precedence they take when you utilize environment variables or other configuration options, will depend on the language agent used. For more information about the hierarchy of settings, see the illustration for the specific agent: C SDK configuration: A hierarchy is not applicable, because configuration values come from API calls. Also, server-side configuration is not supported. However, you can change the app name from the UI or from the C SDK configuration settings. Go hierarchy Java hierarchy .NET hierarchy Node.js hierarchy PHP hierarchy (server-side configuration not supported) Python hierarchy Ruby hierarchy Enable server-side configuration Tip Owner, Admins, or Add-on Managers The C SDK and PHP agent do not support server-side configuration. To enable server-side configuration settings for apps that use other New Relic agents: Go to rpm.newrelic.com/apm > (select an app) > Settings > Application > Server-side agent configuration. OR Go to rpm.newrelic.com/apm. Next, from the index of applications, select the app's gear icon, then select View settings > Server-side agent configuration. Set the Server-side configuration enabled toggle to On. Select Save server-side configuration. After you enable server-side configuration, you can view and change the available settings through the UI. View or change server-side configuration settings Tip Owner, Admins, or Add-on Managers If you use server-side configuration, you must still include your license_key and app_name in the local config file. These settings are required for the agent to communicate with the New Relic collector. The C SDK and PHP agent do not support server-side configuration. To view or change the available server-side configuration settings through the UI for apps that use other New Relic agents: Go to rpm.newrelic.com/apm > (select an app) > Settings > Application > Server-side agent configuration. OR Go to rpm.newrelic.com/apm. Next, from the index of applications, select the app's gear icon, then select View settings > Server-side agent configuration. View or change the available configuration settings for your agent. If you make changes, select Save server-side configuration. Once you set any of these options from the UI, they will override any conflicting options in the agent's configuration file. Disable server-side configuration Once you enable server-side configuration for an account, server-side configuration cannot be turned off without assistance from New Relic Support. This helps mitigate issues that could arise from conflicts with configuration settings if you need to transition back to a local configuration setup.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 172.61446,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Server-side <em>agent</em> configuration",
        "sections": "Server-side <em>agent</em> configuration",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " change automatically applies to all New Relic <em>APM</em> <em>agents</em>, even if they run across multiple hosts. The <em>agent</em> still follows the local configurations for any settings not available from the UI. Server-side configuration precedence This feature provides the convenience of managing the available"
      },
      "id": "6043c83b64441fc5d6378ed1"
    },
    {
      "sections": [
        "Agent NRIntegrationErrors appear in Insights",
        "Problem",
        "Solution",
        "Go",
        "Tip",
        "Java",
        ".NET",
        "Node.js",
        "Python",
        "Ruby"
      ],
      "title": "Agent NRIntegrationErrors appear in Insights",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Troubleshooting"
      ],
      "external_id": "9d5fdee59e1e3c4d6adc390741171e86274d1caa",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/troubleshooting/agent-nrintegrationerrors-appear-insights/",
      "published_at": "2021-05-06T04:38:48Z",
      "updated_at": "2021-03-16T14:52:45Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem You receive the following NrIntegrationError event in New Relic Insights: Configuration mismatch: Agent configured harvest limit for EVENT TYPE exceeds maximum limit; limit adjusted to LIMIT Copy Solution This is caused by a configuration mismatch with the agent. See the relevant agent solution to resolve your configuration mismatch: Go In your newrelic.Config: For transaction events, adjust the value of TransactionEvents.MaxSamplesStored. Tip The Go Agent currently does not support adjusting this value for custom events. Java In your newrelic.yml: For transaction events, adjust the value of transaction_events.max_samples_stored. For custom events, adjust the value of custom_events.max_samples_stored. .NET In your newrelic.config: For transaction events, adjust the value of the maximumSamplesStored attribute under the transactionEvents element. For custom events, adjust the value of the maximumSamplesStored attribute under the customEvents element. Node.js For transaction events, in the transaction_events: { section of your app's newrelic.js, adjust the value of max_samples_per_minute. For custom events, in the custom_insights_events: { section of your app's newrelic.js, adjust the value of max_samples_stored. Python In your newrelic.ini: For transaction events, adjust the value of event_harvest_config. harvest_limits.analytic_event_data. For custom events, adjust the value of event_harvest_config.harvest_limits.custom_event_data. For error events, adjust the value of event_harvest_config.harvest_limits.error_event_data. For span events, adjust the value of event_harvest_config.harvest_limits.span_event_data. Ruby In your newrelic.yml: For transaction events, adjust the value of analytics_events.max_samples_stored. For custom events, adjust the value of custom_events.max_samples_stored. For error events, adjust the value of error_collector.max_event_samples_stored. Tip This error does not apply to the C SDK or PHP agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 120.18149,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> NRIntegrationErrors appear in Insights",
        "sections": "<em>Agent</em> NRIntegrationErrors appear in Insights",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": "Problem You receive the following NrIntegrationError event in New Relic Insights: Configuration mismatch: <em>Agent</em> configured harvest limit for EVENT TYPE exceeds maximum limit; limit adjusted to LIMIT Copy Solution This is caused by a configuration mismatch with the <em>agent</em>. See the relevant <em>agent</em>"
      },
      "id": "603ec0f9e7b9d2da412a07d6"
    },
    {
      "sections": [
        "Use multiple names for an app",
        "Important",
        "Roll up app data",
        "Prevent duplicate transaction events",
        "Roll up Browser data",
        "Define app names from most to least specific",
        "Name app instances via agent config file",
        "Examples",
        "One app, three clusters",
        "Two instances of one app",
        "Other options to organize your apps"
      ],
      "title": "Use multiple names for an app",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "App naming"
      ],
      "external_id": "af78a44c170729aac326233d6468b0b61b6cdff2",
      "image": "https://docs.newrelic.com/static/67c256b1f08164be39b8eeb2ca8ff4e6/8c557/Insights-ToggleOnOff.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/app-naming/use-multiple-names-app/",
      "published_at": "2021-05-05T16:36:25Z",
      "updated_at": "2021-04-16T06:55:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When working with your data in New Relic, you may want to view aggregated data for an application across clusters, environments, or data centers, while at the same time be able to view each of your application instance's data individually. Important If you use multiple names for an app, the last name assigned is the least specific name New Relic uses to roll up the data. For best results to view both instance-level and aggregated data, set the order of your app's rollup names from most specific to least specific in your configuration file. Roll up app data Normally, when two instances report with the same app name, agent language, and license key, New Relic aggregates their data into a single app within the New Relic user interface. You can also view data for the individual hosts and instances from the app's New Relic APM Overview page. To segment your app in a different way, or to work with each instance as an individual app while maintaining the overall view of the data, use your New Relic agent's config file to give an app up to three different rollup names. New Relic will then report the app's data separately to each app listed in the config file. For example, you might want to separate the data collected for your app running in development, staging, and production environments, but also have a common view of the app in every environment. Or, if you have two data centers running the same code, you could name one app EastCoastApp;AggregateApp and the second app WestCoastApp;AggregateApp. Prevent duplicate transaction events By default, an app with multiple names will generate multiple Insights events for transactions (a duplicate transaction for each name). For example, if you give your app three names, that's three times the number of Insights events for transactions. To avoid duplicate Insights events, disable collection for each of the duplicate app names: Go to one.newrelic.com or one.eu.newrelic.com > More > Manage Insights Data. Toggle data collection on/off for duplicate app names, then save. To prevent duplicate events from being collected for an app with multiple names, go to insights.newrelic.com > Manage data > Configure data sources. Roll up Browser data When you use multiple names to report application data, any Browser monitoring data from that application will also be grouped into multiple applications using the same configuration. Important Session trace data will only report to the first application listed. Other Browser data will populate into each of the up to three applications, but session trace data will be limited to the most specific application. Define app names from most to least specific You can give each app up to three names, which New Relic uses to aggregate data from most to least specific. You can then use the New Relic UI to view data for each app name individually, as well as in aggregate for overall application performance. When doing so, the order in which you specify the app names is important. Using multiple names Comments Most specific A unique rollup name. Less specific A shared rollup name to aggregate data in the New Relic UI. This provides more general organization. Optional, least specific An additional, shared rollup name. If used, this is the most general name New Relic uses to aggregate data into a single app. Name app instances via agent config file The naming convention you use in your configuration file depends on your New Relic agent. Set the order of your app's names so that the first rollup name is the most unique. The second and third names can be unique, or they can be the same. The second name is more general for aggregate data, and the third name (if used) is the most general. Agent Configuration file value C Identify a maximum of three names separated by a semicolon ; in your newrelic_app_config_t * config;. Go Set AppName to a maximum of three names separated by a semicolon. Java Set app_name to a maximum of three names separated by a semicolon. .NET Use any of the available options to name your .NET app. Node.js Set app_name to a maximum of three names separated by a comma. Enclose the string of names with single or double quotes. (Or, change the environment variable NEW_RELIC_APP_NAME.) PHP Use any of the available options to name your PHP application. Use three names separated by a semicolon. Python Set app_name to a maximum of three names separated by a semicolon. Do not add a space after the semicolon, or the next name will be interpreted as a comment. Ruby Set app_name to a maximum of three names separated by a semicolon. For more information, refer to the configuration file documentation for your agent. Examples Here are examples of how you could use multiple rollup names for a single app. One app, three clusters A Java app collecting survey data runs on three clusters. Change the value for the app name in your agent config file by giving it three different names, one for each cluster. Cluster 1: app_name: SurveyCluster1;Survey Data Copy Cluster 2: app_name: SurveyCluster2;Survey Data Copy Cluster 3: app_name: SurveyCluster3;Survey Data Copy This will report four applications in New Relic APM: The app name for aggregate data from all three clusters is Survey Data. Three individual applications named SurveyCluster1, SurveyCluster2, and SurveyCluster3. Two instances of one app A PHP agent is monitoring an e-commerce application running on two clusters in each of two data centers, and you want to view data for each subgroup as well as the overall aggregated data. Cluster A: newrelic.appname=\"EcomClusterA;EcomEast;EcomAll\" Copy Cluster B: newrelic.appname=\"EcomClusterB;EcomEast;EcomAll\" Copy Cluster C: newrelic.appname=\"EcomClusterC;EcomWest;EcomAll\" Copy Cluster D: newrelic.appname=\"EcomClusterD;EcomWest;EcomAll\" Copy This example configuration will report seven applications in the New Relic APM UI: Four apps: One for each of the four clusters (A B C D) Two apps: One for each datacenter (East and West) One app for the overall data across clusters and data centers (EcomAll) Other options to organize your apps If you do not want to apply multiple names to your apps, you can organize them with labels and categories. This allows you to easily sort, filter, and page through them from their product index pages in the New Relic UI. You can also set distinct performance thresholds for each environment with alert conditions and key transactions. These thresholds will apply to the individual apps, while the overall app will not have its own thresholds. The overall app will treat incoming data according to the threshold for the relevant enviroment.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 111.75281,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Name app instances via <em>agent</em> config file",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " with the same app name, <em>agent</em> language, and license key, New Relic aggregates their data into a single app within the New Relic user interface. You can also view data for the individual hosts and instances from the app&#x27;s New Relic <em>APM</em> Overview page. To segment your app in a different way, or to work"
      },
      "id": "603ebde1196a677dbaa83dec"
    }
  ],
  "/docs/agents/net-agent/api-guides/guide-using-net-agent-api": [
    {
      "sections": [
        ".NET agent reports handled errors",
        "Problem",
        "Solution",
        "GetResponse() throws an error",
        "Define a custom instrumentation file",
        "Wrap the method in a custom transaction",
        "Cause"
      ],
      "title": ".NET agent reports handled errors",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "5cd50fdec02b9d8e48348c183e786eac54c312e8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/net-agent-reports-handled-errors/",
      "published_at": "2021-05-05T09:38:51Z",
      "updated_at": "2021-04-29T00:18:04Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem New Relic's .NET agent reports handled errors as though they are standard errors. This is most common with Azure worker roles, console apps, async work, and similar operations. Solution To avoid false error reports, instrument a method that directly or indirectly contains the exception handler. Instrument the target method by defining a custom instrumentation file, or by wrapping the method in a custom transaction, as shown in this example: GetResponse() throws an error In this example, New Relic reports an error from GetResponse() unless the method Foo() is instrumented. As long is Foo is instrumented, New Relic begins a transaction when Foo is called and ends the transaction when Foo ends. Because the error is handled before Foo ends, New Relic will not report an error. Note also that GetResponse() becomes a segment of the Foo transaction. using System; using System.Collections.Generic; using System.Threading; using System.Threading.Tasks; using System.Net; using System.IO; namespace ErrorTester { class Program { static void Main(string[] args) { var i = 0; while (true) { Foo(++i); } } static void Foo(int i) { try { GetNotFound(); } catch (Exception ex) { Console.WriteLine(\"Got it \" + i + \"!\"); Thread.Sleep(1000); } } static string GetNotFound() { string uri = \"http://localhost/Test/this/is/not/a/real/page\"; var request = (HttpWebRequest)WebRequest.Create(uri); var response = request.GetResponse(); var data = new StreamReader(response.GetResponseStream()).ReadToEnd(); response.Close(); return data; } } } Copy Define a custom instrumentation file To instrument Foo: Define a custom instrumentation file; for example, CustomInstrumentation.xml: <?xml version=\"1.0\" encoding=\"utf-8\"?> <!-- © 2008-2014 New Relic, Inc. All rights reserved. --> <!-- When you edit this file, please use an XML aware editor (such as Visual Studio), and pair with the companion file extension.xsd to minimize the chance of introducing typos that may confuse the agent when it is run. --> <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerFactory > <match assemblyName=\"ErrorTester\" className=\"ErrorTester.Program\"> <exactMethodMatcher methodName=\"Foo\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Place CustomInstrumenation.xml in the New Relic extensions folder, alongside CoreInstrumentation.xml, and restart your application. Wrap the method in a custom transaction To instrument Foo, wrap it in a custom transaction: <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerFactory name=\"NewRelic.Agent.Core.Tracer.Factories.BackgroundThreadTracerFactory\" metricName=\"Background/Task\"> <match assemblyName=\"ErrorTester\" className=\"ErrorTester.Program\"> <exactMethodMatcher methodName=\"Foo\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Cause The only errors New Relic's .NET agent reports are unhandled errors that end a transaction. If your app calls an exception handler before the transaction ends, New Relic will not report an error. However, New Relic does not always detect exception handlers when the error occurs outside of a web transaction, WCF transaction, or custom transaction. This is because the agent creates \"mini-transactions\" for instrumented methods that are not associated with a transaction. When the instrumented method exits, the mini-transaction ends. If the mini-transaction throws an error and the instrumented method does not handle it, then New Relic will report an error. You can see this in a console app that calls GetResponse(), as shown in the example. If GetResponse throws an error, then New Relic will report it, even though GetResponse() is called within a try/catch block. The agent reports an error because the GetResponse() \"mini-transaction\" ended and the error was still unhandled on transaction exit.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 84.37305,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> reports handled errors",
        "sections": ".<em>NET</em> <em>agent</em> reports handled errors",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "Problem New Relic&#x27;s .<em>NET</em> <em>agent</em> reports handled errors as though they are standard errors. This is most common with Azure worker roles, console apps, async work, and similar operations. Solution To avoid false error reports, instrument a method that directly or indirectly contains the exception"
      },
      "id": "603e910028ccbcc7c0eba7b4"
    },
    {
      "sections": [
        "Guide to using the PHP agent API",
        "Tip",
        "Notice or ignore errors",
        "Enhance the metadata of a transaction",
        "Name reporting app",
        "Instrument missing sections of your code with transactions",
        "Time specific methods using segments",
        "Instrument asynchronous work",
        "Send custom event and metric data from your app",
        "Instrument calls to external services",
        "Monitor specific browser pages",
        "For more help"
      ],
      "title": "Guide to using the PHP agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "PHP agent",
        "API guides"
      ],
      "external_id": "c1e218a22dcfaec484847c97b50bc452b6155a5a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/php-agent/api-guides/guide-using-php-agent-api/",
      "published_at": "2021-05-05T13:49:55Z",
      "updated_at": "2021-04-16T09:19:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's PHP agent provides an API for customizing agent behavior. The agent automatically instruments many popular PHP frameworks, but you can use the PHP API to instrument activity that the agent doesn't already instrument by default. This guide describes PHP API calls for several common tasks; for example: Notice or ignore specific errors. Name a transaction. Rename the application reporting the data. Tip You can also set many of these options per directory or in newrelic.ini. If setting via API, the API takes precedence over the other methods. Notice or ignore errors Usually, the agent detects errors automatically. However, you can manually mark an error with the agent. If you want to... Do this... Report an error the agent does not report automatically See newrelic_notice_error(). Ignore an error Edit error_collector.ignore_exceptions or error_collector.ignore_errors in thenewrelic.ini file. Enhance the metadata of a transaction Sometimes the code you target is visible in New Relic, but some details of the method are not useful. For example: The default name is not helpful, or it is causing a metric grouping issue. You want to add custom attributes to your transactions or spans so you can filter them with NRQL queries. Use these methods when you want to change how New Relic instruments a transaction that's already visible in New Relic: If you want to... Do this... Change the name of a transaction See newrelic_name_transaction(). Add metadata (such as your customer's account name or subscription level) to your transactions or spans Use custom attributes. For custom attributes which will be added to transactions and spans (if enabled), see newrelic_add_custom_parameter(). For custom attributes which will be added only to spans, see newrelic_add_custom_span_parameter(). Mark a transaction as a background job See newrelic_background_job(). Prevent a transaction from affecting your Apdex score See newrelic_ignore_apdex(). Name reporting app The New Relic UI organizes data by how you name your application. Each name appears as a different app. You can rename the reporting app for any part of your code to better help you: Organize and analyze your data on New Relic UI pages (for example, APM's Applications index page, the Summary page, the Transactions page, etc.). Query your data. Create alert policies. This is especially useful if you have a multi-site application or distinct sets of application code using the same PHP installation. Alternatively, you can set the app name at a higher level instead via the newrelic.appname config value, via Apache, or via PHP-FPM. If you want to... Do this... Rename the reporting app for a specific part of your code Set the app name. See newrelic_set_appname(). Instrument missing sections of your code with transactions To instrument your app, New Relic separates each path through your code into its own transaction. New Relic times (or \"instruments\") the parent method in these transactions to measure your app's overall performance, and collects transaction traces from long-running transactions for additional detail. For more information about transactions, see transaction and transaction trace. Use these methods when New Relic is not instrumenting a particular part of your code at all: If you want to... Do this... Start timing a method New Relic is not instrumenting automatically Start a transaction. See newrelic_start_transaction(). Stop timing a method after its work is completed Stop a transaction. See newrelic_end_transaction(). Prevent a transaction from reporting to New Relic Ignore the transaction. See newrelic_ignore_transaction(). Time specific methods using segments If a transaction is already visible in the New Relic UI, but you don't have enough data about a particular method that was called during that transaction, you can create segments to time those individual methods in greater detail. For example, you might want to time a particularly critical method with complex logic. Use this methods when you want to instrument a method within an existing transaction: If you want to... Do this... Time a particular method See newrelic_add_custom_tracer(). Instrument asynchronous work The only async work the PHP agent instruments is Guzzle, which is instrumented by default. Send custom event and metric data from your app New Relic includes a number of ways to record arbitrary custom data. For an explanation of New Relic data types, see Data collection. If you want to... Do this... Send data about an event so you can analyze it in New Relic Create a custom event. See Insert custom events via APM agent (PHP). Tag your events with metadata to filter and facet them Add custom attributes. See newrelic_add_custom_parameter(). Report custom performance data Create a custom metric. See newrelic_custom_metric(). Instrument calls to external services Use these methods to collect data about your app's connections to other apps or datastores: If you want to... Do this... Time a call to a datastore not instrumented by default See newrelic_record_datastore_segment(). See the path that a request takes as it travels through a distributed system For PHP agent versions lower than 9.8, see these API calls: newrelic_create_distributed_trace_payload() newrelic_accept_distributed_trace_payload() newrelic_accept_distributed_trace_payload_httpsafe() For PHP agent versions 9.8 or higher, see these API calls: newrelic_insert_distributed_trace_headers() newrelic_accept_distributed_trace_headers() For examples, see the documentation to manually instrument distributed tracing. Monitor specific browser pages You can install the browser agent by automatically adding it to your pages or by deploying it on specific pages by copying and pasting our JavaScript snippet. You can also control the browser agent by using APM agent API calls. For more information, see Browser monitoring and the PHP agent. For more help If you need more help, check out these support and learning resources: Suggest a change and learn how to contribute to our PHP agent open source repository. Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 75.413765,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Guide</em> to using the PHP <em>agent</em> <em>API</em>",
        "sections": "<em>Guide</em> to using the PHP <em>agent</em> <em>API</em>",
        "tags": "<em>API</em> <em>guides</em>",
        "body": "New Relic&#x27;s PHP <em>agent</em> provides an <em>API</em> for customizing <em>agent</em> behavior. The <em>agent</em> automatically instruments many popular PHP frameworks, but you can use the PHP <em>API</em> to instrument activity that the <em>agent</em> doesn&#x27;t already instrument by default. This guide describes PHP <em>API</em> calls for several common tasks"
      },
      "id": "60441c1ee7b9d2aa685799c5"
    },
    {
      "sections": [
        "Node.js agent API",
        "Request names",
        "Tip",
        "Requirements",
        "Avoid metric grouping issues",
        "Guidelines",
        "URL pattern matching",
        "Load the request naming API",
        "Request API calls",
        "newrelic.setTransactionName(name)",
        "newrelic.setControllerName(name, \\[action])",
        "Custom instrumentation API calls",
        "newrelic.instrument(moduleName, onRequire \\[, onError])",
        "newrelic.instrumentDatastore(moduleName, onRequire \\[, onError])",
        "newrelic.instrumentLoadedModule(moduleName, moduleInstance)",
        "Important",
        "newrelic.instrumentMessages(moduleName, onRequire \\[, onError])",
        "newrelic.instrumentWebframework(moduleName, onRequire \\[, onError])",
        "newrelic.startWebTransaction(url, handle)",
        "newrelic.startBackgroundTransaction(name, \\[group], handle)",
        "newrelic.getTransaction()",
        "newrelic.endTransaction()",
        "newrelic.startSegment(name, record, handler, callback)",
        "Custom metrics API calls",
        "newrelic.recordMetric(name, value)",
        "newrelic.incrementMetric(name, \\[amount])",
        "Custom events API calls",
        "newrelic.recordCustomEvent(eventType, attributes)",
        "Recording a custom event",
        "Transaction handle methods",
        "transactionHandle.end(\\[callback])",
        "transactionHandle.ignore()",
        "transactionHandle.insertDistributedTraceHeaders(headers)",
        "Generating distributed trace headers",
        "transactionHandle.acceptDistributedTraceHeaders(transportType, headers)",
        "Accept incoming distributed trace headers",
        "transactionHandle.createDistributedTracePayload()",
        "Caution",
        "Link a nested background transaction",
        "Place payload on an outgoing request",
        "transactionHandle.acceptDistributedTracePayload(payload)",
        "transactionHandle.isSampled()",
        "Other API calls",
        "newrelic.addCustomAttribute(name, value)",
        "Add custom attribute",
        "newrelic.addCustomAttributes(attributes)",
        "Adding custom attributes",
        "newrelic.addCustomSpanAttribute(name, value)",
        "Add custom span attribute",
        "newrelic.addCustomSpanAttributes(attributes)",
        "Add custom span attributes",
        "newrelic.getBrowserTimingHeader()",
        "newrelic.setIgnoreTransaction(ignored)",
        "newrelic.noticeError(error, \\[customParameters])",
        "newrelic.shutdown(\\[options], callback)",
        "newrelic.getLinkingMetadata()",
        "newrelic.getTraceMetadata()",
        "Rules for naming and ignoring requests",
        "rules.name",
        "Optional rules attributes [#optional-rules]",
        "Testing your naming rules [#testing-rules]",
        "Naming rule examples [#examples-rules]",
        "Match full URL",
        "Replace first match in URL",
        "Replace all matches in any URL",
        "Match group references",
        "rules.ignore",
        "Naming rule example",
        "Ignoring rule example",
        "API calls for rules",
        "newrelic.addNamingRule(pattern, name)",
        "newrelic.addIgnoringRule(pattern)"
      ],
      "title": "Node.js agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "API guides"
      ],
      "external_id": "dd0838adbfafc7e5988ed77ad3ad039cdce29ec0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/api-guides/nodejs-agent-api/",
      "published_at": "2021-05-05T00:40:51Z",
      "updated_at": "2021-04-16T05:29:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic offers several tools to help obtain the information needed to provide useful metrics about your Node.js application. These include: Reading the route names (if used) from the Express and Restify routers Using the API to name the current request, either with simple names or groups of controllers with actions Support rules that are stored in your agent's configuration that can mark requests to be renamed or ignored based on regular expressions matched against the request's raw URLs (also available as API calls) The number of names that New Relic tracks needs to be small enough so that the user experience is robust. It also needs to be large enough to provide the right amount of information (without overwhelming you with data) so that you can identify problem spots in your applications more easily. For more information, see the Node.js agent configuration documentation and the Node.js agent API documentation on Github. Request names The Node.js agent captures the HTTP method along with a potentially parameterized path (such as /user/:id) or a regular expression (such as /^/user/([-0-9a-f]+)$/). These pieces of information become part of the request name. If you have support for slow transaction traces and have enabled capture_params in your config file, the transaction trace will also have the request's parameters and their values attached to it. If you are dissatisfied with the request names that the Node.js agent uses, you can use API calls to create more descriptive names. Tip If grouping your requests under the generic name, then /* is sufficient, and you do not need to customize your configuration file or API calls. Requirements New Relic uses request names to group requests for many charts and tables. The value of these visualizations will drop as the number of different request names increases. For example, do not include potentially dynamic data like GUIDs, numerical IDs, or timestamps in the request names you create. If your request is slow enough to generate a transaction trace, that trace will contain the original URL. If you enable parameter capture, the parameters will also be attached to the trace. Tip Avoid having more than 50 different transaction names. For example, if you have more than a couple hundred different request names, rethink your naming strategy. Avoid metric grouping issues The request naming API helps New Relic avoid problems with trying to handle too many metrics, which sometimes is referred to as \"metric explosion.\" New Relic has several strategies to deal with these issues; the most severe is simply to add offending applications to your deny list. The main reason for you to be careful in using these request-naming tools is to prevent that from happening to your applications. For more information, see Metric grouping issues. Guidelines Define your configuration rules from the most specific to the most general. The first rules listed in your config file or added with the Node.js transaction naming API will be applied first and should be narrowly targeted. More general \"fall-through\" rules should be added toward the end of the list, because they will be evaluated in the order they were configured or added using the Node.js transaction naming API. URL pattern matching An online retailer has a URL pattern like this: /user/customers/all/prospects /user/customers/all/current /user/customers/all/returning /user/customers/John /user/customers/Jane Copy The retailer could create rules like this: // newrelic.js exports.config={ //other configuration rules:{ name:[ { pattern: \"/user/customers/all/prospects/\", name: \"/user/customers/all/prospects\" }, { pattern: \"/user/customers/all/.*\", name: \"/user/customers/all\" }, { pattern: \"/user/customers/.*\", name: \"/user/customers/:customer\" } ] } } Copy With these rules, the retailer would create three transaction names: /user/customers/:customer /user/customers/all /user/customers/all/prospects If the retailer reversed the order, the rules would catch all transactions in :customer, which would not be as useful. Load the request naming API Make sure that loading the New Relic module is the first thing your application does, as it needs to bootstrap itself before the rest of your application loads: var newrelic = require('newrelic'); Copy This returns the request naming API. You can safely require the module from multiple modules in your application, as it only initializes itself once. Request API calls Here is a summary of the Request API calls for New Relic's Node.js agent. newrelic.setTransactionName(name) newrelic.setTransactionName(name) Copy Name the current request, following the request naming requirements. You can call this function anywhere within the context of an HTTP request handler, at any time after handling of the request has started, but before the request has finished. In general, if the request and response objects are in scope, you can set the name. Explicitly calling newrelic.setTransactionName() will override any names set by Express or Restify routes. Also, calls to newrelic.setTransactionName() and newrelic.setControllerName() will overwrite each other. The last one to run before the request ends wins. newrelic.setControllerName(name, \\[action]) newrelic.setControllerName(name, \\[action]) Copy Name the current request using a controller-style pattern, optionally including the current controller action. If the action is omitted, New Relic will include the HTTP method (GET, POST, etc.) as the action. The rules for when you can call newrelic.setControllerName() are the same as they are for newrelic.setTransactionName(), including the request naming requirements. Explicitly calling newrelic.setControllerName() will override any names set by Express or Restify routes. Also, calls to newrelic.setTransactionName() and newrelic.setControllerName() will overwrite each other. The last one to run before the request ends wins. Custom instrumentation API calls Use these API calls to expand your instrumentation with custom instrumentation. newrelic.instrument(moduleName, onRequire \\[, onError]) newrelic.instrument(moduleName, onRequire \\[, onError]) Copy Sets an instrumentation callback for a specific module. The provided onRequire callback will be fired when the given module is loaded with require. The moduleName parameter should be the string that will be passed to require; for example, 'express' or 'amqplib/callback_api'. The optional onError callback is called if the onRequire parameters throws an error. This is useful for debugging your instrumentation. Use this method to: Add instrumentation for modules not currently instrumented by New Relic. Instrument your own code. Replace the Node.js agent's built-in instrumentation with your own. For more information, see New Relic's Node.js instrumentation tutorial on Github. newrelic.instrumentDatastore(moduleName, onRequire \\[, onError]) newrelic.instrumentDatastore(moduleName, onRequire \\[, onError]) Copy Sets an instrumentation callback for a datastore module. This method is just like newrelic.instrument(), except it provides a datastore-specialized shim. For more information, see New Relic's Node.js datastore instrumentation tutorial on Github. newrelic.instrumentLoadedModule(moduleName, moduleInstance) newrelic.instrumentLoadedModule(moduleName, moduleInstance) Copy The instrumentLoadedModule method allows you to add stock instrumentation to specific modules in situations where it's impossible to have require('newrelic'); as the first line of your app's main module. // load the agent const newrelic = require('newrelic') // module loaded before newrelic const expressModule = require('express') // instrument express _after_ the agent has been loaded newrelic.instrumentLoadedModule( 'express', // the module's name, as a string expressModule // the module instance ); Copy Important This method cannot instrument any arbitrary module. Its purpose is to add modules that were missed because the agent was not loaded as the first thing in your program. The instrumentLoadedModule method can only instrument modules the agent would normally instrument. You can see a list of these modules in the agent's lib/instrumentations module. newrelic.instrumentMessages(moduleName, onRequire \\[, onError]) newrelic.instrumentMessages(moduleName, onRequire \\[, onError]) Copy Sets an instrumentation callback for a message service client module. This method is just like newrelic.instrument(), except it provides a message-service-specialized shim. For more information, see New Relic's Node.js message service instrumentation tutorial on Github. newrelic.instrumentWebframework(moduleName, onRequire \\[, onError]) newrelic.instrumentWebframework(moduleName, onRequire \\[, onError]) Copy Sets an instrumentation callback for a web framework module. This method is just like newrelic.instrument(), except it provides a web-framework-specialized shim. For more information, see New Relic's Node.js web framework instrumentation tutorial on Github. newrelic.startWebTransaction(url, handle) newrelic.startWebTransaction(url, handle) Copy Instrument the specified web transaction. Using this API call, you can instrument transactions that New Relic does not automatically detect. The url defines the transaction name and needs to be static. Do not include variable data such as user ID. The handle defines the function you want to instrument. New Relic will capture any metrics that would be captured by auto-instrumentation, as well as manual instrumentation via startSegment(). You must handle custom transactions manually by calling newrelic.getTransaction() at the start of your transaction, and then call transaction.end() when you are finished. New Relic begins timing the transaction when newrelic.startWebTransaction() is called and ends the transaction when transaction.end() is called. You can also return a promise to indicate the end of the transaction. Please note that if this promise rejects, it does not automatically hook into New Relic’s error tracking. This needs to be done manually with noticeError(). newrelic.startBackgroundTransaction(name, \\[group], handle) newrelic.startBackgroundTransaction(name, \\[group], handle) Copy Instrument the specified background transaction. Using this API call, you can expand New Relic's instrumentation to capture data from background transactions. The name defines the transaction name and needs to be static. Do not include variable data such as user ID. The group is optional, and it allows you to group similar jobs together via the transaction type in the user interface. Like name, the group needs to be static. The handle defines a function that includes the entire background job you want to instrument. New Relic will capture any metrics that would be captured by auto-instrumentation, as well as manual instrumentation via startSegment(). You must handle custom transactions manually by calling newrelic.getTransaction() at the start of your transaction, and then call transaction.end() when you are finished. New Relic begins timing the transaction when newrelic.startBackgroundTransaction() is called and ends the transaction when transaction.end() is called. You can also return a promise to indicate the end of the transaction. Please note that if this promise rejects, it does not automatically hook into New Relic’s error tracking. This needs to be done manually with noticeError(). newrelic.getTransaction() newrelic.getTransaction() Copy Returns a handle on the currently executing transaction. This handle can then be used to interact with a given transaction safely from any context. It is best used with newrelic.startWebTransaction() and newrelic.startBackgroundTransaction(). Please refer to the transaction handle section for more details. newrelic.endTransaction() newrelic.endTransaction() Copy End the current web or background custom transaction. This method requires being in the correct transaction context when called. This API call takes no arguments. newrelic.startSegment(name, record, handler, callback) newrelic.startSegment(name, record, handler, callback) Copy Instrument a particular method to improve visibility into a transaction, or optionally turn it into a metric. The name defines a name for the segment. This name will be visible in transaction traces and as a new metric in the New Relic UI. The record flag defines whether the segment should be recorded as a metric. The handler is the function you want to track as a segment. The optional callback is a function passed to the handler to fire after its work is done. The agent begins timing the segment when startSegment is called. The segment is ended when either the handler finishes executing, or callback is fired, if it is provided. Custom metrics API calls Use these API calls to record additional arbitrary metrics: newrelic.recordMetric(name, value) newrelic.recordMetric(name, value) Copy Use recordMetric to record an event-based metric, usually associated with a particular duration. The name must be a string following standard metric naming rules. The value will usually be a number, but it can also be an object. When value is a numeric value, it should represent the magnitude of a measurement associated with an event; for example, the duration for a particular method call. When value is an object, it must contain count, total, min, max, and sumOfSquares keys, all with number values. This form is useful to aggregate metrics on your own and report them periodically; for example, from a setInterval. These values will be aggregated with any previously collected values for the same metric. The names of these keys match the names of the keys used by the platform API. newrelic.incrementMetric(name, \\[amount]) newrelic.incrementMetric(name, \\[amount]) Copy Use incrementMetric to update a metric that acts as a simple counter. The count of the selected metric will be incremented by the specified amount, defaulting to 1. Custom events API calls Use these API calls to record additional events: newrelic.recordCustomEvent(eventType, attributes) newrelic.recordCustomEvent(eventType, attributes) Copy Use recordCustomEvent to record an event-based metric, usually associated with a particular duration. The eventType must be an alphanumeric string less than 255 characters. The attributes must be an object of key and value pairs. The keys must be shorter than 255 characters, and the values must be string, number, or boolean. Recording a custom event The following example demonstrates recording a custom event with multiple attributes. const attributes = { attribute1: 'value1', attribute2: 2 } newrelic.recordCustomEvent('MessagingEvent', attributes) Copy Transaction handle methods This section details the methods provided by the TransactionHandle class instance that can be obtained through newrelic.getTransaction(). Use these methods to interact directly with the current transaction: transactionHandle.end(\\[callback]) transactionHandle.end(\\[callback]) Copy Use transactionHandle.end to end the transaction referenced by the handle instance. The callback is invoked when the transaction has fully ended. The finished transaction passed to the callback as the first argument. transactionHandle.ignore() transactionHandle.ignore() Copy Use transactionHandle.ignore to ignore the transaction referenced by the handle instance. transactionHandle.insertDistributedTraceHeaders(headers) transactionHandle.insertDistributedTraceHeaders(headers) Copy Important This API requires distributed tracing to be enabled. For context on how to use this call and its partner call acceptDistributedTraceHeaders, first read Enable distributed tracing with agent APIs. transactionHandle.insertDistributedTraceHeaders is used to implement distributed tracing. It modifies the headers map that is passed in by adding W3C Trace Context headers and New Relic Distributed Trace headers. The New Relic headers can be disabled with distributed_tracing.exclude_newrelic_header: true in the config. This method replaces the deprecated createDistributedTracePayload method, which only creates New Relic Distributed Trace payloads. Generating distributed trace headers In the following example, by calling insertDistributedTraceHeaders with an empty object, the appropriate Distributed Trace headers and W3C Trace Context headers will be generated for the transaction. // Call newrelic.getTransaction to retrieve a handle on the current transaction. const transactionHandle = newrelic.getTransaction() // This could be a header object from an incoming request as well const headersObject = {} newrelic.startBackgroundTransaction('background task', function executeTransaction() { const transaction = newrelic.getTransaction() // generate the headers transaction.insertDistributedTraceHeaders(headersObject) }) Copy transactionHandle.acceptDistributedTraceHeaders(transportType, headers) transactionHandle.acceptDistributedTraceHeaders(transportType, headers) Copy Important This API requires distributed tracing to be enabled. For context on how to use this call and its partner call insertDistributedTraceHeaders, first read Enable distributed tracing with agent APIs. transactionHandle.acceptDistributedTraceHeaders is used to instrument the called service for inclusion in a distributed trace. It links the spans in a trace by accepting a payload generated by insertDistributedTraceHeaders or generated by some other W3C Trace Context compliant tracer. This method accepts the headers of an incoming request, looks for W3C Trace Context headers, and if not found, falls back to New Relic distributed trace headers. This method replaces the deprecated (and now removed as of version 7.0.0) acceptDistributedTracePayload method, which only handles New Relic distributed trace payloads. transportType should be one of the following strings: AMQP HTTP HTTPS IronMQ JMS Kafka Other Queue Unknown headers should be an object containing all the headers in the incoming request. The keys must be lowercase. Accept incoming distributed trace headers The following example demonstrates adding distributed trace headers retrieved from a Kafka message. In this example, we assume that the incoming Kafka message has Distributed Trace headers inserted. // incoming Kafka message headers const headersObject = message.headers // Call newrelic.getTransaction to retrieve a handle on the current transaction. const transactionHandle = newrelic.getTransaction() newrelic.startBackgroundTransaction('background task', function executeTransaction() { const transaction = newrelic.getTransaction() // accept the headers transaction.acceptDistributedTraceHeaders('Kafka', headersObject) }) Copy transactionHandle.createDistributedTracePayload() transactionHandle.createDistributedTracePayload() Copy Caution This method is deprecated and was removed in version 7.0.0! Please use insertDistributedTraceHeaders. Important This API requires distributed tracing to be enabled. For instructions on how to use this call, along with its partner call acceptDistributedTracePayload, see Enable distributed tracing with agent APIs. This call is used to implement distributed tracing. It generates a payload that is read by the receiving application with acceptDistributedTracePayload. Important Note: In order to maintain proper ordering of spans in a trace, you must generate the payload in the context of the span that sends it. The DistributedTracePayload object has two available methods used for generating the payload in different formats: DistributedTracePayload#text: returns a JSON representation of the payload. Link a nested background transaction // Call newrelic.getTransaction to retrieve a handle on the current transaction. var transactionHandle = newrelic.getTransaction() var payload = transactionHandle.createDistributedTracePayload() var jsonPayload = payload.text() newrelic.startBackgroundTransaction('background task', function executeTransaction() { var backgroundHandle = newrelic.getTransaction() // Link the nested transaction by accepting the payload with the background transaction's handle backgroundHandle.acceptDistributedTracePayload(jsonPayload) }) Copy DistributedTracePayload#httpSafe: returns a base64 encoded JSON representation of the payload. Place payload on an outgoing request // Call newrelic.getTransaction to retrieve a handle on the current transaction. var transactionHandle = newrelic.getTransaction() var payload = transactionHandle.createDistributedTracePayload() // Place the base64 encoded value on an outbound request header. req.headers[myTracingHeader] = payload.httpSafe() Copy transactionHandle.acceptDistributedTracePayload(payload) transactionHandle.acceptDistributedTracePayload(payload) Copy Caution This method is deprecated and was removed in version 7.0.0! Please use acceptDistributedTraceHeaders. Important This API requires distributed tracing to be enabled. For context on how to use this call and its partner call createDistributedTracePayload, first read Enable distributed tracing with agent APIs. transactionHandle.acceptDistributedTracePayload is used to instrument the called service for inclusion in a distributed trace. It links the spans in a trace by accepting the payload generated by createDistributedTracePayload. transactionHandle.isSampled() transactionHandle.isSampled() Copy Returns whether this trace is being sampled. Other API calls New Relic's Node.js agent includes additional API calls. newrelic.addCustomAttribute(name, value) newrelic.addCustomAttribute(name, value) Copy Set a custom attribute value to be displayed along with the transaction trace in the New Relic UI. This must be called within the context of a transaction so it has a place to set the custom attributes. Custom attributes will appear in New Relic APM's transaction trace detail view and in errors for the transaction. Add custom attribute newrelic.addCustomAttribute('attribute1', 'value1') Copy Caution If you want to use your custom attributes, avoid using any of the reserved terms used by NRQL when naming them. newrelic.addCustomAttributes(attributes) newrelic.addCustomAttributes(attributes) Copy Set multiple custom attribute values to be displayed along with the transaction trace in the New Relic UI. The attributes should be passed as a single object. This must be called within the context of a transaction so it has a place to set the custom attributes. Custom attributes will appear in the transaction trace detail view and in errors for the transaction. Adding custom attributes const attributes = { attribute1: 'value1', attribute2: 2 } newrelic.addCustomAttributes(attributes) Copy Caution If you want to use your custom attributes, avoid using any of the reserved terms used by NRQL when naming them. newrelic.addCustomSpanAttribute(name, value) newrelic.addCustomSpanAttribute(name, value) Copy Set a custom span attribute value to be displayed along with a transaction trace span in the New Relic UI. This must be called within the context of an active segment/span so it has a place to set the custom span attributes. Custom span attributes will appear in the Attributes section of the span detail view. Add custom span attribute newrelic.addCustomSpanAttribute('attribute1', 'value') Copy Important This API requires distributed tracing and span events to be enabled. Caution If you want to use your custom span attributes, avoid using any of the reserved terms used by NRQL when naming them. newrelic.addCustomSpanAttributes(attributes) newrelic.addCustomSpanAttributes(attributes) Copy Set multiple custom span attribute values to be displayed along with the transaction trace spans in the New Relic UI. The attributes should be passed as a single object. This must be called within the context of an active segment/span so it has a place to set the custom span attributes. Custom span attributes will appear in the Attributes section of the span detail view. Add custom span attributes const attributes = { attribute1: 'value1', attribute2: 'value2' } newrelic.addCustomSpanAttributes(attributes) Copy Important This API requires distributed tracing and span events to be enabled. Caution If you want to use your custom span attributes, avoid using any of the reserved terms used by NRQL when naming them. newrelic.getBrowserTimingHeader() newrelic.getBrowserTimingHeader() Copy Returns the HTML snippet to be inserted into the header of HTML pages to enable New Relic Browser. The HTML will instruct the browser to fetch a small JavaScript file and start the page timer. newrelic.setIgnoreTransaction(ignored) newrelic.setIgnoreTransaction(ignored) Copy Tell the module whether or not to ignore a given request. This allows you to explicitly filter long-polling, irrelevant routes or requests you know will be time-consuming. This also allows you to gather metrics for requests that otherwise would be ignored. To ignore the transaction, set the parameter to true will ignore the transaction. To prevent a transaction from being ignored with this function, pass the parameter false. Passing null or undefined will not change whether the transaction is ignored. Caution This method is deprecated and was removed in version 7.0.0. Please use transactionHandle.ignore() newrelic.noticeError(error, \\[customParameters]) newrelic.noticeError(error, \\[customParameters]) Copy Use this call if your app is doing its own error handling with domains or try/catch clauses, but you want all of the information about how many errors are coming out of the app to be centrally managed. Unlike other Node.js calls, this can be used outside of route handlers, but it will have additional context if called from within transaction scope. Caution Errors recorded using this method do not obey the ignore_status_codes configuration value. newrelic.shutdown(\\[options], callback) newrelic.shutdown(\\[options], callback) Copy Use this method to gracefully shut down the agent. options options.collectPendingData - type boolean - Tell the agent whether to send any pending data to the New Relic collector before shutting down. options.timeout - type number (ms) - The default time before forcing a shutdown. When collectPendingData is true, the agent will wait for a connection before shutting down. This timeout is useful for short lived processes, like AWS Lambda, in order to keep the process from staying open too long, while trying to connect. Example: newrelic.shutdown({collectPendingData: true, timeout: 3000}, (error) => { process.exit() }) Copy newrelic.getLinkingMetadata() newrelic.getLinkingMetadata() Copy Returns key/value pairs which can be used to link traces or entities. It will only contain items with meaningful values. For instance, if distributed tracing is disabled, trace.id will not be included. newrelic.getTraceMetadata() newrelic.getTraceMetadata() Copy Returns and object containing the current trace ID and span ID. Important This API requires distributed tracing to be enabled or an empty object will be returned. Rules for naming and ignoring requests If you do not want to put calls to the New Relic module directly into your application code, you can use pattern-based rules to name requests. There are two sets of rules: one for renaming requests, and one to mark requests to be ignored by New Relic's instrumentation. Here is the structure for rules in New Relic's Node.js agent. rules.name A list of rules of the format {pattern : \"pattern\", name : \"name\"} for matching incoming request URLs to pattern and naming the matching New Relic transaction's name. This acts as a regex replace, where you can set the pattern either as a string, or as a JavaScript regular expression literal, and both pattern and name are required. When passing a regex as a string, escape backslashes, as the agent does not keep them when given as a string in a pattern. Define your configuration rules from the most specific to the most general, as the patterns will be evaluated in order and are terminal in nature. For more information, see the naming guidelines. This can also be set with the environment variable NEW_RELIC_NAMING_RULES, with multiple rules passed in as a list of comma-delimited JSON object literals: NEW_RELIC_NAMING_RULES='{\"pattern\":\"^t\",\"name\":\"u\"},{\"pattern\":\"^u\",\"name\":\"t\"}' Copy Optional rules attributes [#optional-rules] Additional optional attributes are available: Optional rules attributes Description terminate_chain Default: true When set to true (default), no further rules will be evaluated if this rule is a match. Setting this to false is useful when multiple rules should be used together. For example, one rule could be replacing a common pattern in many different URLs, while subsequent rule(s) would be more specific. replace_all Default: false When set to true, all matches of the pattern will be replaced. Otherwise, only the first match will be replaced. Using the g flag with regular expression literal will have the same effect. For example: pattern: '[0-9]+', replace_all: true Copy This has the same effect as pattern: /[0-9]+/g. precedence By default the rules are evaluated in order, from first to last. If you prefer to have complete control over the order, you can give each rule a precedence attribute. The precedence is an integer number, and rules are evaluated in ascending order. If precedence is not explicitly defined, it will be set to 500 by default. Additional attributes are ignored. Testing your naming rules [#testing-rules] The Node.js agent comes with a command-line tool for testing naming rules. For more information, run the following command in terminal window in a directory where your app is installed: node node_modules/.bin/newrelic-naming-rules Copy Naming rule examples [#examples-rules] Here are some examples of naming rules and the results. Match full URL pattern: \"^/items/[0-9]+$\", name: \"/items/:id\" Copy will result in: /items/123 => /items/:id /orders/123 => /orders/123 (not replaced since the rule is a full match) Copy Replace first match in URL pattern: \"[0-9]+\", name: \":id\" Copy will result in: /orders/123 => /orders/:id /items/123 => /items/:id /orders/123/items/123 => /orders/:id/items/123 Copy Replace all matches in any URL pattern: \"[0-9]+\", name: \":id\", replace_all: true Copy will result in: /orders/123/items/123 => /orders/:id/items/:id Copy Match group references Using regular expression match group references: pattern: '^/(items|orders)/[0-9]+$', name: '/\\\\1/:id' Copy will result in: /orders/123 => /orders/:id /items/123 => /items/:id Copy rules.ignore This can also be set via the environment variable NEW_RELIC_IGNORING_RULES, with multiple rules passed in as a list of comma-delimited patterns. Currently there is no way to escape commas in patterns. NEW_RELIC_IGNORING_RULES='^/socket\\.io/\\*/xhr-polling,ignore_me' Copy Here are full examples of how rules are included in the configuration file: Naming rule example // newrelic.js exports.config = { // other configuration rules : { name : [ { pattern: \"/tables/name-here\", name: \"/name-hererule1\" } ] } Copy Ignoring rule example If you are using socket.io, you will have a use case for ignoring rules right out of the box. To keep socket.io long-polling from dominating your response-time metrics and affecting the Apdex metrics for your application, add a rule such as: // newrelic.js exports.config = { // other configuration rules : { ignore : [ '^\\/socket\\.io\\/.*\\/xhr-polling' ] } }; Copy API calls for rules Here are the API calls for naming and ignoring rules with New Relic's Node.js agent. newrelic.addNamingRule(pattern, name) Programmatic version of rules.name. Once naming rules are added, they cannot be removed until the Node process is restarted. They can also be added via the Node.js agent's configuration. Both parameters are required. newrelic.addIgnoringRule(pattern) Programmatic version of rules.ignore. Once ignoring rules are added, they cannot be removed until the Node process is restarted. They can also be added via the Node.js agent's configuration. This parameter is required.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 75.29962,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Node.js <em>agent</em> <em>API</em>",
        "sections": "Node.js <em>agent</em> <em>API</em>",
        "tags": "<em>API</em> <em>guides</em>",
        "body": " of controllers with actions Support rules that are stored in your <em>agent</em>&#x27;s configuration that can mark requests to be renamed or ignored based on regular expressions matched against the request&#x27;s raw URLs (also available as <em>API</em> calls) The number of names that New Relic tracks needs to be small enough so"
      },
      "id": "6043daa7196a67e488960f4f"
    }
  ],
  "/docs/agents/net-agent/attributes/custom-attributes-net": [
    {
      "sections": [
        ".NET agent attributes",
        "Contents",
        ".NET agent attribute defaults",
        "NewRelic.AddCustomParameter API call",
        "NewRelic.NoticeError API call",
        "response.status",
        "request.referer",
        "request.parameters.*",
        "service.request.*",
        "queue_wait_time_ms",
        "original_url",
        "Upgrade the .NET agent",
        "For more help"
      ],
      "title": ".NET agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Attributes"
      ],
      "external_id": "95f9157a67981978ebd96e2e77310b7a9d584083",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/attributes/net-agent-attributes/",
      "published_at": "2021-05-05T09:35:50Z",
      "updated_at": "2021-03-16T14:53:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. These key-value pairs can be viewed within transaction traces in APM, traced errors in APM, transaction events in dashboards, and page views in dashboards. You can customize exactly which attributes will be sent to each of these destinations. These attribute settings apply to version 3.6.177.0 or higher of the .NET agent. Contents .NET agent attribute defaults The following attributes can be configured in the .NET agent. For more information, see .NET agent configuration: Attributes element. NewRelic.AddCustomParameter API call Attributes added to an AddCustomParameter() call on the New Relic API. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Disabled NewRelic.NoticeError API call Attributes added to a NoticeError() call on the New Relic API. Defaults: Transaction traces: Unavailable Error collector (traced errors): Enabled Transaction events: Unavailable Page views (browser monitoring): Unavailable response.status The response status code for a web request. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Unavailable request.referer The optional request header referer. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Disabled Page views (browser monitoring): Unavailable request.parameters.* Request parameters from the transaction. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable The capture_params property has been deprecated. However, if set to true, it will enable request parameters for transaction traces and traced errors. service.request.* Request parameters from the WCF transaction. Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable queue_wait_time_ms Queue time for a web request. Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Disabled Page views (browser monitoring): Unavailable original_url Original URL from a web request. Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Disabled Page views (browser monitoring): Unavailable Upgrade the .NET agent When upgrading to .NET agent 3.6.177.0 or higher, upgrade your newrelic.config file. For more information about deprecated properties, see Enabling and disabling attributes. For more help Additional documentation resources include: Agent attributes (types, destinations, and limits for attributes used by New Relic agents) Enabling and disabling attributes (properties, rules, and backwards compatibility information for .NET agent attributes) .NET attribute examples (scenarios and results of enabling and disabling different .NET agent attributes) .NET agent configuration: Attributes element (configuring attributes)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 109.552124,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> <em>attributes</em>",
        "sections": ".<em>NET</em> <em>agent</em> <em>attributes</em>",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " help Additional documentation resources include: <em>Agent</em> <em>attributes</em> (types, destinations, and limits for <em>attributes</em> used by New Relic <em>agents</em>) Enabling and disabling <em>attributes</em> (properties, rules, and backwards compatibility information for .<em>NET</em> <em>agent</em> <em>attributes</em>) .<em>NET</em> attribute examples (scenarios and results of enabling and disabling different .<em>NET</em> <em>agent</em> <em>attributes</em>) .<em>NET</em> <em>agent</em> configuration: <em>Attributes</em> element (configuring <em>attributes</em>)"
      },
      "id": "603ec5e7e7b9d202792a07bc"
    },
    {
      "sections": [
        ".NET attribute examples",
        "Disable all attributes",
        "Select specific destinations",
        "Select values and destinations",
        "Emulating legacy server-side attribute behavior",
        "For more help"
      ],
      "title": ".NET attribute examples",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Attributes"
      ],
      "external_id": "717060b8027155bfe05e81079ac4e1c09511a72f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/attributes/net-attribute-examples/",
      "published_at": "2021-05-05T09:35:50Z",
      "updated_at": "2021-03-16T14:53:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are examples of using attributes with the New Relic .NET agent. Disable all attributes In this example, attributes are disabled. The include and exclude lists will be ignored, and all attributes will be filtered out. Configuration: <attributes enabled=\"false\" /> Copy Input keys: foo, bar, request.parameters.foo, request.parameters.bar Copy Output for destinations: transaction_tracer: none error_collector: none transaction_events: none browser_monitoring: none Copy Select specific destinations In this example: Attributes are disabled for transaction traces. The include and exclude lists will be ignored, and all attributes will be filtered out for this destination. Attributes are disabled for browser monitoring by default. Request parameters (prefixed with request.parameters.) are off by default for all destinations. As a result, only bar is sent in traced errors and transaction events. Configuration: <attributes enabled=\"true\"> <exclude>foo</exclude> </attributes> <transactionTracer> <attributes enabled=\"false\" /> </transactionTracer> Copy Input keys: foo, bar, request.parameters.foo, request.parameters.bar Copy Output for destinations: transaction_tracer: none error_collector: bar transaction_events: bar browser_monitoring: none Copy Select values and destinations In this example, specific input keys are selected for certain output destinations and excluded from others. The food.fruit.banana key will be excluded only from transaction traces. The food and food.bread keys will be excluded from all destinations. Configuration: <attributes enabled=\"true\"> <exclude>food*</exclude> <include>food.fruit.*</include> </attributes> <transactionTracer> <attributes enabled=\"true\"> <exclude>food.fruit.banana</exclude> </attributes> </transactionTracer> Copy Input keys: food, food.bread, food.fruit.banana, food.fruit.apple Copy Output for destinations: transaction_tracer: food.fruit.apple error_collector: food.fruit.banana, food.fruit.apple transaction_events: food.fruit.banana, food.fruit.apple browser_monitoring: food.fruit.banana, food.fruit.apple Copy Emulating legacy server-side attribute behavior In this example, the agent collects request parameters and records them to the transaction tracer and error collector destinations. This emulates enabling the legacy server-side configuration settings for Capture attributes or Capture parameters options. Customize the following <attributes> elements in your .NET agent configuration file: <transactionTracer> <attributes> <include>request.parameters*</include> </attributes> </transactionTracer> <errorCollector> <attributes> <include>request.parameters*</include> </attributes> </errorCollector> Copy For more help Additional documentation resources include: Agent attributes (types, destinations, and limits for attributes used by New Relic agents) .NET agent attributes (.NET-specific attributes available in agent versions 3.6.177.0 and higher) Enabling and disabling attributes (properties, rules, and backwards compatibility information for .NET agent attributes)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 109.552124,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>attribute</em> examples",
        "sections": ".<em>NET</em> <em>attribute</em> examples",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " Additional documentation resources include: <em>Agent</em> <em>attributes</em> (types, destinations, and limits for <em>attributes</em> used by New Relic <em>agents</em>) .<em>NET</em> <em>agent</em> <em>attributes</em> (.<em>NET</em>-specific <em>attributes</em> available in <em>agent</em> versions 3.6.177.0 and higher) Enabling and disabling <em>attributes</em> (properties, rules, and backwards compatibility information for .<em>NET</em> <em>agent</em> <em>attributes</em>)"
      },
      "id": "603ed5f228ccbc660aeba76e"
    },
    {
      "sections": [
        "Enable and disable attributes (.NET)",
        "Attribute rules",
        "Root level takes precedence for enabled.",
        "Destination enabled takes precedence over include and exclude.",
        "Attribute is included if the destination is enabled.",
        "Exclude always supersedes include.",
        "Keys are case sensitive.",
        "Use an asterisk \\* for wildcards.",
        "Most specific setting for a key takes priority.",
        "Include or exclude affects the specific destination.",
        "Deprecated properties",
        "analyticsEvents replaced by transactionEvents",
        "requestParameters replaced by request.parameters.*",
        "parameterGroups: enable and ignore replaced by attributes true, include and exclude",
        "captureAttributes flag replaced by attributes sub-elements"
      ],
      "title": "Enable and disable attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Attributes"
      ],
      "external_id": "71d8c3a6ad5df2a487ce2fe102de9ec875f1901d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/attributes/enable-disable-attributes-net/",
      "published_at": "2021-05-05T09:35:51Z",
      "updated_at": "2021-03-16T14:53:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This describes the rules New Relic uses to determine which attributes to include or exclude for a destination. This also includes a summary of the .NET agent properties that were deprecated with the release of New Relic agent attributes in versions 3.6.177.0 or higher. Attribute rules New Relic follows these rules to determine which attributes to include or exclude: Root level takes precedence for enabled. The attributes.enabled field overrides all other settings. When false, no attributes will be reported to New Relic. Example configuration: <attributes enabled=\"false\"> <include>foo</include> <include>bar</include> </attributes> <transactionTracer enabled=\"true\"> <attributes enabled=\"true\"/> </transactionTracer> Copy Example output: Keys passed in: foo, bar, bat Keys included for all destinations: Keys excluded for all destinations: foo, bar, bat Copy Destination enabled takes precedence over include and exclude. The {destination}.attributes.enabled flags take precedence over include and exclude keys. Example configuration: <attributes enabled=\"true\"> <include>one</include> <include>two</include> </attributes> <transactionTracer enabled=\"true\"> <attributes enabled=\"false\"> <include>three</include> <include>four</include> </attributes> </transactionTracer> Copy Example output: Keys passed in: one, two, three, four Keys included for transaction traces: Keys excluded for transaction traces: one, two, three, four Copy Attribute is included if the destination is enabled. If a destination is enabled, all user attributes are sent to that destination by default. All user attributes default to true. However, by default, request attributes and message parameters are disabled for all destinations. Example configuration: <attributes enabled=\"true\"> <exclude>myAttKey</exclude> </attributes> Copy Example output: Keys passed in: foo, bar, myAttKey Keys included: foo, bar Keys excluded: myAttKey Copy Exclude always supersedes include. If the same key is listed in the include and exclude lists, then attributes with the specified key will be excluded. Example configuration: <attributes enabled=\"true\"> <include>foo</include> <include>myCustomAtt</include> <exclude>password</exclude> <exclude>myCustomAtt</exclude> </attributes> Copy Example output: Keys passed in: foo, myCustomAtt, password Keys included: foo Keys excluded: password, myCustomAtt Copy Keys are case sensitive. Keys are case sensitive. Example configuration: <attributes enabled=\"true\"> <exclude>password</exclude> <exclude>PaSsWoRd</exclude> </attributes> Copy Example output: Keys passed in: password, Password, PASSWORD, PaSsWoRd, PassWORD Keys included: Password, PASSWORD, PassWORD Keys excluded: password, PaSsWoRd Copy Use an asterisk \\* for wildcards. You can use an asterisk * at the end of a key as a wildcard. This will match all attributes with the same prefix. Example configuration: <attributes enabled=\"true\"> <include>custom*</include> <exclude>request.parameters.*</exclude> </attributes> Copy Example output: Keys passed in: custom, custom.key1, custom.key2, request.parameters., request.parameters.foo, request.parameters.bar Keys included: custom, custom.key1, custom.key2 Keys excluded: request.parameters., request.parameters.foo, request.parameters.bar Copy Most specific setting for a key takes priority. If multiple include or exclude attributes affect the same key, the most specific setting will have priority. Example configuration: <attributes enabled=\"true\"> <include>request.parameters.foo</include> <exclude>request.parameters.*</exclude> </attributes> Copy Example output: Keys passed in: request.parameters., request.parameters.foo, request.parameters.bar Keys included: request.parameters.foo Keys excluded: request.parameters., request.parameters.bar Copy Include or exclude affects the specific destination. If the attribute include or exclude is specified on a destination, then it only impacts that destination. Example configuration: <attributes enabled=\"true\"> <include>foo</include> </attributes> <transactionEvents enabled=\"true\"> <attributes enabled=”true”> <exclude>foo</exclude> </transactionEvents> Copy Example output: Keys passed in: foo Keys included for transaction events: Keys included for other destinations: foo Keys excluded for transaction events: foo Copy Deprecated properties The following properties have been deprecated. While attributes using these properties will continue to be collected accurately, New Relic recommends switching to the new attributes configuration for these properties when upgrading your .NET agent. analyticsEvents replaced by transactionEvents The analyticsEvents element in newrelic.config has been deprecated. Enable the transactionEvents element in newrelic.config: <transactionEvents enabled=\"true\"/> Copy requestParameters replaced by request.parameters.* By default, request parameters are not sent to New Relic. Add request.parameters.* to the attributes.include list to enable request parameter collection. <attributes> <include>request.parameters.*</include> </attributes> Copy parameterGroups: enable and ignore replaced by attributes true, include and exclude The parameterGroups value and its enabled and ignore settings are deprecated. By default, customParameters and responseHeaderParameters are instrumented, while serviceRequestParameters are not instrumented. To customize these settings: Use the enabled flag to enable instrumentation. Use include and exclude to toggle instrumentation for specific attributes. For example: <attributes enabled=\"true\"> <include>service.request.*</include> <exclude>response.headers.*</exclude> <exclude>myCustomApiKey.*</exclude> </attributes> Copy For more information on configuring attributes, see the attributes examples. captureAttributes flag replaced by attributes sub-elements The capture attributes flag on browserMonitoring, transactionTracer, transactionEvents, and errorCollector has been deprecated. Instead, use the attributes sub-element to configure attribute settings for each of these destinations. New property Example browserMonitoring <browserMonitoring enabled=\"true\"> <attributes enabled=\"false\"> <include>myKey.*</include> <exclude>myKey.foo</exclude> </attributes> </browserMonitoring> Copy transactionTracer <transactionTracer enabled=\"true\"> <attributes enabled=\"false\"> <include>myKey.*</include> <exclude>myKey.foo</exclude> </attributes> </transactionTracer> Copy transactionEvents <transactionEvents enabled=\"true\"> <attributes enabled=\"false\"> <include>myKey.*</include> <exclude>myKey.foo</exclude> </attributes> </transactionEvents> Copy errorCollector <errorCollector enabled=\"true\"> <attributes enabled=\"false\"> <include>myKey.*</include> <exclude>myKey.foo</exclude> </attributes> </errorCollector>> Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 109.55212,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Enable and disable <em>attributes</em> (.<em>NET</em>)",
        "sections": "Enable and disable <em>attributes</em> (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "This describes the rules New Relic uses to determine which <em>attributes</em> to include or exclude for a destination. This also includes a summary of the .<em>NET</em> <em>agent</em> properties that were deprecated with the release of New Relic <em>agent</em> <em>attributes</em> in versions 3.6.177.0 or higher. Attribute rules New Relic"
      },
      "id": "603ed634196a67b796a83d9f"
    }
  ],
  "/docs/agents/net-agent/attributes/enable-disable-attributes-net": [
    {
      "sections": [
        ".NET agent attributes",
        "Contents",
        ".NET agent attribute defaults",
        "NewRelic.AddCustomParameter API call",
        "NewRelic.NoticeError API call",
        "response.status",
        "request.referer",
        "request.parameters.*",
        "service.request.*",
        "queue_wait_time_ms",
        "original_url",
        "Upgrade the .NET agent",
        "For more help"
      ],
      "title": ".NET agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Attributes"
      ],
      "external_id": "95f9157a67981978ebd96e2e77310b7a9d584083",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/attributes/net-agent-attributes/",
      "published_at": "2021-05-05T09:35:50Z",
      "updated_at": "2021-03-16T14:53:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. These key-value pairs can be viewed within transaction traces in APM, traced errors in APM, transaction events in dashboards, and page views in dashboards. You can customize exactly which attributes will be sent to each of these destinations. These attribute settings apply to version 3.6.177.0 or higher of the .NET agent. Contents .NET agent attribute defaults The following attributes can be configured in the .NET agent. For more information, see .NET agent configuration: Attributes element. NewRelic.AddCustomParameter API call Attributes added to an AddCustomParameter() call on the New Relic API. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Disabled NewRelic.NoticeError API call Attributes added to a NoticeError() call on the New Relic API. Defaults: Transaction traces: Unavailable Error collector (traced errors): Enabled Transaction events: Unavailable Page views (browser monitoring): Unavailable response.status The response status code for a web request. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Unavailable request.referer The optional request header referer. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Disabled Page views (browser monitoring): Unavailable request.parameters.* Request parameters from the transaction. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable The capture_params property has been deprecated. However, if set to true, it will enable request parameters for transaction traces and traced errors. service.request.* Request parameters from the WCF transaction. Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable queue_wait_time_ms Queue time for a web request. Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Disabled Page views (browser monitoring): Unavailable original_url Original URL from a web request. Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Disabled Page views (browser monitoring): Unavailable Upgrade the .NET agent When upgrading to .NET agent 3.6.177.0 or higher, upgrade your newrelic.config file. For more information about deprecated properties, see Enabling and disabling attributes. For more help Additional documentation resources include: Agent attributes (types, destinations, and limits for attributes used by New Relic agents) Enabling and disabling attributes (properties, rules, and backwards compatibility information for .NET agent attributes) .NET attribute examples (scenarios and results of enabling and disabling different .NET agent attributes) .NET agent configuration: Attributes element (configuring attributes)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 109.552124,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> <em>attributes</em>",
        "sections": ".<em>NET</em> <em>agent</em> <em>attributes</em>",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " help Additional documentation resources include: <em>Agent</em> <em>attributes</em> (types, destinations, and limits for <em>attributes</em> used by New Relic <em>agents</em>) Enabling and disabling <em>attributes</em> (properties, rules, and backwards compatibility information for .<em>NET</em> <em>agent</em> <em>attributes</em>) .<em>NET</em> attribute examples (scenarios and results of enabling and disabling different .<em>NET</em> <em>agent</em> <em>attributes</em>) .<em>NET</em> <em>agent</em> configuration: <em>Attributes</em> element (configuring <em>attributes</em>)"
      },
      "id": "603ec5e7e7b9d202792a07bc"
    },
    {
      "sections": [
        ".NET attribute examples",
        "Disable all attributes",
        "Select specific destinations",
        "Select values and destinations",
        "Emulating legacy server-side attribute behavior",
        "For more help"
      ],
      "title": ".NET attribute examples",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Attributes"
      ],
      "external_id": "717060b8027155bfe05e81079ac4e1c09511a72f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/attributes/net-attribute-examples/",
      "published_at": "2021-05-05T09:35:50Z",
      "updated_at": "2021-03-16T14:53:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are examples of using attributes with the New Relic .NET agent. Disable all attributes In this example, attributes are disabled. The include and exclude lists will be ignored, and all attributes will be filtered out. Configuration: <attributes enabled=\"false\" /> Copy Input keys: foo, bar, request.parameters.foo, request.parameters.bar Copy Output for destinations: transaction_tracer: none error_collector: none transaction_events: none browser_monitoring: none Copy Select specific destinations In this example: Attributes are disabled for transaction traces. The include and exclude lists will be ignored, and all attributes will be filtered out for this destination. Attributes are disabled for browser monitoring by default. Request parameters (prefixed with request.parameters.) are off by default for all destinations. As a result, only bar is sent in traced errors and transaction events. Configuration: <attributes enabled=\"true\"> <exclude>foo</exclude> </attributes> <transactionTracer> <attributes enabled=\"false\" /> </transactionTracer> Copy Input keys: foo, bar, request.parameters.foo, request.parameters.bar Copy Output for destinations: transaction_tracer: none error_collector: bar transaction_events: bar browser_monitoring: none Copy Select values and destinations In this example, specific input keys are selected for certain output destinations and excluded from others. The food.fruit.banana key will be excluded only from transaction traces. The food and food.bread keys will be excluded from all destinations. Configuration: <attributes enabled=\"true\"> <exclude>food*</exclude> <include>food.fruit.*</include> </attributes> <transactionTracer> <attributes enabled=\"true\"> <exclude>food.fruit.banana</exclude> </attributes> </transactionTracer> Copy Input keys: food, food.bread, food.fruit.banana, food.fruit.apple Copy Output for destinations: transaction_tracer: food.fruit.apple error_collector: food.fruit.banana, food.fruit.apple transaction_events: food.fruit.banana, food.fruit.apple browser_monitoring: food.fruit.banana, food.fruit.apple Copy Emulating legacy server-side attribute behavior In this example, the agent collects request parameters and records them to the transaction tracer and error collector destinations. This emulates enabling the legacy server-side configuration settings for Capture attributes or Capture parameters options. Customize the following <attributes> elements in your .NET agent configuration file: <transactionTracer> <attributes> <include>request.parameters*</include> </attributes> </transactionTracer> <errorCollector> <attributes> <include>request.parameters*</include> </attributes> </errorCollector> Copy For more help Additional documentation resources include: Agent attributes (types, destinations, and limits for attributes used by New Relic agents) .NET agent attributes (.NET-specific attributes available in agent versions 3.6.177.0 and higher) Enabling and disabling attributes (properties, rules, and backwards compatibility information for .NET agent attributes)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 109.552124,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>attribute</em> examples",
        "sections": ".<em>NET</em> <em>attribute</em> examples",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " Additional documentation resources include: <em>Agent</em> <em>attributes</em> (types, destinations, and limits for <em>attributes</em> used by New Relic <em>agents</em>) .<em>NET</em> <em>agent</em> <em>attributes</em> (.<em>NET</em>-specific <em>attributes</em> available in <em>agent</em> versions 3.6.177.0 and higher) Enabling and disabling <em>attributes</em> (properties, rules, and backwards compatibility information for .<em>NET</em> <em>agent</em> <em>attributes</em>)"
      },
      "id": "603ed5f228ccbc660aeba76e"
    },
    {
      "sections": [
        "Custom attributes (.NET)"
      ],
      "title": "Custom attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Attributes"
      ],
      "external_id": "491bfa6b3b5646899f6b0fbf541e1e6172593219",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/attributes/custom-attributes-net/",
      "published_at": "2021-05-05T09:35:51Z",
      "updated_at": "2021-03-13T02:09:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When adding custom attribute values to transactions, custom events, spans, and errors, the APIs accept an object. This describes how these values are processed and how they will appear in APM. In all cases, NULL values are not recorded. .NET type How the value will be represented byte, Int16, Int32, Int64 sbyte, UInt16, UInt32, UInt64 As an integral value float, double, decimal A decimal-based number string A string truncated after 255-bytes. Empty strings are supported. bool True or false DateTime A string representation following the ISO-8601 format, including time zone information: 2020-02-13T11:31:19.5767650-08:00 TimeSpan A decimal-based number representing number of seconds. everything else the ToString() method will be applied.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 108.600136,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Custom <em>attributes</em> (.<em>NET</em>)",
        "sections": "Custom <em>attributes</em> (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "When adding custom attribute values to transactions, custom events, spans, and errors, the APIs accept an object. This describes how these values are processed and how they will appear in APM. In all cases, NULL values are not recorded. .<em>NET</em> type How the value will be represented byte, Int16, Int32"
      },
      "id": "60441bcf196a670a80960f3a"
    }
  ],
  "/docs/agents/net-agent/attributes/net-agent-attributes": [
    {
      "sections": [
        ".NET attribute examples",
        "Disable all attributes",
        "Select specific destinations",
        "Select values and destinations",
        "Emulating legacy server-side attribute behavior",
        "For more help"
      ],
      "title": ".NET attribute examples",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Attributes"
      ],
      "external_id": "717060b8027155bfe05e81079ac4e1c09511a72f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/attributes/net-attribute-examples/",
      "published_at": "2021-05-05T09:35:50Z",
      "updated_at": "2021-03-16T14:53:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are examples of using attributes with the New Relic .NET agent. Disable all attributes In this example, attributes are disabled. The include and exclude lists will be ignored, and all attributes will be filtered out. Configuration: <attributes enabled=\"false\" /> Copy Input keys: foo, bar, request.parameters.foo, request.parameters.bar Copy Output for destinations: transaction_tracer: none error_collector: none transaction_events: none browser_monitoring: none Copy Select specific destinations In this example: Attributes are disabled for transaction traces. The include and exclude lists will be ignored, and all attributes will be filtered out for this destination. Attributes are disabled for browser monitoring by default. Request parameters (prefixed with request.parameters.) are off by default for all destinations. As a result, only bar is sent in traced errors and transaction events. Configuration: <attributes enabled=\"true\"> <exclude>foo</exclude> </attributes> <transactionTracer> <attributes enabled=\"false\" /> </transactionTracer> Copy Input keys: foo, bar, request.parameters.foo, request.parameters.bar Copy Output for destinations: transaction_tracer: none error_collector: bar transaction_events: bar browser_monitoring: none Copy Select values and destinations In this example, specific input keys are selected for certain output destinations and excluded from others. The food.fruit.banana key will be excluded only from transaction traces. The food and food.bread keys will be excluded from all destinations. Configuration: <attributes enabled=\"true\"> <exclude>food*</exclude> <include>food.fruit.*</include> </attributes> <transactionTracer> <attributes enabled=\"true\"> <exclude>food.fruit.banana</exclude> </attributes> </transactionTracer> Copy Input keys: food, food.bread, food.fruit.banana, food.fruit.apple Copy Output for destinations: transaction_tracer: food.fruit.apple error_collector: food.fruit.banana, food.fruit.apple transaction_events: food.fruit.banana, food.fruit.apple browser_monitoring: food.fruit.banana, food.fruit.apple Copy Emulating legacy server-side attribute behavior In this example, the agent collects request parameters and records them to the transaction tracer and error collector destinations. This emulates enabling the legacy server-side configuration settings for Capture attributes or Capture parameters options. Customize the following <attributes> elements in your .NET agent configuration file: <transactionTracer> <attributes> <include>request.parameters*</include> </attributes> </transactionTracer> <errorCollector> <attributes> <include>request.parameters*</include> </attributes> </errorCollector> Copy For more help Additional documentation resources include: Agent attributes (types, destinations, and limits for attributes used by New Relic agents) .NET agent attributes (.NET-specific attributes available in agent versions 3.6.177.0 and higher) Enabling and disabling attributes (properties, rules, and backwards compatibility information for .NET agent attributes)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 109.55212,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>attribute</em> examples",
        "sections": ".<em>NET</em> <em>attribute</em> examples",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " Additional documentation resources include: <em>Agent</em> <em>attributes</em> (types, destinations, and limits for <em>attributes</em> used by New Relic <em>agents</em>) .<em>NET</em> <em>agent</em> <em>attributes</em> (.<em>NET</em>-specific <em>attributes</em> available in <em>agent</em> versions 3.6.177.0 and higher) Enabling and disabling <em>attributes</em> (properties, rules, and backwards compatibility information for .<em>NET</em> <em>agent</em> <em>attributes</em>)"
      },
      "id": "603ed5f228ccbc660aeba76e"
    },
    {
      "sections": [
        "Enable and disable attributes (.NET)",
        "Attribute rules",
        "Root level takes precedence for enabled.",
        "Destination enabled takes precedence over include and exclude.",
        "Attribute is included if the destination is enabled.",
        "Exclude always supersedes include.",
        "Keys are case sensitive.",
        "Use an asterisk \\* for wildcards.",
        "Most specific setting for a key takes priority.",
        "Include or exclude affects the specific destination.",
        "Deprecated properties",
        "analyticsEvents replaced by transactionEvents",
        "requestParameters replaced by request.parameters.*",
        "parameterGroups: enable and ignore replaced by attributes true, include and exclude",
        "captureAttributes flag replaced by attributes sub-elements"
      ],
      "title": "Enable and disable attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Attributes"
      ],
      "external_id": "71d8c3a6ad5df2a487ce2fe102de9ec875f1901d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/attributes/enable-disable-attributes-net/",
      "published_at": "2021-05-05T09:35:51Z",
      "updated_at": "2021-03-16T14:53:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This describes the rules New Relic uses to determine which attributes to include or exclude for a destination. This also includes a summary of the .NET agent properties that were deprecated with the release of New Relic agent attributes in versions 3.6.177.0 or higher. Attribute rules New Relic follows these rules to determine which attributes to include or exclude: Root level takes precedence for enabled. The attributes.enabled field overrides all other settings. When false, no attributes will be reported to New Relic. Example configuration: <attributes enabled=\"false\"> <include>foo</include> <include>bar</include> </attributes> <transactionTracer enabled=\"true\"> <attributes enabled=\"true\"/> </transactionTracer> Copy Example output: Keys passed in: foo, bar, bat Keys included for all destinations: Keys excluded for all destinations: foo, bar, bat Copy Destination enabled takes precedence over include and exclude. The {destination}.attributes.enabled flags take precedence over include and exclude keys. Example configuration: <attributes enabled=\"true\"> <include>one</include> <include>two</include> </attributes> <transactionTracer enabled=\"true\"> <attributes enabled=\"false\"> <include>three</include> <include>four</include> </attributes> </transactionTracer> Copy Example output: Keys passed in: one, two, three, four Keys included for transaction traces: Keys excluded for transaction traces: one, two, three, four Copy Attribute is included if the destination is enabled. If a destination is enabled, all user attributes are sent to that destination by default. All user attributes default to true. However, by default, request attributes and message parameters are disabled for all destinations. Example configuration: <attributes enabled=\"true\"> <exclude>myAttKey</exclude> </attributes> Copy Example output: Keys passed in: foo, bar, myAttKey Keys included: foo, bar Keys excluded: myAttKey Copy Exclude always supersedes include. If the same key is listed in the include and exclude lists, then attributes with the specified key will be excluded. Example configuration: <attributes enabled=\"true\"> <include>foo</include> <include>myCustomAtt</include> <exclude>password</exclude> <exclude>myCustomAtt</exclude> </attributes> Copy Example output: Keys passed in: foo, myCustomAtt, password Keys included: foo Keys excluded: password, myCustomAtt Copy Keys are case sensitive. Keys are case sensitive. Example configuration: <attributes enabled=\"true\"> <exclude>password</exclude> <exclude>PaSsWoRd</exclude> </attributes> Copy Example output: Keys passed in: password, Password, PASSWORD, PaSsWoRd, PassWORD Keys included: Password, PASSWORD, PassWORD Keys excluded: password, PaSsWoRd Copy Use an asterisk \\* for wildcards. You can use an asterisk * at the end of a key as a wildcard. This will match all attributes with the same prefix. Example configuration: <attributes enabled=\"true\"> <include>custom*</include> <exclude>request.parameters.*</exclude> </attributes> Copy Example output: Keys passed in: custom, custom.key1, custom.key2, request.parameters., request.parameters.foo, request.parameters.bar Keys included: custom, custom.key1, custom.key2 Keys excluded: request.parameters., request.parameters.foo, request.parameters.bar Copy Most specific setting for a key takes priority. If multiple include or exclude attributes affect the same key, the most specific setting will have priority. Example configuration: <attributes enabled=\"true\"> <include>request.parameters.foo</include> <exclude>request.parameters.*</exclude> </attributes> Copy Example output: Keys passed in: request.parameters., request.parameters.foo, request.parameters.bar Keys included: request.parameters.foo Keys excluded: request.parameters., request.parameters.bar Copy Include or exclude affects the specific destination. If the attribute include or exclude is specified on a destination, then it only impacts that destination. Example configuration: <attributes enabled=\"true\"> <include>foo</include> </attributes> <transactionEvents enabled=\"true\"> <attributes enabled=”true”> <exclude>foo</exclude> </transactionEvents> Copy Example output: Keys passed in: foo Keys included for transaction events: Keys included for other destinations: foo Keys excluded for transaction events: foo Copy Deprecated properties The following properties have been deprecated. While attributes using these properties will continue to be collected accurately, New Relic recommends switching to the new attributes configuration for these properties when upgrading your .NET agent. analyticsEvents replaced by transactionEvents The analyticsEvents element in newrelic.config has been deprecated. Enable the transactionEvents element in newrelic.config: <transactionEvents enabled=\"true\"/> Copy requestParameters replaced by request.parameters.* By default, request parameters are not sent to New Relic. Add request.parameters.* to the attributes.include list to enable request parameter collection. <attributes> <include>request.parameters.*</include> </attributes> Copy parameterGroups: enable and ignore replaced by attributes true, include and exclude The parameterGroups value and its enabled and ignore settings are deprecated. By default, customParameters and responseHeaderParameters are instrumented, while serviceRequestParameters are not instrumented. To customize these settings: Use the enabled flag to enable instrumentation. Use include and exclude to toggle instrumentation for specific attributes. For example: <attributes enabled=\"true\"> <include>service.request.*</include> <exclude>response.headers.*</exclude> <exclude>myCustomApiKey.*</exclude> </attributes> Copy For more information on configuring attributes, see the attributes examples. captureAttributes flag replaced by attributes sub-elements The capture attributes flag on browserMonitoring, transactionTracer, transactionEvents, and errorCollector has been deprecated. Instead, use the attributes sub-element to configure attribute settings for each of these destinations. New property Example browserMonitoring <browserMonitoring enabled=\"true\"> <attributes enabled=\"false\"> <include>myKey.*</include> <exclude>myKey.foo</exclude> </attributes> </browserMonitoring> Copy transactionTracer <transactionTracer enabled=\"true\"> <attributes enabled=\"false\"> <include>myKey.*</include> <exclude>myKey.foo</exclude> </attributes> </transactionTracer> Copy transactionEvents <transactionEvents enabled=\"true\"> <attributes enabled=\"false\"> <include>myKey.*</include> <exclude>myKey.foo</exclude> </attributes> </transactionEvents> Copy errorCollector <errorCollector enabled=\"true\"> <attributes enabled=\"false\"> <include>myKey.*</include> <exclude>myKey.foo</exclude> </attributes> </errorCollector>> Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 109.55212,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Enable and disable <em>attributes</em> (.<em>NET</em>)",
        "sections": "Enable and disable <em>attributes</em> (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "This describes the rules New Relic uses to determine which <em>attributes</em> to include or exclude for a destination. This also includes a summary of the .<em>NET</em> <em>agent</em> properties that were deprecated with the release of New Relic <em>agent</em> <em>attributes</em> in versions 3.6.177.0 or higher. Attribute rules New Relic"
      },
      "id": "603ed634196a67b796a83d9f"
    },
    {
      "sections": [
        "Custom attributes (.NET)"
      ],
      "title": "Custom attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Attributes"
      ],
      "external_id": "491bfa6b3b5646899f6b0fbf541e1e6172593219",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/attributes/custom-attributes-net/",
      "published_at": "2021-05-05T09:35:51Z",
      "updated_at": "2021-03-13T02:09:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When adding custom attribute values to transactions, custom events, spans, and errors, the APIs accept an object. This describes how these values are processed and how they will appear in APM. In all cases, NULL values are not recorded. .NET type How the value will be represented byte, Int16, Int32, Int64 sbyte, UInt16, UInt32, UInt64 As an integral value float, double, decimal A decimal-based number string A string truncated after 255-bytes. Empty strings are supported. bool True or false DateTime A string representation following the ISO-8601 format, including time zone information: 2020-02-13T11:31:19.5767650-08:00 TimeSpan A decimal-based number representing number of seconds. everything else the ToString() method will be applied.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 108.60013,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Custom <em>attributes</em> (.<em>NET</em>)",
        "sections": "Custom <em>attributes</em> (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "When adding custom attribute values to transactions, custom events, spans, and errors, the APIs accept an object. This describes how these values are processed and how they will appear in APM. In all cases, NULL values are not recorded. .<em>NET</em> type How the value will be represented byte, Int16, Int32"
      },
      "id": "60441bcf196a670a80960f3a"
    }
  ],
  "/docs/agents/net-agent/attributes/net-attribute-examples": [
    {
      "sections": [
        ".NET agent attributes",
        "Contents",
        ".NET agent attribute defaults",
        "NewRelic.AddCustomParameter API call",
        "NewRelic.NoticeError API call",
        "response.status",
        "request.referer",
        "request.parameters.*",
        "service.request.*",
        "queue_wait_time_ms",
        "original_url",
        "Upgrade the .NET agent",
        "For more help"
      ],
      "title": ".NET agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Attributes"
      ],
      "external_id": "95f9157a67981978ebd96e2e77310b7a9d584083",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/attributes/net-agent-attributes/",
      "published_at": "2021-05-05T09:35:50Z",
      "updated_at": "2021-03-16T14:53:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. These key-value pairs can be viewed within transaction traces in APM, traced errors in APM, transaction events in dashboards, and page views in dashboards. You can customize exactly which attributes will be sent to each of these destinations. These attribute settings apply to version 3.6.177.0 or higher of the .NET agent. Contents .NET agent attribute defaults The following attributes can be configured in the .NET agent. For more information, see .NET agent configuration: Attributes element. NewRelic.AddCustomParameter API call Attributes added to an AddCustomParameter() call on the New Relic API. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Disabled NewRelic.NoticeError API call Attributes added to a NoticeError() call on the New Relic API. Defaults: Transaction traces: Unavailable Error collector (traced errors): Enabled Transaction events: Unavailable Page views (browser monitoring): Unavailable response.status The response status code for a web request. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Unavailable request.referer The optional request header referer. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Disabled Page views (browser monitoring): Unavailable request.parameters.* Request parameters from the transaction. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable The capture_params property has been deprecated. However, if set to true, it will enable request parameters for transaction traces and traced errors. service.request.* Request parameters from the WCF transaction. Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable queue_wait_time_ms Queue time for a web request. Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Disabled Page views (browser monitoring): Unavailable original_url Original URL from a web request. Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Disabled Page views (browser monitoring): Unavailable Upgrade the .NET agent When upgrading to .NET agent 3.6.177.0 or higher, upgrade your newrelic.config file. For more information about deprecated properties, see Enabling and disabling attributes. For more help Additional documentation resources include: Agent attributes (types, destinations, and limits for attributes used by New Relic agents) Enabling and disabling attributes (properties, rules, and backwards compatibility information for .NET agent attributes) .NET attribute examples (scenarios and results of enabling and disabling different .NET agent attributes) .NET agent configuration: Attributes element (configuring attributes)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 109.55212,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> <em>attributes</em>",
        "sections": ".<em>NET</em> <em>agent</em> <em>attributes</em>",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " help Additional documentation resources include: <em>Agent</em> <em>attributes</em> (types, destinations, and limits for <em>attributes</em> used by New Relic <em>agents</em>) Enabling and disabling <em>attributes</em> (properties, rules, and backwards compatibility information for .<em>NET</em> <em>agent</em> <em>attributes</em>) .<em>NET</em> attribute examples (scenarios and results of enabling and disabling different .<em>NET</em> <em>agent</em> <em>attributes</em>) .<em>NET</em> <em>agent</em> configuration: <em>Attributes</em> element (configuring <em>attributes</em>)"
      },
      "id": "603ec5e7e7b9d202792a07bc"
    },
    {
      "sections": [
        "Enable and disable attributes (.NET)",
        "Attribute rules",
        "Root level takes precedence for enabled.",
        "Destination enabled takes precedence over include and exclude.",
        "Attribute is included if the destination is enabled.",
        "Exclude always supersedes include.",
        "Keys are case sensitive.",
        "Use an asterisk \\* for wildcards.",
        "Most specific setting for a key takes priority.",
        "Include or exclude affects the specific destination.",
        "Deprecated properties",
        "analyticsEvents replaced by transactionEvents",
        "requestParameters replaced by request.parameters.*",
        "parameterGroups: enable and ignore replaced by attributes true, include and exclude",
        "captureAttributes flag replaced by attributes sub-elements"
      ],
      "title": "Enable and disable attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Attributes"
      ],
      "external_id": "71d8c3a6ad5df2a487ce2fe102de9ec875f1901d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/attributes/enable-disable-attributes-net/",
      "published_at": "2021-05-05T09:35:51Z",
      "updated_at": "2021-03-16T14:53:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This describes the rules New Relic uses to determine which attributes to include or exclude for a destination. This also includes a summary of the .NET agent properties that were deprecated with the release of New Relic agent attributes in versions 3.6.177.0 or higher. Attribute rules New Relic follows these rules to determine which attributes to include or exclude: Root level takes precedence for enabled. The attributes.enabled field overrides all other settings. When false, no attributes will be reported to New Relic. Example configuration: <attributes enabled=\"false\"> <include>foo</include> <include>bar</include> </attributes> <transactionTracer enabled=\"true\"> <attributes enabled=\"true\"/> </transactionTracer> Copy Example output: Keys passed in: foo, bar, bat Keys included for all destinations: Keys excluded for all destinations: foo, bar, bat Copy Destination enabled takes precedence over include and exclude. The {destination}.attributes.enabled flags take precedence over include and exclude keys. Example configuration: <attributes enabled=\"true\"> <include>one</include> <include>two</include> </attributes> <transactionTracer enabled=\"true\"> <attributes enabled=\"false\"> <include>three</include> <include>four</include> </attributes> </transactionTracer> Copy Example output: Keys passed in: one, two, three, four Keys included for transaction traces: Keys excluded for transaction traces: one, two, three, four Copy Attribute is included if the destination is enabled. If a destination is enabled, all user attributes are sent to that destination by default. All user attributes default to true. However, by default, request attributes and message parameters are disabled for all destinations. Example configuration: <attributes enabled=\"true\"> <exclude>myAttKey</exclude> </attributes> Copy Example output: Keys passed in: foo, bar, myAttKey Keys included: foo, bar Keys excluded: myAttKey Copy Exclude always supersedes include. If the same key is listed in the include and exclude lists, then attributes with the specified key will be excluded. Example configuration: <attributes enabled=\"true\"> <include>foo</include> <include>myCustomAtt</include> <exclude>password</exclude> <exclude>myCustomAtt</exclude> </attributes> Copy Example output: Keys passed in: foo, myCustomAtt, password Keys included: foo Keys excluded: password, myCustomAtt Copy Keys are case sensitive. Keys are case sensitive. Example configuration: <attributes enabled=\"true\"> <exclude>password</exclude> <exclude>PaSsWoRd</exclude> </attributes> Copy Example output: Keys passed in: password, Password, PASSWORD, PaSsWoRd, PassWORD Keys included: Password, PASSWORD, PassWORD Keys excluded: password, PaSsWoRd Copy Use an asterisk \\* for wildcards. You can use an asterisk * at the end of a key as a wildcard. This will match all attributes with the same prefix. Example configuration: <attributes enabled=\"true\"> <include>custom*</include> <exclude>request.parameters.*</exclude> </attributes> Copy Example output: Keys passed in: custom, custom.key1, custom.key2, request.parameters., request.parameters.foo, request.parameters.bar Keys included: custom, custom.key1, custom.key2 Keys excluded: request.parameters., request.parameters.foo, request.parameters.bar Copy Most specific setting for a key takes priority. If multiple include or exclude attributes affect the same key, the most specific setting will have priority. Example configuration: <attributes enabled=\"true\"> <include>request.parameters.foo</include> <exclude>request.parameters.*</exclude> </attributes> Copy Example output: Keys passed in: request.parameters., request.parameters.foo, request.parameters.bar Keys included: request.parameters.foo Keys excluded: request.parameters., request.parameters.bar Copy Include or exclude affects the specific destination. If the attribute include or exclude is specified on a destination, then it only impacts that destination. Example configuration: <attributes enabled=\"true\"> <include>foo</include> </attributes> <transactionEvents enabled=\"true\"> <attributes enabled=”true”> <exclude>foo</exclude> </transactionEvents> Copy Example output: Keys passed in: foo Keys included for transaction events: Keys included for other destinations: foo Keys excluded for transaction events: foo Copy Deprecated properties The following properties have been deprecated. While attributes using these properties will continue to be collected accurately, New Relic recommends switching to the new attributes configuration for these properties when upgrading your .NET agent. analyticsEvents replaced by transactionEvents The analyticsEvents element in newrelic.config has been deprecated. Enable the transactionEvents element in newrelic.config: <transactionEvents enabled=\"true\"/> Copy requestParameters replaced by request.parameters.* By default, request parameters are not sent to New Relic. Add request.parameters.* to the attributes.include list to enable request parameter collection. <attributes> <include>request.parameters.*</include> </attributes> Copy parameterGroups: enable and ignore replaced by attributes true, include and exclude The parameterGroups value and its enabled and ignore settings are deprecated. By default, customParameters and responseHeaderParameters are instrumented, while serviceRequestParameters are not instrumented. To customize these settings: Use the enabled flag to enable instrumentation. Use include and exclude to toggle instrumentation for specific attributes. For example: <attributes enabled=\"true\"> <include>service.request.*</include> <exclude>response.headers.*</exclude> <exclude>myCustomApiKey.*</exclude> </attributes> Copy For more information on configuring attributes, see the attributes examples. captureAttributes flag replaced by attributes sub-elements The capture attributes flag on browserMonitoring, transactionTracer, transactionEvents, and errorCollector has been deprecated. Instead, use the attributes sub-element to configure attribute settings for each of these destinations. New property Example browserMonitoring <browserMonitoring enabled=\"true\"> <attributes enabled=\"false\"> <include>myKey.*</include> <exclude>myKey.foo</exclude> </attributes> </browserMonitoring> Copy transactionTracer <transactionTracer enabled=\"true\"> <attributes enabled=\"false\"> <include>myKey.*</include> <exclude>myKey.foo</exclude> </attributes> </transactionTracer> Copy transactionEvents <transactionEvents enabled=\"true\"> <attributes enabled=\"false\"> <include>myKey.*</include> <exclude>myKey.foo</exclude> </attributes> </transactionEvents> Copy errorCollector <errorCollector enabled=\"true\"> <attributes enabled=\"false\"> <include>myKey.*</include> <exclude>myKey.foo</exclude> </attributes> </errorCollector>> Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 109.55212,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Enable and disable <em>attributes</em> (.<em>NET</em>)",
        "sections": "Enable and disable <em>attributes</em> (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "This describes the rules New Relic uses to determine which <em>attributes</em> to include or exclude for a destination. This also includes a summary of the .<em>NET</em> <em>agent</em> properties that were deprecated with the release of New Relic <em>agent</em> <em>attributes</em> in versions 3.6.177.0 or higher. Attribute rules New Relic"
      },
      "id": "603ed634196a67b796a83d9f"
    },
    {
      "sections": [
        "Custom attributes (.NET)"
      ],
      "title": "Custom attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Attributes"
      ],
      "external_id": "491bfa6b3b5646899f6b0fbf541e1e6172593219",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/attributes/custom-attributes-net/",
      "published_at": "2021-05-05T09:35:51Z",
      "updated_at": "2021-03-13T02:09:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When adding custom attribute values to transactions, custom events, spans, and errors, the APIs accept an object. This describes how these values are processed and how they will appear in APM. In all cases, NULL values are not recorded. .NET type How the value will be represented byte, Int16, Int32, Int64 sbyte, UInt16, UInt32, UInt64 As an integral value float, double, decimal A decimal-based number string A string truncated after 255-bytes. Empty strings are supported. bool True or false DateTime A string representation following the ISO-8601 format, including time zone information: 2020-02-13T11:31:19.5767650-08:00 TimeSpan A decimal-based number representing number of seconds. everything else the ToString() method will be applied.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 108.60013,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Custom <em>attributes</em> (.<em>NET</em>)",
        "sections": "Custom <em>attributes</em> (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "When adding custom attribute values to transactions, custom events, spans, and errors, the APIs accept an object. This describes how these values are processed and how they will appear in APM. In all cases, NULL values are not recorded. .<em>NET</em> type How the value will be represented byte, Int16, Int32"
      },
      "id": "60441bcf196a670a80960f3a"
    }
  ],
  "/docs/agents/net-agent/azure-installation/install-azure-marketplace-app-new-relic": [
    {
      "sections": [
        "Install the .NET agent on Azure Cloud Services",
        "Important",
        "Check Web or Worker role's location",
        "Install the NuGet package for Cloud Services",
        "Instrument Worker role",
        "Custom instrumentation example for Worker role",
        "Custom instrumentation file deployment",
        "Optional: Create custom config file",
        "View your app's performance"
      ],
      "title": "Install the .NET agent on Azure Cloud Services",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure installation"
      ],
      "external_id": "afe3e181b9ec18fa0b2be3e76f7c9b20d247d21e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-installation/install-net-agent-azure-cloud-services/",
      "published_at": "2021-05-05T09:26:09Z",
      "updated_at": "2021-03-16T14:55:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install APM's .NET agent on Microsoft's Azure Cloud Services platform. This is not the same as installing the Infrastructure integrations for Microsoft Azure. To make sure you are using the most relevant instructions, first see the .NET agent install overview. Important Before installing the NuGet package into a multi-project Visual Studio solution, make sure you have selected the correct project for your New Relic .NET application (for example, a specific website project). Check Web or Worker role's location If Service files are nested within a Solution folder, the NuGet installer cannot locate or update the necessary files. This will cause issues with the .NET agent setup, which will in turn prevent the agent from reporting metrics on your Cloud Service. Recommendation: Place the Web or Worker role at the root of the solution before installing the NuGet package. Once the New Relic .NET agent is installed, you can move the Cloud role back into the Solution folder. Install the NuGet package for Cloud Services Important The NuGet packages in this procedure support only the old packages.config. They do not support the new PackageReference format. For more information see Microsoft's package reference documentation For multi-project solutions, make sure you have selected the correct project (for example, a specific website project) before installing the NuGet package. Open your Visual Studio solution, or create a new one by selecting File > New > Project. For multi-project solutions, make sure you have selected the correct project (for example, a specific website project). If you do not already have an Azure Cloud Service project in your solution, add one by right-clicking your app in the Solution Explorer and selecting Add Windows Azure Cloud Service Project. Open the Package Manager console by selecting Tools > Library Package Manager > Package Manager Console. Set your project as the default project. From the Package Manager command prompt, type Install-Package NewRelicWindowsAzure and press Enter. Follow the prompts to enter your New Relic license key and your application name as you want it to appear in the New Relic UI. Or, use your solution name as the default app name. From the Solution Explorer, right-click your Azure Cloud Service project, and select Publish. If this is your first time deploying this app to Azure, enter your Azure credentials. If applicable, instrument methods for Worker roles. Instrument Worker role A Worker role is a non-web process run as an Azure Cloud Service. To instrument a Worker role, you must create custom transactions. The .NET agent automatically instruments external calls and database calls, but it does not instrument default methods for transactions. Creating custom transactions solves this. After the Worker role starts up and the method executes, transaction data will appear in the APM Summary and Transactions pages under the Non-web category. The NuGet installer automatically adds the NewRelic.AppName parameter to the application config. This appears as <YOUR_WORKER_ROLE_NAME>.dll.config in E:\\approot. The .NET agent also automatically instruments WaWorkerHost.exe. This is the name of the actual Worker role process. Custom instrumentation example for Worker role This is a custom instrumentation example for a Worker role. It creates a custom transaction named ProcessMessage. The transaction begins when the ProcessMessage method is entered, and it ends when the method returns. The following example uses MyWorkerRole as the namespace. If you do not specify a name, it will default to the Solution name. namespace MyWorkerRole { public class NotificationQueue { public bool ProcessMessage(Message message) { // code to process message } } } Copy Here is the custom instrumentation file for the code: <?xml version=\"1.0\" encoding=\"utf-8\"?> <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerfactory name=\"NewRelic.Agent.Core.Tracer.Factories.BackgroundThreadTracerFactory\" metricName=\"Custom/ProcessMessage\"> <match assemblyname=\"MyWorkerRole\" classname=\"MyWorkerRole.NotificationQueue\"> <exactmethodmatcher methodName=\"ProcessMessage\" /> </match> </tracerfactory> </instrumentation> </extension> Copy On a local installation, place this instrumentation file in C:\\ProgramData\\New Relic\\.NET Agent\\Extensions. Custom instrumentation file deployment Optional: To send the custom instrumentation file up with an Azure Cloud Service deployment: In your Azure Cloud project, add the instrumentation file to your Worker role inside the Roles folder. After installing the New Relic .NET agent NuGet package, locate newrelic.cmd in your Worker Role project. Find the statement IF %ERRORLEVEL% EQU 0 within the :INSTALL_NEWRELIC_AGENT block, and add the following statement to the conditional: IF %ERRORLEVEL% EQU 0 ( copy /Y \"%RoleRoot%\\approot\\MyInstrumentation.xml\" \"%NR_HOME%\\extensions\" >> %RoleRoot%\\nr.log ) ELSE ( Copy In this example, the newrelic.cmd batch file copies the custom instrumentation file to the Extensions folder in D:\\ProgramData\\New Relic\\.NET Agent\\, or %NR_HOME%. This example uses MyInstrumentation.xml, but any name will work as long as the file name and copy command match, and the file is valid XML. Optional: Create custom config file You can create a custom configuration file in Visual Studio. This allows you to make changes to newrelic.config inside Visual Studio, without having to remote into your Azure Role instance every time you make a change. Whenever you publish your app, the config file in Visual Studio is automatically uploaded to the remote host. The choices you make with the installation wizard do not matter. Installing locally does not affect your Azure development environment. In Visual Studio, select the Solution Explorer, then open NewRelicAgent_x64_XYZ.msi. Follow the steps to install the agent locally. Import newrelic.config into your project: In Solution Explorer > Cloud Project, right-click the Web Role, then select Add > Existing Item. Navigate to C: \\ ProgramData \\ New Relic \\ .NET Agent and select newrelic.config. From C: \\ ProgramData \\ New Relic \\ .NET Agent, edit newrelic.cmd. In the :INSTALL_NEWRELIC_AGENT section, find this statement: IF $ERRORLEVEL% EQU 0 ( Copy Add the following code as another statement inside the IF block, then save the file: copy /Y \"%RoleRoot%\\approot\\newrelic.config\" \"%NR_HOME%\" >> %RoleRoot%\\nr.log Copy You can now edit the newrelic.config hosted in Visual Studio. Whenever you publish your app, the copy command will upload the config file to the remote host. View your app's performance Your application must receive traffic in order for you to view its performance in New Relic. You may need to wait a few minutes for data to start appearing. If no data appears, see the troubleshooting procedures for Azure Cloud Services. To view your app's performance in APM: Go to one.newrelic.com > APM > (select an app). The APM Summary page automatically appears. You can also view detailed information about errors, database and instance performance issues, and more. If you created your New Relic app prior to October 2017, you can use the Azure Portal to select the New Relic account blade. You will be automatically logged in with SAML Single Sign-on (SSO) to APM. You can also view your application's error rate and throughput data in the Azure Portal by going to New Relic Accounts > choose your application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.69709,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> the .<em>NET</em> <em>agent</em> on <em>Azure</em> Cloud Services",
        "sections": "<em>Install</em> the .<em>NET</em> <em>agent</em> on <em>Azure</em> Cloud Services",
        "tags": "<em>Azure</em> <em>installation</em>",
        "body": "&gt; &lt;&#x2F;tracerfactory&gt; &lt;&#x2F;instrumentation&gt; &lt;&#x2F;extension&gt; Copy On a local <em>installation</em>, place this instrumentation file in C:\\ProgramData\\New Relic\\.<em>NET</em> <em>Agent</em>\\Extensions. Custom instrumentation file deployment Optional: To send the custom instrumentation file up with an <em>Azure</em> Cloud Service deployment: In your"
      },
      "id": "603e8e7ee7b9d2b4d42a07e3"
    },
    {
      "sections": [
        "Install the .NET agent on Azure Web Apps",
        "Installation options",
        "Tip",
        "Disable Application Insights",
        "Install using the New Relic Azure Site Extension",
        "Install using NuGet (.NET Framework)",
        "Install using NuGet (.NET Core)",
        "Log file configuration for Windows",
        "Log file configuration for Linux",
        "Environment variables for Windows",
        "Environment variables for Linux",
        "Add New Relic app settings to Azure App Services",
        "View your app's performance",
        "Troubleshooting"
      ],
      "title": "Install the .NET agent on Azure Web Apps",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure installation"
      ],
      "external_id": "5cb6afb3ad05fdc243d2cf110f4df1e7e027740d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-installation/install-net-agent-azure-web-apps/",
      "published_at": "2021-05-05T09:27:16Z",
      "updated_at": "2021-03-16T14:55:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install New Relic's .NET agent for application performance monitoring on your Azure Web App. (This is not the same as installing the infrastructure monitoring integrations for Microsoft Azure.) Recommendation: Before following these instructions, read the .NET agent installation overview. Installation options Tip To use .NET or any other agent, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Use any of the following methods to add the New Relic .NET agent to your Azure-deployed web app. The best option depends on your role, environment, deployments, etc. For example: For operations teams that need to monitor the app, best practice may be to: Install using the Azure Site Extension For developer teams, best practice may be to use NuGet: Install using NuGet (.NET Framework) Install using NuGet (.NET Core) In order to monitor non-web apps (including WebJobs), or ASP.NET Core apps targeting .NET Framework, you must explicitly enable the agent for that application's .exe process via one of these two methods: Enable via placement of local newrelic.config file. Enable via application config file In addition, WebJobs may need custom instrumentation for transactions to appear in APM, and additional configuration if they run for less than one minute. Disable Application Insights Both New Relic's .NET agent and Microsoft Application Insights rely on the CLR Profiler, but only one may be active at a time. You must disable Application Insights in order for the .NET agent to function properly. For more information, see our Application Insights troubleshooting procedures. Install using the New Relic Azure Site Extension To install the .NET agent for an Azure Web App using the New Relic Azure Site Extension: Shut down your web application before installing the New Relic Azure Site Extension. Add the site extension: Navigate to http://[yoursitename].scm.azurewebsites.net, then select Site extensions > Gallery. Select the plus icon next to the New Relic site extension. In the Azure portal, add New Relic app settings to your Azure App Service. Restart your web app to use the new version of the agent. Install using NuGet (.NET Framework) The NuGet packages in this procedure support only the old packages.config. They do not support the current PackageReference format. For more information, see Microsoft's package reference documentation. For multi-project solutions, make sure you have selected the correct project (for example, a specific web app project) before installing the NuGet package. If you are upgrading the .NET Framework agent using NuGet, any changes you made in the newrelic.config will be overwritten. To preserve any changes, save your newrelic.config outside of your project, then restore it after upgrading. To install the .NET agent on an Azure Web App using NuGet: In the Azure portal, verify your Azure Platform (32-bit or 64-bit): From the Azure sidebar menu, select App Services > Your Application > Settings > Configuration > General settings. Open your application in Visual Studio, and install the New Relic NuGet package by running the appropriate command from the Package manager console: 32-bit: Install-Package NewRelic.Azure.WebSites 64-bit: Install-Package NewRelic.Azure.WebSites.x64 Publish your application. In the Azure portal, open the web app you want to monitor, then select Settings > Configuration. From Configuration, select + New application setting and add these key/value pairs: Key Value COR_ENABLE_PROFILING 1 COR_PROFILER {71DA0A04-7777-4EC6-9643-7D28B46A8A41} COR_PROFILER_PATH D:\\Home\\site\\wwwroot\\newrelic\\NewRelic.Profiler.dll NEWRELIC_HOME D:\\Home\\site\\wwwroot\\newrelic In the Azure portal, add New Relic app settings to your Azure App Service. Restart your web app. Install using NuGet (.NET Core) New Relic .NET Core agent supports Linux and Windows applications on Azure App Services. The installation process for Azure App Services differs from the .NET Core agent installation procedures for Linux and Windows. To install the .NET agent on an Azure Web App using NuGet: Install the NewRelic.Agent NuGet package. Modify the log node by adding a directory attribute to your newrelic.config file: Log file configuration for Windows log directory=\"D:\\Home\\LogFiles\\NewRelic\" level=\"info\"/log Copy Log file configuration for Linux log directory=\"/home/LogFiles/NewRelic\" level=\"info\"/log Copy Publish your application. In the Azure portal, open the web app you want to monitor, then select Settings > Configuration. From Configuration, select + New application setting and add these key/value pairs: Environment variables for Windows Key Value CORECLR_ENABLE_PROFILING 1 CORECLR_PROFILER {36032161-FFC0-4B61-B559-F6C5D41BAE5A} CORECLR_PROFILER_PATH_32 D:\\Home\\site\\wwwroot\\newrelic\\x86\\NewRelic.Profiler.dll CORECLR_PROFILER_PATH_64 D:\\Home\\site\\wwwroot\\newrelic\\NewRelic.Profiler.dll CORECLR_NEWRELIC_HOME D:\\Home\\site\\wwwroot\\newrelic Environment variables for Linux Key Value CORECLR_ENABLE_PROFILING 1 CORECLR_PROFILER {36032161-FFC0-4B61-B559-F6C5D41BAE5A} CORECLR_PROFILER_PATH /home/site/wwwroot/newrelic/libNewRelicProfiler.so CORECLR_NEWRELIC_HOME /home/site/wwwroot/newrelic In the Azure portal, add New Relic app settings to your Azure App Service. Restart your web app. Add New Relic app settings to Azure App Services To add your app settings: Make sure you have your license key before adding the New Relic .NET agent's app settings. In the Azure portal, open the web app you want to monitor, then select Configuration > Application settings. From Application settings, select + New application setting and add these key/value pairs: Key Value NEW_RELIC_LICENSE_KEY YOUR_LICENSE_KEY NEW_RELIC_APP_NAME YOUR_APP_NAME Save and restart your web app. Setting the license key and app name with Application settings will override the newrelic.config. To verify your app's environment variables in your app's Kudu diagnostic console, go to Environment > Environment variables. For example: https://myappname.scm.azurewebsites.net/Env.cshtml#envVariables Copy View your app's performance Your application must receive traffic in order for you to view its performance in New Relic. You may need to wait a few minutes for data to start appearing. If no data appears, see the troubleshooting procedures for Azure Web Apps. To view your app's performance in New Relic: Go to one.newrelic.com > APM > (select an app). The APM Summary page automatically appears. You can also view detailed information about errors, database and instance performance issues, and more. If you created your New Relic app prior to October 2017, you can use the Azure portal to select the New Relic account blade. You will be automatically logged in with SAML Single Sign-on (SSO) to APM. You can also view your application's error rate and throughput data in the Azure portal by going to New Relic Accounts > (select your app). Troubleshooting If no data appears after installing the agent, generating traffic for your app, and waiting a few minutes, try these troubleshooting tips: Make sure that all files in the newrelic directory at the root of your app got published to Azure. Make sure the environment variables are set correctly. Make sure Microsoft Application Insights is not installed and configured on the application. For more information, see the Application Insights troubleshooting procedures. Refer to additional Azure troubleshooting procedures as applicable.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.37909,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> the .<em>NET</em> <em>agent</em> on <em>Azure</em> Web Apps",
        "sections": "<em>Install</em> the .<em>NET</em> <em>agent</em> on <em>Azure</em> Web Apps",
        "tags": "<em>Azure</em> <em>installation</em>",
        "body": ". Restart your web app. Install using NuGet (.<em>NET</em> Core) New Relic .<em>NET</em> Core <em>agent</em> supports Linux and Windows applications on <em>Azure</em> App Services. The <em>installation</em> process for <em>Azure</em> App Services differs from the .<em>NET</em> Core <em>agent</em> <em>installation</em> procedures for Linux and Windows. To install the .<em>NET</em> <em>agent</em>"
      },
      "id": "603e8e7c28ccbc420ceba748"
    },
    {
      "sections": [
        "Install .NET agent on Azure Service Fabric",
        "Important",
        "Install using NuGet",
        ".NET Framework",
        ".NET Core for Windows",
        ".NET Core for Linux"
      ],
      "title": "Install .NET agent on Azure Service Fabric",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure installation"
      ],
      "external_id": "c520de26567fd173a0ac7b19ac0044a5757862bb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-installation/install-net-agent-azure-service-fabric/",
      "published_at": "2021-05-05T09:26:09Z",
      "updated_at": "2021-03-13T02:21:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install APM's .NET Framework agent and .NET Core agent on Azure Service Fabric. This is not the same as installing the Infrastructure integrations for Microsoft Azure. Install .NET agent on Azure Service Fabric Important In most cases, installing the .NET agent in an Azure Service Fabric environment can be performed using the standard install procedures for either Windows or Linux. This document highlights some alternate ways you can install the agent. You will need to ensure the agent gets installed on all nodes in your cluster. To monitor multiple nodes, you may want to integrate the install into your deployment process. If you are using containers in your Service Fabric environment you should read Install for Docker. You can also install the agent in a Service Fabric environment using NuGet. NuGet is often a good option for developers because the agent gets deployed along with your application. Though, using NuGet requires some manual installation procedures. See Install with NuGet. Install using NuGet To install the .NET agent using NuGet: Follow the standard NuGet install procedures. When using NuGet, you must set some environment variables. This can be done in your application's ServiceManifest.xml file. See the relevant instructions below: .NET Framework In the ServiceManifest.xml file in your project, include the following under the CodePackage node: <CodePackage Name=\"Code\" Version=\"1.0.0\"> </CodePackage> <CodePackage> ... <EntryPoint> <ExeHost> ... <!-- It is important for the WorkingFolder to be set to CodePackage --> <!-- This is because the environment variables set below rely on this being the working folder for the agent to work --> <WorkingFolder>CodePackage</WorkingFolder> ... </ExeHost> </EntryPoint> ... <EnvironmentVariables> ... <EnvironmentVariable Name=\"COR_ENABLE_PROFILING\" Value=\"1\" /> <EnvironmentVariable Name=\"COR_PROFILER\" Value=\"{71DA0A04-7777-4EC6-9643-7D28B46A8A41}\" /> <EnvironmentVariable Name=\"COR_PROFILER_PATH\" Value=\".\\newrelic\\NewRelic.Profiler.dll\" /> <EnvironmentVariable Name=\"NEWRELIC_HOME\" Value=\".\\newrelic\" /> <EnvironmentVariable Name=\"NEW_RELIC_LICENSE_KEY\" Value=\"YOUR_LICENSE_KEY\" /> <EnvironmentVariable Name=\"NEW_RELIC_APP_NAME\" Value=\"YOUR_APP_NAME\" /> ... </EnvironmentVariables> ... </CodePackage> Copy .NET Core for Windows In the ServiceManifest.xml file in your project, include the following under the CodePackage node: <CodePackage> ... <EntryPoint> <ExeHost> ... <!-- It is important for the WorkingFolder to be set to CodePackage --> <!-- This is because the environment variables set below rely on this being the working folder for the agent to work --> <WorkingFolder>CodePackage</WorkingFolder> ... </ExeHost> </EntryPoint> ... <EnvironmentVariables> ... <EnvironmentVariable Name=\"CORECLR_ENABLE_PROFILING\" Value=\"1\" /> <EnvironmentVariable Name=\"CORECLR_PROFILER\" Value=\"{36032161-FFC0-4B61-B559-F6C5D41BAE5A}\" /> <EnvironmentVariable Name=\"CORECLR_PROFILER_PATH\" Value=\".\\newrelic\\NewRelic.Profiler.dll\" /> <EnvironmentVariable Name=\"CORECLR_NEWRELIC_HOME\" Value=\".\\newrelic\" /> <EnvironmentVariable Name=\"NEW_RELIC_LICENSE_KEY\" Value=\"YOUR_LICENSE_KEY\" /> <EnvironmentVariable Name=\"NEW_RELIC_APP_NAME\" Value=\"YOUR_APP_NAME\" /> ... </EnvironmentVariables> ... </CodePackage> Copy .NET Core for Linux In the ServiceManifest.xml file in your project, include the following under the CodePackage node: <CodePackage> ... <EntryPoint> <ExeHost> ... <!-- It is important for the WorkingFolder to be set to CodePackage --> <!-- This is because the environment variables set below rely on this being the working folder for the agent to work --> <WorkingFolder>CodePackage</WorkingFolder> ... </ExeHost> </EntryPoint> ... <EnvironmentVariables> ... <EnvironmentVariable Name=\"CORECLR_ENABLE_PROFILING\" Value=\"1\" /> <EnvironmentVariable Name=\"CORECLR_PROFILER\" Value=\"{36032161-FFC0-4B61-B559-F6C5D41BAE5A}\" /> <EnvironmentVariable Name=\"CORECLR_PROFILER_PATH\" Value=\"./newrelic/libNewRelicProfiler.so\" /> <EnvironmentVariable Name=\"CORECLR_NEWRELIC_HOME\" Value=\"./newrelic\" /> <EnvironmentVariable Name=\"NEW_RELIC_LICENSE_KEY\" Value=\"YOUR_LICENSE_KEY\" /> <EnvironmentVariable Name=\"NEW_RELIC_APP_NAME\" Value=\"YOUR_APP_NAME\" /> ... </EnvironmentVariables> ... </CodePackage> Copy For the .NET Framework only: Edit your app.config file and add the NewRelic.AgentEnabled app setting: <appSettings> ... <add key=\"NewRelic.AgentEnabled\" value=\"true\" /> ... </appSettings> Copy If your application is generating traffic, data should appear in your APM account in several minutes. If data does not appear, try these troubleshooting steps: Make sure that all files in the newrelic directory at the root of your app was published to Azure. Make sure the environment variables are set correctly. See the general troubleshooting documentation to check for common errors.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 111.68245,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> .<em>NET</em> <em>agent</em> on <em>Azure</em> Service Fabric",
        "sections": "<em>Install</em> .<em>NET</em> <em>agent</em> on <em>Azure</em> Service Fabric",
        "tags": "<em>Azure</em> <em>installation</em>",
        "body": "This document explains how to install APM&#x27;s .<em>NET</em> Framework <em>agent</em> and .<em>NET</em> Core <em>agent</em> on <em>Azure</em> Service Fabric. This is not the same as installing the Infrastructure integrations for Microsoft <em>Azure</em>. Install .<em>NET</em> <em>agent</em> on <em>Azure</em> Service Fabric Important In most cases, installing the .<em>NET</em> <em>agent</em>"
      },
      "id": "6043c8a6e7b9d24fa25799bc"
    }
  ],
  "/docs/agents/net-agent/azure-installation/install-net-agent-azure-cloud-services": [
    {
      "sections": [
        "Install Azure Marketplace app with New Relic",
        "End of life notice",
        "Install New Relic .NET agent"
      ],
      "title": "Install Azure Marketplace app with New Relic",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure installation"
      ],
      "external_id": "aef2e193486dd4993ae483d01735a03537b138b2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-installation/install-azure-marketplace-app-new-relic/",
      "published_at": "2021-05-05T09:27:16Z",
      "updated_at": "2021-03-13T02:42:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "End of life notice As of October 2017 you cannot create a New Relic account through Microsoft's Azure Marketplace Portal. Instead, if you have an Azure ID but do not already have a New Relic account, contact New Relic Sales. For more information, see the Azure transition information in New Relic's Online Technical Community. Install New Relic .NET agent Continue with the procedures to install the New Relic .NET agent with your Azure app as applicable for: Microsoft's Web App Services in the Azure Portal Microsoft's Cloud Services platform The .NET agent's support for Microsoft Azure is not the same as Infrastructure monitoring's integrations with Azure. Azure integrations have separate integration installation procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.71378,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> <em>Azure</em> Marketplace app with New Relic",
        "sections": "<em>Install</em> New Relic .<em>NET</em> <em>agent</em>",
        "tags": "<em>Azure</em> <em>installation</em>",
        "body": "&#x27;s Online Technical Community. Install New Relic .<em>NET</em> <em>agent</em> Continue with the procedures to install the New Relic .<em>NET</em> <em>agent</em> with your <em>Azure</em> app as applicable for: Microsoft&#x27;s Web App Services in the <em>Azure</em> Portal Microsoft&#x27;s Cloud Services platform The .<em>NET</em> <em>agent</em>&#x27;s support for Microsoft <em>Azure</em> is not the same as Infrastructure monitoring&#x27;s integrations with <em>Azure</em>. <em>Azure</em> integrations have separate integration <em>installation</em> procedures."
      },
      "id": "6043c3ade7b9d24ead5799b2"
    },
    {
      "sections": [
        "Install the .NET agent on Azure Web Apps",
        "Installation options",
        "Tip",
        "Disable Application Insights",
        "Install using the New Relic Azure Site Extension",
        "Install using NuGet (.NET Framework)",
        "Install using NuGet (.NET Core)",
        "Log file configuration for Windows",
        "Log file configuration for Linux",
        "Environment variables for Windows",
        "Environment variables for Linux",
        "Add New Relic app settings to Azure App Services",
        "View your app's performance",
        "Troubleshooting"
      ],
      "title": "Install the .NET agent on Azure Web Apps",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure installation"
      ],
      "external_id": "5cb6afb3ad05fdc243d2cf110f4df1e7e027740d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-installation/install-net-agent-azure-web-apps/",
      "published_at": "2021-05-05T09:27:16Z",
      "updated_at": "2021-03-16T14:55:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install New Relic's .NET agent for application performance monitoring on your Azure Web App. (This is not the same as installing the infrastructure monitoring integrations for Microsoft Azure.) Recommendation: Before following these instructions, read the .NET agent installation overview. Installation options Tip To use .NET or any other agent, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Use any of the following methods to add the New Relic .NET agent to your Azure-deployed web app. The best option depends on your role, environment, deployments, etc. For example: For operations teams that need to monitor the app, best practice may be to: Install using the Azure Site Extension For developer teams, best practice may be to use NuGet: Install using NuGet (.NET Framework) Install using NuGet (.NET Core) In order to monitor non-web apps (including WebJobs), or ASP.NET Core apps targeting .NET Framework, you must explicitly enable the agent for that application's .exe process via one of these two methods: Enable via placement of local newrelic.config file. Enable via application config file In addition, WebJobs may need custom instrumentation for transactions to appear in APM, and additional configuration if they run for less than one minute. Disable Application Insights Both New Relic's .NET agent and Microsoft Application Insights rely on the CLR Profiler, but only one may be active at a time. You must disable Application Insights in order for the .NET agent to function properly. For more information, see our Application Insights troubleshooting procedures. Install using the New Relic Azure Site Extension To install the .NET agent for an Azure Web App using the New Relic Azure Site Extension: Shut down your web application before installing the New Relic Azure Site Extension. Add the site extension: Navigate to http://[yoursitename].scm.azurewebsites.net, then select Site extensions > Gallery. Select the plus icon next to the New Relic site extension. In the Azure portal, add New Relic app settings to your Azure App Service. Restart your web app to use the new version of the agent. Install using NuGet (.NET Framework) The NuGet packages in this procedure support only the old packages.config. They do not support the current PackageReference format. For more information, see Microsoft's package reference documentation. For multi-project solutions, make sure you have selected the correct project (for example, a specific web app project) before installing the NuGet package. If you are upgrading the .NET Framework agent using NuGet, any changes you made in the newrelic.config will be overwritten. To preserve any changes, save your newrelic.config outside of your project, then restore it after upgrading. To install the .NET agent on an Azure Web App using NuGet: In the Azure portal, verify your Azure Platform (32-bit or 64-bit): From the Azure sidebar menu, select App Services > Your Application > Settings > Configuration > General settings. Open your application in Visual Studio, and install the New Relic NuGet package by running the appropriate command from the Package manager console: 32-bit: Install-Package NewRelic.Azure.WebSites 64-bit: Install-Package NewRelic.Azure.WebSites.x64 Publish your application. In the Azure portal, open the web app you want to monitor, then select Settings > Configuration. From Configuration, select + New application setting and add these key/value pairs: Key Value COR_ENABLE_PROFILING 1 COR_PROFILER {71DA0A04-7777-4EC6-9643-7D28B46A8A41} COR_PROFILER_PATH D:\\Home\\site\\wwwroot\\newrelic\\NewRelic.Profiler.dll NEWRELIC_HOME D:\\Home\\site\\wwwroot\\newrelic In the Azure portal, add New Relic app settings to your Azure App Service. Restart your web app. Install using NuGet (.NET Core) New Relic .NET Core agent supports Linux and Windows applications on Azure App Services. The installation process for Azure App Services differs from the .NET Core agent installation procedures for Linux and Windows. To install the .NET agent on an Azure Web App using NuGet: Install the NewRelic.Agent NuGet package. Modify the log node by adding a directory attribute to your newrelic.config file: Log file configuration for Windows log directory=\"D:\\Home\\LogFiles\\NewRelic\" level=\"info\"/log Copy Log file configuration for Linux log directory=\"/home/LogFiles/NewRelic\" level=\"info\"/log Copy Publish your application. In the Azure portal, open the web app you want to monitor, then select Settings > Configuration. From Configuration, select + New application setting and add these key/value pairs: Environment variables for Windows Key Value CORECLR_ENABLE_PROFILING 1 CORECLR_PROFILER {36032161-FFC0-4B61-B559-F6C5D41BAE5A} CORECLR_PROFILER_PATH_32 D:\\Home\\site\\wwwroot\\newrelic\\x86\\NewRelic.Profiler.dll CORECLR_PROFILER_PATH_64 D:\\Home\\site\\wwwroot\\newrelic\\NewRelic.Profiler.dll CORECLR_NEWRELIC_HOME D:\\Home\\site\\wwwroot\\newrelic Environment variables for Linux Key Value CORECLR_ENABLE_PROFILING 1 CORECLR_PROFILER {36032161-FFC0-4B61-B559-F6C5D41BAE5A} CORECLR_PROFILER_PATH /home/site/wwwroot/newrelic/libNewRelicProfiler.so CORECLR_NEWRELIC_HOME /home/site/wwwroot/newrelic In the Azure portal, add New Relic app settings to your Azure App Service. Restart your web app. Add New Relic app settings to Azure App Services To add your app settings: Make sure you have your license key before adding the New Relic .NET agent's app settings. In the Azure portal, open the web app you want to monitor, then select Configuration > Application settings. From Application settings, select + New application setting and add these key/value pairs: Key Value NEW_RELIC_LICENSE_KEY YOUR_LICENSE_KEY NEW_RELIC_APP_NAME YOUR_APP_NAME Save and restart your web app. Setting the license key and app name with Application settings will override the newrelic.config. To verify your app's environment variables in your app's Kudu diagnostic console, go to Environment > Environment variables. For example: https://myappname.scm.azurewebsites.net/Env.cshtml#envVariables Copy View your app's performance Your application must receive traffic in order for you to view its performance in New Relic. You may need to wait a few minutes for data to start appearing. If no data appears, see the troubleshooting procedures for Azure Web Apps. To view your app's performance in New Relic: Go to one.newrelic.com > APM > (select an app). The APM Summary page automatically appears. You can also view detailed information about errors, database and instance performance issues, and more. If you created your New Relic app prior to October 2017, you can use the Azure portal to select the New Relic account blade. You will be automatically logged in with SAML Single Sign-on (SSO) to APM. You can also view your application's error rate and throughput data in the Azure portal by going to New Relic Accounts > (select your app). Troubleshooting If no data appears after installing the agent, generating traffic for your app, and waiting a few minutes, try these troubleshooting tips: Make sure that all files in the newrelic directory at the root of your app got published to Azure. Make sure the environment variables are set correctly. Make sure Microsoft Application Insights is not installed and configured on the application. For more information, see the Application Insights troubleshooting procedures. Refer to additional Azure troubleshooting procedures as applicable.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.37909,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> the .<em>NET</em> <em>agent</em> on <em>Azure</em> Web Apps",
        "sections": "<em>Install</em> the .<em>NET</em> <em>agent</em> on <em>Azure</em> Web Apps",
        "tags": "<em>Azure</em> <em>installation</em>",
        "body": ". Restart your web app. Install using NuGet (.<em>NET</em> Core) New Relic .<em>NET</em> Core <em>agent</em> supports Linux and Windows applications on <em>Azure</em> App Services. The <em>installation</em> process for <em>Azure</em> App Services differs from the .<em>NET</em> Core <em>agent</em> <em>installation</em> procedures for Linux and Windows. To install the .<em>NET</em> <em>agent</em>"
      },
      "id": "603e8e7c28ccbc420ceba748"
    },
    {
      "sections": [
        "Install .NET agent on Azure Service Fabric",
        "Important",
        "Install using NuGet",
        ".NET Framework",
        ".NET Core for Windows",
        ".NET Core for Linux"
      ],
      "title": "Install .NET agent on Azure Service Fabric",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure installation"
      ],
      "external_id": "c520de26567fd173a0ac7b19ac0044a5757862bb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-installation/install-net-agent-azure-service-fabric/",
      "published_at": "2021-05-05T09:26:09Z",
      "updated_at": "2021-03-13T02:21:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install APM's .NET Framework agent and .NET Core agent on Azure Service Fabric. This is not the same as installing the Infrastructure integrations for Microsoft Azure. Install .NET agent on Azure Service Fabric Important In most cases, installing the .NET agent in an Azure Service Fabric environment can be performed using the standard install procedures for either Windows or Linux. This document highlights some alternate ways you can install the agent. You will need to ensure the agent gets installed on all nodes in your cluster. To monitor multiple nodes, you may want to integrate the install into your deployment process. If you are using containers in your Service Fabric environment you should read Install for Docker. You can also install the agent in a Service Fabric environment using NuGet. NuGet is often a good option for developers because the agent gets deployed along with your application. Though, using NuGet requires some manual installation procedures. See Install with NuGet. Install using NuGet To install the .NET agent using NuGet: Follow the standard NuGet install procedures. When using NuGet, you must set some environment variables. This can be done in your application's ServiceManifest.xml file. See the relevant instructions below: .NET Framework In the ServiceManifest.xml file in your project, include the following under the CodePackage node: <CodePackage Name=\"Code\" Version=\"1.0.0\"> </CodePackage> <CodePackage> ... <EntryPoint> <ExeHost> ... <!-- It is important for the WorkingFolder to be set to CodePackage --> <!-- This is because the environment variables set below rely on this being the working folder for the agent to work --> <WorkingFolder>CodePackage</WorkingFolder> ... </ExeHost> </EntryPoint> ... <EnvironmentVariables> ... <EnvironmentVariable Name=\"COR_ENABLE_PROFILING\" Value=\"1\" /> <EnvironmentVariable Name=\"COR_PROFILER\" Value=\"{71DA0A04-7777-4EC6-9643-7D28B46A8A41}\" /> <EnvironmentVariable Name=\"COR_PROFILER_PATH\" Value=\".\\newrelic\\NewRelic.Profiler.dll\" /> <EnvironmentVariable Name=\"NEWRELIC_HOME\" Value=\".\\newrelic\" /> <EnvironmentVariable Name=\"NEW_RELIC_LICENSE_KEY\" Value=\"YOUR_LICENSE_KEY\" /> <EnvironmentVariable Name=\"NEW_RELIC_APP_NAME\" Value=\"YOUR_APP_NAME\" /> ... </EnvironmentVariables> ... </CodePackage> Copy .NET Core for Windows In the ServiceManifest.xml file in your project, include the following under the CodePackage node: <CodePackage> ... <EntryPoint> <ExeHost> ... <!-- It is important for the WorkingFolder to be set to CodePackage --> <!-- This is because the environment variables set below rely on this being the working folder for the agent to work --> <WorkingFolder>CodePackage</WorkingFolder> ... </ExeHost> </EntryPoint> ... <EnvironmentVariables> ... <EnvironmentVariable Name=\"CORECLR_ENABLE_PROFILING\" Value=\"1\" /> <EnvironmentVariable Name=\"CORECLR_PROFILER\" Value=\"{36032161-FFC0-4B61-B559-F6C5D41BAE5A}\" /> <EnvironmentVariable Name=\"CORECLR_PROFILER_PATH\" Value=\".\\newrelic\\NewRelic.Profiler.dll\" /> <EnvironmentVariable Name=\"CORECLR_NEWRELIC_HOME\" Value=\".\\newrelic\" /> <EnvironmentVariable Name=\"NEW_RELIC_LICENSE_KEY\" Value=\"YOUR_LICENSE_KEY\" /> <EnvironmentVariable Name=\"NEW_RELIC_APP_NAME\" Value=\"YOUR_APP_NAME\" /> ... </EnvironmentVariables> ... </CodePackage> Copy .NET Core for Linux In the ServiceManifest.xml file in your project, include the following under the CodePackage node: <CodePackage> ... <EntryPoint> <ExeHost> ... <!-- It is important for the WorkingFolder to be set to CodePackage --> <!-- This is because the environment variables set below rely on this being the working folder for the agent to work --> <WorkingFolder>CodePackage</WorkingFolder> ... </ExeHost> </EntryPoint> ... <EnvironmentVariables> ... <EnvironmentVariable Name=\"CORECLR_ENABLE_PROFILING\" Value=\"1\" /> <EnvironmentVariable Name=\"CORECLR_PROFILER\" Value=\"{36032161-FFC0-4B61-B559-F6C5D41BAE5A}\" /> <EnvironmentVariable Name=\"CORECLR_PROFILER_PATH\" Value=\"./newrelic/libNewRelicProfiler.so\" /> <EnvironmentVariable Name=\"CORECLR_NEWRELIC_HOME\" Value=\"./newrelic\" /> <EnvironmentVariable Name=\"NEW_RELIC_LICENSE_KEY\" Value=\"YOUR_LICENSE_KEY\" /> <EnvironmentVariable Name=\"NEW_RELIC_APP_NAME\" Value=\"YOUR_APP_NAME\" /> ... </EnvironmentVariables> ... </CodePackage> Copy For the .NET Framework only: Edit your app.config file and add the NewRelic.AgentEnabled app setting: <appSettings> ... <add key=\"NewRelic.AgentEnabled\" value=\"true\" /> ... </appSettings> Copy If your application is generating traffic, data should appear in your APM account in several minutes. If data does not appear, try these troubleshooting steps: Make sure that all files in the newrelic directory at the root of your app was published to Azure. Make sure the environment variables are set correctly. See the general troubleshooting documentation to check for common errors.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 111.68245,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> .<em>NET</em> <em>agent</em> on <em>Azure</em> Service Fabric",
        "sections": "<em>Install</em> .<em>NET</em> <em>agent</em> on <em>Azure</em> Service Fabric",
        "tags": "<em>Azure</em> <em>installation</em>",
        "body": "This document explains how to install APM&#x27;s .<em>NET</em> Framework <em>agent</em> and .<em>NET</em> Core <em>agent</em> on <em>Azure</em> Service Fabric. This is not the same as installing the Infrastructure integrations for Microsoft <em>Azure</em>. Install .<em>NET</em> <em>agent</em> on <em>Azure</em> Service Fabric Important In most cases, installing the .<em>NET</em> <em>agent</em>"
      },
      "id": "6043c8a6e7b9d24fa25799bc"
    }
  ],
  "/docs/agents/net-agent/azure-installation/install-net-agent-azure-service-fabric": [
    {
      "sections": [
        "Install Azure Marketplace app with New Relic",
        "End of life notice",
        "Install New Relic .NET agent"
      ],
      "title": "Install Azure Marketplace app with New Relic",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure installation"
      ],
      "external_id": "aef2e193486dd4993ae483d01735a03537b138b2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-installation/install-azure-marketplace-app-new-relic/",
      "published_at": "2021-05-05T09:27:16Z",
      "updated_at": "2021-03-13T02:42:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "End of life notice As of October 2017 you cannot create a New Relic account through Microsoft's Azure Marketplace Portal. Instead, if you have an Azure ID but do not already have a New Relic account, contact New Relic Sales. For more information, see the Azure transition information in New Relic's Online Technical Community. Install New Relic .NET agent Continue with the procedures to install the New Relic .NET agent with your Azure app as applicable for: Microsoft's Web App Services in the Azure Portal Microsoft's Cloud Services platform The .NET agent's support for Microsoft Azure is not the same as Infrastructure monitoring's integrations with Azure. Azure integrations have separate integration installation procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.71378,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> <em>Azure</em> Marketplace app with New Relic",
        "sections": "<em>Install</em> New Relic .<em>NET</em> <em>agent</em>",
        "tags": "<em>Azure</em> <em>installation</em>",
        "body": "&#x27;s Online Technical Community. Install New Relic .<em>NET</em> <em>agent</em> Continue with the procedures to install the New Relic .<em>NET</em> <em>agent</em> with your <em>Azure</em> app as applicable for: Microsoft&#x27;s Web App Services in the <em>Azure</em> Portal Microsoft&#x27;s Cloud Services platform The .<em>NET</em> <em>agent</em>&#x27;s support for Microsoft <em>Azure</em> is not the same as Infrastructure monitoring&#x27;s integrations with <em>Azure</em>. <em>Azure</em> integrations have separate integration <em>installation</em> procedures."
      },
      "id": "6043c3ade7b9d24ead5799b2"
    },
    {
      "sections": [
        "Install the .NET agent on Azure Cloud Services",
        "Important",
        "Check Web or Worker role's location",
        "Install the NuGet package for Cloud Services",
        "Instrument Worker role",
        "Custom instrumentation example for Worker role",
        "Custom instrumentation file deployment",
        "Optional: Create custom config file",
        "View your app's performance"
      ],
      "title": "Install the .NET agent on Azure Cloud Services",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure installation"
      ],
      "external_id": "afe3e181b9ec18fa0b2be3e76f7c9b20d247d21e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-installation/install-net-agent-azure-cloud-services/",
      "published_at": "2021-05-05T09:26:09Z",
      "updated_at": "2021-03-16T14:55:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install APM's .NET agent on Microsoft's Azure Cloud Services platform. This is not the same as installing the Infrastructure integrations for Microsoft Azure. To make sure you are using the most relevant instructions, first see the .NET agent install overview. Important Before installing the NuGet package into a multi-project Visual Studio solution, make sure you have selected the correct project for your New Relic .NET application (for example, a specific website project). Check Web or Worker role's location If Service files are nested within a Solution folder, the NuGet installer cannot locate or update the necessary files. This will cause issues with the .NET agent setup, which will in turn prevent the agent from reporting metrics on your Cloud Service. Recommendation: Place the Web or Worker role at the root of the solution before installing the NuGet package. Once the New Relic .NET agent is installed, you can move the Cloud role back into the Solution folder. Install the NuGet package for Cloud Services Important The NuGet packages in this procedure support only the old packages.config. They do not support the new PackageReference format. For more information see Microsoft's package reference documentation For multi-project solutions, make sure you have selected the correct project (for example, a specific website project) before installing the NuGet package. Open your Visual Studio solution, or create a new one by selecting File > New > Project. For multi-project solutions, make sure you have selected the correct project (for example, a specific website project). If you do not already have an Azure Cloud Service project in your solution, add one by right-clicking your app in the Solution Explorer and selecting Add Windows Azure Cloud Service Project. Open the Package Manager console by selecting Tools > Library Package Manager > Package Manager Console. Set your project as the default project. From the Package Manager command prompt, type Install-Package NewRelicWindowsAzure and press Enter. Follow the prompts to enter your New Relic license key and your application name as you want it to appear in the New Relic UI. Or, use your solution name as the default app name. From the Solution Explorer, right-click your Azure Cloud Service project, and select Publish. If this is your first time deploying this app to Azure, enter your Azure credentials. If applicable, instrument methods for Worker roles. Instrument Worker role A Worker role is a non-web process run as an Azure Cloud Service. To instrument a Worker role, you must create custom transactions. The .NET agent automatically instruments external calls and database calls, but it does not instrument default methods for transactions. Creating custom transactions solves this. After the Worker role starts up and the method executes, transaction data will appear in the APM Summary and Transactions pages under the Non-web category. The NuGet installer automatically adds the NewRelic.AppName parameter to the application config. This appears as <YOUR_WORKER_ROLE_NAME>.dll.config in E:\\approot. The .NET agent also automatically instruments WaWorkerHost.exe. This is the name of the actual Worker role process. Custom instrumentation example for Worker role This is a custom instrumentation example for a Worker role. It creates a custom transaction named ProcessMessage. The transaction begins when the ProcessMessage method is entered, and it ends when the method returns. The following example uses MyWorkerRole as the namespace. If you do not specify a name, it will default to the Solution name. namespace MyWorkerRole { public class NotificationQueue { public bool ProcessMessage(Message message) { // code to process message } } } Copy Here is the custom instrumentation file for the code: <?xml version=\"1.0\" encoding=\"utf-8\"?> <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerfactory name=\"NewRelic.Agent.Core.Tracer.Factories.BackgroundThreadTracerFactory\" metricName=\"Custom/ProcessMessage\"> <match assemblyname=\"MyWorkerRole\" classname=\"MyWorkerRole.NotificationQueue\"> <exactmethodmatcher methodName=\"ProcessMessage\" /> </match> </tracerfactory> </instrumentation> </extension> Copy On a local installation, place this instrumentation file in C:\\ProgramData\\New Relic\\.NET Agent\\Extensions. Custom instrumentation file deployment Optional: To send the custom instrumentation file up with an Azure Cloud Service deployment: In your Azure Cloud project, add the instrumentation file to your Worker role inside the Roles folder. After installing the New Relic .NET agent NuGet package, locate newrelic.cmd in your Worker Role project. Find the statement IF %ERRORLEVEL% EQU 0 within the :INSTALL_NEWRELIC_AGENT block, and add the following statement to the conditional: IF %ERRORLEVEL% EQU 0 ( copy /Y \"%RoleRoot%\\approot\\MyInstrumentation.xml\" \"%NR_HOME%\\extensions\" >> %RoleRoot%\\nr.log ) ELSE ( Copy In this example, the newrelic.cmd batch file copies the custom instrumentation file to the Extensions folder in D:\\ProgramData\\New Relic\\.NET Agent\\, or %NR_HOME%. This example uses MyInstrumentation.xml, but any name will work as long as the file name and copy command match, and the file is valid XML. Optional: Create custom config file You can create a custom configuration file in Visual Studio. This allows you to make changes to newrelic.config inside Visual Studio, without having to remote into your Azure Role instance every time you make a change. Whenever you publish your app, the config file in Visual Studio is automatically uploaded to the remote host. The choices you make with the installation wizard do not matter. Installing locally does not affect your Azure development environment. In Visual Studio, select the Solution Explorer, then open NewRelicAgent_x64_XYZ.msi. Follow the steps to install the agent locally. Import newrelic.config into your project: In Solution Explorer > Cloud Project, right-click the Web Role, then select Add > Existing Item. Navigate to C: \\ ProgramData \\ New Relic \\ .NET Agent and select newrelic.config. From C: \\ ProgramData \\ New Relic \\ .NET Agent, edit newrelic.cmd. In the :INSTALL_NEWRELIC_AGENT section, find this statement: IF $ERRORLEVEL% EQU 0 ( Copy Add the following code as another statement inside the IF block, then save the file: copy /Y \"%RoleRoot%\\approot\\newrelic.config\" \"%NR_HOME%\" >> %RoleRoot%\\nr.log Copy You can now edit the newrelic.config hosted in Visual Studio. Whenever you publish your app, the copy command will upload the config file to the remote host. View your app's performance Your application must receive traffic in order for you to view its performance in New Relic. You may need to wait a few minutes for data to start appearing. If no data appears, see the troubleshooting procedures for Azure Cloud Services. To view your app's performance in APM: Go to one.newrelic.com > APM > (select an app). The APM Summary page automatically appears. You can also view detailed information about errors, database and instance performance issues, and more. If you created your New Relic app prior to October 2017, you can use the Azure Portal to select the New Relic account blade. You will be automatically logged in with SAML Single Sign-on (SSO) to APM. You can also view your application's error rate and throughput data in the Azure Portal by going to New Relic Accounts > choose your application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.69708,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> the .<em>NET</em> <em>agent</em> on <em>Azure</em> Cloud Services",
        "sections": "<em>Install</em> the .<em>NET</em> <em>agent</em> on <em>Azure</em> Cloud Services",
        "tags": "<em>Azure</em> <em>installation</em>",
        "body": "&gt; &lt;&#x2F;tracerfactory&gt; &lt;&#x2F;instrumentation&gt; &lt;&#x2F;extension&gt; Copy On a local <em>installation</em>, place this instrumentation file in C:\\ProgramData\\New Relic\\.<em>NET</em> <em>Agent</em>\\Extensions. Custom instrumentation file deployment Optional: To send the custom instrumentation file up with an <em>Azure</em> Cloud Service deployment: In your"
      },
      "id": "603e8e7ee7b9d2b4d42a07e3"
    },
    {
      "sections": [
        "Install the .NET agent on Azure Web Apps",
        "Installation options",
        "Tip",
        "Disable Application Insights",
        "Install using the New Relic Azure Site Extension",
        "Install using NuGet (.NET Framework)",
        "Install using NuGet (.NET Core)",
        "Log file configuration for Windows",
        "Log file configuration for Linux",
        "Environment variables for Windows",
        "Environment variables for Linux",
        "Add New Relic app settings to Azure App Services",
        "View your app's performance",
        "Troubleshooting"
      ],
      "title": "Install the .NET agent on Azure Web Apps",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure installation"
      ],
      "external_id": "5cb6afb3ad05fdc243d2cf110f4df1e7e027740d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-installation/install-net-agent-azure-web-apps/",
      "published_at": "2021-05-05T09:27:16Z",
      "updated_at": "2021-03-16T14:55:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install New Relic's .NET agent for application performance monitoring on your Azure Web App. (This is not the same as installing the infrastructure monitoring integrations for Microsoft Azure.) Recommendation: Before following these instructions, read the .NET agent installation overview. Installation options Tip To use .NET or any other agent, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Use any of the following methods to add the New Relic .NET agent to your Azure-deployed web app. The best option depends on your role, environment, deployments, etc. For example: For operations teams that need to monitor the app, best practice may be to: Install using the Azure Site Extension For developer teams, best practice may be to use NuGet: Install using NuGet (.NET Framework) Install using NuGet (.NET Core) In order to monitor non-web apps (including WebJobs), or ASP.NET Core apps targeting .NET Framework, you must explicitly enable the agent for that application's .exe process via one of these two methods: Enable via placement of local newrelic.config file. Enable via application config file In addition, WebJobs may need custom instrumentation for transactions to appear in APM, and additional configuration if they run for less than one minute. Disable Application Insights Both New Relic's .NET agent and Microsoft Application Insights rely on the CLR Profiler, but only one may be active at a time. You must disable Application Insights in order for the .NET agent to function properly. For more information, see our Application Insights troubleshooting procedures. Install using the New Relic Azure Site Extension To install the .NET agent for an Azure Web App using the New Relic Azure Site Extension: Shut down your web application before installing the New Relic Azure Site Extension. Add the site extension: Navigate to http://[yoursitename].scm.azurewebsites.net, then select Site extensions > Gallery. Select the plus icon next to the New Relic site extension. In the Azure portal, add New Relic app settings to your Azure App Service. Restart your web app to use the new version of the agent. Install using NuGet (.NET Framework) The NuGet packages in this procedure support only the old packages.config. They do not support the current PackageReference format. For more information, see Microsoft's package reference documentation. For multi-project solutions, make sure you have selected the correct project (for example, a specific web app project) before installing the NuGet package. If you are upgrading the .NET Framework agent using NuGet, any changes you made in the newrelic.config will be overwritten. To preserve any changes, save your newrelic.config outside of your project, then restore it after upgrading. To install the .NET agent on an Azure Web App using NuGet: In the Azure portal, verify your Azure Platform (32-bit or 64-bit): From the Azure sidebar menu, select App Services > Your Application > Settings > Configuration > General settings. Open your application in Visual Studio, and install the New Relic NuGet package by running the appropriate command from the Package manager console: 32-bit: Install-Package NewRelic.Azure.WebSites 64-bit: Install-Package NewRelic.Azure.WebSites.x64 Publish your application. In the Azure portal, open the web app you want to monitor, then select Settings > Configuration. From Configuration, select + New application setting and add these key/value pairs: Key Value COR_ENABLE_PROFILING 1 COR_PROFILER {71DA0A04-7777-4EC6-9643-7D28B46A8A41} COR_PROFILER_PATH D:\\Home\\site\\wwwroot\\newrelic\\NewRelic.Profiler.dll NEWRELIC_HOME D:\\Home\\site\\wwwroot\\newrelic In the Azure portal, add New Relic app settings to your Azure App Service. Restart your web app. Install using NuGet (.NET Core) New Relic .NET Core agent supports Linux and Windows applications on Azure App Services. The installation process for Azure App Services differs from the .NET Core agent installation procedures for Linux and Windows. To install the .NET agent on an Azure Web App using NuGet: Install the NewRelic.Agent NuGet package. Modify the log node by adding a directory attribute to your newrelic.config file: Log file configuration for Windows log directory=\"D:\\Home\\LogFiles\\NewRelic\" level=\"info\"/log Copy Log file configuration for Linux log directory=\"/home/LogFiles/NewRelic\" level=\"info\"/log Copy Publish your application. In the Azure portal, open the web app you want to monitor, then select Settings > Configuration. From Configuration, select + New application setting and add these key/value pairs: Environment variables for Windows Key Value CORECLR_ENABLE_PROFILING 1 CORECLR_PROFILER {36032161-FFC0-4B61-B559-F6C5D41BAE5A} CORECLR_PROFILER_PATH_32 D:\\Home\\site\\wwwroot\\newrelic\\x86\\NewRelic.Profiler.dll CORECLR_PROFILER_PATH_64 D:\\Home\\site\\wwwroot\\newrelic\\NewRelic.Profiler.dll CORECLR_NEWRELIC_HOME D:\\Home\\site\\wwwroot\\newrelic Environment variables for Linux Key Value CORECLR_ENABLE_PROFILING 1 CORECLR_PROFILER {36032161-FFC0-4B61-B559-F6C5D41BAE5A} CORECLR_PROFILER_PATH /home/site/wwwroot/newrelic/libNewRelicProfiler.so CORECLR_NEWRELIC_HOME /home/site/wwwroot/newrelic In the Azure portal, add New Relic app settings to your Azure App Service. Restart your web app. Add New Relic app settings to Azure App Services To add your app settings: Make sure you have your license key before adding the New Relic .NET agent's app settings. In the Azure portal, open the web app you want to monitor, then select Configuration > Application settings. From Application settings, select + New application setting and add these key/value pairs: Key Value NEW_RELIC_LICENSE_KEY YOUR_LICENSE_KEY NEW_RELIC_APP_NAME YOUR_APP_NAME Save and restart your web app. Setting the license key and app name with Application settings will override the newrelic.config. To verify your app's environment variables in your app's Kudu diagnostic console, go to Environment > Environment variables. For example: https://myappname.scm.azurewebsites.net/Env.cshtml#envVariables Copy View your app's performance Your application must receive traffic in order for you to view its performance in New Relic. You may need to wait a few minutes for data to start appearing. If no data appears, see the troubleshooting procedures for Azure Web Apps. To view your app's performance in New Relic: Go to one.newrelic.com > APM > (select an app). The APM Summary page automatically appears. You can also view detailed information about errors, database and instance performance issues, and more. If you created your New Relic app prior to October 2017, you can use the Azure portal to select the New Relic account blade. You will be automatically logged in with SAML Single Sign-on (SSO) to APM. You can also view your application's error rate and throughput data in the Azure portal by going to New Relic Accounts > (select your app). Troubleshooting If no data appears after installing the agent, generating traffic for your app, and waiting a few minutes, try these troubleshooting tips: Make sure that all files in the newrelic directory at the root of your app got published to Azure. Make sure the environment variables are set correctly. Make sure Microsoft Application Insights is not installed and configured on the application. For more information, see the Application Insights troubleshooting procedures. Refer to additional Azure troubleshooting procedures as applicable.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.37909,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> the .<em>NET</em> <em>agent</em> on <em>Azure</em> Web Apps",
        "sections": "<em>Install</em> the .<em>NET</em> <em>agent</em> on <em>Azure</em> Web Apps",
        "tags": "<em>Azure</em> <em>installation</em>",
        "body": ". Restart your web app. Install using NuGet (.<em>NET</em> Core) New Relic .<em>NET</em> Core <em>agent</em> supports Linux and Windows applications on <em>Azure</em> App Services. The <em>installation</em> process for <em>Azure</em> App Services differs from the .<em>NET</em> Core <em>agent</em> <em>installation</em> procedures for Linux and Windows. To install the .<em>NET</em> <em>agent</em>"
      },
      "id": "603e8e7c28ccbc420ceba748"
    }
  ],
  "/docs/agents/net-agent/azure-installation/install-net-agent-azure-web-apps": [
    {
      "sections": [
        "Install Azure Marketplace app with New Relic",
        "End of life notice",
        "Install New Relic .NET agent"
      ],
      "title": "Install Azure Marketplace app with New Relic",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure installation"
      ],
      "external_id": "aef2e193486dd4993ae483d01735a03537b138b2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-installation/install-azure-marketplace-app-new-relic/",
      "published_at": "2021-05-05T09:27:16Z",
      "updated_at": "2021-03-13T02:42:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "End of life notice As of October 2017 you cannot create a New Relic account through Microsoft's Azure Marketplace Portal. Instead, if you have an Azure ID but do not already have a New Relic account, contact New Relic Sales. For more information, see the Azure transition information in New Relic's Online Technical Community. Install New Relic .NET agent Continue with the procedures to install the New Relic .NET agent with your Azure app as applicable for: Microsoft's Web App Services in the Azure Portal Microsoft's Cloud Services platform The .NET agent's support for Microsoft Azure is not the same as Infrastructure monitoring's integrations with Azure. Azure integrations have separate integration installation procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.71378,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> <em>Azure</em> Marketplace app with New Relic",
        "sections": "<em>Install</em> New Relic .<em>NET</em> <em>agent</em>",
        "tags": "<em>Azure</em> <em>installation</em>",
        "body": "&#x27;s Online Technical Community. Install New Relic .<em>NET</em> <em>agent</em> Continue with the procedures to install the New Relic .<em>NET</em> <em>agent</em> with your <em>Azure</em> app as applicable for: Microsoft&#x27;s Web App Services in the <em>Azure</em> Portal Microsoft&#x27;s Cloud Services platform The .<em>NET</em> <em>agent</em>&#x27;s support for Microsoft <em>Azure</em> is not the same as Infrastructure monitoring&#x27;s integrations with <em>Azure</em>. <em>Azure</em> integrations have separate integration <em>installation</em> procedures."
      },
      "id": "6043c3ade7b9d24ead5799b2"
    },
    {
      "sections": [
        "Install the .NET agent on Azure Cloud Services",
        "Important",
        "Check Web or Worker role's location",
        "Install the NuGet package for Cloud Services",
        "Instrument Worker role",
        "Custom instrumentation example for Worker role",
        "Custom instrumentation file deployment",
        "Optional: Create custom config file",
        "View your app's performance"
      ],
      "title": "Install the .NET agent on Azure Cloud Services",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure installation"
      ],
      "external_id": "afe3e181b9ec18fa0b2be3e76f7c9b20d247d21e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-installation/install-net-agent-azure-cloud-services/",
      "published_at": "2021-05-05T09:26:09Z",
      "updated_at": "2021-03-16T14:55:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install APM's .NET agent on Microsoft's Azure Cloud Services platform. This is not the same as installing the Infrastructure integrations for Microsoft Azure. To make sure you are using the most relevant instructions, first see the .NET agent install overview. Important Before installing the NuGet package into a multi-project Visual Studio solution, make sure you have selected the correct project for your New Relic .NET application (for example, a specific website project). Check Web or Worker role's location If Service files are nested within a Solution folder, the NuGet installer cannot locate or update the necessary files. This will cause issues with the .NET agent setup, which will in turn prevent the agent from reporting metrics on your Cloud Service. Recommendation: Place the Web or Worker role at the root of the solution before installing the NuGet package. Once the New Relic .NET agent is installed, you can move the Cloud role back into the Solution folder. Install the NuGet package for Cloud Services Important The NuGet packages in this procedure support only the old packages.config. They do not support the new PackageReference format. For more information see Microsoft's package reference documentation For multi-project solutions, make sure you have selected the correct project (for example, a specific website project) before installing the NuGet package. Open your Visual Studio solution, or create a new one by selecting File > New > Project. For multi-project solutions, make sure you have selected the correct project (for example, a specific website project). If you do not already have an Azure Cloud Service project in your solution, add one by right-clicking your app in the Solution Explorer and selecting Add Windows Azure Cloud Service Project. Open the Package Manager console by selecting Tools > Library Package Manager > Package Manager Console. Set your project as the default project. From the Package Manager command prompt, type Install-Package NewRelicWindowsAzure and press Enter. Follow the prompts to enter your New Relic license key and your application name as you want it to appear in the New Relic UI. Or, use your solution name as the default app name. From the Solution Explorer, right-click your Azure Cloud Service project, and select Publish. If this is your first time deploying this app to Azure, enter your Azure credentials. If applicable, instrument methods for Worker roles. Instrument Worker role A Worker role is a non-web process run as an Azure Cloud Service. To instrument a Worker role, you must create custom transactions. The .NET agent automatically instruments external calls and database calls, but it does not instrument default methods for transactions. Creating custom transactions solves this. After the Worker role starts up and the method executes, transaction data will appear in the APM Summary and Transactions pages under the Non-web category. The NuGet installer automatically adds the NewRelic.AppName parameter to the application config. This appears as <YOUR_WORKER_ROLE_NAME>.dll.config in E:\\approot. The .NET agent also automatically instruments WaWorkerHost.exe. This is the name of the actual Worker role process. Custom instrumentation example for Worker role This is a custom instrumentation example for a Worker role. It creates a custom transaction named ProcessMessage. The transaction begins when the ProcessMessage method is entered, and it ends when the method returns. The following example uses MyWorkerRole as the namespace. If you do not specify a name, it will default to the Solution name. namespace MyWorkerRole { public class NotificationQueue { public bool ProcessMessage(Message message) { // code to process message } } } Copy Here is the custom instrumentation file for the code: <?xml version=\"1.0\" encoding=\"utf-8\"?> <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerfactory name=\"NewRelic.Agent.Core.Tracer.Factories.BackgroundThreadTracerFactory\" metricName=\"Custom/ProcessMessage\"> <match assemblyname=\"MyWorkerRole\" classname=\"MyWorkerRole.NotificationQueue\"> <exactmethodmatcher methodName=\"ProcessMessage\" /> </match> </tracerfactory> </instrumentation> </extension> Copy On a local installation, place this instrumentation file in C:\\ProgramData\\New Relic\\.NET Agent\\Extensions. Custom instrumentation file deployment Optional: To send the custom instrumentation file up with an Azure Cloud Service deployment: In your Azure Cloud project, add the instrumentation file to your Worker role inside the Roles folder. After installing the New Relic .NET agent NuGet package, locate newrelic.cmd in your Worker Role project. Find the statement IF %ERRORLEVEL% EQU 0 within the :INSTALL_NEWRELIC_AGENT block, and add the following statement to the conditional: IF %ERRORLEVEL% EQU 0 ( copy /Y \"%RoleRoot%\\approot\\MyInstrumentation.xml\" \"%NR_HOME%\\extensions\" >> %RoleRoot%\\nr.log ) ELSE ( Copy In this example, the newrelic.cmd batch file copies the custom instrumentation file to the Extensions folder in D:\\ProgramData\\New Relic\\.NET Agent\\, or %NR_HOME%. This example uses MyInstrumentation.xml, but any name will work as long as the file name and copy command match, and the file is valid XML. Optional: Create custom config file You can create a custom configuration file in Visual Studio. This allows you to make changes to newrelic.config inside Visual Studio, without having to remote into your Azure Role instance every time you make a change. Whenever you publish your app, the config file in Visual Studio is automatically uploaded to the remote host. The choices you make with the installation wizard do not matter. Installing locally does not affect your Azure development environment. In Visual Studio, select the Solution Explorer, then open NewRelicAgent_x64_XYZ.msi. Follow the steps to install the agent locally. Import newrelic.config into your project: In Solution Explorer > Cloud Project, right-click the Web Role, then select Add > Existing Item. Navigate to C: \\ ProgramData \\ New Relic \\ .NET Agent and select newrelic.config. From C: \\ ProgramData \\ New Relic \\ .NET Agent, edit newrelic.cmd. In the :INSTALL_NEWRELIC_AGENT section, find this statement: IF $ERRORLEVEL% EQU 0 ( Copy Add the following code as another statement inside the IF block, then save the file: copy /Y \"%RoleRoot%\\approot\\newrelic.config\" \"%NR_HOME%\" >> %RoleRoot%\\nr.log Copy You can now edit the newrelic.config hosted in Visual Studio. Whenever you publish your app, the copy command will upload the config file to the remote host. View your app's performance Your application must receive traffic in order for you to view its performance in New Relic. You may need to wait a few minutes for data to start appearing. If no data appears, see the troubleshooting procedures for Azure Cloud Services. To view your app's performance in APM: Go to one.newrelic.com > APM > (select an app). The APM Summary page automatically appears. You can also view detailed information about errors, database and instance performance issues, and more. If you created your New Relic app prior to October 2017, you can use the Azure Portal to select the New Relic account blade. You will be automatically logged in with SAML Single Sign-on (SSO) to APM. You can also view your application's error rate and throughput data in the Azure Portal by going to New Relic Accounts > choose your application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.69708,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> the .<em>NET</em> <em>agent</em> on <em>Azure</em> Cloud Services",
        "sections": "<em>Install</em> the .<em>NET</em> <em>agent</em> on <em>Azure</em> Cloud Services",
        "tags": "<em>Azure</em> <em>installation</em>",
        "body": "&gt; &lt;&#x2F;tracerfactory&gt; &lt;&#x2F;instrumentation&gt; &lt;&#x2F;extension&gt; Copy On a local <em>installation</em>, place this instrumentation file in C:\\ProgramData\\New Relic\\.<em>NET</em> <em>Agent</em>\\Extensions. Custom instrumentation file deployment Optional: To send the custom instrumentation file up with an <em>Azure</em> Cloud Service deployment: In your"
      },
      "id": "603e8e7ee7b9d2b4d42a07e3"
    },
    {
      "sections": [
        "Install .NET agent on Azure Service Fabric",
        "Important",
        "Install using NuGet",
        ".NET Framework",
        ".NET Core for Windows",
        ".NET Core for Linux"
      ],
      "title": "Install .NET agent on Azure Service Fabric",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure installation"
      ],
      "external_id": "c520de26567fd173a0ac7b19ac0044a5757862bb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-installation/install-net-agent-azure-service-fabric/",
      "published_at": "2021-05-05T09:26:09Z",
      "updated_at": "2021-03-13T02:21:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install APM's .NET Framework agent and .NET Core agent on Azure Service Fabric. This is not the same as installing the Infrastructure integrations for Microsoft Azure. Install .NET agent on Azure Service Fabric Important In most cases, installing the .NET agent in an Azure Service Fabric environment can be performed using the standard install procedures for either Windows or Linux. This document highlights some alternate ways you can install the agent. You will need to ensure the agent gets installed on all nodes in your cluster. To monitor multiple nodes, you may want to integrate the install into your deployment process. If you are using containers in your Service Fabric environment you should read Install for Docker. You can also install the agent in a Service Fabric environment using NuGet. NuGet is often a good option for developers because the agent gets deployed along with your application. Though, using NuGet requires some manual installation procedures. See Install with NuGet. Install using NuGet To install the .NET agent using NuGet: Follow the standard NuGet install procedures. When using NuGet, you must set some environment variables. This can be done in your application's ServiceManifest.xml file. See the relevant instructions below: .NET Framework In the ServiceManifest.xml file in your project, include the following under the CodePackage node: <CodePackage Name=\"Code\" Version=\"1.0.0\"> </CodePackage> <CodePackage> ... <EntryPoint> <ExeHost> ... <!-- It is important for the WorkingFolder to be set to CodePackage --> <!-- This is because the environment variables set below rely on this being the working folder for the agent to work --> <WorkingFolder>CodePackage</WorkingFolder> ... </ExeHost> </EntryPoint> ... <EnvironmentVariables> ... <EnvironmentVariable Name=\"COR_ENABLE_PROFILING\" Value=\"1\" /> <EnvironmentVariable Name=\"COR_PROFILER\" Value=\"{71DA0A04-7777-4EC6-9643-7D28B46A8A41}\" /> <EnvironmentVariable Name=\"COR_PROFILER_PATH\" Value=\".\\newrelic\\NewRelic.Profiler.dll\" /> <EnvironmentVariable Name=\"NEWRELIC_HOME\" Value=\".\\newrelic\" /> <EnvironmentVariable Name=\"NEW_RELIC_LICENSE_KEY\" Value=\"YOUR_LICENSE_KEY\" /> <EnvironmentVariable Name=\"NEW_RELIC_APP_NAME\" Value=\"YOUR_APP_NAME\" /> ... </EnvironmentVariables> ... </CodePackage> Copy .NET Core for Windows In the ServiceManifest.xml file in your project, include the following under the CodePackage node: <CodePackage> ... <EntryPoint> <ExeHost> ... <!-- It is important for the WorkingFolder to be set to CodePackage --> <!-- This is because the environment variables set below rely on this being the working folder for the agent to work --> <WorkingFolder>CodePackage</WorkingFolder> ... </ExeHost> </EntryPoint> ... <EnvironmentVariables> ... <EnvironmentVariable Name=\"CORECLR_ENABLE_PROFILING\" Value=\"1\" /> <EnvironmentVariable Name=\"CORECLR_PROFILER\" Value=\"{36032161-FFC0-4B61-B559-F6C5D41BAE5A}\" /> <EnvironmentVariable Name=\"CORECLR_PROFILER_PATH\" Value=\".\\newrelic\\NewRelic.Profiler.dll\" /> <EnvironmentVariable Name=\"CORECLR_NEWRELIC_HOME\" Value=\".\\newrelic\" /> <EnvironmentVariable Name=\"NEW_RELIC_LICENSE_KEY\" Value=\"YOUR_LICENSE_KEY\" /> <EnvironmentVariable Name=\"NEW_RELIC_APP_NAME\" Value=\"YOUR_APP_NAME\" /> ... </EnvironmentVariables> ... </CodePackage> Copy .NET Core for Linux In the ServiceManifest.xml file in your project, include the following under the CodePackage node: <CodePackage> ... <EntryPoint> <ExeHost> ... <!-- It is important for the WorkingFolder to be set to CodePackage --> <!-- This is because the environment variables set below rely on this being the working folder for the agent to work --> <WorkingFolder>CodePackage</WorkingFolder> ... </ExeHost> </EntryPoint> ... <EnvironmentVariables> ... <EnvironmentVariable Name=\"CORECLR_ENABLE_PROFILING\" Value=\"1\" /> <EnvironmentVariable Name=\"CORECLR_PROFILER\" Value=\"{36032161-FFC0-4B61-B559-F6C5D41BAE5A}\" /> <EnvironmentVariable Name=\"CORECLR_PROFILER_PATH\" Value=\"./newrelic/libNewRelicProfiler.so\" /> <EnvironmentVariable Name=\"CORECLR_NEWRELIC_HOME\" Value=\"./newrelic\" /> <EnvironmentVariable Name=\"NEW_RELIC_LICENSE_KEY\" Value=\"YOUR_LICENSE_KEY\" /> <EnvironmentVariable Name=\"NEW_RELIC_APP_NAME\" Value=\"YOUR_APP_NAME\" /> ... </EnvironmentVariables> ... </CodePackage> Copy For the .NET Framework only: Edit your app.config file and add the NewRelic.AgentEnabled app setting: <appSettings> ... <add key=\"NewRelic.AgentEnabled\" value=\"true\" /> ... </appSettings> Copy If your application is generating traffic, data should appear in your APM account in several minutes. If data does not appear, try these troubleshooting steps: Make sure that all files in the newrelic directory at the root of your app was published to Azure. Make sure the environment variables are set correctly. See the general troubleshooting documentation to check for common errors.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 111.68245,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> .<em>NET</em> <em>agent</em> on <em>Azure</em> Service Fabric",
        "sections": "<em>Install</em> .<em>NET</em> <em>agent</em> on <em>Azure</em> Service Fabric",
        "tags": "<em>Azure</em> <em>installation</em>",
        "body": "This document explains how to install APM&#x27;s .<em>NET</em> Framework <em>agent</em> and .<em>NET</em> Core <em>agent</em> on <em>Azure</em> Service Fabric. This is not the same as installing the Infrastructure integrations for Microsoft <em>Azure</em>. Install .<em>NET</em> <em>agent</em> on <em>Azure</em> Service Fabric Important In most cases, installing the .<em>NET</em> <em>agent</em>"
      },
      "id": "6043c8a6e7b9d24fa25799bc"
    }
  ],
  "/docs/agents/net-agent/azure-troubleshooting/azure-cloud-services-no-data-appears": [
    {
      "sections": [
        "No data reporting with Microsoft Application Insights",
        "Problem",
        "Solution"
      ],
      "title": "No data reporting with Microsoft Application Insights",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure troubleshooting"
      ],
      "external_id": "1b022bab6a2b6e99972745182dcd4340be20bc3f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-troubleshooting/no-data-reporting-microsoft-application-insights/",
      "published_at": "2021-05-05T09:36:44Z",
      "updated_at": "2021-04-15T22:32:46Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Problem The .NET agent has been installed and the required App Settings are set, but no data appears, and no New Relic logs are created in D:\\Home\\Logfiles\\NewRelic\\. In addition, when you use the Azure Kudu console's Process Explorer to inspect your application's Environment Variables, it shows the COR_PROFILER_PATH_64 and COR_PROFILER_PATH_32 are set and pointing to the following: D:\\Program Files (x86)\\SiteExtensions\\InstrumentationEngine\\1.0.19\\Instrumentation64\\MicrosoftInstrumentationEngine_x64.dll Copy Solution The .NET Common Language Runtime (CLR) only allows one profiler. If Microsoft's Application Insights profiler is installed on the system, the New Relic profiler will not instrument any applications, and no data will appear. For more information, see the Microsoft Azure Web Apps documentation. To resolve this issue, remove or disable Application Insights from your application. To remove the Application Insights Site Extension: Remove all settings related to Application Insights from Application > Settings > Application Settings and Save. This may include the following keys: Any key that begins with APPINSIGHTS_ Any key that begins with APPLICATIONINSIGHTS_ Any key that begins with XDT_MicrosoftApplicationInsights_ DiagnosticServices_EXTENSION_VERSION InstrumentationEngine_EXTENSION_VERSION Remove the extension from Application > Tools > Extensions. Right-click the extension and Delete. Remove the Tile Add-On from your Application Panel (if present). Restart your application. To disable Application Insights through the Azure Portal: Go to the Application Insights panel under the Settings. This may restart your app.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 132.31233,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Azure</em> <em>troubleshooting</em>",
        "body": "Problem The .<em>NET</em> <em>agent</em> has been installed and the required App Settings are set, but no data appears, and no New Relic logs are created in D:\\Home\\Logfiles\\NewRelic\\. In addition, when you use the <em>Azure</em> Kudu console&#x27;s Process Explorer to inspect your application&#x27;s Environment Variables, it shows"
      },
      "id": "6043d56328ccbcd70e2c609a"
    },
    {
      "sections": [
        "Azure Web Apps: Using Always On and no data appears",
        "Important",
        "Problem",
        "Cause",
        "Solution",
        "Other options",
        "Use Kudu to name your app.",
        "Use app/web.config to name your app.",
        "Use Synthetic monitoring to monitor your website."
      ],
      "title": "Azure Web Apps: Using Always On and no data appears",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure troubleshooting"
      ],
      "external_id": "15dfcc0c2baf705da5a4fdcc4773307d31285be6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-troubleshooting/azure-web-apps-using-always-no-data-appears/",
      "published_at": "2021-05-05T09:36:45Z",
      "updated_at": "2021-03-13T02:45:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important Beginning with .NET agent version 8.22.181.0, Azure's Always On setting may be enabled without interfering with the agent. If you'd like to use Always On, simply update the agent. If your application targets .NET Framework 4.0 or lower, Always On will still interfere with the agent and the workarounds below are still applicable. Problem You installed New Relic's .NET agent through Microsoft Azure Web Apps and are using Azure's Always On setting. After generating some traffic and waiting a few minutes for data collection to start for your app, data still does not appear in the APM user interface. Cause If no data appears within five minutes, Azure's Always On setting may be conflicting with New Relic. This feature is only available in Azure's Basic and Standard modes. The Always On setting prevents the environment variable APP_POOL_ID from being set. New Relic's .NET agent needs this environment variable to get the app name. If the agent cannot determine an application name, then it won't start up. Solution If you are using Microsoft's Standard or Basic tiers with the Azure Portal, ensure that the Always On setting is disabled. In the Azure Portal, select (your app) > Settings > Application Settings. Set the Always On toggle to Off. Other options Here are some other options you can try. If these do not work, you must turn off the Always On setting. Use Kudu to name your app. To name your application in the local newrelic.config using Kudu: From the Microsoft Azure Portal, select (your app) > Tools > Kudu, then select Go. Select Debug Console > CMD. Select Site > wwwroot > newrelic. Select the edit icon for newrelic.config, and add: <application> <name> Your app's name </name> </application> Copy Save and restart your application. Use app/web.config to name your app. Important This option has been found to only be a temporary fix. The .NET agent may stop reporting intermittently. To name your application in its app/web.config file: Add the following key to appSettings: <appSettings> <add key=\"NewRelic.AppName\" value=\"Your app's name\" /> </appSettings> Copy Restart your instance. Use Synthetic monitoring to monitor your website. Depending on your usage of Always On, you can try using Synthetic monitoring to keep your website active. If you are not using the Always On setting, you can try using the Synthetic monitoring free pinger monitor. If you are using the Always On setting, Synthetic monitoring needs to be able to reach an endpoint for your worker roles. If it can't, you can try using a Synthetics scripted monitor to run on your site.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.051186,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Azure</em> Web Apps: Using Always On and no data appears",
        "sections": "<em>Azure</em> Web Apps: Using Always On and no data appears",
        "tags": "<em>Azure</em> <em>troubleshooting</em>",
        "body": "Important Beginning with .<em>NET</em> <em>agent</em> version 8.22.181.0, <em>Azure</em>&#x27;s Always On setting may be enabled without interfering with the <em>agent</em>. If you&#x27;d like to use Always On, simply update the <em>agent</em>. If your application targets .<em>NET</em> Framework 4.0 or lower, Always On will still interfere with the <em>agent</em>"
      },
      "id": "6043b800e7b9d227235799ea"
    },
    {
      "sections": [
        "Azure Web Apps: Profiler .dll locks during deployment",
        "Problem",
        "Solution",
        "Stop the file from releasing",
        "Use the New Relic Site Extension"
      ],
      "title": "Azure Web Apps: Profiler .dll locks during deployment",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure troubleshooting"
      ],
      "external_id": "d7453c93ccf14de7be798dc0571d18118d82a4fc",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-troubleshooting/azure-web-apps-profiler-dll-locks-during-deployment/",
      "published_at": "2021-05-05T09:36:44Z",
      "updated_at": "2021-03-13T05:37:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Problem When deploying a new version of New Relic's .NET agent (NewRelic.Profiler.dll) for your Microsoft Azure Web App, an error message prevents you from continuing until you stop or restart the process. Solution Normally the process stops, then the assets are overwritten by the assets that New Relic packs in the site root (located at D:\\Home\\site\\wwwroot\\newrelic) during a deployment. To resolve the problem, try either of these solutions. Stop the file from releasing This solution is available for your Azure Web App if you are attempting to deploy a new .NET agent version over an existing version: Stop your web app to release the .dll file. Allow the update to proceed. Once the deploy is complete, restart the instance. Use the New Relic Site Extension You can install New Relic's .NET agent into your Azure Web App by using the New Relic Site Extension. (You should only need to install the extension once.) Navigate to https : //yoursite.scm.azurewebsites.net/ and select Site Extensions. From the Gallery, select the add icon, then select New Relic. Follow the instructions to manually add the configuration keys to your web app, and use the option that best fits your needs. To update the Site Extension: From the Azure Portal, select WebApps > (select your site) > All Settings > Extensions > New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.041855,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Azure</em> Web Apps: Profiler .dll locks during deployment",
        "sections": "<em>Azure</em> Web Apps: Profiler .dll locks during deployment",
        "tags": "<em>Azure</em> <em>troubleshooting</em>",
        "body": "Problem When deploying a new version of New Relic&#x27;s .<em>NET</em> <em>agent</em> (NewRelic.Profiler.dll) for your Microsoft <em>Azure</em> Web App, an error message prevents you from continuing until you stop or restart the process. Solution Normally the process stops, then the assets are overwritten by the assets that New"
      },
      "id": "6043b9c8196a678a1e960f5a"
    }
  ],
  "/docs/agents/net-agent/azure-troubleshooting/azure-web-apps-profiler-dll-locks-during-deployment": [
    {
      "sections": [
        "No data reporting with Microsoft Application Insights",
        "Problem",
        "Solution"
      ],
      "title": "No data reporting with Microsoft Application Insights",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure troubleshooting"
      ],
      "external_id": "1b022bab6a2b6e99972745182dcd4340be20bc3f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-troubleshooting/no-data-reporting-microsoft-application-insights/",
      "published_at": "2021-05-05T09:36:44Z",
      "updated_at": "2021-04-15T22:32:46Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Problem The .NET agent has been installed and the required App Settings are set, but no data appears, and no New Relic logs are created in D:\\Home\\Logfiles\\NewRelic\\. In addition, when you use the Azure Kudu console's Process Explorer to inspect your application's Environment Variables, it shows the COR_PROFILER_PATH_64 and COR_PROFILER_PATH_32 are set and pointing to the following: D:\\Program Files (x86)\\SiteExtensions\\InstrumentationEngine\\1.0.19\\Instrumentation64\\MicrosoftInstrumentationEngine_x64.dll Copy Solution The .NET Common Language Runtime (CLR) only allows one profiler. If Microsoft's Application Insights profiler is installed on the system, the New Relic profiler will not instrument any applications, and no data will appear. For more information, see the Microsoft Azure Web Apps documentation. To resolve this issue, remove or disable Application Insights from your application. To remove the Application Insights Site Extension: Remove all settings related to Application Insights from Application > Settings > Application Settings and Save. This may include the following keys: Any key that begins with APPINSIGHTS_ Any key that begins with APPLICATIONINSIGHTS_ Any key that begins with XDT_MicrosoftApplicationInsights_ DiagnosticServices_EXTENSION_VERSION InstrumentationEngine_EXTENSION_VERSION Remove the extension from Application > Tools > Extensions. Right-click the extension and Delete. Remove the Tile Add-On from your Application Panel (if present). Restart your application. To disable Application Insights through the Azure Portal: Go to the Application Insights panel under the Settings. This may restart your app.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 132.31233,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Azure</em> <em>troubleshooting</em>",
        "body": "Problem The .<em>NET</em> <em>agent</em> has been installed and the required App Settings are set, but no data appears, and no New Relic logs are created in D:\\Home\\Logfiles\\NewRelic\\. In addition, when you use the <em>Azure</em> Kudu console&#x27;s Process Explorer to inspect your application&#x27;s Environment Variables, it shows"
      },
      "id": "6043d56328ccbcd70e2c609a"
    },
    {
      "sections": [
        "Azure Web Apps: Using Always On and no data appears",
        "Important",
        "Problem",
        "Cause",
        "Solution",
        "Other options",
        "Use Kudu to name your app.",
        "Use app/web.config to name your app.",
        "Use Synthetic monitoring to monitor your website."
      ],
      "title": "Azure Web Apps: Using Always On and no data appears",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure troubleshooting"
      ],
      "external_id": "15dfcc0c2baf705da5a4fdcc4773307d31285be6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-troubleshooting/azure-web-apps-using-always-no-data-appears/",
      "published_at": "2021-05-05T09:36:45Z",
      "updated_at": "2021-03-13T02:45:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important Beginning with .NET agent version 8.22.181.0, Azure's Always On setting may be enabled without interfering with the agent. If you'd like to use Always On, simply update the agent. If your application targets .NET Framework 4.0 or lower, Always On will still interfere with the agent and the workarounds below are still applicable. Problem You installed New Relic's .NET agent through Microsoft Azure Web Apps and are using Azure's Always On setting. After generating some traffic and waiting a few minutes for data collection to start for your app, data still does not appear in the APM user interface. Cause If no data appears within five minutes, Azure's Always On setting may be conflicting with New Relic. This feature is only available in Azure's Basic and Standard modes. The Always On setting prevents the environment variable APP_POOL_ID from being set. New Relic's .NET agent needs this environment variable to get the app name. If the agent cannot determine an application name, then it won't start up. Solution If you are using Microsoft's Standard or Basic tiers with the Azure Portal, ensure that the Always On setting is disabled. In the Azure Portal, select (your app) > Settings > Application Settings. Set the Always On toggle to Off. Other options Here are some other options you can try. If these do not work, you must turn off the Always On setting. Use Kudu to name your app. To name your application in the local newrelic.config using Kudu: From the Microsoft Azure Portal, select (your app) > Tools > Kudu, then select Go. Select Debug Console > CMD. Select Site > wwwroot > newrelic. Select the edit icon for newrelic.config, and add: <application> <name> Your app's name </name> </application> Copy Save and restart your application. Use app/web.config to name your app. Important This option has been found to only be a temporary fix. The .NET agent may stop reporting intermittently. To name your application in its app/web.config file: Add the following key to appSettings: <appSettings> <add key=\"NewRelic.AppName\" value=\"Your app's name\" /> </appSettings> Copy Restart your instance. Use Synthetic monitoring to monitor your website. Depending on your usage of Always On, you can try using Synthetic monitoring to keep your website active. If you are not using the Always On setting, you can try using the Synthetic monitoring free pinger monitor. If you are using the Always On setting, Synthetic monitoring needs to be able to reach an endpoint for your worker roles. If it can't, you can try using a Synthetics scripted monitor to run on your site.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.051186,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Azure</em> Web Apps: Using Always On and no data appears",
        "sections": "<em>Azure</em> Web Apps: Using Always On and no data appears",
        "tags": "<em>Azure</em> <em>troubleshooting</em>",
        "body": "Important Beginning with .<em>NET</em> <em>agent</em> version 8.22.181.0, <em>Azure</em>&#x27;s Always On setting may be enabled without interfering with the <em>agent</em>. If you&#x27;d like to use Always On, simply update the <em>agent</em>. If your application targets .<em>NET</em> Framework 4.0 or lower, Always On will still interfere with the <em>agent</em>"
      },
      "id": "6043b800e7b9d227235799ea"
    },
    {
      "sections": [
        "Azure Cloud Services: No data appears",
        "Problem",
        "Solution"
      ],
      "title": "Azure Cloud Services: No data appears",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure troubleshooting"
      ],
      "external_id": "02ccb0a4315ac400995631f6b1967b5581548183",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-troubleshooting/azure-cloud-services-no-data-appears/",
      "published_at": "2021-05-05T09:36:45Z",
      "updated_at": "2021-03-13T02:47:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Problem You installed New Relic's .NET agent through Microsoft Azure Cloud Services, and then you installed the NuGet package. After generating some traffic and waiting a few minutes for data to start being collected for your app, data still does not appear in the APM user interface. Solution In order for the .NET agent to start up and attach to your app, at least one metric must be collected. If you have an external call or database call that New Relic instruments, then your app will report data to your APM Summary page. In addition, information about external calls will appear on your app's Service maps. Without custom instrumentation, Worker roles only report database calls and external calls. (Instrumenting a Worker Role is similar to instrumenting a custom application.) To view other details, you must gather custom metrics using New Relic's .NET API and view them in a custom dashboard.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.01046,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Azure</em> Cloud Services: No data appears",
        "sections": "<em>Azure</em> Cloud Services: No data appears",
        "tags": "<em>Azure</em> <em>troubleshooting</em>",
        "body": "Problem You installed New Relic&#x27;s .<em>NET</em> <em>agent</em> through Microsoft <em>Azure</em> Cloud Services, and then you installed the NuGet package. After generating some traffic and waiting a few minutes for data to start being collected for your app, data still does not appear in the APM user interface. Solution"
      },
      "id": "6043b66c28ccbc6f972d759d"
    }
  ],
  "/docs/agents/net-agent/azure-troubleshooting/azure-web-apps-unable-open-log-file": [
    {
      "sections": [
        "No data reporting with Microsoft Application Insights",
        "Problem",
        "Solution"
      ],
      "title": "No data reporting with Microsoft Application Insights",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure troubleshooting"
      ],
      "external_id": "1b022bab6a2b6e99972745182dcd4340be20bc3f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-troubleshooting/no-data-reporting-microsoft-application-insights/",
      "published_at": "2021-05-05T09:36:44Z",
      "updated_at": "2021-04-15T22:32:46Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Problem The .NET agent has been installed and the required App Settings are set, but no data appears, and no New Relic logs are created in D:\\Home\\Logfiles\\NewRelic\\. In addition, when you use the Azure Kudu console's Process Explorer to inspect your application's Environment Variables, it shows the COR_PROFILER_PATH_64 and COR_PROFILER_PATH_32 are set and pointing to the following: D:\\Program Files (x86)\\SiteExtensions\\InstrumentationEngine\\1.0.19\\Instrumentation64\\MicrosoftInstrumentationEngine_x64.dll Copy Solution The .NET Common Language Runtime (CLR) only allows one profiler. If Microsoft's Application Insights profiler is installed on the system, the New Relic profiler will not instrument any applications, and no data will appear. For more information, see the Microsoft Azure Web Apps documentation. To resolve this issue, remove or disable Application Insights from your application. To remove the Application Insights Site Extension: Remove all settings related to Application Insights from Application > Settings > Application Settings and Save. This may include the following keys: Any key that begins with APPINSIGHTS_ Any key that begins with APPLICATIONINSIGHTS_ Any key that begins with XDT_MicrosoftApplicationInsights_ DiagnosticServices_EXTENSION_VERSION InstrumentationEngine_EXTENSION_VERSION Remove the extension from Application > Tools > Extensions. Right-click the extension and Delete. Remove the Tile Add-On from your Application Panel (if present). Restart your application. To disable Application Insights through the Azure Portal: Go to the Application Insights panel under the Settings. This may restart your app.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 132.31232,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Azure</em> <em>troubleshooting</em>",
        "body": "Problem The .<em>NET</em> <em>agent</em> has been installed and the required App Settings are set, but no data appears, and no New Relic logs are created in D:\\Home\\Logfiles\\NewRelic\\. In addition, when you use the <em>Azure</em> Kudu console&#x27;s Process Explorer to inspect your application&#x27;s Environment Variables, it shows"
      },
      "id": "6043d56328ccbcd70e2c609a"
    },
    {
      "sections": [
        "Azure Web Apps: Using Always On and no data appears",
        "Important",
        "Problem",
        "Cause",
        "Solution",
        "Other options",
        "Use Kudu to name your app.",
        "Use app/web.config to name your app.",
        "Use Synthetic monitoring to monitor your website."
      ],
      "title": "Azure Web Apps: Using Always On and no data appears",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure troubleshooting"
      ],
      "external_id": "15dfcc0c2baf705da5a4fdcc4773307d31285be6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-troubleshooting/azure-web-apps-using-always-no-data-appears/",
      "published_at": "2021-05-05T09:36:45Z",
      "updated_at": "2021-03-13T02:45:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important Beginning with .NET agent version 8.22.181.0, Azure's Always On setting may be enabled without interfering with the agent. If you'd like to use Always On, simply update the agent. If your application targets .NET Framework 4.0 or lower, Always On will still interfere with the agent and the workarounds below are still applicable. Problem You installed New Relic's .NET agent through Microsoft Azure Web Apps and are using Azure's Always On setting. After generating some traffic and waiting a few minutes for data collection to start for your app, data still does not appear in the APM user interface. Cause If no data appears within five minutes, Azure's Always On setting may be conflicting with New Relic. This feature is only available in Azure's Basic and Standard modes. The Always On setting prevents the environment variable APP_POOL_ID from being set. New Relic's .NET agent needs this environment variable to get the app name. If the agent cannot determine an application name, then it won't start up. Solution If you are using Microsoft's Standard or Basic tiers with the Azure Portal, ensure that the Always On setting is disabled. In the Azure Portal, select (your app) > Settings > Application Settings. Set the Always On toggle to Off. Other options Here are some other options you can try. If these do not work, you must turn off the Always On setting. Use Kudu to name your app. To name your application in the local newrelic.config using Kudu: From the Microsoft Azure Portal, select (your app) > Tools > Kudu, then select Go. Select Debug Console > CMD. Select Site > wwwroot > newrelic. Select the edit icon for newrelic.config, and add: <application> <name> Your app's name </name> </application> Copy Save and restart your application. Use app/web.config to name your app. Important This option has been found to only be a temporary fix. The .NET agent may stop reporting intermittently. To name your application in its app/web.config file: Add the following key to appSettings: <appSettings> <add key=\"NewRelic.AppName\" value=\"Your app's name\" /> </appSettings> Copy Restart your instance. Use Synthetic monitoring to monitor your website. Depending on your usage of Always On, you can try using Synthetic monitoring to keep your website active. If you are not using the Always On setting, you can try using the Synthetic monitoring free pinger monitor. If you are using the Always On setting, Synthetic monitoring needs to be able to reach an endpoint for your worker roles. If it can't, you can try using a Synthetics scripted monitor to run on your site.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.05118,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Azure</em> Web Apps: Using Always On and no data appears",
        "sections": "<em>Azure</em> Web Apps: Using Always On and no data appears",
        "tags": "<em>Azure</em> <em>troubleshooting</em>",
        "body": "Important Beginning with .<em>NET</em> <em>agent</em> version 8.22.181.0, <em>Azure</em>&#x27;s Always On setting may be enabled without interfering with the <em>agent</em>. If you&#x27;d like to use Always On, simply update the <em>agent</em>. If your application targets .<em>NET</em> Framework 4.0 or lower, Always On will still interfere with the <em>agent</em>"
      },
      "id": "6043b800e7b9d227235799ea"
    },
    {
      "sections": [
        "Azure Web Apps: Profiler .dll locks during deployment",
        "Problem",
        "Solution",
        "Stop the file from releasing",
        "Use the New Relic Site Extension"
      ],
      "title": "Azure Web Apps: Profiler .dll locks during deployment",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure troubleshooting"
      ],
      "external_id": "d7453c93ccf14de7be798dc0571d18118d82a4fc",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-troubleshooting/azure-web-apps-profiler-dll-locks-during-deployment/",
      "published_at": "2021-05-05T09:36:44Z",
      "updated_at": "2021-03-13T05:37:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Problem When deploying a new version of New Relic's .NET agent (NewRelic.Profiler.dll) for your Microsoft Azure Web App, an error message prevents you from continuing until you stop or restart the process. Solution Normally the process stops, then the assets are overwritten by the assets that New Relic packs in the site root (located at D:\\Home\\site\\wwwroot\\newrelic) during a deployment. To resolve the problem, try either of these solutions. Stop the file from releasing This solution is available for your Azure Web App if you are attempting to deploy a new .NET agent version over an existing version: Stop your web app to release the .dll file. Allow the update to proceed. Once the deploy is complete, restart the instance. Use the New Relic Site Extension You can install New Relic's .NET agent into your Azure Web App by using the New Relic Site Extension. (You should only need to install the extension once.) Navigate to https : //yoursite.scm.azurewebsites.net/ and select Site Extensions. From the Gallery, select the add icon, then select New Relic. Follow the instructions to manually add the configuration keys to your web app, and use the option that best fits your needs. To update the Site Extension: From the Azure Portal, select WebApps > (select your site) > All Settings > Extensions > New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.04185,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Azure</em> Web Apps: Profiler .dll locks during deployment",
        "sections": "<em>Azure</em> Web Apps: Profiler .dll locks during deployment",
        "tags": "<em>Azure</em> <em>troubleshooting</em>",
        "body": "Problem When deploying a new version of New Relic&#x27;s .<em>NET</em> <em>agent</em> (NewRelic.Profiler.dll) for your Microsoft <em>Azure</em> Web App, an error message prevents you from continuing until you stop or restart the process. Solution Normally the process stops, then the assets are overwritten by the assets that New"
      },
      "id": "6043b9c8196a678a1e960f5a"
    }
  ],
  "/docs/agents/net-agent/azure-troubleshooting/azure-web-apps-using-always-no-data-appears": [
    {
      "sections": [
        "No data reporting with Microsoft Application Insights",
        "Problem",
        "Solution"
      ],
      "title": "No data reporting with Microsoft Application Insights",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure troubleshooting"
      ],
      "external_id": "1b022bab6a2b6e99972745182dcd4340be20bc3f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-troubleshooting/no-data-reporting-microsoft-application-insights/",
      "published_at": "2021-05-05T09:36:44Z",
      "updated_at": "2021-04-15T22:32:46Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Problem The .NET agent has been installed and the required App Settings are set, but no data appears, and no New Relic logs are created in D:\\Home\\Logfiles\\NewRelic\\. In addition, when you use the Azure Kudu console's Process Explorer to inspect your application's Environment Variables, it shows the COR_PROFILER_PATH_64 and COR_PROFILER_PATH_32 are set and pointing to the following: D:\\Program Files (x86)\\SiteExtensions\\InstrumentationEngine\\1.0.19\\Instrumentation64\\MicrosoftInstrumentationEngine_x64.dll Copy Solution The .NET Common Language Runtime (CLR) only allows one profiler. If Microsoft's Application Insights profiler is installed on the system, the New Relic profiler will not instrument any applications, and no data will appear. For more information, see the Microsoft Azure Web Apps documentation. To resolve this issue, remove or disable Application Insights from your application. To remove the Application Insights Site Extension: Remove all settings related to Application Insights from Application > Settings > Application Settings and Save. This may include the following keys: Any key that begins with APPINSIGHTS_ Any key that begins with APPLICATIONINSIGHTS_ Any key that begins with XDT_MicrosoftApplicationInsights_ DiagnosticServices_EXTENSION_VERSION InstrumentationEngine_EXTENSION_VERSION Remove the extension from Application > Tools > Extensions. Right-click the extension and Delete. Remove the Tile Add-On from your Application Panel (if present). Restart your application. To disable Application Insights through the Azure Portal: Go to the Application Insights panel under the Settings. This may restart your app.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 132.31232,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Azure</em> <em>troubleshooting</em>",
        "body": "Problem The .<em>NET</em> <em>agent</em> has been installed and the required App Settings are set, but no data appears, and no New Relic logs are created in D:\\Home\\Logfiles\\NewRelic\\. In addition, when you use the <em>Azure</em> Kudu console&#x27;s Process Explorer to inspect your application&#x27;s Environment Variables, it shows"
      },
      "id": "6043d56328ccbcd70e2c609a"
    },
    {
      "sections": [
        "Azure Web Apps: Profiler .dll locks during deployment",
        "Problem",
        "Solution",
        "Stop the file from releasing",
        "Use the New Relic Site Extension"
      ],
      "title": "Azure Web Apps: Profiler .dll locks during deployment",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure troubleshooting"
      ],
      "external_id": "d7453c93ccf14de7be798dc0571d18118d82a4fc",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-troubleshooting/azure-web-apps-profiler-dll-locks-during-deployment/",
      "published_at": "2021-05-05T09:36:44Z",
      "updated_at": "2021-03-13T05:37:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Problem When deploying a new version of New Relic's .NET agent (NewRelic.Profiler.dll) for your Microsoft Azure Web App, an error message prevents you from continuing until you stop or restart the process. Solution Normally the process stops, then the assets are overwritten by the assets that New Relic packs in the site root (located at D:\\Home\\site\\wwwroot\\newrelic) during a deployment. To resolve the problem, try either of these solutions. Stop the file from releasing This solution is available for your Azure Web App if you are attempting to deploy a new .NET agent version over an existing version: Stop your web app to release the .dll file. Allow the update to proceed. Once the deploy is complete, restart the instance. Use the New Relic Site Extension You can install New Relic's .NET agent into your Azure Web App by using the New Relic Site Extension. (You should only need to install the extension once.) Navigate to https : //yoursite.scm.azurewebsites.net/ and select Site Extensions. From the Gallery, select the add icon, then select New Relic. Follow the instructions to manually add the configuration keys to your web app, and use the option that best fits your needs. To update the Site Extension: From the Azure Portal, select WebApps > (select your site) > All Settings > Extensions > New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.04185,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Azure</em> Web Apps: Profiler .dll locks during deployment",
        "sections": "<em>Azure</em> Web Apps: Profiler .dll locks during deployment",
        "tags": "<em>Azure</em> <em>troubleshooting</em>",
        "body": "Problem When deploying a new version of New Relic&#x27;s .<em>NET</em> <em>agent</em> (NewRelic.Profiler.dll) for your Microsoft <em>Azure</em> Web App, an error message prevents you from continuing until you stop or restart the process. Solution Normally the process stops, then the assets are overwritten by the assets that New"
      },
      "id": "6043b9c8196a678a1e960f5a"
    },
    {
      "sections": [
        "Azure Cloud Services: No data appears",
        "Problem",
        "Solution"
      ],
      "title": "Azure Cloud Services: No data appears",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure troubleshooting"
      ],
      "external_id": "02ccb0a4315ac400995631f6b1967b5581548183",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-troubleshooting/azure-cloud-services-no-data-appears/",
      "published_at": "2021-05-05T09:36:45Z",
      "updated_at": "2021-03-13T02:47:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Problem You installed New Relic's .NET agent through Microsoft Azure Cloud Services, and then you installed the NuGet package. After generating some traffic and waiting a few minutes for data to start being collected for your app, data still does not appear in the APM user interface. Solution In order for the .NET agent to start up and attach to your app, at least one metric must be collected. If you have an external call or database call that New Relic instruments, then your app will report data to your APM Summary page. In addition, information about external calls will appear on your app's Service maps. Without custom instrumentation, Worker roles only report database calls and external calls. (Instrumenting a Worker Role is similar to instrumenting a custom application.) To view other details, you must gather custom metrics using New Relic's .NET API and view them in a custom dashboard.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.01046,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Azure</em> Cloud Services: No data appears",
        "sections": "<em>Azure</em> Cloud Services: No data appears",
        "tags": "<em>Azure</em> <em>troubleshooting</em>",
        "body": "Problem You installed New Relic&#x27;s .<em>NET</em> <em>agent</em> through Microsoft <em>Azure</em> Cloud Services, and then you installed the NuGet package. After generating some traffic and waiting a few minutes for data to start being collected for your app, data still does not appear in the APM user interface. Solution"
      },
      "id": "6043b66c28ccbc6f972d759d"
    }
  ]
}