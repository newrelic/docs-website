{
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/start-interaction": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-10-24T16:17:45Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 356.33704,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "setMaxEventPoolSize (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Important",
        "Parameters",
        "Return values",
        "Examples",
        "Set maximum size of event pool to 1000"
      ],
      "title": "setMaxEventPoolSize (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "16019f6e7ab593733c87c9dc1831ff9ffa11dbb8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/set-max-event-pool-size/",
      "published_at": "2021-10-24T17:46:32Z",
      "updated_at": "2021-09-27T15:51:59Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.setMaxEventPoolSize(int $maxSize) Copy Sets the maximum size of the event pool. Requirements Agent version 5.0.0 or higher. Description By default, mobile monitoring collects a maximum of 1,000 events per event harvest cycle, which is 600 seconds long by default. This method controls the maximum size of the event pool stored in the memory until the next harvest cycle. When the pool size limit is reached, the New Relic Android agent will begin sampling events, discarding some old and some new events, until the pool of events are transmitted with the next harvest cycle. This method lets you override the maximum size of that event pool. When the pool size limit is reached, the New Relic Android agent will begin sampling events, discarding some old and some new events, until the pool of events are transmitted with the next harvest cycle. The default value for the event harvest cycle is 600 seconds. See also setMaxEventBufferTime(), which lets you change the length of the event harvest cycle. Important Be aware that reporting a large number of events, or reporting events too frequently, may impact app performance. For context on how to use this API, see Send custom attributes and events to Insights. Parameters Parameter Description $maxSize int Required. Maximum size of event pool. Return values Returns true if it succeeds, or false if it doesn't. Examples Set maximum size of event pool to 1000 boolean poolSizeSet = NewRelic.setMaxEventPoolSize(1000); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 185.83524,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setMaxEventPoolSize (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "setMaxEventPoolSize (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.setMaxEventPoolSize(int $maxSize) Copy Sets the maximum size of the event pool. Requirements Agent version 5.0.0 or higher. Description By default, <em>mobile</em> <em>monitoring</em> collects a maximum of 1,000 events per event harvest cycle, which is 600 seconds long by default. This method"
      },
      "id": "603ea0ea28ccbce4f4eba760"
    },
    {
      "sections": [
        "setMaxEventBufferTime (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Important",
        "Parameters",
        "Return values",
        "Examples",
        "Set max event buffer time to 300 seconds"
      ],
      "title": "setMaxEventBufferTime (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "bef23b1df5e20829e7d8fa83463cdba530aefd4f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/set-max-event-buffer-time/",
      "published_at": "2021-10-24T16:11:37Z",
      "updated_at": "2021-09-27T15:50:50Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.setMaxEventBufferTime(int $maxBufferTimeInSec) Copy Sets the event harvest cycle length. Requirements Agent version 5.0.0 or higher. Description This method sets the maximum time in seconds that the New Relic Android agent will store events in memory before including the buffered event to be sent to New Relic in the next harvest cycle. Default is 600 seconds (10 minutes). Minimum value cannot be less than 60 seconds. Maximum value should not be greater than 600 seconds. In other words, when the oldest event timestamp exceeds this custom configured time, the agent transmits the buffered content at the harvest cycle between each connection from a New Relic agent to the collector. See also setMaxEventPoolSize(), which sets the maximum number of events that are stored by the agent during a harvest cycle. Important Be aware that reporting a large number of events, or reporting events too frequently, may impact app performance. For context on how to use this API, see Send custom attributes and events to Insights. Parameters Parameter Description $maxBufferTimeInSec int Required. The maximum time (in seconds) that the agent should store events in memory. The default value harvest cycle length is 600 seconds. Return values Returns true if it succeeds, or false if it doesn't. Examples Set max event buffer time to 300 seconds boolean fiveMinuteLimitSet = NewRelic.setMaxEventBufferTime(300); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 185.8342,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setMaxEventBufferTime (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "setMaxEventBufferTime (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.setMaxEventBufferTime(int $maxBufferTimeInSec) Copy Sets the event harvest cycle length. Requirements Agent version 5.0.0 or higher. Description This method sets the maximum time in seconds that the <em>New</em> <em>Relic</em> <em>Android</em> agent will store events in memory before including the buffered"
      },
      "id": "603ea0af64441ff7fe4e8853"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/with-application-build": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-10-24T16:17:45Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 356.33704,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "setMaxEventPoolSize (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Important",
        "Parameters",
        "Return values",
        "Examples",
        "Set maximum size of event pool to 1000"
      ],
      "title": "setMaxEventPoolSize (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "16019f6e7ab593733c87c9dc1831ff9ffa11dbb8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/set-max-event-pool-size/",
      "published_at": "2021-10-24T17:46:32Z",
      "updated_at": "2021-09-27T15:51:59Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.setMaxEventPoolSize(int $maxSize) Copy Sets the maximum size of the event pool. Requirements Agent version 5.0.0 or higher. Description By default, mobile monitoring collects a maximum of 1,000 events per event harvest cycle, which is 600 seconds long by default. This method controls the maximum size of the event pool stored in the memory until the next harvest cycle. When the pool size limit is reached, the New Relic Android agent will begin sampling events, discarding some old and some new events, until the pool of events are transmitted with the next harvest cycle. This method lets you override the maximum size of that event pool. When the pool size limit is reached, the New Relic Android agent will begin sampling events, discarding some old and some new events, until the pool of events are transmitted with the next harvest cycle. The default value for the event harvest cycle is 600 seconds. See also setMaxEventBufferTime(), which lets you change the length of the event harvest cycle. Important Be aware that reporting a large number of events, or reporting events too frequently, may impact app performance. For context on how to use this API, see Send custom attributes and events to Insights. Parameters Parameter Description $maxSize int Required. Maximum size of event pool. Return values Returns true if it succeeds, or false if it doesn't. Examples Set maximum size of event pool to 1000 boolean poolSizeSet = NewRelic.setMaxEventPoolSize(1000); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 185.83524,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setMaxEventPoolSize (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "setMaxEventPoolSize (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.setMaxEventPoolSize(int $maxSize) Copy Sets the maximum size of the event pool. Requirements Agent version 5.0.0 or higher. Description By default, <em>mobile</em> <em>monitoring</em> collects a maximum of 1,000 events per event harvest cycle, which is 600 seconds long by default. This method"
      },
      "id": "603ea0ea28ccbce4f4eba760"
    },
    {
      "sections": [
        "setMaxEventBufferTime (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Important",
        "Parameters",
        "Return values",
        "Examples",
        "Set max event buffer time to 300 seconds"
      ],
      "title": "setMaxEventBufferTime (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "bef23b1df5e20829e7d8fa83463cdba530aefd4f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/set-max-event-buffer-time/",
      "published_at": "2021-10-24T16:11:37Z",
      "updated_at": "2021-09-27T15:50:50Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.setMaxEventBufferTime(int $maxBufferTimeInSec) Copy Sets the event harvest cycle length. Requirements Agent version 5.0.0 or higher. Description This method sets the maximum time in seconds that the New Relic Android agent will store events in memory before including the buffered event to be sent to New Relic in the next harvest cycle. Default is 600 seconds (10 minutes). Minimum value cannot be less than 60 seconds. Maximum value should not be greater than 600 seconds. In other words, when the oldest event timestamp exceeds this custom configured time, the agent transmits the buffered content at the harvest cycle between each connection from a New Relic agent to the collector. See also setMaxEventPoolSize(), which sets the maximum number of events that are stored by the agent during a harvest cycle. Important Be aware that reporting a large number of events, or reporting events too frequently, may impact app performance. For context on how to use this API, see Send custom attributes and events to Insights. Parameters Parameter Description $maxBufferTimeInSec int Required. The maximum time (in seconds) that the agent should store events in memory. The default value harvest cycle length is 600 seconds. Return values Returns true if it succeeds, or false if it doesn't. Examples Set max event buffer time to 300 seconds boolean fiveMinuteLimitSet = NewRelic.setMaxEventBufferTime(300); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 185.8342,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setMaxEventBufferTime (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "setMaxEventBufferTime (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.setMaxEventBufferTime(int $maxBufferTimeInSec) Copy Sets the event harvest cycle length. Requirements Agent version 5.0.0 or higher. Description This method sets the maximum time in seconds that the <em>New</em> <em>Relic</em> <em>Android</em> agent will store events in memory before including the buffered"
      },
      "id": "603ea0af64441ff7fe4e8853"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/with-application-version": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-10-24T16:17:45Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 356.3368,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "setMaxEventPoolSize (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Important",
        "Parameters",
        "Return values",
        "Examples",
        "Set maximum size of event pool to 1000"
      ],
      "title": "setMaxEventPoolSize (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "16019f6e7ab593733c87c9dc1831ff9ffa11dbb8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/set-max-event-pool-size/",
      "published_at": "2021-10-24T17:46:32Z",
      "updated_at": "2021-09-27T15:51:59Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.setMaxEventPoolSize(int $maxSize) Copy Sets the maximum size of the event pool. Requirements Agent version 5.0.0 or higher. Description By default, mobile monitoring collects a maximum of 1,000 events per event harvest cycle, which is 600 seconds long by default. This method controls the maximum size of the event pool stored in the memory until the next harvest cycle. When the pool size limit is reached, the New Relic Android agent will begin sampling events, discarding some old and some new events, until the pool of events are transmitted with the next harvest cycle. This method lets you override the maximum size of that event pool. When the pool size limit is reached, the New Relic Android agent will begin sampling events, discarding some old and some new events, until the pool of events are transmitted with the next harvest cycle. The default value for the event harvest cycle is 600 seconds. See also setMaxEventBufferTime(), which lets you change the length of the event harvest cycle. Important Be aware that reporting a large number of events, or reporting events too frequently, may impact app performance. For context on how to use this API, see Send custom attributes and events to Insights. Parameters Parameter Description $maxSize int Required. Maximum size of event pool. Return values Returns true if it succeeds, or false if it doesn't. Examples Set maximum size of event pool to 1000 boolean poolSizeSet = NewRelic.setMaxEventPoolSize(1000); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 185.8352,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setMaxEventPoolSize (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "setMaxEventPoolSize (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.setMaxEventPoolSize(int $maxSize) Copy Sets the maximum size of the event pool. Requirements Agent version 5.0.0 or higher. Description By default, <em>mobile</em> <em>monitoring</em> collects a maximum of 1,000 events per event harvest cycle, which is 600 seconds long by default. This method"
      },
      "id": "603ea0ea28ccbce4f4eba760"
    },
    {
      "sections": [
        "setMaxEventBufferTime (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Important",
        "Parameters",
        "Return values",
        "Examples",
        "Set max event buffer time to 300 seconds"
      ],
      "title": "setMaxEventBufferTime (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "bef23b1df5e20829e7d8fa83463cdba530aefd4f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/set-max-event-buffer-time/",
      "published_at": "2021-10-24T16:11:37Z",
      "updated_at": "2021-09-27T15:50:50Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.setMaxEventBufferTime(int $maxBufferTimeInSec) Copy Sets the event harvest cycle length. Requirements Agent version 5.0.0 or higher. Description This method sets the maximum time in seconds that the New Relic Android agent will store events in memory before including the buffered event to be sent to New Relic in the next harvest cycle. Default is 600 seconds (10 minutes). Minimum value cannot be less than 60 seconds. Maximum value should not be greater than 600 seconds. In other words, when the oldest event timestamp exceeds this custom configured time, the agent transmits the buffered content at the harvest cycle between each connection from a New Relic agent to the collector. See also setMaxEventPoolSize(), which sets the maximum number of events that are stored by the agent during a harvest cycle. Important Be aware that reporting a large number of events, or reporting events too frequently, may impact app performance. For context on how to use this API, see Send custom attributes and events to Insights. Parameters Parameter Description $maxBufferTimeInSec int Required. The maximum time (in seconds) that the agent should store events in memory. The default value harvest cycle length is 600 seconds. Return values Returns true if it succeeds, or false if it doesn't. Examples Set max event buffer time to 300 seconds boolean fiveMinuteLimitSet = NewRelic.setMaxEventBufferTime(300); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 185.83418,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setMaxEventBufferTime (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "setMaxEventBufferTime (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.setMaxEventBufferTime(int $maxBufferTimeInSec) Copy Sets the event harvest cycle length. Requirements Agent version 5.0.0 or higher. Description This method sets the maximum time in seconds that the <em>New</em> <em>Relic</em> <em>Android</em> agent will store events in memory before including the buffered"
      },
      "id": "603ea0af64441ff7fe4e8853"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/with-interaction-tracing": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-10-24T16:17:45Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 356.3368,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>Android</em> <em>SDK</em> <em>API</em> Use the <em>Android</em> <em>SDK</em> <em>API</em> for <em>mobile</em> <em>monitoring</em> to instrument parts of your code that are not instrumented by default. Then, view those custom events"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "setMaxEventPoolSize (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Important",
        "Parameters",
        "Return values",
        "Examples",
        "Set maximum size of event pool to 1000"
      ],
      "title": "setMaxEventPoolSize (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "16019f6e7ab593733c87c9dc1831ff9ffa11dbb8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/set-max-event-pool-size/",
      "published_at": "2021-10-24T17:46:32Z",
      "updated_at": "2021-09-27T15:51:59Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.setMaxEventPoolSize(int $maxSize) Copy Sets the maximum size of the event pool. Requirements Agent version 5.0.0 or higher. Description By default, mobile monitoring collects a maximum of 1,000 events per event harvest cycle, which is 600 seconds long by default. This method controls the maximum size of the event pool stored in the memory until the next harvest cycle. When the pool size limit is reached, the New Relic Android agent will begin sampling events, discarding some old and some new events, until the pool of events are transmitted with the next harvest cycle. This method lets you override the maximum size of that event pool. When the pool size limit is reached, the New Relic Android agent will begin sampling events, discarding some old and some new events, until the pool of events are transmitted with the next harvest cycle. The default value for the event harvest cycle is 600 seconds. See also setMaxEventBufferTime(), which lets you change the length of the event harvest cycle. Important Be aware that reporting a large number of events, or reporting events too frequently, may impact app performance. For context on how to use this API, see Send custom attributes and events to Insights. Parameters Parameter Description $maxSize int Required. Maximum size of event pool. Return values Returns true if it succeeds, or false if it doesn't. Examples Set maximum size of event pool to 1000 boolean poolSizeSet = NewRelic.setMaxEventPoolSize(1000); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 185.8352,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setMaxEventPoolSize (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "setMaxEventPoolSize (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.setMaxEventPoolSize(int $maxSize) Copy Sets the maximum size of the event pool. Requirements Agent version 5.0.0 or higher. Description By default, <em>mobile</em> <em>monitoring</em> collects a maximum of 1,000 events per event harvest cycle, which is 600 seconds long by default. This method"
      },
      "id": "603ea0ea28ccbce4f4eba760"
    },
    {
      "sections": [
        "setMaxEventBufferTime (Android SDK API)",
        "Syntax",
        "Requirements",
        "Description",
        "Important",
        "Parameters",
        "Return values",
        "Examples",
        "Set max event buffer time to 300 seconds"
      ],
      "title": "setMaxEventBufferTime (Android SDK API)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Android SDK API"
      ],
      "external_id": "bef23b1df5e20829e7d8fa83463cdba530aefd4f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/android-sdk-api/set-max-event-buffer-time/",
      "published_at": "2021-10-24T16:11:37Z",
      "updated_at": "2021-09-27T15:50:50Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.setMaxEventBufferTime(int $maxBufferTimeInSec) Copy Sets the event harvest cycle length. Requirements Agent version 5.0.0 or higher. Description This method sets the maximum time in seconds that the New Relic Android agent will store events in memory before including the buffered event to be sent to New Relic in the next harvest cycle. Default is 600 seconds (10 minutes). Minimum value cannot be less than 60 seconds. Maximum value should not be greater than 600 seconds. In other words, when the oldest event timestamp exceeds this custom configured time, the agent transmits the buffered content at the harvest cycle between each connection from a New Relic agent to the collector. See also setMaxEventPoolSize(), which sets the maximum number of events that are stored by the agent during a harvest cycle. Important Be aware that reporting a large number of events, or reporting events too frequently, may impact app performance. For context on how to use this API, see Send custom attributes and events to Insights. Parameters Parameter Description $maxBufferTimeInSec int Required. The maximum time (in seconds) that the agent should store events in memory. The default value harvest cycle length is 600 seconds. Return values Returns true if it succeeds, or false if it doesn't. Examples Set max event buffer time to 300 seconds boolean fiveMinuteLimitSet = NewRelic.setMaxEventBufferTime(300); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 185.83418,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setMaxEventBufferTime (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "sections": "setMaxEventBufferTime (<em>Android</em> <em>SDK</em> <em>API</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Syntax <em>NewRelic</em>.setMaxEventBufferTime(int $maxBufferTimeInSec) Copy Sets the event harvest cycle length. Requirements Agent version 5.0.0 or higher. Description This method sets the maximum time in seconds that the <em>New</em> <em>Relic</em> <em>Android</em> agent will store events in memory before including the buffered"
      },
      "id": "603ea0af64441ff7fe4e8853"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/api-guides/android-agent-configuration-feature-flags": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-10-24T16:17:45Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 215.34607,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": ". As part of the installation process, <em>mobile</em> <em>monitoring</em> automatically generates an application token. This is a 40-character hexadecimal string for authenticating each <em>mobile</em> app that you <em>monitor</em>. Follow the <em>Android</em> installation and configuration procedures for your environment as applicable. If you have"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "Android SDK API guide",
        "Important",
        "Install the SDK",
        "Instrument your code",
        "Caution",
        "Automatically instrumented methods",
        "Category attribute example",
        "Use the API methods",
        "Manual cross application tracing",
        "Cross application tracing example"
      ],
      "title": "Android SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "API guides"
      ],
      "external_id": "9a99f7acf96c5dece74c728c21248eb322d58ddc",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/api-guides/android-sdk-api-guide/",
      "published_at": "2021-10-24T16:18:42Z",
      "updated_at": "2021-07-09T14:58:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important Starting with version 5.9.0 of the New Relic Android agent, you can set a custom user identifier value to associate user sessions with analytics events and attributes. For more information, see the NewRelic.setUserId method. The Android agent provides an SDK API to set up custom instrumentation for monitoring your application. The API gives you the ability to: Instrument your own code. Create, name, and end interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to New Relic Insights. Track networking from libraries not supported automatically. Install the SDK Before using the Android SDK API: Review the Android SDK API release notes to ensure you have your app instrumented with a current SDK for mobile monitoring. Go to one.newrelic.com, click Add more data and then follow the steps for Android. For more information, see the detailed Android installation and configuration procedures. If you need to support Android 2.2, see the legacy Android agent SDK procedures. Instrument your code Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. If you have custom libraries or application code that you want to include in interaction traces: Use the following Java annotation: import com.newrelic.agent.android.instrumentation.Trace; Copy Add the @Trace annotation to the methods you want to instrument: @Trace public void myHeavyweightMethod() { â€¦ Copy To indicate what kind of method is being traced, use the optional category attribute. Automatically instrumented methods Automatic instrumentation is one of the agent's more convenient features. However, if it interferes with the method being traced, add @SkipTrace to the method, and the agent will skip it during compile time instrumentation. Classes Methods Activity onCreate onCreateView AsyncTask execute executeOnExecutor BitmapFactory decodeFile decodeResourceStream decodeResource decodeByteArray decodeStream decodeFileDescriptor decodeResourceStream SQLiteDatabase query queryWithFactory rawQuery rawQueryWithFactory insert insertOrThrow insertWithOnConflict replace replaceOrThrow delete update updateWithOnConflict execSql GSON toJson fromJson JSONObject <init> toString JSONArray <init> toString Category attribute example The category can be a custom name, or it can be one of the predefined MetricCategory enums (listed below). Here is an example of instrumenting an image processing method using the predefined IMAGE category: @Trace(category = MetricCategory.IMAGE) public void processImageData() { â€¦ Copy Available MetricCategory enums include: MetricCategory Description VIEW_LOADING Creating sub views, controls, and other related tasks VIEW_LAYOUT Inflation of layouts, resolving components DATABASE SQLite and other file I/O IMAGE Image loading and processing JSON JSON parsing or creation NETWORK Web service integration methods, remote resource loading Use the API methods The following table lists all the New Relic Android SDK API calls, ordered by common use cases. If you want to... Do this Track app activity that may be helpful for troubleshooting crashes See recordBreadcrumb. Track a method as an interaction See startInteraction. Name or rename an interaction See setInteractionName. End an interaction See endInteraction. Disable or enable all interactions See withInteractionTracing. Set an app version associated with an interaction See withApplicationVersion. Set custom build ID See withApplicationBuild. Create custom metrics See recordMetric. Report custom attributes and events There are several ways to add custom attributes and events. For more about which would be the best method to use and why, see Add custom data. Create an attribute: setAttribute Increment an attribute count: incrementAttribute Remove an attribute: removeAttribute Remove all attributes: removeAllAttributes Record custom event: recordCustomEvent Record a breadcrumb event: recordBreadcrumb Set the maximum size of an event pool: setMaxEventPoolSize Set maximum time agent stores events in memory: setMaxEventBufferTime Return the current session's ID: currentSessionId Set custom user ID for associating sessions with events and attributes: setUserId Track custom network requests and failures Use these methods: Record HTTP transactions at varying levels of detail: See noticeHttpTransaction. Record network failures: See noticeNetworkFailure. Record a handled exception as an event, including context See recordHandledException(). Manual cross application tracing The noticeHttpTransaction code does not automatically append the appropriate header ID value needed to get cross application tracing to work. This is why you will not see the application link in your Android app on New Relic's Map page for mobile apps or on the HTTP requests page. You can use a public method in the New Relic Android SDK to get the appropriate ID to pass along with your HTTP request to your back-end application, as long as it is already instrumented by New Relic. The appropriate header ID will be passed from the back-end application in the response, providing everything needed for cross application tracing to function. Cross application tracing example This example adds the NewRelic-ID to the back-end HTTP request, with conn as the external HTTP connection. (Notice the additional import.) import com.newrelic.agent.android.NewRelic; import com.newrelic.agent.android.Agent; //required for getCrossProcessId() ... ... //new method for appending the crossProcessID necessary for CAT in New Relic public static void setCrossProcessHeader(HttpURLConnection conn) { String crossProcessId = Agent.getCrossProcessId(); // API call into the agent for the X-NewRelic-ID if (crossProcessId != null) { conn.setRequestProperty(\"X-NewRelic-ID\", crossProcessId); } } Copy After adding the appropriate header to the request to the back-end app, the response from the app needs to be parsed for the X-Newrelic-App-Data header, and then added to the noticeHttpTransaction call as a string. For example: //NewRelic.noticeHttpTransaction(url, httpMethod, statusCode, startTimeMs, endTimeMs, bytesSent, bytesReceived, responseBody, params, response); //Where xNewRelicAppDataHeader is the value of the X-NewRelic-App-Data header NewRelic.noticeHttpTransaction(\"http://api.newrelic.com\", \"GET\", 200, System.nanoTime(), System.nanoTime(),100 ,100, \"Test\", new HashMap<String, String>(), xNewRelicAppDataHeader); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.94733,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Android</em> SDK <em>API</em> <em>guide</em>",
        "sections": "<em>Android</em> SDK <em>API</em> <em>guide</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " instrumentation for <em>monitoring</em> your application. The <em>API</em> gives you the ability to: Instrument your own code. Create, name, and end interaction traces from events in your <em>mobile</em> app. Record custom metrics. Send custom attributes and events to <em>New</em> <em>Relic</em> Insights. Track networking from libraries not supported"
      },
      "id": "603ea2bc64441f11ee4e889b"
    },
    {
      "sections": [
        "No data appears (Android)",
        "Problem",
        "Solution"
      ],
      "title": "No data appears (Android)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Troubleshoot"
      ],
      "external_id": "cab2851a6f3c8bfddb1ed445f8722b3dddff7442",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/troubleshoot/no-data-appears-android/",
      "published_at": "2021-10-24T16:48:16Z",
      "updated_at": "2021-07-09T15:38:22Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem After installing the Android agent and waiting at least 5 minutes, no data appears in New Relic UI. Solution If no data appears after you wait at least five minutes, use New Relic Diagnostics to automatically detect common problems and suggest troubleshooting. If that does not solve your issue, try the following: Make sure your system meets the compatibility and requirements. Make sure that you are calling the Android agent on the first line of onCreate() in the MainActivity class and that you are running the agent on the main thread. The Android agent does not support starting the agent in another class. Check whether your Android app exceeds the 64k multidex limit. Increase the logging level and examine your logs for errors: Increase the New Relic logging level to AUDIT using withLogLevel: NewRelic.withApplicationToken(\"YOUR_APP_TOKEN\") .withLogLevel(AgentLog.AUDIT) .start(this.getApplication()); Copy Generate a few minutes of activity in your app. Examine your device log and your application build logs for issues. Confirm the device can reach the mobile monitoring endpoints listed in the Networks doc. If you need additional help, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 117.670204,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "No data appears (<em>Android</em>)",
        "sections": "No data appears (<em>Android</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Problem After installing the <em>Android</em> agent and waiting at least 5 minutes, no data appears in <em>New</em> <em>Relic</em> UI. Solution If no data appears after you wait at least five minutes, use <em>New</em> <em>Relic</em> Diagnostics to automatically detect common problems and suggest troubleshooting. If that does not solve your"
      },
      "id": "603e8eb6196a67b64ea83d81"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/api-guides/android-sdk-api-guide": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-10-24T16:17:45Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 215.34592,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": ". As part of the installation process, <em>mobile</em> <em>monitoring</em> automatically generates an application token. This is a 40-character hexadecimal string for authenticating each <em>mobile</em> app that you <em>monitor</em>. Follow the <em>Android</em> installation and configuration procedures for your environment as applicable. If you have"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "Android agent configuration and feature flags",
        "Change configuration settings",
        "Analytics settings",
        "withAnalyticsEvents",
        "FeatureFlag.AnalyticsEvents",
        "Application settings",
        "withApplicationVersion",
        "withApplicationBuild",
        "Crash and error reporting settings",
        "withCrashReportingEnabledFeatureFlag.CrashReportingEnabled",
        "FeatureFlag.HandledExceptions",
        "Distributed tracing",
        "FeatureFlag.DistributedTracing",
        "Interaction settings",
        "withInteractionTracingFeatureFlag.InteractionTracing",
        "withDefaultInteractionsFeatureFlag.DefaultInteractions",
        "Networking settings",
        "FeatureFlag.NetworkRequests",
        "FeatureFlag.NetworkErrorRequests",
        "withHttpResponseBodyCaptureEnabledFeatureFlag.HttpResponseBodyCaptureEnabled",
        "Logging settings",
        "withLoggingEnabled",
        "withLogLevel",
        "Data endpoint settings",
        "usingCollectorAddress",
        "usingCrashCollectorAddress"
      ],
      "title": "Android agent configuration and feature flags",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "API guides"
      ],
      "external_id": "68c34002aa50d0a945d604f984bd3a64257b4f6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/api-guides/android-agent-configuration-feature-flags/",
      "published_at": "2021-10-24T16:17:45Z",
      "updated_at": "2021-07-09T14:57:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Android agent provides configuration settings to change the default behavior of the agent. For an explanation of mobile custom data types, see Add custom data to mobile monitoring. Change configuration settings All settings, including the call to invoke the agent, are called in the onCreate method of the MainActivity class. To change settings, call the setting in one of two ways (if the setting supports it): Change the setting on its own line for each specific condition: NewRelic. disableFeature(FeatureFlag.DefaultInteractions) ; NewRelic. enableFeature(FeatureFlag.CrashReporting) ; NewRelic.withApplicationToken(<NEW_RELIC_TOKEN>).start(this.getApplication()); Copy OR Change the setting as part of the agent start call using the .with method: NewRelic.withApplicationToken(<NEW_RELIC_TOKEN>) .withDefaultInteractions(false) .withCrashReportingEnabled(true) .start(this.getApplication()); Copy Analytics settings withAnalyticsEvents Enable or disable collection of event data. These events are reported to Insights and used in the Crash analysis page. Type Boolean Default true FeatureFlag.AnalyticsEvents Enable or disable the reporting of event data. Event collection will still occur; the events will just not be sent to our collector. You might decide to use this instead of withAnalyticsEvents if you wanted to disable collection but still be able to see what the agent was collecting. Type Boolean Default true Application settings withApplicationVersion Set custom application version strings. Type String Default Defaults to version number set in AndroidManifest.xml withApplicationBuild Set custom application build strings. Type String Default Defaults to build ID set in AndroidManifest.xml Crash and error reporting settings withCrashReportingEnabled FeatureFlag.CrashReportingEnabled Enable or disable crash reporting. Type Boolean Default true FeatureFlag.HandledExceptions Enable or disable recording handled exceptions events, which appear on the Handled exception page. Type Boolean Default true Distributed tracing FeatureFlag.DistributedTracing Enable or disable the adding of distributed tracing headers to network requests. Refer to How New Relic distributed tracing works for more information on distributed tracing in mobile apps. Type Boolean Default true Interaction settings withInteractionTracing FeatureFlag.InteractionTracing Enable or disable interaction tracing. Trace instrumentation still occurs, but no traces are harvested. This will disable default and custom interactions. Available for Android agent version 5.4.0 or higher. Type Boolean Default true withDefaultInteractions FeatureFlag.DefaultInteractions Enable or disable default interactions. Trace instrumentation still occurs, but no traces are harvested. This will enable or disable default interactions only while custom interactions remain enabled. Type Boolean Default true Networking settings FeatureFlag.NetworkRequests Enable or disable reporting successful HTTP requests to the MobileRequest event type in Insights. Available for Android agent version 5.14.0 or higher. Type Boolean Default true Enabled by default as of agent version 5.15.2 FeatureFlag.NetworkErrorRequests Enable or disable reporting network and Http request errors to MobileRequestError event type in Insights. Available for Android agent version 5.11.0 or higher. Type Boolean Default true withHttpResponseBodyCaptureEnabled FeatureFlag.HttpResponseBodyCaptureEnabled Enable or disable capture of HTTP response bodies for HTTP error traces, and MobileRequestError events. Type Boolean Default true Logging settings withLoggingEnabled Enable or disable agent logging. Type Boolean Default true withLogLevel Specifies the log level. Options include: ERROR (least verbose) WARNING INFO (default) VERBOSE DEBUG AUDIT (most verbose) Type String Default AgentLog.INFO To increase your logging level in the app, add .withLogLevel to your NewRelic.withApplicationToken() method call. For example: NewRelic.withApplicationToken(\"YOUR_APP_TOKEN\") .withLogLevel(AgentLog.DEBUG) .start(this.getApplication()); Copy Data endpoint settings usingCollectorAddress Specifies the URI authority component of the harvest data upload endpoint. Type Boolean Default mobile-collector.newrelic.com To replace data endpoint the agent will use when reporting data harvests, add .usingCollectorAddress() to your NewRelic.withApplicationToken() method call. For example: NewRelic.withApplicationToken(\"YOUR_APP_TOKEN\") .usingCollectorAddress(\"harvest-upload-delegate.domain.com\") .start(this.getApplication()); Copy This endpoint is also used for handled exception uploads. usingCrashCollectorAddress Specifies the authority component of the crash data upload URI. Type String Default mobile-crash.newrelic.com To replace data endpoint the agent will use when reporting crashes, add .usingCrashCollectorAddress() to your NewRelic.withApplicationToken() method call. For example: NewRelic.withApplicationToken(\"YOUR_APP_TOKEN\") .usingCrashCollectorAddress(\"crash-upload-delegate.domain.com\") .start(this.getApplication()); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.94725,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Android</em> agent configuration and feature flags",
        "sections": "<em>Android</em> agent configuration and feature flags",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "The <em>Android</em> agent provides configuration settings to change the default behavior of the agent. For an explanation of <em>mobile</em> custom data types, see Add custom data to <em>mobile</em> <em>monitoring</em>. Change configuration settings All settings, including the call to invoke the agent, are called in the onCreate"
      },
      "id": "603ed80e28ccbc0cfceba773"
    },
    {
      "sections": [
        "No data appears (Android)",
        "Problem",
        "Solution"
      ],
      "title": "No data appears (Android)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Troubleshoot"
      ],
      "external_id": "cab2851a6f3c8bfddb1ed445f8722b3dddff7442",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/troubleshoot/no-data-appears-android/",
      "published_at": "2021-10-24T16:48:16Z",
      "updated_at": "2021-07-09T15:38:22Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem After installing the Android agent and waiting at least 5 minutes, no data appears in New Relic UI. Solution If no data appears after you wait at least five minutes, use New Relic Diagnostics to automatically detect common problems and suggest troubleshooting. If that does not solve your issue, try the following: Make sure your system meets the compatibility and requirements. Make sure that you are calling the Android agent on the first line of onCreate() in the MainActivity class and that you are running the agent on the main thread. The Android agent does not support starting the agent in another class. Check whether your Android app exceeds the 64k multidex limit. Increase the logging level and examine your logs for errors: Increase the New Relic logging level to AUDIT using withLogLevel: NewRelic.withApplicationToken(\"YOUR_APP_TOKEN\") .withLogLevel(AgentLog.AUDIT) .start(this.getApplication()); Copy Generate a few minutes of activity in your app. Examine your device log and your application build logs for issues. Confirm the device can reach the mobile monitoring endpoints listed in the Networks doc. If you need additional help, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 117.670204,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "No data appears (<em>Android</em>)",
        "sections": "No data appears (<em>Android</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Problem After installing the <em>Android</em> agent and waiting at least 5 minutes, no data appears in <em>New</em> <em>Relic</em> UI. Solution If no data appears after you wait at least five minutes, use <em>New</em> <em>Relic</em> Diagnostics to automatically detect common problems and suggest troubleshooting. If that does not solve your"
      },
      "id": "603e8eb6196a67b64ea83d81"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android": [
    {
      "sections": [
        "Get data into New Relic",
        "New Relic-built agents and integrations",
        "Report custom data"
      ],
      "title": "Get data into New Relic",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Get started"
      ],
      "external_id": "016a25d46dedc5da1455b29d8557ce68a4345756",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/get-started/introduction-new-relic-data-ingest-apis-sdks/",
      "published_at": "2021-10-24T19:36:34Z",
      "updated_at": "2021-10-23T17:32:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "There are many ways to get data into your New Relic account. Any New Relic user can use any of our data ingest methods to report data to our platform. New Relic-built agents and integrations When you enable New Relic solutions like APM, browser monitoring, mobile monitoring, infrastructure monitoring, or any of our wide array of integrations, by default you'll receive data from your monitored applications, hosts, services, or other entities. Some options for getting started: Log into one.newrelic.com and click Add more data to get some guidance on setting up New Relic solutions. To browse our solutions, see New Relic integrations. Report custom data If you need to report data that our agents and integrations don't provide, we have tools that will allow you to bring in any type of data you need. To learn more, see Intro to custom data.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 149.99095,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Get</em> data into <em>New</em> <em>Relic</em>",
        "sections": "<em>Get</em> data into <em>New</em> <em>Relic</em>",
        "tags": "<em>Get</em> <em>started</em>",
        "body": "There are many ways to <em>get</em> data into your <em>New</em> <em>Relic</em> account. Any <em>New</em> <em>Relic</em> user can use any of our data ingest methods to report data to our platform. <em>New</em> <em>Relic</em>-built agents and integrations When you enable <em>New</em> <em>Relic</em> solutions like APM, browser <em>monitoring</em>, <em>mobile</em> <em>monitoring</em>, infrastructure"
      },
      "id": "6174474328ccbcdff4c6b77e"
    },
    {
      "sections": [
        "Get started with New Relic observability",
        "Youâ€™re in control because you understand your system",
        "All the answers in one place",
        "Start anywhere"
      ],
      "title": "Get started with New Relic observability",
      "type": "docs",
      "tags": [
        "Observe everything",
        "Get started"
      ],
      "external_id": "30f87d5f702f926efec49b59591679fa93627ad5",
      "image": "https://docs.newrelic.com/static/44970161aec793f3141cfcdc0fc96a57/c1b63/observability-2.png",
      "url": "https://docs.newrelic.com/docs/using-new-relic/welcome-new-relic/get-started/get-started-full-stack-observability/",
      "published_at": "2021-10-24T11:46:39Z",
      "updated_at": "2021-10-23T16:46:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "True observability is the power of knowing what's happening across your digital system and why, at any time, whatever solution youâ€™re using. Itâ€™s getting the whole picture of everything that enables your applications and devices to deliver value to your customers, from the container running a microservice in the cloud to a mobile website's shopping cart button. Youâ€™re in control because you understand your system New Relic helps you cut through the layers of complexity surrounding your systems by bringing together and connecting data from any instrumented source and environment, without having to jump between tools. You can interrogate your data for patterns, discover them using our data platform, or get proactive results from our machine learning tools. New Relic provides answers to essential questions in one place. All the answers in one place As a full user you get access to our entire set of observability tools. All our tools are interconnected and accessible in New Relic One. All the data you bring to New Relic through agents and integrations are metrics, events, logs, and traces that feed our platform's analytics and monitoring capabilities. New Relic links your data in a meaningful way so that you can explore it, build dashboards, and set up alerts. Our more curated observability UI experiences allow to visualize, analyze, and troubleshoot your entire software stack in one unified platform. The New Relic Explorer consolidates all the entities in your system, and how they're connected, in a single place, so you can easily detect performance trends and issues. By automatically connecting infrastructure health with application performance and end-user behavior, you can cut through the noise to find the signal. Start anywhere Being fully-connected, New Relic allows you to start your observability journey from any element of your stack. For example, you can get to crucial infrastructure logs from traces of an application running on a problematic Kubernetes pod. Use the Explorer in New Relic One to access and observe the full stack of your software, see performance data and alerting status at a glance, and check relationships. We provide you with a simple, yet powerful visual tool to monitor all your entities, that is, anything we can identify that reports data. In the New Relic ecosystem, entities include basic components like applications, hosts, containers, or database services, but it can also refer to custom groupings of such elements. You can also create your own entities. The more entities you instrument, the more data you'll bring in. The more data you've brought to New Relic, the more you'll understand your metrics, events, logs, and traces. You want to instrument Start with Keep exploring Front-end applications Mobile applications User behavior and flows New Relic Explorer Browser monitoring Mobile monitoring Synthetic monitoring Single page monitoring Scripted browsers Containerized minions Workloads Backend applications Serverless applications New Relic Explorer Application monitoring Serverless monitoring Learning about Apdex Distributed tracing Logs in context APM data to infrastructure Workloads Infrastructure hosts and services (on-premise, cloud, orchestrated) Container environments and orchestration tools (Kubernetes, ECS, etc.) Infrastructure monitoring Infrastructure integrations Kubernetes integration Docker integration ECS integration Log forwarding APM data to infrastructure Custom integrations Kubernetes cluster explorer Infrastructure alerts Workloads",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.99373,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Get</em> <em>started</em> with <em>New</em> <em>Relic</em> observability",
        "sections": "<em>Get</em> <em>started</em> with <em>New</em> <em>Relic</em> observability",
        "tags": "<em>Get</em> <em>started</em>",
        "body": ". You want to instrument <em>Start</em> with Keep exploring Front-end applications <em>Mobile</em> applications User behavior and flows <em>New</em> <em>Relic</em> Explorer Browser <em>monitoring</em> <em>Mobile</em> <em>monitoring</em> Synthetic <em>monitoring</em> Single page <em>monitoring</em> Scripted browsers Containerized minions Workloads Backend applications Serverless"
      },
      "id": "61743c6764441f60375fd317"
    },
    {
      "sections": [
        "Android agent compatibility and requirements",
        "Foreground monitoring",
        "Android compatibility",
        "Important",
        "Agent and Gradle compatibility",
        "Kotlin and Kotlin DSL",
        "Kotlin DSL support by Android agent version",
        "Kotlin DSL support by AGP version",
        "Unit testing not supported"
      ],
      "title": "Android agent compatibility and requirements",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "fdae9b0d2971ed33098e8c7cf6152654e45cca69",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/new-relic-android-compatibility-requirements/",
      "published_at": "2021-10-24T16:18:42Z",
      "updated_at": "2021-08-08T20:44:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring is compliant with standard application stores, including Google Play Store, Amazon Appstore, and others. Before you install and configure the mobile agent with your Android applications, follow these guidelines for compatibility and other requirements. Foreground monitoring The Android agent only monitors your app while it is in the foreground. The agent does not monitor background services while the app is closed. For more information, see our Mobile data privacy and security documentation. Android compatibility Make sure your Android app meets these requirements: Component Application requirements Operating system Android 2.3 or higher API/SDK HttpURLConnection, OkHttp2 (except versions 2.0 and 2.4), OkHttp (versions 2.8, 3.5+, 4.0+), OkIO (version 1.11), AndroidHttpClient, Volley (version 1.0.0), and Apache HTTP Client networking APIs Build with Android SDK Tools version 21 or higher and the following as appropriate: Android Studio Gradle 3.3 Gradle plugin 3.4 Proguard 5.0 DexGuard 7.2.04 through 8.x Important As of January 2021, our Android agent discontinued support for Android Gradle Plugin version 2. For more information, see our Explorers Hub post. Upgrade to the most recent version before installing the Android agent. Languages Java 1.7 through Java 9. JDK 11 is supported in version 6.2.0 and higher. Devices Any Android compatible device (smartphones, tablets, etc.) File sizes The agent adds less than 500KB to your release APK. Architectures ARM, Intel Atom Signature validation The agent cannot instrument JARs that use signature validation during signing. JARs with manifests containing SHA1-Digest or SHA-256-Digest attributes will not be modified. Agent and Gradle compatibility The following are compatible versions of the New Relic Android agent, Gradle, and the Android Gradle plugin. Important As of March 2021, our Android agent discontinued support for Android Gradle Plugin version 2. For more information, see our Explorers Hub post. Android Gradle plugin New Relic Android agent compatibility 2.3 No longer supported in versions 6.0 and higher. 5.25 - 5.26 are not supported 3.0 - 3.3 No longer supported in versions 6.0 and higher. 3.4 5.25 and higher 4.+ 5.26 and higher Kotlin and Kotlin DSL You can also use Kotlin projects with Gradle and New Relic's Android agent. Kotlin DSL support by Android agent version With the exception of incompatibilities noted with Android Gradle, New Relic's Android agent is compatible with versions 1.3 - 1.4 of the Kotlin Gradle Plugin. Kotlin DSL version New Relic Android agent compatibility 1.2 Unsupported 1.3 5.24 and lower: Requires Kotlin Gradle Plugin version 1.3.10 or higher 5.25: Requires Kotlin Gradle Plugin version 1.3.10 or higher 5.26: Unsupported in Android agent versions 5.26.0 through 5.28.0 1.4 5.24 and lower: Requires Kotlin Gradle Plugin version 1.3.10 or higher 5.25: Supported 5.26: Unsupported in Android agent versions 5.26.0 through 5.28.0 Kotlin DSL support by AGP version Kotlin DSL support was officially added to Android Gradle Plugin in version 4.1, but many developers are already using it in place of Groovy. Kotlin DSL version Android Gradle Plugin and Android Gradle compatibility 1.3 3.2 (AGP), 4.6 (Gradle) : Requires Kotlin Gradle Plugin version 1.3.10 or higher 3.3 (AGP), (5.1.1 Gradle): Requires Kotlin Gradle Plugin version 1.3.10 or higher 3.4 (AGP), 5.1.1 Gradle): Requires Kotlin Gradle Plugin version 1.3.10 or higher 3.5 (AGP), 5.4.1 Gradle): Requires Kotlin Gradle Plugin version 1.3.10 or higher 3.6 (AGP), 5.6.4 Gradle): Requires Kotlin Gradle Plugin version 1.3.40 or higher 4.0 (AGP), 6.1.1 Gradle): Requires Kotlin Gradle Plugin version 1.3.40 or higher 4.1 (AGP), 6.5 Gradle): Requires Kotlin Gradle Plugin version 1.3.40 or higher 1.4 3.2 (AGP), 4.6 (Gradle) : Requires Gradle 5.3 3.3 (AGP), (5.1.1 Gradle): Requires Gradle 5.3 3.4 (AGP), 5.1.1 Gradle): Supported 3.5 (AGP), 5.4.1 Gradle): Supported 3.6 (AGP), 5.6.4 Gradle): Supported 4.0 (AGP), 6.1.1 Gradle): Supported 4.1 (AGP), 6.5 Gradle): Supported Unit testing not supported Our New Relic mobile agents are designed and tested to work in a normal app lifecycle. We do not support running any testing environment on applications with the agent. Testing can cause conflicts and unpredictable behavior.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.9265,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Android</em> agent compatibility and requirements",
        "sections": "Foreground <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "<em>Mobile</em> <em>monitoring</em> is compliant with standard application stores, including Google Play Store, Amazon Appstore, and others. Before you install and configure the <em>mobile</em> agent with your <em>Android</em> applications, follow these guidelines for compatibility and other requirements. Foreground <em>monitoring</em>"
      },
      "id": "604418abe7b9d2d1015799cc"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/get-started/new-relic-android-compatibility-requirements": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-10-24T16:17:45Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 276.42688,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": ". As part of the installation process, <em>mobile</em> <em>monitoring</em> automatically generates an application token. This is a 40-character hexadecimal string for authenticating each <em>mobile</em> app that you <em>monitor</em>. Follow the <em>Android</em> installation and configuration procedures for your environment as applicable. If you have"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "Get data into New Relic",
        "New Relic-built agents and integrations",
        "Report custom data"
      ],
      "title": "Get data into New Relic",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Get started"
      ],
      "external_id": "016a25d46dedc5da1455b29d8557ce68a4345756",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/get-started/introduction-new-relic-data-ingest-apis-sdks/",
      "published_at": "2021-10-24T19:36:34Z",
      "updated_at": "2021-10-23T17:32:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "There are many ways to get data into your New Relic account. Any New Relic user can use any of our data ingest methods to report data to our platform. New Relic-built agents and integrations When you enable New Relic solutions like APM, browser monitoring, mobile monitoring, infrastructure monitoring, or any of our wide array of integrations, by default you'll receive data from your monitored applications, hosts, services, or other entities. Some options for getting started: Log into one.newrelic.com and click Add more data to get some guidance on setting up New Relic solutions. To browse our solutions, see New Relic integrations. Report custom data If you need to report data that our agents and integrations don't provide, we have tools that will allow you to bring in any type of data you need. To learn more, see Intro to custom data.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 149.99084,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Get</em> data into <em>New</em> <em>Relic</em>",
        "sections": "<em>Get</em> data into <em>New</em> <em>Relic</em>",
        "tags": "<em>Get</em> <em>started</em>",
        "body": "There are many ways to <em>get</em> data into your <em>New</em> <em>Relic</em> account. Any <em>New</em> <em>Relic</em> user can use any of our data ingest methods to report data to our platform. <em>New</em> <em>Relic</em>-built agents and integrations When you enable <em>New</em> <em>Relic</em> solutions like APM, browser <em>monitoring</em>, <em>mobile</em> <em>monitoring</em>, infrastructure"
      },
      "id": "6174474328ccbcdff4c6b77e"
    },
    {
      "sections": [
        "Get started with New Relic observability",
        "Youâ€™re in control because you understand your system",
        "All the answers in one place",
        "Start anywhere"
      ],
      "title": "Get started with New Relic observability",
      "type": "docs",
      "tags": [
        "Observe everything",
        "Get started"
      ],
      "external_id": "30f87d5f702f926efec49b59591679fa93627ad5",
      "image": "https://docs.newrelic.com/static/44970161aec793f3141cfcdc0fc96a57/c1b63/observability-2.png",
      "url": "https://docs.newrelic.com/docs/using-new-relic/welcome-new-relic/get-started/get-started-full-stack-observability/",
      "published_at": "2021-10-24T11:46:39Z",
      "updated_at": "2021-10-23T16:46:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "True observability is the power of knowing what's happening across your digital system and why, at any time, whatever solution youâ€™re using. Itâ€™s getting the whole picture of everything that enables your applications and devices to deliver value to your customers, from the container running a microservice in the cloud to a mobile website's shopping cart button. Youâ€™re in control because you understand your system New Relic helps you cut through the layers of complexity surrounding your systems by bringing together and connecting data from any instrumented source and environment, without having to jump between tools. You can interrogate your data for patterns, discover them using our data platform, or get proactive results from our machine learning tools. New Relic provides answers to essential questions in one place. All the answers in one place As a full user you get access to our entire set of observability tools. All our tools are interconnected and accessible in New Relic One. All the data you bring to New Relic through agents and integrations are metrics, events, logs, and traces that feed our platform's analytics and monitoring capabilities. New Relic links your data in a meaningful way so that you can explore it, build dashboards, and set up alerts. Our more curated observability UI experiences allow to visualize, analyze, and troubleshoot your entire software stack in one unified platform. The New Relic Explorer consolidates all the entities in your system, and how they're connected, in a single place, so you can easily detect performance trends and issues. By automatically connecting infrastructure health with application performance and end-user behavior, you can cut through the noise to find the signal. Start anywhere Being fully-connected, New Relic allows you to start your observability journey from any element of your stack. For example, you can get to crucial infrastructure logs from traces of an application running on a problematic Kubernetes pod. Use the Explorer in New Relic One to access and observe the full stack of your software, see performance data and alerting status at a glance, and check relationships. We provide you with a simple, yet powerful visual tool to monitor all your entities, that is, anything we can identify that reports data. In the New Relic ecosystem, entities include basic components like applications, hosts, containers, or database services, but it can also refer to custom groupings of such elements. You can also create your own entities. The more entities you instrument, the more data you'll bring in. The more data you've brought to New Relic, the more you'll understand your metrics, events, logs, and traces. You want to instrument Start with Keep exploring Front-end applications Mobile applications User behavior and flows New Relic Explorer Browser monitoring Mobile monitoring Synthetic monitoring Single page monitoring Scripted browsers Containerized minions Workloads Backend applications Serverless applications New Relic Explorer Application monitoring Serverless monitoring Learning about Apdex Distributed tracing Logs in context APM data to infrastructure Workloads Infrastructure hosts and services (on-premise, cloud, orchestrated) Container environments and orchestration tools (Kubernetes, ECS, etc.) Infrastructure monitoring Infrastructure integrations Kubernetes integration Docker integration ECS integration Log forwarding APM data to infrastructure Custom integrations Kubernetes cluster explorer Infrastructure alerts Workloads",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.99362,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Get</em> <em>started</em> with <em>New</em> <em>Relic</em> observability",
        "sections": "<em>Get</em> <em>started</em> with <em>New</em> <em>Relic</em> observability",
        "tags": "<em>Get</em> <em>started</em>",
        "body": ". You want to instrument <em>Start</em> with Keep exploring Front-end applications <em>Mobile</em> applications User behavior and flows <em>New</em> <em>Relic</em> Explorer Browser <em>monitoring</em> <em>Mobile</em> <em>monitoring</em> Synthetic <em>monitoring</em> Single page <em>monitoring</em> Scripted browsers Containerized minions Workloads Backend applications Serverless"
      },
      "id": "61743c6764441f60375fd317"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/get-started/new-relic-mobile-and-dt": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-10-24T16:17:45Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 173.55939,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to Android <em>monitoring</em>",
        "sections": "Introduction to Android <em>monitoring</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em>",
        "body": " on information in <em>New</em> <em>Relic</em> Insights. To access: In <em>mobile</em> <em>monitoring</em>: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/attribute-dictionary/",
      "sections": [
        "New Relic data dictionary",
        "AjaxRequest",
        "AwsLambdaInvocation",
        "AwsLambdaInvocationError",
        "BrowserInteraction",
        "BrowserTiming",
        "ContainerSample",
        "DistributedTraceSummary",
        "InfrastructureEvent",
        "JavaScriptError",
        "Metric",
        "Mobile",
        "MobileCrash",
        "MobileHandledException",
        "MobileRequest",
        "MobileRequestError",
        "MobileSession",
        "NetworkSample",
        "NrAiIncident",
        "NrAuditEvent",
        "NrConsumption",
        "NrDailyUsage",
        "NrIntegrationError",
        "NrMTDConsumption",
        "NrUsage",
        "PageAction",
        "PageView",
        "PageViewTiming",
        "ProcessSample",
        "Span",
        "StorageSample",
        "SyntheticCheck",
        "SyntheticRequest",
        "SyntheticsPrivateLocationStatus",
        "SyntheticsPrivateMinion",
        "SystemSample",
        "Transaction",
        "TransactionError",
        "WorkloadStatus"
      ],
      "published_at": "2021-10-24T23:18:19Z",
      "title": "New Relic data dictionary",
      "updated_at": "2021-10-24T01:40:30Z",
      "type": "docs",
      "external_id": "cbca3a897621bcbb31159067d6d4ec27c5178fe4",
      "document_type": "views_page_content",
      "popularity": 1,
      "body": "AjaxRequest Data source : Browser agent An AjaxRequest event is created automatically when an Ajax request occurs during a BrowserInteraction event. The event attributes track geographic and browser info. Attribute name Definition Data types appId ID The ID of your application, as recorded by New Relic. AjaxRequest BrowserInteraction BrowserTiming PageAction PageView PageViewTiming appName The name of the application that handled the request as shown in New Relic Browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnLatitude The latitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's latitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnLongitude The longitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's longitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnOrganization The organization that owns the Autonomous System Number. Often an ISP, sometimes a private company or institution. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming browserInteractionId ID A unique value generated for each browser interaction captured by the New Relic agent. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError browserInteractionName The name of the interaction. This is either the targetGroupedUrl or the custom name set via the API. AjaxRequest BrowserInteraction BrowserTiming city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileSession PageAction PageView PageViewTiming countryCode The country from which the browser initiated the page load. For a list of country codes, see ISO 3166-1 alpha-2. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming deviceType The type of device that loaded the page: mobile, tablet, or desktop. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageView eventId ID A value that you can link to multiple BrowserInteraction events so you can view the interactions that occurred surrounding a specific event. For example, you can see the browser interactions that occurred prior to a JS error. AjaxRequest BrowserInteraction BrowserTiming groupedPageURL The grouped URL of the view that made the AJAX request. For example: myapp.com/acct/*/dash. AjaxRequest BrowserTiming groupedRequestUrl The grouped URL of the AJAX request. For example: myapp.com/acct/*/ajax. AjaxRequest Span hostname The fully qualified domain name (FQDN) of the request URL. AjaxRequest httpMethod enum The HTTP method of the AJAX request. Example: POST. AjaxRequest httpResponseCode enum The HTTP response code. Example: 200. AjaxRequest jsDuration seconds (s) The total duration, in seconds, spent on JavaScript execution. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. This attribute doesn't exist for initial page load events. AjaxRequest BrowserInteraction BrowserTiming pageUrl The URL of the page that was loaded for the PageView. For example: http://www.newrelic.com. This URL does not include query parameters. AjaxRequest BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span parentEventId ID A unique value generated for each interaction with the page. You can use this value to group interactions together. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError port enum The request port. AjaxRequest Span priority Likelihood this event will be saved. AjaxRequest regionCode The specific administrative division within a country where the PageView event occurred. In the United States, regions correspond to state codes, such as WA or NY. Outside the United States, a country's regions correspond to numerical codes. In the United States, regions correspond to state codes ; for example, WA or NY. Outside the United States, a country's regions correspond to numerical codes . AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming requestBodySize bytes (B) The payload size of the request body, in bytes. AjaxRequest requestUrl The URL of the AJAX request. For example: myapp.com/acct/1/ajax. AjaxRequest responseBodySize bytes (B) The payload size of the response body, in bytes. AjaxRequest session A unique identifier for a single session. The session cookie expires when the user closes the browser (for example, they fully exit Chrome.) A new session identifier will be assigned when the user opens up a new instance of the browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span timeSinceBrowserInteractionStart seconds (s) The time in seconds between the start of the BrowserInteraction and the start of the request. AjaxRequest BrowserTiming timeToLastCallbackEnd seconds (s) The duration, in seconds, from the start of the request (timestamp) to the end of the last callback. This is not just an additive function; the callback time can overlap with the wait time. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. AjaxRequest BrowserInteraction BrowserTiming timeToLoadEventStart seconds (s) The time, in seconds, from the start of the AJAX request to the start of its load event. This value represents the duration of the AJAX request with single page app (SPA) monitoring. For more information, see the Mozilla developer documentation about XMLHttpRequest load events. AjaxRequest timeToSettle seconds (s) The time, in seconds, from the start of the request to when all resulting callbacks (including callbacks of subsequent AJAX requests) are complete. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. AjaxRequest BrowserTiming timestamp The time (date, hour, minute, second) at which the interaction occurred. AjaxRequest BrowserInteraction BrowserTiming PageAction PageView PageViewTiming Span userAgentName The browserâ€™s name, such as Chrome and Firefox, obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentOS The browserâ€™s reported operating system, such as Windows or Linux, that it is running on. This is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentVersion The browserâ€™s reported software version, which is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming AwsLambdaInvocation Data source : AWS Lambda This event is reported by New Relic monitoring for AWS Lambda. This event captures overall function timing and associated metadata. A single AwsLambdaInvocation event is generated for each invocation. Attribute name Definition Data types aws.lambda.arn The Amazon Resource Name (ARN) of the instrumented Lambda function. AwsLambdaInvocationError AwsLambdaInvocation aws.lambda.coldStart A Boolean indicating if the AWS Lambda invocation is a cold start. AwsLambdaInvocationError AwsLambdaInvocation aws.lambda.eventSource.arn The Amazon Resource Name (ARN) of the entity that invoked the instrumented Lambda function. AwsLambdaInvocationError AwsLambdaInvocation aws.requestId ID AWS identifier of the invocation. AwsLambdaInvocationError AwsLambdaInvocation databaseCallCount count The number of database calls made by this transaction. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError databaseDuration seconds (s) The database response time in seconds. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError duration seconds (s) The total invocation time for the transaction, in seconds. (Data source: AWS Lambda) AwsLambdaInvocationError AwsLambdaInvocation externalCallCount count The number of external calls made by this transaction. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError externalDuration seconds (s) The total response time of all external (out-of-process) services, in seconds. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError newRelic.ingestPoint Where the data point entered the platform (such as browser.spans, or api.traces). AwsLambdaInvocationError AwsLambdaInvocation Span parent.account ID If a distributed tracing payload is received, this is the account identifier for the transaction's upstream caller. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError parent.app ID If a distributed tracing payload is received, this is the application identifier. APM agents retrieve this value in the connect response under the key primary_application_id. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError parent.transportType When a distributed tracing payload is received, the method of transport for the payload. Example values: Unknown, HTTP, HTTPS, Kafka, JMS, IronMQ, AMQP, Queue, or Other. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError parent.type If a distributed trace payload was received, the parent's data source type. Example values: App, Browser, Mobile. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.headers.accept The types as read from the HTTP Accept request header. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.headers.contentLength bytes (B) Incoming request size in bytes as read from the Content-Length HTTP request header. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.headers.contentType Incoming request content-type as read from the HTTP request header Content-Type. Example value: application/octet-stream. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.headers.host The name from the HTTP host request header. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.headers.referer The incoming request referer as read from the Referer request header. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.headers.userAgent The contents of the User-Agent HTTP header. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.method The HTTP request method used. Example values: POST, GET. AwsLambdaInvocationError AwsLambdaInvocation Span Transaction TransactionError response.headers.contentLength bytes (B) The outgoing response size in bytes as read from the Content-Length response header. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError response.headers.contentType For an HTTP response, the data type of the returned response. Example values: text/html, application/json. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError response.status bytes (B) The response code for an HTTP request AwsLambdaInvocation totalTime seconds (s) The sum of all async components' duration, in seconds. An async component is a method or function where there is no instrumented encapsulating method or function. AwsLambdaInvocation Transaction traceId ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. AwsLambdaInvocationError AwsLambdaInvocation MobileRequest MobileRequestError Span type The New Relic event type. Example values: Transaction, Span. AwsLambdaInvocationError AwsLambdaInvocation AwsLambdaInvocationError Data source : AWS Lambda This event is reported by New Relic monitoring for AWS Lambda. It's generated when an error occurs during a Lambda function invocation. Attribute name Definition Data types aws.lambda.arn The Amazon Resource Name (ARN) of the instrumented Lambda function. AwsLambdaInvocationError AwsLambdaInvocation aws.lambda.coldStart A Boolean indicating if the AWS Lambda invocation is a cold start. AwsLambdaInvocationError AwsLambdaInvocation aws.lambda.eventSource.arn The Amazon Resource Name (ARN) of the entity that invoked the instrumented Lambda function. AwsLambdaInvocationError AwsLambdaInvocation aws.requestId ID AWS identifier of the invocation. AwsLambdaInvocationError AwsLambdaInvocation databaseCallCount count The number of database calls made by this transaction. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError databaseDuration seconds (s) The database response time in seconds. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError duration seconds (s) The total invocation time for the transaction, in seconds. (Data source: AWS Lambda) AwsLambdaInvocationError AwsLambdaInvocation error.class The class name or type for the error. This will be server and platform specific. AwsLambdaInvocationError TransactionError error.message The error message for the transaction. This will be server and platform specific. AwsLambdaInvocationError TransactionError externalCallCount count The number of external calls made by this transaction. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError externalDuration seconds (s) The total response time of all external (out-of-process) services, in seconds. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError newRelic.ingestPoint Where the data point entered the platform (such as browser.spans, or api.traces). AwsLambdaInvocationError AwsLambdaInvocation Span parent.account ID If a distributed tracing payload is received, this is the account identifier for the transaction's upstream caller. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError parent.app ID If a distributed tracing payload is received, this is the application identifier. APM agents retrieve this value in the connect response under the key primary_application_id. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError parent.transportType When a distributed tracing payload is received, the method of transport for the payload. Example values: Unknown, HTTP, HTTPS, Kafka, JMS, IronMQ, AMQP, Queue, or Other. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError parent.type If a distributed trace payload was received, the parent's data source type. Example values: App, Browser, Mobile. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.headers.accept The types as read from the HTTP Accept request header. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.headers.contentLength bytes (B) Incoming request size in bytes as read from the Content-Length HTTP request header. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.headers.contentType Incoming request content-type as read from the HTTP request header Content-Type. Example value: application/octet-stream. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.headers.host The name from the HTTP host request header. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.headers.referer The incoming request referer as read from the Referer request header. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.headers.userAgent The contents of the User-Agent HTTP header. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.method The HTTP request method used. Example values: POST, GET. AwsLambdaInvocationError AwsLambdaInvocation Span Transaction TransactionError response.headers.contentLength bytes (B) The outgoing response size in bytes as read from the Content-Length response header. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError response.headers.contentType For an HTTP response, the data type of the returned response. Example values: text/html, application/json. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError stackTrace The error stack trace. The format will be different depending on the agent language. AwsLambdaInvocationError traceId ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. AwsLambdaInvocationError AwsLambdaInvocation MobileRequest MobileRequestError Span transactionName Name of the transaction in which the error occurred. Example value: Controller/customers/show. Value may be 'Unknown' if an error occurs outside of a transaction. AwsLambdaInvocationError TransactionError type The New Relic event type. Example values: Transaction, Span. AwsLambdaInvocationError AwsLambdaInvocation BrowserInteraction Data source : Browser agent A BrowserInteraction represents a unit of work in a browser session, triggered by a user interacting with the webpage. It captures information about the session, AJAX calls and custom JavaScript timing that occurred as a result of the interaction. Initial load and route changes are captured as special types of browser interactions, and are used for SPA monitoring. Attribute name Definition Data types actionText The text of the HTML element that was clicked when a browser interaction started. BrowserInteraction ajaxCount count A count of all XHRs included in the timing of a SPA interaction. BrowserInteraction appId ID The ID of your application, as recorded by New Relic. AjaxRequest BrowserInteraction BrowserTiming PageAction PageView PageViewTiming appName The name of the application that handled the request as shown in New Relic Browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnLatitude The latitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's latitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnLongitude The longitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's longitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnOrganization The organization that owns the Autonomous System Number. Often an ISP, sometimes a private company or institution. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming backendTransactionName The name of the backend transaction that served the initial page load. BrowserInteraction browserInteractionId ID A unique value generated for each browser interaction captured by the New Relic agent. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError browserInteractionName The name of the interaction. This is either the targetGroupedUrl or the custom name set via the API. AjaxRequest BrowserInteraction BrowserTiming category The type of interaction; either initial page load, route change, or custom. BrowserInteraction city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileSession PageAction PageView PageViewTiming countryCode The country from which the browser initiated the page load. For a list of country codes, see ISO 3166-1 alpha-2. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming deviceType The type of device that loaded the page: mobile, tablet, or desktop. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageView domain The domain portion of the request URL. BrowserInteraction JavaScriptError PageView PageViewTiming duration seconds (s) The total time elapsed of the interaction event BrowserInteraction eventId ID A value that you can link to multiple BrowserInteraction events so you can view the interactions that occurred surrounding a specific event. For example, you can see the browser interactions that occurred prior to a JS error. AjaxRequest BrowserInteraction BrowserTiming firstContentfulPaint firstContentfulPaint is the point when the browser renders the first bit of content from the DOM, which may be text, an image, SVG, or a <canvas> element. Google's User-centric Performance Metrics contains detailed information about its Paint Timing API and firstContentfulPaint. See Compatibility and requirements for New Relic Browser for additional information about firstContentfulPaint browser compatibility. BrowserInteraction PageView firstPaint firstPaint marks the point when the browser renders anything that is visually different from what was on the screen prior to navigation. This includes non-default background paint and the enclosing box of an iframe. Google's User-centric Performance Metrics contains detailed information about its Paint Timing API and firstPaint. See Compatibility and requirements for New Relic Browser for additional information about firstPaint browser compatibility. BrowserInteraction PageView jsDuration seconds (s) The total duration, in seconds, spent on JavaScript execution. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. This attribute doesn't exist for initial page load events. AjaxRequest BrowserInteraction BrowserTiming monitorAccountId The Synthetics account from which you are running the monitor. BrowserInteraction JavaScriptError monitorId ID A unique number identifying a particular monitor. BrowserInteraction JavaScriptError SyntheticCheck monitorJobId ID The ID of a single Synthetics monitor run, which began at a specific time and originated from a specific location. BrowserInteraction JavaScriptError parentEventId ID A unique value generated for each interaction with the page. You can use this value to group interactions together. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError previousGroupedUrl The grouped version of the URL in the browser at the start of the interaction. BrowserInteraction previousRouteName The route name of the page at the start of the interaction. This is the last value passed by setCurrentRouteName before the start of the interaction. BrowserInteraction previousURL The ungrouped URL in the browser at the start of the interaction. BrowserInteraction regionCode The specific administrative division within a country where the PageView event occurred. In the United States, regions correspond to state codes, such as WA or NY. Outside the United States, a country's regions correspond to numerical codes. In the United States, regions correspond to state codes ; for example, WA or NY. Outside the United States, a country's regions correspond to numerical codes . AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming session A unique identifier for a single session. The session cookie expires when the user closes the browser (for example, they fully exit Chrome.) A new session identifier will be assigned when the user opens up a new instance of the browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span targetGroupedUrl The grouped version of the URL in the browser at the end of the interaction. BrowserInteraction targetRouteName The route name for the page at the end of the interaction. The last value passed by setCurrentRouteName before the end of the interaction. BrowserInteraction targetUrl The ungrouped URL in the browser at the end of the interaction. BrowserInteraction timeToConnectEnd seconds (s) The time, in seconds, from the start of the interaction to the connectEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToConnectStart seconds (s) The time, in seconds, from the start of the interaction to the connectStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomComplete seconds (s) The time, in seconds, from the start of the interaction to the domComplete, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomContentLoadedEventEnd seconds (s) The time, in seconds, from the start of the interaction to the domContentLoadedEventEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomContentLoadedEventStart seconds (s) The time, in seconds, from the start of the interaction to the domContentLoadedEventStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomInteractive seconds (s) The time, in seconds, from the start of the interaction to the domInteractive, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomLoading seconds (s) The time, in seconds, from the start of the interaction to the domLoading, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomainLookupEnd seconds (s) The time, in seconds, from the start of the interaction to the domainLookupEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomainLookupStart seconds (s) The time, in seconds, from the start of the interaction to the domainLookupStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToFetchStart seconds (s) The time, in seconds, from the start of the interaction to the fetchStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToLastCallbackEnd seconds (s) The duration, in seconds, from the start of the request (timestamp) to the end of the last callback. This is not just an additive function; the callback time can overlap with the wait time. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. AjaxRequest BrowserInteraction BrowserTiming timeToLoadEventEnd seconds (s) The time, in seconds, from the start of the interaction to the loadEventEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToLoadEventStart seconds (s) The time, in seconds, from the start of the interaction to the loadEventStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information, see our documentation about instrumentation for the Navigation Timing API. BrowserInteraction timeToRedirectEnd seconds (s) The time, in seconds, from the start of the interaction to the redirectEnd, as defined by the Navigation Timing API. This attribute exists only for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToRedirectStart seconds (s) The time, in seconds, from the start of the interaction to the redirectStart, as defined by the Navigation Timing API. This attribute exists only for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToRequestStart seconds (s) The time, in seconds, from the start of the interaction to the requestStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToResponseEnd seconds (s) The time, in seconds, from the start of the interaction to the responseEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToResponseStart seconds (s) The time, in seconds, from the start of the interaction to the responseStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToSecureConnectionStart seconds (s) The time, in seconds, from the start of the interaction to the secureConnectionStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToUnloadEventEnd seconds (s) The time, in seconds, from the start of the interaction to the unloadEventEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToUnloadEventStart seconds (s) The time, in seconds, from the start of the interaction to the unloadEventStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timestamp The time (date, hour, minute, second) at which the interaction occurred. AjaxRequest BrowserInteraction BrowserTiming PageAction PageView PageViewTiming Span trigger The cause of the route change or page load. The default values are click, submit, popstate, or initial page load. For a custom event created with the API, the default value for trigger will be api. This value can also be set via the API. BrowserInteraction userAgentName The browserâ€™s name, such as Chrome and Firefox, obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentOS The browserâ€™s reported operating system, such as Windows or Linux, that it is running on. This is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentVersion The browserâ€™s reported software version, which is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming BrowserTiming Data source : Browser agent BrowserTiming is a custom event that captures SPA timing data for browser interactions started using the custom createTracer SPA API method. BrowserTiming contains many of the same attributes used by other events, especially AjaxRequest. Attribute name Definition Data types appId ID The ID of your application, as recorded by New Relic. AjaxRequest BrowserInteraction BrowserTiming PageAction PageView PageViewTiming appName The name of the application that handled the request as shown in New Relic Browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnLatitude The latitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's latitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnLongitude The longitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's longitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnOrganization The organization that owns the Autonomous System Number. Often an ISP, sometimes a private company or institution. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming browserInteractionId ID A unique value generated for each browser interaction captured by the New Relic agent. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError browserInteractionName The name of the interaction. This is either the targetGroupedUrl or the custom name set via the API. AjaxRequest BrowserInteraction BrowserTiming browserTimingName The name of the event. This is taken from the name argument of createTracer. BrowserTiming city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileSession PageAction PageView PageViewTiming countryCode The country from which the browser initiated the page load. For a list of country codes, see ISO 3166-1 alpha-2. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming deviceType The type of device that loaded the page: mobile, tablet, or desktop. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageView eventId ID A value that you can link to multiple BrowserInteraction events so you can view the interactions that occurred surrounding a specific event. For example, you can see the browser interactions that occurred prior to a JS error. AjaxRequest BrowserInteraction BrowserTiming groupedPageURL The grouped URL of the view that made the AJAX request. For example: myapp.com/acct/*/dash. AjaxRequest BrowserTiming jsDuration seconds (s) The total duration, in seconds, spent on JavaScript execution. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. This attribute doesn't exist for initial page load events. AjaxRequest BrowserInteraction BrowserTiming pageUrl The URL of the page that was loaded for the PageView. For example: http://www.newrelic.com. This URL does not include query parameters. AjaxRequest BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span parentEventId ID A unique value generated for each interaction with the page. You can use this value to group interactions together. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError regionCode The specific administrative division within a country where the PageView event occurred. In the United States, regions correspond to state codes, such as WA or NY. Outside the United States, a country's regions correspond to numerical codes. In the United States, regions correspond to state codes ; for example, WA or NY. Outside the United States, a country's regions correspond to numerical codes . AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming session A unique identifier for a single session. The session cookie expires when the user closes the browser (for example, they fully exit Chrome.) A new session identifier will be assigned when the user opens up a new instance of the browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span timeSinceBrowserInteractionStart seconds (s) The time in seconds between the start of the BrowserInteraction and the start of the request. AjaxRequest BrowserTiming timeToLastCallbackEnd seconds (s) The duration, in seconds, from the start of the request (timestamp) to the end of the last callback. This is not just an additive function; the callback time can overlap with the wait time. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. AjaxRequest BrowserInteraction BrowserTiming timeToSettle seconds (s) The time, in seconds, from the start of the request to when all resulting callbacks (including callbacks of subsequent AJAX requests) are complete. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. AjaxRequest BrowserTiming timeToTracedCallbackStart seconds (s) The time in seconds from the start of the custom tracer until the start of the traced callback. This attribute is unique to the BrowserTiming event. BrowserTiming timestamp The time (date, hour, minute, second) at which the interaction occurred. AjaxRequest BrowserInteraction BrowserTiming PageAction PageView PageViewTiming Span tracedCallbackDuration seconds (s) The duration in seconds of the traced callback. This attribute is unique to the BrowserTiming event. BrowserTiming userAgentName The browserâ€™s name, such as Chrome and Firefox, obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentOS The browserâ€™s reported operating system, such as Windows or Linux, that it is running on. This is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentVersion The browserâ€™s reported software version, which is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming ContainerSample Data source : Infrastructure This event is reported by the New Relic Infrastructure agent. It collects data from all the Docker containers on the host (which may or may not be running). It includes the container's ID, name, image, image name, and metrics about CPU, memory and networking. We take a snapshot of this data every 15 seconds for each container and package it into this event, which is then sent to New Relic. This data appears on the Containers UI page. Attribute name Definition Data types StorageDataAvailableBytes bytes (B) Data space available in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageDataTotalBytes bytes (B) Total Data space in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageDataUsagePercent percentage (%) Percent of Data space used in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageDataUsedBytes bytes (B) Data space used by the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageMetadataAvailableBytes bytes (B) Metadata space available in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageMetadataTotalBytes bytes (B) Total Metadata space in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageMetadataUsagePercent percentage (%) Percent of Metadata space used in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageMetadataUsedBytes bytes (B) Metadata space used by the Storage Driver. Only Device Mapper driver is supported. ContainerSample commandLine The command line used in the container. ContainerSample containerId ID The unique Docker container ID. ContainerSample cpuKernelPercent percentage (%) CPU time percentage used in kernel space. ContainerSample cpuLimitCores count Number of cores available for the container. ContainerSample cpuPercent percentage (%) CPU usage percentage used. ContainerSample cpuShares count Number of CPU shares assigned to the container. ContainerSample cpuThrottlePeriods count Total number of periods throttled. ContainerSample cpuThrottleTimeMs milliseconds (ms) Total throttling time in milliseconds. ContainerSample cpuUsedCores percentage (%) CPU usage per core. ContainerSample cpuUsedCoresPercent percentage (%) CPU usage percentage per core. ContainerSample cpuUserPercent percentage (%) CPU time percentage used in user space. ContainerSample criticalViolationCount count The number of times that alert conditions violated critical thresholds, causing critical violations and opening incidents. If this attribute does not exist on the sample, it has zero violations. ContainerSample NetworkSample ProcessSample StorageSample SystemSample image ID The Docker image ID for the image the container is based on. ContainerSample imageName The Docker image name for the container. ContainerSample label_KEY Docker labels associated with this container (where KEY represents a custom label's key value). ContainerSample memoryCacheBytes count The amount of memory used by the container that can be associated precisely with a block on a block device. ContainerSample memoryKernelUsageBytes bytes (B) The amount of current kernel memory allocation. ContainerSample memoryResidentSizeBytes bytes (B) The amount of memory that doesn't correspond to anything on disk: stacks, heaps, and anonymous memory maps. ContainerSample memorySizeLimitBytes bytes (B) The total amount of memory the container is allowed to use. ContainerSample memorySoftLimitBytes bytes (B) The soft limit of memory usage equivalent to the memory reservation of the container. ContainerSample memorySwapLimitBytes bytes (B) The total amount of memory the container is using, including swap. ContainerSample memorySwapLimitUsagePercent percentage (%) This metric is calculated as the percentage of memorySwapUsageBytes over memorySwapLimitBytes, if the limit exists. ContainerSample memorySwapOnlyUsageBytes bytes (B) The amount of swap memory the container is using. This memory doesn't include non-swap memory. ContainerSample memorySwapUsageBytes bytes (B) The amount of memory swap the container is using, including swap. ContainerSample memoryUsageBytes bytes (B) This metric doesn't account for swap usage. ContainerSample memoryUsageLimitPercent percentage (%) This metric is calculated as the memoryUsageBytes percentage over memorySizeLimitBytes, if the limit exists. ContainerSample name The Docker container name. ContainerSample networkRxBytes bytes (B) Total number of received bytes. ContainerSample networkRxBytesPerSecond rate Number of received bytes per second. ContainerSample networkRxDropped count Total number of received packets dropped. ContainerSample networkRxDroppedPerSecond rate Number of received packets dropped per second. ContainerSample networkRxError count Total number of received packets with error. ContainerSample networkRxErrorsPerSecond rate Number of received packets with error per second. ContainerSample networkRxPackets count Total number of received packets. ContainerSample networkRxPacketsPerSecond rate Number of received packets with error per second. ContainerSample networkTxBytesPerSecond rate Number of transmitted bytes per second. ContainerSample networkTxDropped count Total number of transmitted packets dropped. ContainerSample networkTxDroppedPerSecond rate Number of transmitted packets dropped per second. ContainerSample networkTxErrors count Total number of transmitted packets with error. ContainerSample networkTxErrorsPerSecond rate Number of transmitted packets with error per second. ContainerSample networkTxPackets count Total number of transmitted packets. ContainerSample networkTxPacketsPerSecond rate Number of transmitted packets per second. ContainerSample networksTxBytes count Total number of bytes transmitted. ContainerSample restartCount count The number of times the container was restarted. ContainerSample state It can be: created, restarting, running, removing, paused, exited, or dead. ContainerSample status Holds the current container state. ContainerSample warningViolationCount count The number of times that alert conditions violated warning thresholds, causing warning violations. ContainerSample NetworkSample ProcessSample StorageSample SystemSample DistributedTraceSummary Data source : Distributed Tracing This event contains summary data about a distributed trace and provides an aggregated view of distributed tracing data. DistributedTraceSummary events are generated by New Relic and are triggered by distributed tracing data from agents or the Trace API. Attribute name Definition Data types accountIds A comma delimited list of newrelic accountIds that took part in this trace. DistributedTraceSummary backend.duration.ms milliseconds (ms) The total elapsed time in milliseconds of all backend services in this trace. DistributedTraceSummary backend.timestamp milliseconds (ms) The timestamp of the first span in this trace from a backend entity. In distributed tracing, any events that are not from client-side applications contributed to the backend duration. DistributedTraceSummary duration.ms The duration of the entire distributed trace, including both backend and client-side entities. the earliest span to the latest. DistributedTraceSummary entityCount count The number of unique entities that took part in this trace. DistributedTraceSummary entityGuids A comma delimited list of entity GUIDs for entities that participated in this trace. These GUIDs are assigned by New Relic for the New Relic-monitored entity (host, application, etc.). Each GUID is stored as a Base64 encoded value. DistributedTraceSummary errorCount count The number of events in this distributed trace that were identified as errors. DistributedTraceSummary newRelic.traceFilter.type The name of the trace filter used by the Infinite Tracing trace observer to select this trace. DistributedTraceSummary Span root.entity.accountId The New Relic account ID that the root entity of this trace reports data to. DistributedTraceSummary root.entity.guid The entity GUID associated with the root entity of this trace. DistributedTraceSummary root.entity.name The name of the root entity of this trace. DistributedTraceSummary root.span.duration.ms milliseconds (ms) The elapsed time in milliseconds of the root span of this trace. The root of a distributed trace is the first span, and will have a null value for parent.id. DistributedTraceSummary root.span.id The unique identifier of the root span of this trace. The root of a distributed trace is the first span, and it has a null value for parent.id. DistributedTraceSummary root.span.name The name of the root span of this trace. DistributedTraceSummary root.span.timestamp milliseconds (ms) The timestamp of the root span of this trace. The root of a distributed trace is the first span, and will have a null value for parent.id. DistributedTraceSummary spanCount count The number of events in this distributed trace. Events in a distributed trace can have several event types, including Span, Transaction, and TransactionError. DistributedTraceSummary timestamp milliseconds (ms) The timestamp of the root span in this distributed trace. DistributedTraceSummary trace.id ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. DistributedTraceSummary MobileRequest MobileRequestError Span Transaction TransactionError InfrastructureEvent Data sources : InfrastructureCloudTrail InfrastructureEvent describes changes (deltas) that occur in a system's live state. When an inventory or system state is added, removed, or changed, Infrastructure will produce an InfrastructureEvent that logs that activity. Attribute name Definition Data types category A New Relic category used to organize events in the UI. For example: automation, notification, and service. InfrastructureEvent changeType A simple classification of the type of change made to the entity: added, modified, or removed. InfrastructureEvent changedPath The fully specified name of the item that changed. This is constructed by taking the source and adding one or more additional path elements that uniquely identify the item that changed. InfrastructureEvent deltaId Delta refers to a recorded change in the system. The deltaId is a number used by New Relic to organize incoming inventory change data. InfrastructureEvent eventId The unique ID of the event, generated by New Relic. InfrastructureEvent format The type of infrastructure event. Each format type includes attributes that may be used to render the event in the UI. InfrastructureEvent newStatus The new agent status: disconnected or connected. InfrastructureEvent newValue If a change is made to the entity, this attribute contains the new value of the inventory that was changed. This will have no value if no change has been made. The value will display approximately 4K bytes of data. InfrastructureEvent oldValue If a change is made to the entity, this attribute contains the old value of the inventory that was changed. This will be blank if no change has been made. InfrastructureEvent provider For integrations that use generic event types (like the DatastoreSample event), the provider value specifies the source of the data (the service, or a sub-category of data from that service). Some Insights events are generic and are used by several integrations. For example, the DatastoreSample event is used by several integrations, including the AWS DynamoDB integration and the AWS RDS integration. In these cases, the provider attribute value represents the source of that attribute. This will usually be the service that data comes from or, for integrations that use several provider values, a certain sub-category of data from that service. When a provider value is present for a generic event, that event will have additional integration-specific attributes attached to it. Hereâ€™s an example of an Insights NRQL query that returns the attributes present for a DatastoreSample event reported by the AWS RDS integration: SELECT * from DatastoreSample where provider = 'RdsDbCluster' InfrastructureEvent source The fully specified origin of this inventory item. This is typically in the form category/plugin, where plugin is the generic word used for the tool that gathered this data. InfrastructureEvent summary A summary of the change that happened. Uses a human-friendly string, such as Agent disconnected. InfrastructureEvent violationUpdateType The type of change to the violation: For example: open or closed. InfrastructureEvent JavaScriptError Data source : Browser agent As JavaScript errors are triggered, we capture details as events. The JavaScriptError event contains information to help you segment errors to understand how they impact performance. Attribute name Definition Data types appId ID The identification number for the reporting browser agent. JavaScriptError appName The name of the application that handled the request as shown in New Relic Browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnLatitude The latitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's latitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnLongitude The longitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's longitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnOrganization The organization that owns the Autonomous System Number. Often an ISP, sometimes a private company or institution. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming browserInteractionId ID A unique value generated for each browser interaction captured by the New Relic agent. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError browserStackHash ID An unique identifier generated for a stack trace. The browserStackHash for a stack trace is different across different browsers. An identical stack trace will generate the same identifier. JavaScriptError city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileSession PageAction PageView PageViewTiming countryCode The country from which the browser initiated the page load. For a list of country codes, see ISO 3166-1 alpha-2. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming deviceType The type of device that loaded the page: mobile, tablet, or desktop. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageView domain The domain portion of the request URL. BrowserInteraction JavaScriptError PageView PageViewTiming entityGuid The unique identifier of the monitor referenced in New Relic One. JavaScriptError SyntheticCheck SyntheticRequest errorClass The error type of the JavaScript Error object. Examples: ReferenceError, SyntaxError, and UncaughtException. JavaScriptError errorMessage The error message that was delivered. JavaScriptError firstErrorInSession A value to indicate whether or not this was the first JS error in the session. Example: true. JavaScriptError monitorAccountId The Synthetics account from which you are running the monitor. BrowserInteraction JavaScriptError monitorId ID A unique number identifying a particular monitor. BrowserInteraction JavaScriptError SyntheticCheck monitorJobId ID The ID of a single Synthetics monitor run, which began at a specific time and originated from a specific location. BrowserInteraction JavaScriptError pageUrl The URL of the page that was loaded for the PageView. For example: http://www.newrelic.com. This URL does not include query parameters. AjaxRequest BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span parentEventId ID A unique value generated for each interaction with the page. You can use this value to group interactions together. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError regionCode The specific administrative division within a country where the PageView event occurred. In the United States, regions correspond to state codes, such as WA or NY. Outside the United States, a country's regions correspond to numerical codes. In the United States, regions correspond to state codes ; for example, WA or NY. Outside the United States, a country's regions correspond to numerical codes . AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming releaseIds ID The releases in which the app was updated. Example: {\\\"jQuery\\\":\\\"v3.1.1\\\",\\\"multiverse\\\":\\\"96e9ac7\\\"}. JavaScriptError requestUri The URI of the requested resource. JavaScriptError session A unique identifier for a single session. The session cookie expires when the user closes the browser (for example, they fully exit Chrome.) A new session identifier will be assigned when the user opens up a new instance of the browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span stackHash ID A unique identifier generated by the Browser agent for a stack trace. The stackHash for a stack trace is the same across different browsers. An identical stack trace will generate the same identifier. JavaScriptError stackTrace A collection of the active stack frames when the error occurred. JavaScriptError stackTraceGzip A compressed version of the stackTrace attribute. JavaScriptError timestamp The time that the error occurred, in Unix time. JavaScriptError transactionName The full metric name of the transaction in which the error occurred, or Unknown if the error occurs outside of a transaction. JavaScriptError userAgentName The browserâ€™s name, such as Chrome and Firefox, obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentOS The browserâ€™s reported operating system, such as Windows or Linux, that it is running on. This is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentVersion The browserâ€™s reported software version, which is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming Metric Data source : Metrics Represents a metric data point (e.g., a measurement over a range of time, or a sample at a specific point in time) with multiple attributes attached, which allow for in-depth analysis and querying. This metric data comes from our Metric API, our Telemetry SDKs, and some of our open-source exporters/integrations. Attribute name Definition Data types endTimestamp milliseconds (ms) The end of the time range associated with the metric, in Unix time, in milliseconds. This is calculated by adding the metric interval to the timestamp of the metric (timestamp + interval.ms). Metric interval.ms milliseconds (ms) The length of the time window. Metric metricName Name of the metric. Metric newrelic.source The source of this data. For example: metricAPI. Metric timestamp milliseconds (ms) The start time for the metric, in Unix time. Metric Mobile Data source : Mobile A Mobile event is created when a crash occurs, when an interaction ends or has run for 1 second, or if a session completes after the app is closed, backgrounded, or has run for 10 minutes. Mobile events were once the only event type and were generated for every event, but now there are several specialized event types. Recommendation: Upgrade to the most recent mobile monitoring agent version to take full advantage of the new event types. Attribute name Definition Data types category The type of data, either session or interaction. Mobile MobileSession interactionDuration For interaction category events only. This is the total time for the interaction to render on the device. In addition to render time, this usually includes all external calls associated with the interaction. Currently, this attribute is measured in seconds for Android devices and in milliseconds for iOS devices. Mobile name For interaction category events only. This is the label of the interaction associated with the event. It is by default assigned by New Relic. For example: ApplicationsListFragment or Display iOS_Example.MasterViewController. Mobile reportedTimestampMs For interaction category events only. The UTC based timestamp for when the event was sent to New Relic. This is different from the attribute â€˜timestampâ€™, which is when the event began. Mobile MobileCrash Data source : Mobile The MobileCrash event is created when an app crashes. MobileCrash includes attributes such as crash line number, class, and crash message. Attribute name Definition Data types appBuild Indicates the technical build number of the app binary. As a developer, you can use this attribute to identify specific builds of your app. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appId ID A unique identifier for a monitored app, based on the app token. For example: 35091. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appName The name of the monitored app. For example: My Mobile App - iOS. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appToken The mobile application license token. MobileCrash appVersion The version number of the monitored app. For example: 2.2.9. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersionId ID An identifier for the specific version of the app. For example: 1713477. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession architecture The processor architecture of the device. For example: armv7 or arm64. MobileCrash asnOwner The telecom owner of the ASN. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession bundleId ID The unique string used to identify the application. MobileCrash MobileSession carrier The network over which the app transferred data, such as Wi-Fi, Verizon, or Sprint. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession crashException The exception associated with the crash, if one is present. For example: java.lang.NullPointerException. MobileCrash crashFingerprint ID The New Relic-generated fingerprint used to uniquely identify the crash and other crashes identical to this one. MobileCrash crashLocationFile The file in which the crash occurred. MobileCrash crashMessage The message associated with the crash, if one is present. MobileCrash deviceManufacturer The manufacturer of the device, such as Motorola or HTC. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceModel The model number of the device, such as XT1039 or SM-G900F. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceName The device's name. MobileCrash deviceUuid ID A unique identifier assigned at the time of app installation by New Relic. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of uuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession diskAvailable bytes (B) Space available on the device, in bytes. MobileCrash interactionHistory The client interactions with the application that led to the crash. MobileCrash isFirstOccurrence A boolean value indicating whether or not this was the first occurrence of the crash. MobileCrash lastInteraction The last interaction before a crash or harvest event, if one is present. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession memUsageMb megabytes (MB) The total amount of memory, in MB, used by the application. Updated every 60 seconds. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession modelNumber The model of the device. This is the same as the session-level deviceModel attribute. MobileCrash networkStatus The type of network that the device was on at the time of crash, such as wifi or LTE. MobileCrash newRelicVersion The version number of the agent running on the application. For example: 4.232.0. Duplicate of newRelicAgentVersion. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession occurrenceId ID The ID for this instance of the crash. MobileCrash orientation The orientation of the device, such as landscape or portrait. MobileCrash osBuild For Android only. The specific build of the Android OS. MobileCrash MobileHandledException osMajorVersion The simplified version number of the app's host operating system, such as iOS 11, as compared to iOS 11.0.4. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osName The name of the app's host operating system, for example, iOS or Android. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osVersion The exact version number of the app's host operating system, such as iOS 11.0.4, as compared to iOS 11. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession parentProcess The parent process that launched the crashing process. MobileCrash parentProcessId ID The parent identification number (PID) of the parent process. MobileCrash platform The platform type of the mobile monitoring agent, such as native or Cordova. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession processId ID The PID of the previously running process on the device. MobileCrash processName The name of the previously running process. MobileCrash processPath The path to the binary. MobileCrash reportedTimestampMs The UTC timestamp for when the event was received by New Relic. (This is different from timestamp, which is when the MobileSession event began that crashed.) MobileCrash runTime For Android only. The Android Runtime version where the exception/crash was generated. MobileCrash MobileHandledException sessionCrashed A boolean value indicating whether or not that session crashed. MobileCrash MobileSession sessionId ID A unique identifier for a single user session. A new sessionId is created each time the app is brought into the foreground. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession symbolicated A boolean value indicating whether or not the crash was properly symbolicated. MobileCrash timeSinceLastInteraction milliseconds (ms) The time, in milliseconds, since the interaction before a crash event. MobileCrash userImageUuids ID The array of build UUIDs for applications and libraries. MobileCrash uuid ID A unique identifier assigned by New Relic for a specific app on a particular device. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of deviceUuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession MobileHandledException Data source : Mobile MobileHandledException is sent when an exception is caught and is used for non-fatal exceptions reported to New Relic using the recordHandledException API for Android or iOS. Attribute name Definition Data types appBuild Indicates the technical build number of the app binary. As a developer, you can use this attribute to identify specific builds of your app. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appId ID A unique identifier for a monitored app, based on the app token. For example: 35091. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appName The name of the monitored app. For example: My Mobile App - iOS. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersion The version number of the monitored app. For example: 2.2.9. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersionId ID An identifier for the specific version of the app. For example: 1713477. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnOwner The telecom owner of the ASN. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession carrier The network over which the app transferred data, such as Wi-Fi, Verizon, or Sprint. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileSession PageAction PageView PageViewTiming countryCode The country from which the device ran the application. For a list of country codes, see ISO 3166-1 alpha-2. MobileHandledException MobileRequest MobileRequestError MobileSession device The specific type of the device: iPhone 8, iPad Pro, etc. Duplicate of deviceType. MobileHandledException MobileRequest MobileRequestError MobileSession deviceManufacturer The manufacturer of the device, such as Motorola or HTC. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceModel The model number of the device, such as XT1039 or SM-G900F. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceType The specific type of device: iPhone 8, iPad Pro, etc. Duplicate of device. MobileHandledException MobileRequest MobileRequestError MobileSession deviceUuid ID A unique identifier assigned at the time of app installation by New Relic. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of uuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession exceptionAppBuildUuid ID The build uuid of the application binary in which the exception was caught. MobileHandledException exceptionCause The unsymbolicated, platform-specific cause of the exception. MobileHandledException exceptionLocation New Relic defined location of an exception. Contains a combination of exception file name, class, line number, and method. MobileHandledException exceptionLocationClass The class that generated the exception. Only present if symbolication succeeded. MobileHandledException exceptionLocationFile The class that generated the exception. Only present if symbolication succeeded. MobileHandledException exceptionLocationLibraryOffset For XCFramework agent only. The library offset of the library that generated the exception. Only present if symbolication succeeded. MobileHandledException exceptionLocationLine Comes from the exception: The line number where the exception was generated. Only present if symbolication succeeded. MobileHandledException exceptionLocationMethod The method that generated the exception. Only present if symbolication succeeded. MobileHandledException exceptionMessage The unsymbolicated message from the exception. It can be user-generated or a generic system message. For Android, this is the Throwable message. MobileHandledException exceptionName The unsymbolicated exception type. MobileHandledException fingerprint ID The New Relic-generated identifier used to group like exceptions. MobileHandledException handledExceptionUuid ID The unique ID of the exception event. MobileHandledException lastInteraction The last interaction before a crash or harvest event, if one is present. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession libraryName For XCFramework agent only. The library name where the exception was generated. MobileHandledException libraryStartAddr For XCFramework agent only. The library start address where the exception was generated. MobileHandledException memUsageMb megabytes (MB) The total amount of memory, in MB, used by the application. Updated every 60 seconds. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession newRelicVersion The version number of the agent running on the application. For example: 4.232.0. Duplicate of newRelicAgentVersion. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession occurrenceTimestamp Agent-reported epoch timestamp of the handled exception. MobileHandledException osBuild For Android only. The specific build of the Android OS. MobileCrash MobileHandledException osMajorVersion The simplified version number of the app's host operating system, such as iOS 11, as compared to iOS 11.0.4. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osName The name of the app's host operating system, for example, iOS or Android. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osVersion The exact version number of the app's host operating system, such as iOS 11.0.4, as compared to iOS 11. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession platform The platform type of the mobile monitoring agent, such as native or Cordova. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession regionCode The specific region within a country where the monitored app is located. In the United States, regions are states. The regionCode is based on IP address and may not always match your region. MobileHandledException MobileRequest MobileRequestError MobileSession runTime For Android only. The Android Runtime version where the exception/crash was generated. MobileCrash MobileHandledException sessionId ID A unique identifier for a single user session. A new sessionId is created each time the app is brought into the foreground. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession timestamp Epoch timestamp of the handled exception. This exception timestamp represents the time New Relic created the event, if it's older than two days or some other unexpected time. MobileHandledException uuid ID A unique identifier assigned by New Relic for a specific app on a particular device. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of deviceUuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession MobileRequest Data source : Mobile A MobileRequest event is created when an HTTP request successfully completes, resulting in a response code below 400. Attribute name Definition Data types appBuild Indicates the technical build number of the app binary. As a developer, you can use this attribute to identify specific builds of your app. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appId ID A unique identifier for a monitored app, based on the app token. For example: 35091. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appName The name of the monitored app. For example: My Mobile App - iOS. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersion The version number of the monitored app. For example: 2.2.9. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersionId ID An identifier for the specific version of the app. For example: 1713477. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnOwner The telecom owner of the ASN. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession bytesReceived bytes (B) Optional: If the application received a response from the requestUrl, the size of that response in bytes. MobileRequest MobileRequestError bytesSent bytes (B) Optional: If the application sent a request to the requestUrl, the size of that request in bytes. MobileRequest MobileRequestError carrier The network over which the app transferred data, such as Wi-Fi, Verizon, or Sprint. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession connectionType The type of connection which the device was using, such as 2G or 3G. MobileRequest MobileRequestError countryCode The country from which the device ran the application. For a list of country codes, see ISO 3166-1 alpha-2. MobileHandledException MobileRequest MobileRequestError MobileSession device The specific type of the device: iPhone 8, iPad Pro, etc. Duplicate of deviceType. MobileHandledException MobileRequest MobileRequestError MobileSession deviceGroup The category of the device, such as iPhone or Tablet. MobileRequest MobileRequestError MobileSession deviceManufacturer The manufacturer of the device, such as Motorola or HTC. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceModel The model number of the device, such as XT1039 or SM-G900F. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceSize The display size of the device: Small, normal, large, xlarge. MobileRequest MobileRequestError deviceType The specific type of device: iPhone 8, iPad Pro, etc. Duplicate of device. MobileHandledException MobileRequest MobileRequestError MobileSession deviceUuid ID A unique identifier assigned at the time of app installation by New Relic. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of uuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession duration seconds (s) Optional: The time to complete the request, measured in fractional seconds. MobileRequest MobileRequestError guid ID The unique identifier for the segment. This is equivalent to spanID in OpenTracing semantics. MobileRequest MobileRequestError Span lastInteraction The last interaction before a crash or harvest event, if one is present. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession memUsageMb megabytes (MB) The total amount of memory, in MB, used by the application. Updated every 60 seconds. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession newRelicVersion The version number of the agent running on the application. For example: 4.232.0. Duplicate of newRelicAgentVersion. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osMajorVersion The simplified version number of the app's host operating system, such as iOS 11, as compared to iOS 11.0.4. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osName The name of the app's host operating system, for example, iOS or Android. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osVersion The exact version number of the app's host operating system, such as iOS 11.0.4, as compared to iOS 11. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession platform The platform type of the mobile monitoring agent, such as native or Cordova. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession regionCode The specific region within a country where the monitored app is located. In the United States, regions are states. The regionCode is based on IP address and may not always match your region. MobileHandledException MobileRequest MobileRequestError MobileSession requestDomain The domain that the application attempted to access when the event occurred. MobileRequest MobileRequestError requestFingerprint ID The New Relic-generated identifier used to group like request events. MobileRequest requestMethod The REST method (GET, PUT, POST, etc.) that the application attempted when the event occurred. MobileRequest MobileRequestError requestPath The path that the application attempted to access when the event occurred. MobileRequest MobileRequestError requestUrl The URL that the application attempted to access when the event occurred. MobileRequest MobileRequestError requestUuid ID A unique identifer for the request event. MobileRequest MobileRequestError responseTime seconds (s) The time between the request and the response in fractional seconds. MobileRequest MobileRequestError sessionId ID A unique identifier for a single user session. A new sessionId is created each time the app is brought into the foreground. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession statusCode Optional: The HTTP status code for the HTTP event. MobileRequest MobileRequestError timestamp The UTC epoch time at which an event began. MobileRequest MobileRequestError MobileSession trace.id ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. DistributedTraceSummary MobileRequest MobileRequestError Span Transaction TransactionError traceId ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. AwsLambdaInvocationError AwsLambdaInvocation MobileRequest MobileRequestError Span uuid ID A unique identifier assigned by New Relic for a specific app on a particular device. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of deviceUuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession MobileRequestError Data source : Mobile A MobileRequestError is used for HTTP errors or network failures. HTTP errors are HTTP requests that have a status code greater than 400. A network failure is a HTTP request that results in no response. The event is sent when the HTTP request completes. Attribute name Definition Data types appBuild Indicates the technical build number of the app binary. As a developer, you can use this attribute to identify specific builds of your app. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appId ID A unique identifier for a monitored app, based on the app token. For example: 35091. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appName The name of the monitored app. For example: My Mobile App - iOS. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersion The version number of the monitored app. For example: 2.2.9. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersionId ID An identifier for the specific version of the app. For example: 1713477. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnOwner The telecom owner of the ASN. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession bytesReceived bytes (B) Optional: If the application received a response from the requestUrl, the size of that response in bytes. MobileRequest MobileRequestError bytesSent bytes (B) Optional: If the application sent a request to the requestUrl, the size of that request in bytes. MobileRequest MobileRequestError carrier The network over which the app transferred data, such as Wi-Fi, Verizon, or Sprint. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession connectionType The type of connection which the device was using, such as 2G or 3G. MobileRequest MobileRequestError countryCode The country from which the device ran the application. For a list of country codes, see ISO 3166-1 alpha-2. MobileHandledException MobileRequest MobileRequestError MobileSession device The specific type of the device: iPhone 8, iPad Pro, etc. Duplicate of deviceType. MobileHandledException MobileRequest MobileRequestError MobileSession deviceGroup The category of the device, such as iPhone or Tablet. MobileRequest MobileRequestError MobileSession deviceManufacturer The manufacturer of the device, such as Motorola or HTC. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceModel The model number of the device, such as XT1039 or SM-G900F. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceSize The display size of the device: Small, normal, large, xlarge. MobileRequest MobileRequestError deviceType The specific type of device: iPhone 8, iPad Pro, etc. Duplicate of device. MobileHandledException MobileRequest MobileRequestError MobileSession deviceUuid ID A unique identifier assigned at the time of app installation by New Relic. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of uuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession duration seconds (s) Optional: The time to complete the request, measured in fractional seconds. MobileRequest MobileRequestError errorType Either HTTPError or NetworkFailure, depending on whether the error is a result of a failed request to a host or a failure on the cellular network. MobileRequestError guid ID The unique identifier for the segment. This is equivalent to spanID in OpenTracing semantics. MobileRequest MobileRequestError Span lastInteraction The last interaction before a crash or harvest event, if one is present. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession memUsageMb megabytes (MB) The total amount of memory, in MB, used by the application. Updated every 60 seconds. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession networkError The error message associated with the iOS NSURL Error code. See networkErrorCode for more information. MobileRequestError networkErrorCode If the error is a network error, this is the iOS network error code. For Android applications, this is the mapped value. MobileRequestError newRelicVersion The version number of the agent running on the application. For example: 4.232.0. Duplicate of newRelicAgentVersion. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osMajorVersion The simplified version number of the app's host operating system, such as iOS 11, as compared to iOS 11.0.4. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osName The name of the app's host operating system, for example, iOS or Android. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osVersion The exact version number of the app's host operating system, such as iOS 11.0.4, as compared to iOS 11. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession platform The platform type of the mobile monitoring agent, such as native or Cordova. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession regionCode The specific region within a country where the monitored app is located. In the United States, regions are states. The regionCode is based on IP address and may not always match your region. MobileHandledException MobileRequest MobileRequestError MobileSession requestDomain The domain that the application attempted to access when the event occurred. MobileRequest MobileRequestError requestErrorFingerprint ID The New Relic-generated identifier used to group like request error events. MobileRequestError requestMethod The REST method (GET, PUT, POST, etc.) that the application attempted when the event occurred. MobileRequest MobileRequestError requestPath The path that the application attempted to access when the event occurred. MobileRequest MobileRequestError requestUrl The URL that the application attempted to access when the event occurred. MobileRequest MobileRequestError requestUuid ID A unique identifer for the request event. MobileRequest MobileRequestError responseBody Optional: The response that is sent from the requestDomain for the HTTP error, up to 4096 bytes. MobileRequestError responseTime seconds (s) The time between the request and the response in fractional seconds. MobileRequest MobileRequestError sessionId ID A unique identifier for a single user session. A new sessionId is created each time the app is brought into the foreground. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession statusCode Optional: The HTTP status code for the HTTP event. MobileRequest MobileRequestError timestamp The UTC epoch time at which an event began. MobileRequest MobileRequestError MobileSession trace.id ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. DistributedTraceSummary MobileRequest MobileRequestError Span Transaction TransactionError traceId ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. AwsLambdaInvocationError AwsLambdaInvocation MobileRequest MobileRequestError Span uuid ID A unique identifier assigned by New Relic for a specific app on a particular device. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of deviceUuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession MobileSession Data source : Mobile A MobileSession event is sent when an app is closed, backgrounded, or when 10 minutes of active use has elapsed. This is the source of the general session data used by the other mobile monitoring events. MobileSession captures attributes such as device type, device OS, and geographical information. Attribute name Definition Data types appBuild Indicates the technical build number of the app binary. As a developer, you can use this attribute to identify specific builds of your app. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appId ID A unique identifier for a monitored app, based on the app token. For example: 35091. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appName The name of the monitored app. For example: My Mobile App - iOS. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersion The version number of the monitored app. For example: 2.2.9. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersionId ID An identifier for the specific version of the app. For example: 1713477. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnOwner The telecom owner of the ASN. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession bundleId ID The unique string used to identify the application. MobileCrash MobileSession carrier The network over which the app transferred data, such as Wi-Fi, Verizon, or Sprint. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession category The type of data, either session or interaction. Mobile MobileSession city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileSession PageAction PageView PageViewTiming countryCode The country from which the device ran the application. For a list of country codes, see ISO 3166-1 alpha-2. MobileHandledException MobileRequest MobileRequestError MobileSession device The specific type of the device: iPhone 8, iPad Pro, etc. Duplicate of deviceType. MobileHandledException MobileRequest MobileRequestError MobileSession deviceGroup The category of the device, such as iPhone or Tablet. MobileRequest MobileRequestError MobileSession deviceManufacturer The manufacturer of the device, such as Motorola or HTC. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceModel The model number of the device, such as XT1039 or SM-G900F. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceType The specific type of device: iPhone 8, iPad Pro, etc. Duplicate of device. MobileHandledException MobileRequest MobileRequestError MobileSession deviceUuid ID A unique identifier assigned at the time of app installation by New Relic. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of uuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession install Indicates true only if the current session is the first session after app install. MobileSession lastInteraction The last interaction before a crash or harvest event, if one is present. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession memUsageMb megabytes (MB) The total amount of memory, in MB, used by the application. Updated every 60 seconds. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession newRelicAgent The New Relic agent running on the application. For example: the iOSAgent or the androidAgent. MobileSession newRelicVersion The version number of the agent running on the application. For example: 4.232.0. Duplicate of newRelicAgentVersion. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osMajorVersion The simplified version number of the app's host operating system, such as iOS 11, as compared to iOS 11.0.4. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osName The name of the app's host operating system, for example, iOS or Android. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osVersion The exact version number of the app's host operating system, such as iOS 11.0.4, as compared to iOS 11. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession platform The platform type of the mobile monitoring agent, such as native or Cordova. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession regionCode The specific region within a country where the monitored app is located. In the United States, regions are states. The regionCode is based on IP address and may not always match your region. MobileHandledException MobileRequest MobileRequestError MobileSession sessionCrashed A boolean value indicating whether or not that session crashed. MobileCrash MobileSession sessionDuration seconds (s) The length of time for which the user used the application in seconds. If the session crashes, sessionDuration is not captured (although other events and attributes are still recorded). For sessions longer than 10 minutes, events in the Interaction and Custom event categories are sent to Insights while the session is ongoing, and therefore do not have sessionDuration attributes. Events recorded near the end of the session will include the duration, as will the Session event category. MobileSession sessionId ID A unique identifier for a single user session. A new sessionId is created each time the app is brought into the foreground. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession timeSinceLoad seconds (s) The time, in seconds, from the beginning of the mobile session to the time the event occurred. MobileSession timestamp The UTC epoch time at which an event began. MobileRequest MobileRequestError MobileSession upgradeFrom Indictates previous version number only if this is the first launch after app upgrade. MobileSession uuid ID A unique identifier assigned by New Relic for a specific app on a particular device. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of deviceUuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession NetworkSample Data source : Infrastructure NetworkSample event captures the descriptive and state information for each network device associated with a server. It includes the device's interface and address information, as well as current usage data. New Relic samples this data every 10 seconds for each attached network interface and packages it into a NetworkSample event, then sends the raw data to New Relic's collectors every 60 seconds. Attribute name Definition Data types agentName The name of the agent (Infrastructure). NetworkSample ProcessSample StorageSample SystemSample agentVersion The version of the New Relic Infrastructure agent. NetworkSample ProcessSample StorageSample SystemSample criticalViolationCount count The number of times that alert conditions violated critical thresholds, causing critical violations and opening incidents. If this attribute does not exist on the sample, it has zero violations. ContainerSample NetworkSample ProcessSample StorageSample SystemSample entityID ID New Relic's unique ID number for the entity that is reporting data. This is used by New Relic to distinguish between customers and their entities. NetworkSample ProcessSample StorageSample SystemSample fullHostname The fully qualified (DNS) hostname. NetworkSample ProcessSample StorageSample SystemSample hardwareAddress The unique hardware address of the interface. NetworkSample hostname The short version of the entity's name. NetworkSample ProcessSample StorageSample SystemSample interfaceName The interface name as reported by the operating system. NetworkSample ipV4Address The IP version 4 address. NetworkSample ipV6Address The IP version 6 address. NetworkSample kernelVersion The Linux kernel version, in string format. This attribute is available only for systems on a Linux platform. NetworkSample ProcessSample StorageSample SystemSample linuxDistribution The name of the Linux distribution the server is using. This attribute is available only for systems on a Linux platform. NetworkSample ProcessSample StorageSample SystemSample operatingSystem The operating system on which the agent is installed. NetworkSample ProcessSample StorageSample SystemSample receiveBytesPerSecond bytes (B) The number of bytes per second received during the sampling period. NetworkSample receiveDroppedPerSecond count The number of received packets per second dropped during the sampling period. NetworkSample receiveErrorsPerSecond count The number of receive errors per second on the interface during the sampling period. NetworkSample receivePacketsPerSecond count The number of packets per second (",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.71574,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> data dictionary",
        "sections": "<em>New</em> <em>Relic</em> data dictionary",
        "body": " : <em>Distributed</em> <em>Tracing</em> This event contains summary data about a <em>distributed</em> <em>trace</em> and provides an aggregated view of <em>distributed</em> <em>tracing</em> data. <em>DistributedTrace</em>Summary events are generated by <em>New</em> <em>Relic</em> and are triggered by <em>distributed</em> <em>tracing</em> data from agents or the <em>Trace</em> API. Attribute name Definition"
      },
      "id": "603f53b164441f41894e8875"
    },
    {
      "sections": [
        "Know your data limits",
        "Responses to limit violations",
        "System limits UI",
        "Troubleshooting system limits",
        "Account-level limits",
        "Data ingest API limits",
        "Finding other agent and integration limits"
      ],
      "title": "Know your data limits",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Manage data"
      ],
      "external_id": "7c540d94a8b5e4f024d175ad53cab9fab343187c",
      "image": "https://docs.newrelic.com/static/8ee61e3091f6e044202cff92026afada/8c557/limits-graph.png",
      "url": "https://docs.newrelic.com/docs/data-apis/manage-data/view-system-limits/",
      "published_at": "2021-10-24T21:26:09Z",
      "updated_at": "2021-10-23T17:31:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To ensure our systems are always up and ready to support you, and to keep you from unintended use, we place limits on the amount of data you can send, query, and store. Responses to limit violations Limits are enforced per child account, and across our APIs. You might reach a limit if you start monitoring a new high-traffic application, or have a sudden data spike. When you do reach a limit, New Relic responds according to the type of data and the limit thatâ€™s reached. For example: We place a limit on the number of ingested requests per minute (RPM) per data type. When this limit is reached, we stop accepting data and return a 429 status code for the duration of the minute. For queries, we place limits on the number of queries per minute and the number of records inspected (see query limits). When the number of queries per minute limit is reached, New Relic will begin rejecting queries until the number of queries is below the limit. When the records inspected limit is reached, New Relic will reject traffic from the source scanning the largest number of records and attempt to allow traffic from other sources. For metrics, we place a limit on the number of unique timeseries (cardinality) per account and per metric. When this limit is reached, aggregated data is turned off for the rest of the UTC day. For every major limit violation, New Relic creates an NrIntegrationError event for that account, which has these limit-related attributes: Attribute Description category RateLimit or ApiLimit. The RateLimit category is used for limits based on a unit of time such as the number of requests ingested per minute. The ApiLimit is used for constant limits, such as the number of attributes on a record. limitName The name of the limit. message Describes the limit and the impact. limitValue The limit reached. System limits UI The system Limits page (from the account dropdown, click Manage your data and click Limits on the left) displays when your account has encountered a rate limit in the specified time period. The page displays a default period of 24 hours; you can set a custom range from the top-right of the page. Non-limit-related NrIntegrationError events are not displayed here. In addition, this page does not display information about limits you have not hit, or how close you are to reaching a limit. For more on creating queries and alerts for data ingest and billing metrics, see Query billing/usage data. one.newrelic.com > account dropdown > Manage your data > Limits: An example of a chart on the Limits UI page displaying a cardinality violation limit issue. To add more detail, or build a dashboard, click the View NRQL button on the chart to see the NRQL powering this view. The graph displays each unique limit type that was reached during the selected time-period. This can help you find any trends based on time. The Limits page also provides a table where you can find the limit name, the limit event message associated with it, and last occurrence time and date. If you click a limit in the table, you see more about what happened, and when. one.newrelic.com > account dropdown > Manage your data > Limits: An example of a limit events table on the Limits UI page. Troubleshooting system limits To troubleshoot limits when you reach them, click the limit info in the table, and then follow the docs link that's provided. Different limits have different solutions. Account-level limits The following table includes general max limits that apply across all New Relic accounts. Specific New Relic tools, like agents and integrations, have their own limits and configurations, and might be lower than these theoretical maximum limits. Limited condition Limit Rate of NRDB record * ingest 55 million per account per minute Max NRDB records * ingested per API call 1MB (10^6 bytes) Max attribute value size 1KB (10^3 bytes) Max payload size 1MB (10^6 bytes) Max total attributes per data type (including default attributes) 254 (less for some tools; for example, 64 for agents) Number of unique custom data types 250 per account per day (applies to custom events because that's source of new data types) APM limits Agent instances: 50K per account Agent instances per app: 10K APM apps/services: 10K per second Browser: number of page views 1M per minute per app Distributed tracing: Max age of span timestamp values 20 minutes. Timestamp must be within 20 minutes of current time at ingest or within 20 minutes from the time the last span with the same trace.id was received by New Relic. Distributed tracing: Max spans per minute per account Dependent on agreement. Max limit: 2M. Distributed tracing: Max spans per trace 50K Distributed tracing: Max attributes per span 200 Rate of metric timeslice data (used by APM, browser, mobile) Ingest: 2 million per minute Rate of names: 4 million per minute per account Number per monitored app: 300K Mobile monitoring: number of crashes reported 10K per hour Infrastructure agents, integrations Number of infrastructure agents and/or integrations: 5K per account Gross number of new monitored containers: 5K per hour per account Query limits NRDB records * inspected: 100 billion per account per hour Rate of queries: 20 per account per second See other query limits * NRDB records refers to database records for our core data types, which includes events, metrics (dimensional), logs, and distributed tracing (span) data, all stored in the New Relic database (NRDB). This does not include metric timeslice data. Data ingest API limits Our ingest APIs have additional limits that may override the more general account-level limits. Note that these limits also apply to our tools that use these APIs (like our Telemetry SDKs or our open source telemetry integrations). Metric API (dimensional metrics) Event API Log API Trace API Finding other agent and integration limits To find limits for our other agents and integrations, which will override more general account-level limits, see the docs for those tools: you can search our solutions here. Some default reporting limits are located in these tools' configuration docs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.2349,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " <em>trace</em>.id was received by <em>New</em> <em>Relic</em>. <em>Distributed</em> <em>tracing</em>: Max spans per minute per account Dependent on agreement. Max limit: 2M. <em>Distributed</em> <em>tracing</em>: Max spans per <em>trace</em> 50K <em>Distributed</em> <em>tracing</em>: Max attributes per span 200 Rate of metric timeslice data (used by APM, browser, <em>mobile</em>) Ingest: 2 million per"
      },
      "id": "60446a7c64441f48d7378f2b"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/install-configure/android-agent-crash-reporting": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-10-24T16:17:45Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 215.34561,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " by adding breadcrumbs. Then, query <em>Mobile</em>Breadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your <em>Android</em> application&#x27;s directly in your IDE using CodeStream and errors inbox. To do this, <em>install</em> CodeStream, connect CodeStream and <em>New</em> <em>Relic</em> and create Git tags that match your appVersion."
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "Install Android apps with Gradle and Android Studio",
        "Install your Android app",
        "Configure with Gradle and Android Studio",
        "Project level build.gradle file:",
        "App level build.gradle file:",
        "Important",
        "Update your Android installation",
        "Android 4.x: Multidex support",
        "New Relic Gradle Plugin configuration"
      ],
      "title": "Install Android apps with Gradle and Android Studio",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "51fab3eba87ddee949cd4729de8b5f64534de9c7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/install-android-apps-gradle-android-studio/",
      "published_at": "2021-10-24T16:47:25Z",
      "updated_at": "2021-07-27T17:09:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Gradle or Android Studio, follow these instructions to install New Relic's mobile monitoring for the first time. If you have previously installed the Android agent SDK for mobile monitoring, follow the steps before upgrading to the latest version with Gradle and Android Studio. Install your Android app As part of the installation process for mobile monitoring, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. Go to one.newrelic.com > Mobile. If applicable: From the Mobile apps index, select Add a new app. From the Get started page, select Android as the platform for mobile monitoring. Type a meaningful name for your mobile app, and select Continue. Continue with the steps to configure mobile monitoring with Gradle and Android Studio. OR: To complete the configuration process for a new mobile app later: Go to one.newrelic.com > Mobile, then select See instructions next to your mobile app name. To upgrade an existing Android installation: Go to one.newrelic.com > Mobile > (select an app) > Settings > Installation. Configure with Gradle and Android Studio These procedures to configure your Android app with Gradle and Android Studio also appear on the Get started page in New Relic. Merge New Relic's mobile monitoring code in the Gradle & Android Studio tab to your build.gradle file. Project level build.gradle file: In this example, AGENT_VERSION represents your agent version number. See the agent release notes, and use the latest version. buildscript { repositories { mavenCentral() } dependencies { classpath \"com.newrelic.agent.android:agent-gradle-plugin:AGENT_VERSION\" } } Copy App level build.gradle file: In this example, AGENT_VERSION represents your agent version number. See the agent release notes, and use the latest version. repositories { mavenCentral() } apply plugin: 'android' apply plugin: 'newrelic' dependencies { compile 'com.newrelic.agent.android:android-agent:AGENT_VERSION' } Copy ProGuard or DexGuard: In your projectâ€™s root directory (projectname/app), add a newrelic.properties file with the following line: com.newrelic.application_token=GENERATED_TOKEN Copy Follow the additional, required configuration steps for using ProGuard or DexGuard with New Relic. Set app permissions: Ensure that your Android app requests INTERNET and ACCESS_NETWORK_STATE permissions by adding these lines to your AndroidManifest.xml file: <uses-permission android:name=\"android.permission.INTERNET\" /> <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /> Copy To start New Relic's mobile monitoring agent: In your Default Activity (as defined in your Manifest), import the NewRelic class: import com.newrelic.agent.android.NewRelic; Copy Important We do not support starting the mobile monitoring agent in other classes, as that can cause unexpected or unstable behavior. To initialize mobile monitoring: In the onCreate() method, add this call: NewRelic.withApplicationToken(\"GENERATED_TOKEN\").start(this.getApplication()); Copy Optional: Change the logging level. To build and run your application: Clean your project, then run your app in an emulator or device to generate traffic. Wait a few minutes, then view data for your Android app from the Overview page: Go to one.newrelic.com > Mobile > (select an app). If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI, follow the troubleshooting procedures. Update your Android installation To keep your Android agent up to date, follow the procedures to upgrade the Android agent SDK for New Relic. To install the latest Android version for your mobile app: Go to one.newrelic.com > Mobile > (select an app) > Settings > Installation. Android 4.x: Multidex support New Relic's mobile monitoring for Android versions prior to Android 5.0 (API level 21) use the Dalvik runtime to execute app code. By default, Dalvik limits apps to a single classes.dex bytecode file per APK. In order to get around this limitation, you must enable multidex support. Then you can use the multidex support library, which becomes part of the primary DEX file of your app and then manages access to the additional DEX files and the code they contain. When building each DEX file for a multidex app, the build tools perform complex decision making to determine which classes are needed in the primary DEX file so that your app can start successfully. If any class required during startup is not provided in the primary DEX file, then your app crashes with the error java.lang.NoClassDefFoundError. If you see the java.lang.NoClassDefFoundError error, then you must manually specify these additional classes as required in the primary DEX file: Create a proguard.multidex.config file within the /app folder of your project. Update mypackage to reflect your package name. #################### # keep class names # #################### #Keep New Relic in the main dex -keep class com.newrelic.** { *; } -keep class com.mypackage.activities.** { *; } Copy Merge the following code into the app-level build.gradle file: android { defaultConfig{ â€¦ multiDexKeepProguard file(\"proguard.multidex.config\") } } Copy For more information, see the Android Developers documentation on declaring classes required in the primary DEX file. New Relic Gradle Plugin configuration For details on how to configure the behavior of the mobile monitoring agent plugin during Gradle builds, see the New Relic Gradle plugin extension guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 151.64082,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> <em>Android</em> apps with Gradle and <em>Android</em> Studio",
        "sections": "<em>Install</em> <em>Android</em> apps with Gradle and <em>Android</em> Studio",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "If you use Gradle or <em>Android</em> Studio, follow these instructions to <em>install</em> <em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for the first time. If you have previously installed the <em>Android</em> agent SDK for <em>mobile</em> <em>monitoring</em>, follow the steps before upgrading to the latest version with Gradle and <em>Android</em> Studio. <em>Install</em>"
      },
      "id": "603ea70128ccbc59c2eba74e"
    },
    {
      "sections": [
        "Configure ProGuard or DexGuard for Android apps",
        "Configure ProGuard",
        "Network library support",
        "Configure DexGuard"
      ],
      "title": "Configure ProGuard or DexGuard for Android apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "8a8df969c4099f75cb214354cef311dfa2ab50e2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/configure-proguard-or-dexguard-android-apps/",
      "published_at": "2021-10-24T16:47:25Z",
      "updated_at": "2021-08-21T09:16:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Follow these instructions to support ProGuard or DexGuard with the Android agent. Check our Android compatibility and requirements, and if you have previously installed the Android agent SDK, follow the steps before upgrading to the latest version with ProGuard or DexGuard. Configure ProGuard To add support for ProGuard: Add an exclusion to your app; for example: To support New Relic instrumentation, add keep class. To disable warnings related to unresolved problems, add dont warn. To preserve line numbers for crash reporting, add LineNumberTable. To preserve stack information for handled exceptions, add SourceFile and EnclosingMethod. Add the following to your ProGuard config file (proguard.cfg, proguard-android.txt, proguard-rules.pro, etc.): -keep class com.newrelic.** { *; } -dontwarn com.newrelic.** -keepattributes Exceptions, Signature, InnerClasses, LineNumberTable, SourceFile, EnclosingMethod Copy Clean and rebuild your project. Run your app in an emulator or device to start seeing data on your mobile app's Overview page. Optional: Use the mobile monitoring Settings page to customize your mobile app. If no data appears, review your logcat output for errors. Network library support New Relic instrumentation happens before ProGuard obfuscates your code. In order for these libraries to be properly instrumented, their classes must not be obfuscated by ProGuard. Here are examples of rules to be applied to preserve these classes. This is not a complete list. Different rules will be needed depending on your library or version. Library Rules Apache Http -keep class org.apache.http.** { *; } -dontwarn org.apache.http.** Copy OkHttp 2 -keep class com.squareup.okhttp.* { *; } -dontwarn com.squareup.okhttp.** -dontwarn okio.** Copy OkHttp 3 -keep class okhttp3.** { *; } -dontwarn okhttp3.** -dontwarn okio.** Copy Retrofit 2 -keep class retrofit2.** { *; } -dontwarn retrofit2.** Copy Configure DexGuard DexGuard uses the same configuration options as ProGuard, and it can read any pre-existing ProGuard configuration files. DexGuard also has its own set of additional configuration options and provides sample configurations for many common app frameworks. To add support for DexGuard: Add DexGuard to your app and set up the Gradle plugin according to the directions from DexGuard. Create a dexguard-project.txt file to hold specific DexGuard configuration options, and add: -dontnote com.newrelic.agent.android.NewRelic -dontnote com.newrelic.agent.android.harvest.crash.Crash Copy After the DexGuard plugin has been configured, check the following. DexGuard 8.x: verify that your app's buildTypes configuration is similar to this: buildTypes { release { minifyEnabled true proguardFile getDefaultDexGuardFile('dexguard-release.pro') proguardFile 'proguard-rules.pro' proguardFile 'dexguard-project.txt' } ... Copy Clean and rebuild your project. Run your app in an emulator or device to start seeing data on your mobile app's Overview page. Optional: Use the mobile monitoring Settings page to customize your mobile app. If no data appears, review your logcat output for errors.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.69226,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Configure</em> ProGuard or DexGuard for <em>Android</em> apps",
        "sections": "<em>Configure</em> ProGuard or DexGuard for <em>Android</em> apps",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": ", and add: -dontnote com.newrelic.agent.<em>android.NewRelic</em> -dontnote com.newrelic.agent.<em>android</em>.harvest.crash.Crash Copy After the DexGuard plugin has been configured, check the following. DexGuard 8.x: verify that your app&#x27;s buildTypes configuration is similar to this: buildTypes { release { minifyEnabled"
      },
      "id": "604418de196a6770e7960f6c"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/install-configure/configure-new-relic-gradle-plugin": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-10-24T16:17:45Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 215.34561,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " by adding breadcrumbs. Then, query <em>Mobile</em>Breadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your <em>Android</em> application&#x27;s directly in your IDE using CodeStream and errors inbox. To do this, <em>install</em> CodeStream, connect CodeStream and <em>New</em> <em>Relic</em> and create Git tags that match your appVersion."
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "Install Android apps with Gradle and Android Studio",
        "Install your Android app",
        "Configure with Gradle and Android Studio",
        "Project level build.gradle file:",
        "App level build.gradle file:",
        "Important",
        "Update your Android installation",
        "Android 4.x: Multidex support",
        "New Relic Gradle Plugin configuration"
      ],
      "title": "Install Android apps with Gradle and Android Studio",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "51fab3eba87ddee949cd4729de8b5f64534de9c7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/install-android-apps-gradle-android-studio/",
      "published_at": "2021-10-24T16:47:25Z",
      "updated_at": "2021-07-27T17:09:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Gradle or Android Studio, follow these instructions to install New Relic's mobile monitoring for the first time. If you have previously installed the Android agent SDK for mobile monitoring, follow the steps before upgrading to the latest version with Gradle and Android Studio. Install your Android app As part of the installation process for mobile monitoring, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. Go to one.newrelic.com > Mobile. If applicable: From the Mobile apps index, select Add a new app. From the Get started page, select Android as the platform for mobile monitoring. Type a meaningful name for your mobile app, and select Continue. Continue with the steps to configure mobile monitoring with Gradle and Android Studio. OR: To complete the configuration process for a new mobile app later: Go to one.newrelic.com > Mobile, then select See instructions next to your mobile app name. To upgrade an existing Android installation: Go to one.newrelic.com > Mobile > (select an app) > Settings > Installation. Configure with Gradle and Android Studio These procedures to configure your Android app with Gradle and Android Studio also appear on the Get started page in New Relic. Merge New Relic's mobile monitoring code in the Gradle & Android Studio tab to your build.gradle file. Project level build.gradle file: In this example, AGENT_VERSION represents your agent version number. See the agent release notes, and use the latest version. buildscript { repositories { mavenCentral() } dependencies { classpath \"com.newrelic.agent.android:agent-gradle-plugin:AGENT_VERSION\" } } Copy App level build.gradle file: In this example, AGENT_VERSION represents your agent version number. See the agent release notes, and use the latest version. repositories { mavenCentral() } apply plugin: 'android' apply plugin: 'newrelic' dependencies { compile 'com.newrelic.agent.android:android-agent:AGENT_VERSION' } Copy ProGuard or DexGuard: In your projectâ€™s root directory (projectname/app), add a newrelic.properties file with the following line: com.newrelic.application_token=GENERATED_TOKEN Copy Follow the additional, required configuration steps for using ProGuard or DexGuard with New Relic. Set app permissions: Ensure that your Android app requests INTERNET and ACCESS_NETWORK_STATE permissions by adding these lines to your AndroidManifest.xml file: <uses-permission android:name=\"android.permission.INTERNET\" /> <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /> Copy To start New Relic's mobile monitoring agent: In your Default Activity (as defined in your Manifest), import the NewRelic class: import com.newrelic.agent.android.NewRelic; Copy Important We do not support starting the mobile monitoring agent in other classes, as that can cause unexpected or unstable behavior. To initialize mobile monitoring: In the onCreate() method, add this call: NewRelic.withApplicationToken(\"GENERATED_TOKEN\").start(this.getApplication()); Copy Optional: Change the logging level. To build and run your application: Clean your project, then run your app in an emulator or device to generate traffic. Wait a few minutes, then view data for your Android app from the Overview page: Go to one.newrelic.com > Mobile > (select an app). If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI, follow the troubleshooting procedures. Update your Android installation To keep your Android agent up to date, follow the procedures to upgrade the Android agent SDK for New Relic. To install the latest Android version for your mobile app: Go to one.newrelic.com > Mobile > (select an app) > Settings > Installation. Android 4.x: Multidex support New Relic's mobile monitoring for Android versions prior to Android 5.0 (API level 21) use the Dalvik runtime to execute app code. By default, Dalvik limits apps to a single classes.dex bytecode file per APK. In order to get around this limitation, you must enable multidex support. Then you can use the multidex support library, which becomes part of the primary DEX file of your app and then manages access to the additional DEX files and the code they contain. When building each DEX file for a multidex app, the build tools perform complex decision making to determine which classes are needed in the primary DEX file so that your app can start successfully. If any class required during startup is not provided in the primary DEX file, then your app crashes with the error java.lang.NoClassDefFoundError. If you see the java.lang.NoClassDefFoundError error, then you must manually specify these additional classes as required in the primary DEX file: Create a proguard.multidex.config file within the /app folder of your project. Update mypackage to reflect your package name. #################### # keep class names # #################### #Keep New Relic in the main dex -keep class com.newrelic.** { *; } -keep class com.mypackage.activities.** { *; } Copy Merge the following code into the app-level build.gradle file: android { defaultConfig{ â€¦ multiDexKeepProguard file(\"proguard.multidex.config\") } } Copy For more information, see the Android Developers documentation on declaring classes required in the primary DEX file. New Relic Gradle Plugin configuration For details on how to configure the behavior of the mobile monitoring agent plugin during Gradle builds, see the New Relic Gradle plugin extension guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 151.64082,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> <em>Android</em> apps with Gradle and <em>Android</em> Studio",
        "sections": "<em>Install</em> <em>Android</em> apps with Gradle and <em>Android</em> Studio",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "If you use Gradle or <em>Android</em> Studio, follow these instructions to <em>install</em> <em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for the first time. If you have previously installed the <em>Android</em> agent SDK for <em>mobile</em> <em>monitoring</em>, follow the steps before upgrading to the latest version with Gradle and <em>Android</em> Studio. <em>Install</em>"
      },
      "id": "603ea70128ccbc59c2eba74e"
    },
    {
      "sections": [
        "Configure ProGuard or DexGuard for Android apps",
        "Configure ProGuard",
        "Network library support",
        "Configure DexGuard"
      ],
      "title": "Configure ProGuard or DexGuard for Android apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "8a8df969c4099f75cb214354cef311dfa2ab50e2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/configure-proguard-or-dexguard-android-apps/",
      "published_at": "2021-10-24T16:47:25Z",
      "updated_at": "2021-08-21T09:16:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Follow these instructions to support ProGuard or DexGuard with the Android agent. Check our Android compatibility and requirements, and if you have previously installed the Android agent SDK, follow the steps before upgrading to the latest version with ProGuard or DexGuard. Configure ProGuard To add support for ProGuard: Add an exclusion to your app; for example: To support New Relic instrumentation, add keep class. To disable warnings related to unresolved problems, add dont warn. To preserve line numbers for crash reporting, add LineNumberTable. To preserve stack information for handled exceptions, add SourceFile and EnclosingMethod. Add the following to your ProGuard config file (proguard.cfg, proguard-android.txt, proguard-rules.pro, etc.): -keep class com.newrelic.** { *; } -dontwarn com.newrelic.** -keepattributes Exceptions, Signature, InnerClasses, LineNumberTable, SourceFile, EnclosingMethod Copy Clean and rebuild your project. Run your app in an emulator or device to start seeing data on your mobile app's Overview page. Optional: Use the mobile monitoring Settings page to customize your mobile app. If no data appears, review your logcat output for errors. Network library support New Relic instrumentation happens before ProGuard obfuscates your code. In order for these libraries to be properly instrumented, their classes must not be obfuscated by ProGuard. Here are examples of rules to be applied to preserve these classes. This is not a complete list. Different rules will be needed depending on your library or version. Library Rules Apache Http -keep class org.apache.http.** { *; } -dontwarn org.apache.http.** Copy OkHttp 2 -keep class com.squareup.okhttp.* { *; } -dontwarn com.squareup.okhttp.** -dontwarn okio.** Copy OkHttp 3 -keep class okhttp3.** { *; } -dontwarn okhttp3.** -dontwarn okio.** Copy Retrofit 2 -keep class retrofit2.** { *; } -dontwarn retrofit2.** Copy Configure DexGuard DexGuard uses the same configuration options as ProGuard, and it can read any pre-existing ProGuard configuration files. DexGuard also has its own set of additional configuration options and provides sample configurations for many common app frameworks. To add support for DexGuard: Add DexGuard to your app and set up the Gradle plugin according to the directions from DexGuard. Create a dexguard-project.txt file to hold specific DexGuard configuration options, and add: -dontnote com.newrelic.agent.android.NewRelic -dontnote com.newrelic.agent.android.harvest.crash.Crash Copy After the DexGuard plugin has been configured, check the following. DexGuard 8.x: verify that your app's buildTypes configuration is similar to this: buildTypes { release { minifyEnabled true proguardFile getDefaultDexGuardFile('dexguard-release.pro') proguardFile 'proguard-rules.pro' proguardFile 'dexguard-project.txt' } ... Copy Clean and rebuild your project. Run your app in an emulator or device to start seeing data on your mobile app's Overview page. Optional: Use the mobile monitoring Settings page to customize your mobile app. If no data appears, review your logcat output for errors.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.69226,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Configure</em> ProGuard or DexGuard for <em>Android</em> apps",
        "sections": "<em>Configure</em> ProGuard or DexGuard for <em>Android</em> apps",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": ", and add: -dontnote com.newrelic.agent.<em>android.NewRelic</em> -dontnote com.newrelic.agent.<em>android</em>.harvest.crash.Crash Copy After the DexGuard plugin has been configured, check the following. DexGuard 8.x: verify that your app&#x27;s buildTypes configuration is similar to this: buildTypes { release { minifyEnabled"
      },
      "id": "604418de196a6770e7960f6c"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/install-configure/configure-proguard-or-dexguard-android-apps": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-10-24T16:17:45Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 215.34547,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " by adding breadcrumbs. Then, query <em>Mobile</em>Breadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your <em>Android</em> application&#x27;s directly in your IDE using CodeStream and errors inbox. To do this, <em>install</em> CodeStream, connect CodeStream and <em>New</em> <em>Relic</em> and create Git tags that match your appVersion."
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "Install Android apps with Gradle and Android Studio",
        "Install your Android app",
        "Configure with Gradle and Android Studio",
        "Project level build.gradle file:",
        "App level build.gradle file:",
        "Important",
        "Update your Android installation",
        "Android 4.x: Multidex support",
        "New Relic Gradle Plugin configuration"
      ],
      "title": "Install Android apps with Gradle and Android Studio",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "51fab3eba87ddee949cd4729de8b5f64534de9c7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/install-android-apps-gradle-android-studio/",
      "published_at": "2021-10-24T16:47:25Z",
      "updated_at": "2021-07-27T17:09:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Gradle or Android Studio, follow these instructions to install New Relic's mobile monitoring for the first time. If you have previously installed the Android agent SDK for mobile monitoring, follow the steps before upgrading to the latest version with Gradle and Android Studio. Install your Android app As part of the installation process for mobile monitoring, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. Go to one.newrelic.com > Mobile. If applicable: From the Mobile apps index, select Add a new app. From the Get started page, select Android as the platform for mobile monitoring. Type a meaningful name for your mobile app, and select Continue. Continue with the steps to configure mobile monitoring with Gradle and Android Studio. OR: To complete the configuration process for a new mobile app later: Go to one.newrelic.com > Mobile, then select See instructions next to your mobile app name. To upgrade an existing Android installation: Go to one.newrelic.com > Mobile > (select an app) > Settings > Installation. Configure with Gradle and Android Studio These procedures to configure your Android app with Gradle and Android Studio also appear on the Get started page in New Relic. Merge New Relic's mobile monitoring code in the Gradle & Android Studio tab to your build.gradle file. Project level build.gradle file: In this example, AGENT_VERSION represents your agent version number. See the agent release notes, and use the latest version. buildscript { repositories { mavenCentral() } dependencies { classpath \"com.newrelic.agent.android:agent-gradle-plugin:AGENT_VERSION\" } } Copy App level build.gradle file: In this example, AGENT_VERSION represents your agent version number. See the agent release notes, and use the latest version. repositories { mavenCentral() } apply plugin: 'android' apply plugin: 'newrelic' dependencies { compile 'com.newrelic.agent.android:android-agent:AGENT_VERSION' } Copy ProGuard or DexGuard: In your projectâ€™s root directory (projectname/app), add a newrelic.properties file with the following line: com.newrelic.application_token=GENERATED_TOKEN Copy Follow the additional, required configuration steps for using ProGuard or DexGuard with New Relic. Set app permissions: Ensure that your Android app requests INTERNET and ACCESS_NETWORK_STATE permissions by adding these lines to your AndroidManifest.xml file: <uses-permission android:name=\"android.permission.INTERNET\" /> <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /> Copy To start New Relic's mobile monitoring agent: In your Default Activity (as defined in your Manifest), import the NewRelic class: import com.newrelic.agent.android.NewRelic; Copy Important We do not support starting the mobile monitoring agent in other classes, as that can cause unexpected or unstable behavior. To initialize mobile monitoring: In the onCreate() method, add this call: NewRelic.withApplicationToken(\"GENERATED_TOKEN\").start(this.getApplication()); Copy Optional: Change the logging level. To build and run your application: Clean your project, then run your app in an emulator or device to generate traffic. Wait a few minutes, then view data for your Android app from the Overview page: Go to one.newrelic.com > Mobile > (select an app). If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI, follow the troubleshooting procedures. Update your Android installation To keep your Android agent up to date, follow the procedures to upgrade the Android agent SDK for New Relic. To install the latest Android version for your mobile app: Go to one.newrelic.com > Mobile > (select an app) > Settings > Installation. Android 4.x: Multidex support New Relic's mobile monitoring for Android versions prior to Android 5.0 (API level 21) use the Dalvik runtime to execute app code. By default, Dalvik limits apps to a single classes.dex bytecode file per APK. In order to get around this limitation, you must enable multidex support. Then you can use the multidex support library, which becomes part of the primary DEX file of your app and then manages access to the additional DEX files and the code they contain. When building each DEX file for a multidex app, the build tools perform complex decision making to determine which classes are needed in the primary DEX file so that your app can start successfully. If any class required during startup is not provided in the primary DEX file, then your app crashes with the error java.lang.NoClassDefFoundError. If you see the java.lang.NoClassDefFoundError error, then you must manually specify these additional classes as required in the primary DEX file: Create a proguard.multidex.config file within the /app folder of your project. Update mypackage to reflect your package name. #################### # keep class names # #################### #Keep New Relic in the main dex -keep class com.newrelic.** { *; } -keep class com.mypackage.activities.** { *; } Copy Merge the following code into the app-level build.gradle file: android { defaultConfig{ â€¦ multiDexKeepProguard file(\"proguard.multidex.config\") } } Copy For more information, see the Android Developers documentation on declaring classes required in the primary DEX file. New Relic Gradle Plugin configuration For details on how to configure the behavior of the mobile monitoring agent plugin during Gradle builds, see the New Relic Gradle plugin extension guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 151.64082,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> <em>Android</em> apps with Gradle and <em>Android</em> Studio",
        "sections": "<em>Install</em> <em>Android</em> apps with Gradle and <em>Android</em> Studio",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "If you use Gradle or <em>Android</em> Studio, follow these instructions to <em>install</em> <em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for the first time. If you have previously installed the <em>Android</em> agent SDK for <em>mobile</em> <em>monitoring</em>, follow the steps before upgrading to the latest version with Gradle and <em>Android</em> Studio. <em>Install</em>"
      },
      "id": "603ea70128ccbc59c2eba74e"
    },
    {
      "sections": [
        "Install the New Relic plugin for Android Instant Apps",
        "Terminology",
        "Install the plugin",
        "Minimal build.gradle example",
        "Instrumentation",
        "ProGuard and Dexguard support",
        "Important",
        "Troubleshoot auto-instrumentation"
      ],
      "title": "Install the New Relic plugin for Android Instant Apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "a9b40dd5eccb3d96a0cdc246eafe66b92fdeab6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/install-new-relic-plugin-android-instant-apps/",
      "published_at": "2021-10-24T16:46:37Z",
      "updated_at": "2021-07-09T15:02:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Android Instant Apps allow users to quickly use your applications without installation. With the Android agent version 5.17.0 and higher, you can use New Relic to detect and instrument all feature modules for an instant app. Use this documentation along with the standard New Relic procedures to install Android apps with Gradle and Android Studio. After following the standard installation procedures, follow these additional steps for Android instant apps. Terminology This procedure uses the following terms that are specific to the Android Instant Apps plugin: Module: Any packaged class and/or resource collection APK: A module that packages the apps resources and DEXâ€™ed classes Feature module: A slimmed down module that contains only a subset of the total APK Install the plugin To install the New Relic plugin for Android Instant Apps: First follow the steps in the Install Android apps with Gradle and Android Studio documentation. Apply the agent plugin in every project Gradle build file. List the Android agent as a dependency. Start the agent from each Activity class in the feature that could be side-loaded through a Digital Asset Link intent, (for example, mobile.example.com/signin). Minimal build.gradle example apply plugin: â€˜com.android.[application|library|feature|instantapp]' apply plugin: â€˜newrelicâ€™ dependencies { implementation \"com.newrelic.agent.android:android-agent:${project.agentVersion}\" } Copy Review the considerations for instrumentation. Instrumentation When instrumenting an instant app, be aware of the following considerations with APKs: Instant apps and APKs Comments Instrumentation Instrumentation of instant apps behaves the same as instrumentation with a normal APK. The agent will detect when an APK is an instant app. For feature APKs, the agent will inject a unique build ID that instant apps will use when reporting crashes. The side-loaded (main) activity of every feature must call NewRelic.start() when the activity is created (as per normal instructions). ProGuard and Dexguard support for feature and application APKs Place the newrelic.properties file in the root (main) directory of the project. ProGuard and Dexguard support The Android Studio Gradle plugin will obfuscate any build configuration where minifyEnabled is set to true. In these conditions, the New Relic agent will forward the ProGuard map generated for the build to crash collectors, tagged with a unique build ID generated by the agent. Obfuscation is best configured in the application or instant app project that includes other modules as dependencies. Modules may configure ProGuard as needed. Important When using ProGuard or DexGuard with Android apps, follow the procedures to complete the additional, required configuration steps. For more information, see the ProGuard and DexGuard configuration documentation. Troubleshoot auto-instrumentation If you are not whether the agent is auto-instrumenting an instant app project, try running these steps: Build app with debug (-d, --debug) option, and capture the build log. Search the log for evidence of instant apps by looking for either of these terms: This appears to be an Instant App Copy BuildId[1a2b34c5-def6-7890-g123-h4567890a] Copy The agent will add an attribute named 'instantApp' to the app's Insights session attributes if the app appears to be an instant app.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.24986,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> the <em>New</em> <em>Relic</em> plugin for <em>Android</em> Instant Apps",
        "sections": "<em>Install</em> the <em>New</em> <em>Relic</em> plugin for <em>Android</em> Instant Apps",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " and&#x2F;or resource collection APK: A module that packages the apps resources and DEXâ€™ed classes Feature module: A slimmed down module that contains only a subset of the total APK <em>Install</em> the plugin To <em>install</em> the <em>New</em> <em>Relic</em> plugin for <em>Android</em> Instant Apps: First follow the steps in the <em>Install</em> <em>Android</em> apps"
      },
      "id": "603e87a764441fa6934e885e"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/install-configure/install-android-apps-gradle-android-studio": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-10-24T16:17:45Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 215.34547,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " by adding breadcrumbs. Then, query <em>Mobile</em>Breadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your <em>Android</em> application&#x27;s directly in your IDE using CodeStream and errors inbox. To do this, <em>install</em> CodeStream, connect CodeStream and <em>New</em> <em>Relic</em> and create Git tags that match your appVersion."
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "Configure ProGuard or DexGuard for Android apps",
        "Configure ProGuard",
        "Network library support",
        "Configure DexGuard"
      ],
      "title": "Configure ProGuard or DexGuard for Android apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "8a8df969c4099f75cb214354cef311dfa2ab50e2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/configure-proguard-or-dexguard-android-apps/",
      "published_at": "2021-10-24T16:47:25Z",
      "updated_at": "2021-08-21T09:16:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Follow these instructions to support ProGuard or DexGuard with the Android agent. Check our Android compatibility and requirements, and if you have previously installed the Android agent SDK, follow the steps before upgrading to the latest version with ProGuard or DexGuard. Configure ProGuard To add support for ProGuard: Add an exclusion to your app; for example: To support New Relic instrumentation, add keep class. To disable warnings related to unresolved problems, add dont warn. To preserve line numbers for crash reporting, add LineNumberTable. To preserve stack information for handled exceptions, add SourceFile and EnclosingMethod. Add the following to your ProGuard config file (proguard.cfg, proguard-android.txt, proguard-rules.pro, etc.): -keep class com.newrelic.** { *; } -dontwarn com.newrelic.** -keepattributes Exceptions, Signature, InnerClasses, LineNumberTable, SourceFile, EnclosingMethod Copy Clean and rebuild your project. Run your app in an emulator or device to start seeing data on your mobile app's Overview page. Optional: Use the mobile monitoring Settings page to customize your mobile app. If no data appears, review your logcat output for errors. Network library support New Relic instrumentation happens before ProGuard obfuscates your code. In order for these libraries to be properly instrumented, their classes must not be obfuscated by ProGuard. Here are examples of rules to be applied to preserve these classes. This is not a complete list. Different rules will be needed depending on your library or version. Library Rules Apache Http -keep class org.apache.http.** { *; } -dontwarn org.apache.http.** Copy OkHttp 2 -keep class com.squareup.okhttp.* { *; } -dontwarn com.squareup.okhttp.** -dontwarn okio.** Copy OkHttp 3 -keep class okhttp3.** { *; } -dontwarn okhttp3.** -dontwarn okio.** Copy Retrofit 2 -keep class retrofit2.** { *; } -dontwarn retrofit2.** Copy Configure DexGuard DexGuard uses the same configuration options as ProGuard, and it can read any pre-existing ProGuard configuration files. DexGuard also has its own set of additional configuration options and provides sample configurations for many common app frameworks. To add support for DexGuard: Add DexGuard to your app and set up the Gradle plugin according to the directions from DexGuard. Create a dexguard-project.txt file to hold specific DexGuard configuration options, and add: -dontnote com.newrelic.agent.android.NewRelic -dontnote com.newrelic.agent.android.harvest.crash.Crash Copy After the DexGuard plugin has been configured, check the following. DexGuard 8.x: verify that your app's buildTypes configuration is similar to this: buildTypes { release { minifyEnabled true proguardFile getDefaultDexGuardFile('dexguard-release.pro') proguardFile 'proguard-rules.pro' proguardFile 'dexguard-project.txt' } ... Copy Clean and rebuild your project. Run your app in an emulator or device to start seeing data on your mobile app's Overview page. Optional: Use the mobile monitoring Settings page to customize your mobile app. If no data appears, review your logcat output for errors.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.69226,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Configure</em> ProGuard or DexGuard for <em>Android</em> apps",
        "sections": "<em>Configure</em> ProGuard or DexGuard for <em>Android</em> apps",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": ", and add: -dontnote com.newrelic.agent.<em>android.NewRelic</em> -dontnote com.newrelic.agent.<em>android</em>.harvest.crash.Crash Copy After the DexGuard plugin has been configured, check the following. DexGuard 8.x: verify that your app&#x27;s buildTypes configuration is similar to this: buildTypes { release { minifyEnabled"
      },
      "id": "604418de196a6770e7960f6c"
    },
    {
      "sections": [
        "Install the New Relic plugin for Android Instant Apps",
        "Terminology",
        "Install the plugin",
        "Minimal build.gradle example",
        "Instrumentation",
        "ProGuard and Dexguard support",
        "Important",
        "Troubleshoot auto-instrumentation"
      ],
      "title": "Install the New Relic plugin for Android Instant Apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "a9b40dd5eccb3d96a0cdc246eafe66b92fdeab6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/install-new-relic-plugin-android-instant-apps/",
      "published_at": "2021-10-24T16:46:37Z",
      "updated_at": "2021-07-09T15:02:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Android Instant Apps allow users to quickly use your applications without installation. With the Android agent version 5.17.0 and higher, you can use New Relic to detect and instrument all feature modules for an instant app. Use this documentation along with the standard New Relic procedures to install Android apps with Gradle and Android Studio. After following the standard installation procedures, follow these additional steps for Android instant apps. Terminology This procedure uses the following terms that are specific to the Android Instant Apps plugin: Module: Any packaged class and/or resource collection APK: A module that packages the apps resources and DEXâ€™ed classes Feature module: A slimmed down module that contains only a subset of the total APK Install the plugin To install the New Relic plugin for Android Instant Apps: First follow the steps in the Install Android apps with Gradle and Android Studio documentation. Apply the agent plugin in every project Gradle build file. List the Android agent as a dependency. Start the agent from each Activity class in the feature that could be side-loaded through a Digital Asset Link intent, (for example, mobile.example.com/signin). Minimal build.gradle example apply plugin: â€˜com.android.[application|library|feature|instantapp]' apply plugin: â€˜newrelicâ€™ dependencies { implementation \"com.newrelic.agent.android:android-agent:${project.agentVersion}\" } Copy Review the considerations for instrumentation. Instrumentation When instrumenting an instant app, be aware of the following considerations with APKs: Instant apps and APKs Comments Instrumentation Instrumentation of instant apps behaves the same as instrumentation with a normal APK. The agent will detect when an APK is an instant app. For feature APKs, the agent will inject a unique build ID that instant apps will use when reporting crashes. The side-loaded (main) activity of every feature must call NewRelic.start() when the activity is created (as per normal instructions). ProGuard and Dexguard support for feature and application APKs Place the newrelic.properties file in the root (main) directory of the project. ProGuard and Dexguard support The Android Studio Gradle plugin will obfuscate any build configuration where minifyEnabled is set to true. In these conditions, the New Relic agent will forward the ProGuard map generated for the build to crash collectors, tagged with a unique build ID generated by the agent. Obfuscation is best configured in the application or instant app project that includes other modules as dependencies. Modules may configure ProGuard as needed. Important When using ProGuard or DexGuard with Android apps, follow the procedures to complete the additional, required configuration steps. For more information, see the ProGuard and DexGuard configuration documentation. Troubleshoot auto-instrumentation If you are not whether the agent is auto-instrumenting an instant app project, try running these steps: Build app with debug (-d, --debug) option, and capture the build log. Search the log for evidence of instant apps by looking for either of these terms: This appears to be an Instant App Copy BuildId[1a2b34c5-def6-7890-g123-h4567890a] Copy The agent will add an attribute named 'instantApp' to the app's Insights session attributes if the app appears to be an instant app.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.24986,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> the <em>New</em> <em>Relic</em> plugin for <em>Android</em> Instant Apps",
        "sections": "<em>Install</em> the <em>New</em> <em>Relic</em> plugin for <em>Android</em> Instant Apps",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " and&#x2F;or resource collection APK: A module that packages the apps resources and DEXâ€™ed classes Feature module: A slimmed down module that contains only a subset of the total APK <em>Install</em> the plugin To <em>install</em> the <em>New</em> <em>Relic</em> plugin for <em>Android</em> Instant Apps: First follow the steps in the <em>Install</em> <em>Android</em> apps"
      },
      "id": "603e87a764441fa6934e885e"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/install-configure/install-new-relic-plugin-android-instant-apps": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-10-24T16:17:45Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 215.34534,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " by adding breadcrumbs. Then, query <em>Mobile</em>Breadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your <em>Android</em> application&#x27;s directly in your IDE using CodeStream and errors inbox. To do this, <em>install</em> CodeStream, connect CodeStream and <em>New</em> <em>Relic</em> and create Git tags that match your appVersion."
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "Install Android apps with Gradle and Android Studio",
        "Install your Android app",
        "Configure with Gradle and Android Studio",
        "Project level build.gradle file:",
        "App level build.gradle file:",
        "Important",
        "Update your Android installation",
        "Android 4.x: Multidex support",
        "New Relic Gradle Plugin configuration"
      ],
      "title": "Install Android apps with Gradle and Android Studio",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "51fab3eba87ddee949cd4729de8b5f64534de9c7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/install-android-apps-gradle-android-studio/",
      "published_at": "2021-10-24T16:47:25Z",
      "updated_at": "2021-07-27T17:09:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Gradle or Android Studio, follow these instructions to install New Relic's mobile monitoring for the first time. If you have previously installed the Android agent SDK for mobile monitoring, follow the steps before upgrading to the latest version with Gradle and Android Studio. Install your Android app As part of the installation process for mobile monitoring, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. Go to one.newrelic.com > Mobile. If applicable: From the Mobile apps index, select Add a new app. From the Get started page, select Android as the platform for mobile monitoring. Type a meaningful name for your mobile app, and select Continue. Continue with the steps to configure mobile monitoring with Gradle and Android Studio. OR: To complete the configuration process for a new mobile app later: Go to one.newrelic.com > Mobile, then select See instructions next to your mobile app name. To upgrade an existing Android installation: Go to one.newrelic.com > Mobile > (select an app) > Settings > Installation. Configure with Gradle and Android Studio These procedures to configure your Android app with Gradle and Android Studio also appear on the Get started page in New Relic. Merge New Relic's mobile monitoring code in the Gradle & Android Studio tab to your build.gradle file. Project level build.gradle file: In this example, AGENT_VERSION represents your agent version number. See the agent release notes, and use the latest version. buildscript { repositories { mavenCentral() } dependencies { classpath \"com.newrelic.agent.android:agent-gradle-plugin:AGENT_VERSION\" } } Copy App level build.gradle file: In this example, AGENT_VERSION represents your agent version number. See the agent release notes, and use the latest version. repositories { mavenCentral() } apply plugin: 'android' apply plugin: 'newrelic' dependencies { compile 'com.newrelic.agent.android:android-agent:AGENT_VERSION' } Copy ProGuard or DexGuard: In your projectâ€™s root directory (projectname/app), add a newrelic.properties file with the following line: com.newrelic.application_token=GENERATED_TOKEN Copy Follow the additional, required configuration steps for using ProGuard or DexGuard with New Relic. Set app permissions: Ensure that your Android app requests INTERNET and ACCESS_NETWORK_STATE permissions by adding these lines to your AndroidManifest.xml file: <uses-permission android:name=\"android.permission.INTERNET\" /> <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /> Copy To start New Relic's mobile monitoring agent: In your Default Activity (as defined in your Manifest), import the NewRelic class: import com.newrelic.agent.android.NewRelic; Copy Important We do not support starting the mobile monitoring agent in other classes, as that can cause unexpected or unstable behavior. To initialize mobile monitoring: In the onCreate() method, add this call: NewRelic.withApplicationToken(\"GENERATED_TOKEN\").start(this.getApplication()); Copy Optional: Change the logging level. To build and run your application: Clean your project, then run your app in an emulator or device to generate traffic. Wait a few minutes, then view data for your Android app from the Overview page: Go to one.newrelic.com > Mobile > (select an app). If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI, follow the troubleshooting procedures. Update your Android installation To keep your Android agent up to date, follow the procedures to upgrade the Android agent SDK for New Relic. To install the latest Android version for your mobile app: Go to one.newrelic.com > Mobile > (select an app) > Settings > Installation. Android 4.x: Multidex support New Relic's mobile monitoring for Android versions prior to Android 5.0 (API level 21) use the Dalvik runtime to execute app code. By default, Dalvik limits apps to a single classes.dex bytecode file per APK. In order to get around this limitation, you must enable multidex support. Then you can use the multidex support library, which becomes part of the primary DEX file of your app and then manages access to the additional DEX files and the code they contain. When building each DEX file for a multidex app, the build tools perform complex decision making to determine which classes are needed in the primary DEX file so that your app can start successfully. If any class required during startup is not provided in the primary DEX file, then your app crashes with the error java.lang.NoClassDefFoundError. If you see the java.lang.NoClassDefFoundError error, then you must manually specify these additional classes as required in the primary DEX file: Create a proguard.multidex.config file within the /app folder of your project. Update mypackage to reflect your package name. #################### # keep class names # #################### #Keep New Relic in the main dex -keep class com.newrelic.** { *; } -keep class com.mypackage.activities.** { *; } Copy Merge the following code into the app-level build.gradle file: android { defaultConfig{ â€¦ multiDexKeepProguard file(\"proguard.multidex.config\") } } Copy For more information, see the Android Developers documentation on declaring classes required in the primary DEX file. New Relic Gradle Plugin configuration For details on how to configure the behavior of the mobile monitoring agent plugin during Gradle builds, see the New Relic Gradle plugin extension guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 151.64082,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> <em>Android</em> apps with Gradle and <em>Android</em> Studio",
        "sections": "<em>Install</em> <em>Android</em> apps with Gradle and <em>Android</em> Studio",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "If you use Gradle or <em>Android</em> Studio, follow these instructions to <em>install</em> <em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for the first time. If you have previously installed the <em>Android</em> agent SDK for <em>mobile</em> <em>monitoring</em>, follow the steps before upgrading to the latest version with Gradle and <em>Android</em> Studio. <em>Install</em>"
      },
      "id": "603ea70128ccbc59c2eba74e"
    },
    {
      "sections": [
        "Configure ProGuard or DexGuard for Android apps",
        "Configure ProGuard",
        "Network library support",
        "Configure DexGuard"
      ],
      "title": "Configure ProGuard or DexGuard for Android apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "8a8df969c4099f75cb214354cef311dfa2ab50e2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/configure-proguard-or-dexguard-android-apps/",
      "published_at": "2021-10-24T16:47:25Z",
      "updated_at": "2021-08-21T09:16:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Follow these instructions to support ProGuard or DexGuard with the Android agent. Check our Android compatibility and requirements, and if you have previously installed the Android agent SDK, follow the steps before upgrading to the latest version with ProGuard or DexGuard. Configure ProGuard To add support for ProGuard: Add an exclusion to your app; for example: To support New Relic instrumentation, add keep class. To disable warnings related to unresolved problems, add dont warn. To preserve line numbers for crash reporting, add LineNumberTable. To preserve stack information for handled exceptions, add SourceFile and EnclosingMethod. Add the following to your ProGuard config file (proguard.cfg, proguard-android.txt, proguard-rules.pro, etc.): -keep class com.newrelic.** { *; } -dontwarn com.newrelic.** -keepattributes Exceptions, Signature, InnerClasses, LineNumberTable, SourceFile, EnclosingMethod Copy Clean and rebuild your project. Run your app in an emulator or device to start seeing data on your mobile app's Overview page. Optional: Use the mobile monitoring Settings page to customize your mobile app. If no data appears, review your logcat output for errors. Network library support New Relic instrumentation happens before ProGuard obfuscates your code. In order for these libraries to be properly instrumented, their classes must not be obfuscated by ProGuard. Here are examples of rules to be applied to preserve these classes. This is not a complete list. Different rules will be needed depending on your library or version. Library Rules Apache Http -keep class org.apache.http.** { *; } -dontwarn org.apache.http.** Copy OkHttp 2 -keep class com.squareup.okhttp.* { *; } -dontwarn com.squareup.okhttp.** -dontwarn okio.** Copy OkHttp 3 -keep class okhttp3.** { *; } -dontwarn okhttp3.** -dontwarn okio.** Copy Retrofit 2 -keep class retrofit2.** { *; } -dontwarn retrofit2.** Copy Configure DexGuard DexGuard uses the same configuration options as ProGuard, and it can read any pre-existing ProGuard configuration files. DexGuard also has its own set of additional configuration options and provides sample configurations for many common app frameworks. To add support for DexGuard: Add DexGuard to your app and set up the Gradle plugin according to the directions from DexGuard. Create a dexguard-project.txt file to hold specific DexGuard configuration options, and add: -dontnote com.newrelic.agent.android.NewRelic -dontnote com.newrelic.agent.android.harvest.crash.Crash Copy After the DexGuard plugin has been configured, check the following. DexGuard 8.x: verify that your app's buildTypes configuration is similar to this: buildTypes { release { minifyEnabled true proguardFile getDefaultDexGuardFile('dexguard-release.pro') proguardFile 'proguard-rules.pro' proguardFile 'dexguard-project.txt' } ... Copy Clean and rebuild your project. Run your app in an emulator or device to start seeing data on your mobile app's Overview page. Optional: Use the mobile monitoring Settings page to customize your mobile app. If no data appears, review your logcat output for errors.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.69225,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Configure</em> ProGuard or DexGuard for <em>Android</em> apps",
        "sections": "<em>Configure</em> ProGuard or DexGuard for <em>Android</em> apps",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": ", and add: -dontnote com.newrelic.agent.<em>android.NewRelic</em> -dontnote com.newrelic.agent.<em>android</em>.harvest.crash.Crash Copy After the DexGuard plugin has been configured, check the following. DexGuard 8.x: verify that your app&#x27;s buildTypes configuration is similar to this: buildTypes { release { minifyEnabled"
      },
      "id": "604418de196a6770e7960f6c"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/install-configure/upgrade-new-relic-mobiles-android-sdk": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-10-24T16:17:45Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 215.34534,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": " by adding breadcrumbs. Then, query <em>Mobile</em>Breadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your <em>Android</em> application&#x27;s directly in your IDE using CodeStream and errors inbox. To do this, <em>install</em> CodeStream, connect CodeStream and <em>New</em> <em>Relic</em> and create Git tags that match your appVersion."
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "Install Android apps with Gradle and Android Studio",
        "Install your Android app",
        "Configure with Gradle and Android Studio",
        "Project level build.gradle file:",
        "App level build.gradle file:",
        "Important",
        "Update your Android installation",
        "Android 4.x: Multidex support",
        "New Relic Gradle Plugin configuration"
      ],
      "title": "Install Android apps with Gradle and Android Studio",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "51fab3eba87ddee949cd4729de8b5f64534de9c7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/install-android-apps-gradle-android-studio/",
      "published_at": "2021-10-24T16:47:25Z",
      "updated_at": "2021-07-27T17:09:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Gradle or Android Studio, follow these instructions to install New Relic's mobile monitoring for the first time. If you have previously installed the Android agent SDK for mobile monitoring, follow the steps before upgrading to the latest version with Gradle and Android Studio. Install your Android app As part of the installation process for mobile monitoring, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. Go to one.newrelic.com > Mobile. If applicable: From the Mobile apps index, select Add a new app. From the Get started page, select Android as the platform for mobile monitoring. Type a meaningful name for your mobile app, and select Continue. Continue with the steps to configure mobile monitoring with Gradle and Android Studio. OR: To complete the configuration process for a new mobile app later: Go to one.newrelic.com > Mobile, then select See instructions next to your mobile app name. To upgrade an existing Android installation: Go to one.newrelic.com > Mobile > (select an app) > Settings > Installation. Configure with Gradle and Android Studio These procedures to configure your Android app with Gradle and Android Studio also appear on the Get started page in New Relic. Merge New Relic's mobile monitoring code in the Gradle & Android Studio tab to your build.gradle file. Project level build.gradle file: In this example, AGENT_VERSION represents your agent version number. See the agent release notes, and use the latest version. buildscript { repositories { mavenCentral() } dependencies { classpath \"com.newrelic.agent.android:agent-gradle-plugin:AGENT_VERSION\" } } Copy App level build.gradle file: In this example, AGENT_VERSION represents your agent version number. See the agent release notes, and use the latest version. repositories { mavenCentral() } apply plugin: 'android' apply plugin: 'newrelic' dependencies { compile 'com.newrelic.agent.android:android-agent:AGENT_VERSION' } Copy ProGuard or DexGuard: In your projectâ€™s root directory (projectname/app), add a newrelic.properties file with the following line: com.newrelic.application_token=GENERATED_TOKEN Copy Follow the additional, required configuration steps for using ProGuard or DexGuard with New Relic. Set app permissions: Ensure that your Android app requests INTERNET and ACCESS_NETWORK_STATE permissions by adding these lines to your AndroidManifest.xml file: <uses-permission android:name=\"android.permission.INTERNET\" /> <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /> Copy To start New Relic's mobile monitoring agent: In your Default Activity (as defined in your Manifest), import the NewRelic class: import com.newrelic.agent.android.NewRelic; Copy Important We do not support starting the mobile monitoring agent in other classes, as that can cause unexpected or unstable behavior. To initialize mobile monitoring: In the onCreate() method, add this call: NewRelic.withApplicationToken(\"GENERATED_TOKEN\").start(this.getApplication()); Copy Optional: Change the logging level. To build and run your application: Clean your project, then run your app in an emulator or device to generate traffic. Wait a few minutes, then view data for your Android app from the Overview page: Go to one.newrelic.com > Mobile > (select an app). If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI, follow the troubleshooting procedures. Update your Android installation To keep your Android agent up to date, follow the procedures to upgrade the Android agent SDK for New Relic. To install the latest Android version for your mobile app: Go to one.newrelic.com > Mobile > (select an app) > Settings > Installation. Android 4.x: Multidex support New Relic's mobile monitoring for Android versions prior to Android 5.0 (API level 21) use the Dalvik runtime to execute app code. By default, Dalvik limits apps to a single classes.dex bytecode file per APK. In order to get around this limitation, you must enable multidex support. Then you can use the multidex support library, which becomes part of the primary DEX file of your app and then manages access to the additional DEX files and the code they contain. When building each DEX file for a multidex app, the build tools perform complex decision making to determine which classes are needed in the primary DEX file so that your app can start successfully. If any class required during startup is not provided in the primary DEX file, then your app crashes with the error java.lang.NoClassDefFoundError. If you see the java.lang.NoClassDefFoundError error, then you must manually specify these additional classes as required in the primary DEX file: Create a proguard.multidex.config file within the /app folder of your project. Update mypackage to reflect your package name. #################### # keep class names # #################### #Keep New Relic in the main dex -keep class com.newrelic.** { *; } -keep class com.mypackage.activities.** { *; } Copy Merge the following code into the app-level build.gradle file: android { defaultConfig{ â€¦ multiDexKeepProguard file(\"proguard.multidex.config\") } } Copy For more information, see the Android Developers documentation on declaring classes required in the primary DEX file. New Relic Gradle Plugin configuration For details on how to configure the behavior of the mobile monitoring agent plugin during Gradle builds, see the New Relic Gradle plugin extension guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 151.64082,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> <em>Android</em> apps with Gradle and <em>Android</em> Studio",
        "sections": "<em>Install</em> <em>Android</em> apps with Gradle and <em>Android</em> Studio",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "If you use Gradle or <em>Android</em> Studio, follow these instructions to <em>install</em> <em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for the first time. If you have previously installed the <em>Android</em> agent SDK for <em>mobile</em> <em>monitoring</em>, follow the steps before upgrading to the latest version with Gradle and <em>Android</em> Studio. <em>Install</em>"
      },
      "id": "603ea70128ccbc59c2eba74e"
    },
    {
      "sections": [
        "Configure ProGuard or DexGuard for Android apps",
        "Configure ProGuard",
        "Network library support",
        "Configure DexGuard"
      ],
      "title": "Configure ProGuard or DexGuard for Android apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "8a8df969c4099f75cb214354cef311dfa2ab50e2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/configure-proguard-or-dexguard-android-apps/",
      "published_at": "2021-10-24T16:47:25Z",
      "updated_at": "2021-08-21T09:16:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Follow these instructions to support ProGuard or DexGuard with the Android agent. Check our Android compatibility and requirements, and if you have previously installed the Android agent SDK, follow the steps before upgrading to the latest version with ProGuard or DexGuard. Configure ProGuard To add support for ProGuard: Add an exclusion to your app; for example: To support New Relic instrumentation, add keep class. To disable warnings related to unresolved problems, add dont warn. To preserve line numbers for crash reporting, add LineNumberTable. To preserve stack information for handled exceptions, add SourceFile and EnclosingMethod. Add the following to your ProGuard config file (proguard.cfg, proguard-android.txt, proguard-rules.pro, etc.): -keep class com.newrelic.** { *; } -dontwarn com.newrelic.** -keepattributes Exceptions, Signature, InnerClasses, LineNumberTable, SourceFile, EnclosingMethod Copy Clean and rebuild your project. Run your app in an emulator or device to start seeing data on your mobile app's Overview page. Optional: Use the mobile monitoring Settings page to customize your mobile app. If no data appears, review your logcat output for errors. Network library support New Relic instrumentation happens before ProGuard obfuscates your code. In order for these libraries to be properly instrumented, their classes must not be obfuscated by ProGuard. Here are examples of rules to be applied to preserve these classes. This is not a complete list. Different rules will be needed depending on your library or version. Library Rules Apache Http -keep class org.apache.http.** { *; } -dontwarn org.apache.http.** Copy OkHttp 2 -keep class com.squareup.okhttp.* { *; } -dontwarn com.squareup.okhttp.** -dontwarn okio.** Copy OkHttp 3 -keep class okhttp3.** { *; } -dontwarn okhttp3.** -dontwarn okio.** Copy Retrofit 2 -keep class retrofit2.** { *; } -dontwarn retrofit2.** Copy Configure DexGuard DexGuard uses the same configuration options as ProGuard, and it can read any pre-existing ProGuard configuration files. DexGuard also has its own set of additional configuration options and provides sample configurations for many common app frameworks. To add support for DexGuard: Add DexGuard to your app and set up the Gradle plugin according to the directions from DexGuard. Create a dexguard-project.txt file to hold specific DexGuard configuration options, and add: -dontnote com.newrelic.agent.android.NewRelic -dontnote com.newrelic.agent.android.harvest.crash.Crash Copy After the DexGuard plugin has been configured, check the following. DexGuard 8.x: verify that your app's buildTypes configuration is similar to this: buildTypes { release { minifyEnabled true proguardFile getDefaultDexGuardFile('dexguard-release.pro') proguardFile 'proguard-rules.pro' proguardFile 'dexguard-project.txt' } ... Copy Clean and rebuild your project. Run your app in an emulator or device to start seeing data on your mobile app's Overview page. Optional: Use the mobile monitoring Settings page to customize your mobile app. If no data appears, review your logcat output for errors.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.69225,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Configure</em> ProGuard or DexGuard for <em>Android</em> apps",
        "sections": "<em>Configure</em> ProGuard or DexGuard for <em>Android</em> apps",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": ", and add: -dontnote com.newrelic.agent.<em>android.NewRelic</em> -dontnote com.newrelic.agent.<em>android</em>.harvest.crash.Crash Copy After the DexGuard plugin has been configured, check the following. DexGuard 8.x: verify that your app&#x27;s buildTypes configuration is similar to this: buildTypes { release { minifyEnabled"
      },
      "id": "604418de196a6770e7960f6c"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/legacy/install-android-apps-android-22-support": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-10-24T16:17:45Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 210.94778,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": ". As part of the installation process, <em>mobile</em> <em>monitoring</em> automatically generates an application token. This is a 40-character hexadecimal string for authenticating each <em>mobile</em> app that you <em>monitor</em>. Follow the <em>Android</em> installation and configuration procedures for your environment as applicable. If you have"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "HTTP requests page",
        "Find and use HTTP requests page",
        "Understand HTTP request data",
        "Response time chart",
        "HTTP errors and network failures chart",
        "Total requests",
        "Group, sort, and filter HTTP requests",
        "View and share HTTP request data",
        "View legacy HTTP requests UI page",
        "View legacy HTTP requests UI",
        "View legacy drill-down details",
        "View legacy request data"
      ],
      "title": "HTTP requests page",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "56c27e3a1cad7439b752d38b4d00a60ab98f0e10",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/http-requests-page/",
      "published_at": "2021-10-24T16:30:00Z",
      "updated_at": "2021-10-07T20:06:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring has an HTTP requests UI page that helps you better understand HTTP requests associated with your mobile app and how those network calls are affecting performance. This document describes the Enterprise-level HTTP requests page. Non-Enterprise accounts will see the legacy HTTP requests page. Find and use HTTP requests page To view mobile monitoring's HTTP requests page: Go to one.newrelic.com > Mobile > (select an app) > Network > HTTP requests. Use our standard page functions to look for trends in the HTTP analysis charts. Target specific request and response attributes by grouping, sorting, and filtering the data. Understand HTTP request data Here are some places to find the most important HTTP request information: Response time chart The response time chart shows how your app's network calls are performing across percentiles. Use it to compare the average response time to the 1st, 50th, and 99th percentile. Percentiles let you filter out outliers that may be making your average response time higher than expected. HTTP errors and network failures chart This chart shows the unsuccessful network calls your app is experiencing. Select the chart title to go to the HTTP errors page for more detail on the errors and failures. Total requests Sort by Total requests to identify which network requests are being used most frequently. The reason this can be helpful is because your slowest network calls may be only infrequently used, while more frequently used requests might be more worthy of optimization even if they are not the slowest. For a description of the non-Enterprise HTTP requests UI page, see Legacy HTTP requests. Group, sort, and filter HTTP requests If you want to... Do this... Group and sort HTTP requests in different ways Make selections from the Group by and Sort by dropdowns. By default, the HTTP requests page is grouped by request domain and sorted by average response time. Filter for specific HTTP requests Select an HTTP request from the Errors and failures list and/or select multiple filters from the Filter dropdown. See or remove applied filters The filters you select are displayed next to the filter dropdown. To clear filters, select the X icon on the filter you want to clear. Change the time window Select a new time period from the time picker dropdown. View information for a specific app version Using the Versions dropdown, select the version for which you want to see charts and lists. View and share HTTP request data To view any HTTP requests chart in Insights: Select for any chart. Select View query > View in Insights. Optional: Add the data to a dashboard, or share it by using a permalink. To delve deeper into your request data, query MobileRequest events and attributes. View legacy HTTP requests UI page Accounts that do not have an Enterprise-level subscription see a different HTTP requests UI page: View legacy HTTP requests UI To view your top five domains or drill down into details about specific HTTP requests: Go to one.newrelic.com > (select an app) > Network > HTTP requests. Optional: Select the Sort by and Hide < 1% throughput options. To view or hide all requests made by your app, select Expand all or Collapse all. To view details for a specific host or HTTP request (including request time, average throughput, and data transfer), select its name. View legacy drill-down details Use any of New Relic's standard page functions to drill down into detailed information. In addition, from the HTTP requests page, you can drill down into detailed information about specific requests, including: Top five HTTP request times Average throughput Average data transfer To view legacy details: one.newrelic.com > Mobile > (select an app) > Network > HTTP requests > (select a request): > Switch to legacy requests. If you want to... Do this View information to a specific version of your app Select Versions from the side bar (if applicable). Change the time period Use the time picker below the New Relic menu bar. View legacy request data You can dig deeper into your request data by querying and charting the MobileRequest event.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 122.578995,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "View <em>legacy</em> HTTP requests UI page",
        "tags": "<em>Mobile</em> <em>monitoring</em>",
        "body": " from the side bar (if applicable). Change the time period Use the time picker below the <em>New</em> <em>Relic</em> menu bar. View <em>legacy</em> request data You can dig deeper into your request data by querying and charting the <em>Mobile</em>Request event."
      },
      "id": "60450de028ccbc42662c6083"
    },
    {
      "sections": [
        "No data appears (Android)",
        "Problem",
        "Solution"
      ],
      "title": "No data appears (Android)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Troubleshoot"
      ],
      "external_id": "cab2851a6f3c8bfddb1ed445f8722b3dddff7442",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/troubleshoot/no-data-appears-android/",
      "published_at": "2021-10-24T16:48:16Z",
      "updated_at": "2021-07-09T15:38:22Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem After installing the Android agent and waiting at least 5 minutes, no data appears in New Relic UI. Solution If no data appears after you wait at least five minutes, use New Relic Diagnostics to automatically detect common problems and suggest troubleshooting. If that does not solve your issue, try the following: Make sure your system meets the compatibility and requirements. Make sure that you are calling the Android agent on the first line of onCreate() in the MainActivity class and that you are running the agent on the main thread. The Android agent does not support starting the agent in another class. Check whether your Android app exceeds the 64k multidex limit. Increase the logging level and examine your logs for errors: Increase the New Relic logging level to AUDIT using withLogLevel: NewRelic.withApplicationToken(\"YOUR_APP_TOKEN\") .withLogLevel(AgentLog.AUDIT) .start(this.getApplication()); Copy Generate a few minutes of activity in your app. Examine your device log and your application build logs for issues. Confirm the device can reach the mobile monitoring endpoints listed in the Networks doc. If you need additional help, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.836426,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "No data appears (<em>Android</em>)",
        "sections": "No data appears (<em>Android</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Problem After installing the <em>Android</em> agent and waiting at least 5 minutes, no data appears in <em>New</em> <em>Relic</em> UI. Solution If no data appears after you wait at least five minutes, use <em>New</em> <em>Relic</em> Diagnostics to automatically detect common problems and suggest troubleshooting. If that does not solve your"
      },
      "id": "603e8eb6196a67b64ea83d81"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/troubleshoot/android-app-exceeds-64k-multidex-limit": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-10-24T16:17:45Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 215.34518,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": ". As part of the installation process, <em>mobile</em> <em>monitoring</em> automatically generates an application token. This is a 40-character hexadecimal string for authenticating each <em>mobile</em> app that you <em>monitor</em>. Follow the <em>Android</em> installation and configuration procedures for your environment as applicable. If you have"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "No data appears (Android)",
        "Problem",
        "Solution"
      ],
      "title": "No data appears (Android)",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Troubleshoot"
      ],
      "external_id": "cab2851a6f3c8bfddb1ed445f8722b3dddff7442",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/troubleshoot/no-data-appears-android/",
      "published_at": "2021-10-24T16:48:16Z",
      "updated_at": "2021-07-09T15:38:22Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem After installing the Android agent and waiting at least 5 minutes, no data appears in New Relic UI. Solution If no data appears after you wait at least five minutes, use New Relic Diagnostics to automatically detect common problems and suggest troubleshooting. If that does not solve your issue, try the following: Make sure your system meets the compatibility and requirements. Make sure that you are calling the Android agent on the first line of onCreate() in the MainActivity class and that you are running the agent on the main thread. The Android agent does not support starting the agent in another class. Check whether your Android app exceeds the 64k multidex limit. Increase the logging level and examine your logs for errors: Increase the New Relic logging level to AUDIT using withLogLevel: NewRelic.withApplicationToken(\"YOUR_APP_TOKEN\") .withLogLevel(AgentLog.AUDIT) .start(this.getApplication()); Copy Generate a few minutes of activity in your app. Examine your device log and your application build logs for issues. Confirm the device can reach the mobile monitoring endpoints listed in the Networks doc. If you need additional help, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 167.50652,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "No data appears (<em>Android</em>)",
        "sections": "No data appears (<em>Android</em>)",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "Problem After installing the <em>Android</em> agent and waiting at least 5 minutes, no data appears in <em>New</em> <em>Relic</em> UI. Solution If no data appears after you wait at least five minutes, use <em>New</em> <em>Relic</em> Diagnostics to automatically detect common problems and suggest troubleshooting. If that does not solve your"
      },
      "id": "603e8eb6196a67b64ea83d81"
    },
    {
      "sections": [
        "Install the New Relic plugin for Android Instant Apps",
        "Terminology",
        "Install the plugin",
        "Minimal build.gradle example",
        "Instrumentation",
        "ProGuard and Dexguard support",
        "Important",
        "Troubleshoot auto-instrumentation"
      ],
      "title": "Install the New Relic plugin for Android Instant Apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "a9b40dd5eccb3d96a0cdc246eafe66b92fdeab6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/install-new-relic-plugin-android-instant-apps/",
      "published_at": "2021-10-24T16:46:37Z",
      "updated_at": "2021-07-09T15:02:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Android Instant Apps allow users to quickly use your applications without installation. With the Android agent version 5.17.0 and higher, you can use New Relic to detect and instrument all feature modules for an instant app. Use this documentation along with the standard New Relic procedures to install Android apps with Gradle and Android Studio. After following the standard installation procedures, follow these additional steps for Android instant apps. Terminology This procedure uses the following terms that are specific to the Android Instant Apps plugin: Module: Any packaged class and/or resource collection APK: A module that packages the apps resources and DEXâ€™ed classes Feature module: A slimmed down module that contains only a subset of the total APK Install the plugin To install the New Relic plugin for Android Instant Apps: First follow the steps in the Install Android apps with Gradle and Android Studio documentation. Apply the agent plugin in every project Gradle build file. List the Android agent as a dependency. Start the agent from each Activity class in the feature that could be side-loaded through a Digital Asset Link intent, (for example, mobile.example.com/signin). Minimal build.gradle example apply plugin: â€˜com.android.[application|library|feature|instantapp]' apply plugin: â€˜newrelicâ€™ dependencies { implementation \"com.newrelic.agent.android:android-agent:${project.agentVersion}\" } Copy Review the considerations for instrumentation. Instrumentation When instrumenting an instant app, be aware of the following considerations with APKs: Instant apps and APKs Comments Instrumentation Instrumentation of instant apps behaves the same as instrumentation with a normal APK. The agent will detect when an APK is an instant app. For feature APKs, the agent will inject a unique build ID that instant apps will use when reporting crashes. The side-loaded (main) activity of every feature must call NewRelic.start() when the activity is created (as per normal instructions). ProGuard and Dexguard support for feature and application APKs Place the newrelic.properties file in the root (main) directory of the project. ProGuard and Dexguard support The Android Studio Gradle plugin will obfuscate any build configuration where minifyEnabled is set to true. In these conditions, the New Relic agent will forward the ProGuard map generated for the build to crash collectors, tagged with a unique build ID generated by the agent. Obfuscation is best configured in the application or instant app project that includes other modules as dependencies. Modules may configure ProGuard as needed. Important When using ProGuard or DexGuard with Android apps, follow the procedures to complete the additional, required configuration steps. For more information, see the ProGuard and DexGuard configuration documentation. Troubleshoot auto-instrumentation If you are not whether the agent is auto-instrumenting an instant app project, try running these steps: Build app with debug (-d, --debug) option, and capture the build log. Search the log for evidence of instant apps by looking for either of these terms: This appears to be an Instant App Copy BuildId[1a2b34c5-def6-7890-g123-h4567890a] Copy The agent will add an attribute named 'instantApp' to the app's Insights session attributes if the app appears to be an instant app.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 119.90538,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install the <em>New</em> <em>Relic</em> plugin for <em>Android</em> Instant Apps",
        "sections": "Install the <em>New</em> <em>Relic</em> plugin for <em>Android</em> Instant Apps",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "<em>Android</em> Instant Apps allow users to quickly use your applications without installation. With the <em>Android</em> agent version 5.17.0 and higher, you can use <em>New</em> <em>Relic</em> to detect and instrument all feature modules for an instant app. Use this documentation along with the standard <em>New</em> <em>Relic</em> procedures"
      },
      "id": "603e87a764441fa6934e885e"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-android/troubleshoot/no-data-appears-android": [
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-10-24T16:17:45Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 215.34503,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Android</em> <em>monitoring</em>",
        "sections": "Introduction to <em>Android</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": ". As part of the installation process, <em>mobile</em> <em>monitoring</em> automatically generates an application token. This is a 40-character hexadecimal string for authenticating each <em>mobile</em> app that you <em>monitor</em>. Follow the <em>Android</em> installation and configuration procedures for your environment as applicable. If you have"
      },
      "id": "6043a48f196a6784e6960f6d"
    },
    {
      "sections": [
        "Android app exceeds 64k multidex limit",
        "Problem",
        "Build time error message example",
        "Run time crash message example",
        "Solution"
      ],
      "title": "Android app exceeds 64k multidex limit",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Troubleshoot"
      ],
      "external_id": "4b456c8143055292aa480cc213ffc82b72ddee70",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/troubleshoot/android-app-exceeds-64k-multidex-limit/",
      "published_at": "2021-10-24T16:48:15Z",
      "updated_at": "2021-07-09T15:04:03Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem Your Android app exceeds the 64k limit for the total number of methods that can be referenced within a single Dalvik Executable file (DEX), including methods for frameworks, libraries, and your own Android app code. You see error messages from the agent such as these: Build time error message example > com.android.build.api.transform.TransformException: com.android.ide.common.process.ProcessException: java.util.concurrent.ExecutionException: com.android.dex.DexException: Too many classes in --main-dex-list, main dex capacity exceeded Copy Run time crash message example E/AndroidRuntime: FATAL EXCEPTION: main Process: com.example.mobile.debug, PID: 12345 java.lang.NoClassDefFoundError: com.example.foobar.myapp.MainActivity Copy These exception errors typically occur with Android devices prior to Android 5.0 (API level 21), which requires the multidex support library. Solution To fix build errors or runtime exceptions when using the latest Android build tool: Make sure you have the latest Android agent version. Enable multidex. Enable Proguard or Dexguard to optimize classes and methods in your DEX. If you still have problems with keeping your Android app under the 64k limit, use a keepfile.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 167.50348,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Android</em> app exceeds 64k multidex limit",
        "sections": "<em>Android</em> app exceeds 64k multidex limit",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "&#x2F;<em>Android</em>Runtime: FATAL EXCEPTION: main Process: com.example.<em>mobile</em>.debug, PID: 12345 java.lang.NoClassDefFoundError: com.example.foobar.myapp.MainActivity Copy These exception errors typically occur with <em>Android</em> devices prior to <em>Android</em> 5.0 (API level 21), which requires the multidex support library. Solution"
      },
      "id": "60441922196a6721e4960f26"
    },
    {
      "sections": [
        "Install the New Relic plugin for Android Instant Apps",
        "Terminology",
        "Install the plugin",
        "Minimal build.gradle example",
        "Instrumentation",
        "ProGuard and Dexguard support",
        "Important",
        "Troubleshoot auto-instrumentation"
      ],
      "title": "Install the New Relic plugin for Android Instant Apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "a9b40dd5eccb3d96a0cdc246eafe66b92fdeab6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/install-new-relic-plugin-android-instant-apps/",
      "published_at": "2021-10-24T16:46:37Z",
      "updated_at": "2021-07-09T15:02:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Android Instant Apps allow users to quickly use your applications without installation. With the Android agent version 5.17.0 and higher, you can use New Relic to detect and instrument all feature modules for an instant app. Use this documentation along with the standard New Relic procedures to install Android apps with Gradle and Android Studio. After following the standard installation procedures, follow these additional steps for Android instant apps. Terminology This procedure uses the following terms that are specific to the Android Instant Apps plugin: Module: Any packaged class and/or resource collection APK: A module that packages the apps resources and DEXâ€™ed classes Feature module: A slimmed down module that contains only a subset of the total APK Install the plugin To install the New Relic plugin for Android Instant Apps: First follow the steps in the Install Android apps with Gradle and Android Studio documentation. Apply the agent plugin in every project Gradle build file. List the Android agent as a dependency. Start the agent from each Activity class in the feature that could be side-loaded through a Digital Asset Link intent, (for example, mobile.example.com/signin). Minimal build.gradle example apply plugin: â€˜com.android.[application|library|feature|instantapp]' apply plugin: â€˜newrelicâ€™ dependencies { implementation \"com.newrelic.agent.android:android-agent:${project.agentVersion}\" } Copy Review the considerations for instrumentation. Instrumentation When instrumenting an instant app, be aware of the following considerations with APKs: Instant apps and APKs Comments Instrumentation Instrumentation of instant apps behaves the same as instrumentation with a normal APK. The agent will detect when an APK is an instant app. For feature APKs, the agent will inject a unique build ID that instant apps will use when reporting crashes. The side-loaded (main) activity of every feature must call NewRelic.start() when the activity is created (as per normal instructions). ProGuard and Dexguard support for feature and application APKs Place the newrelic.properties file in the root (main) directory of the project. ProGuard and Dexguard support The Android Studio Gradle plugin will obfuscate any build configuration where minifyEnabled is set to true. In these conditions, the New Relic agent will forward the ProGuard map generated for the build to crash collectors, tagged with a unique build ID generated by the agent. Obfuscation is best configured in the application or instant app project that includes other modules as dependencies. Modules may configure ProGuard as needed. Important When using ProGuard or DexGuard with Android apps, follow the procedures to complete the additional, required configuration steps. For more information, see the ProGuard and DexGuard configuration documentation. Troubleshoot auto-instrumentation If you are not whether the agent is auto-instrumenting an instant app project, try running these steps: Build app with debug (-d, --debug) option, and capture the build log. Search the log for evidence of instant apps by looking for either of these terms: This appears to be an Instant App Copy BuildId[1a2b34c5-def6-7890-g123-h4567890a] Copy The agent will add an attribute named 'instantApp' to the app's Insights session attributes if the app appears to be an instant app.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 119.90538,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install the <em>New</em> <em>Relic</em> plugin for <em>Android</em> Instant Apps",
        "sections": "Install the <em>New</em> <em>Relic</em> plugin for <em>Android</em> Instant Apps",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>Android</em>",
        "body": "<em>Android</em> Instant Apps allow users to quickly use your applications without installation. With the <em>Android</em> agent version 5.17.0 and higher, you can use <em>New</em> <em>Relic</em> to detect and instrument all feature modules for an instant app. Use this documentation along with the standard <em>New</em> <em>Relic</em> procedures"
      },
      "id": "603e87a764441fa6934e885e"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-apps/mobile-app-features/authentication-partner-saml-sso-accounts": [
    {
      "sections": [
        "Alerting with New Relic mobile apps",
        "Requirements",
        "Turn notifications on or off",
        "View alert incident details",
        "Troubleshoot alert settings",
        "Check notification settings for your mobile device.",
        "Delete the Android or iOS device from your New Relic account.",
        "Uninstall the New Relic mobile app.",
        "Reinstall the New Relic mobile app."
      ],
      "title": "Alerting with New Relic mobile apps",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "Authentication and alerts"
      ],
      "external_id": "d55850dc642cc8ade20310e1d4654db61af1e809",
      "image": "https://docs.newrelic.com/static/f942198cbd9a41b7355ef7f01fa6cc66/e5166/alerts-incident-detail-nexus.jpg",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/authentication-alerts/alerting-new-relic-mobile-apps/",
      "published_at": "2021-10-24T17:45:03Z",
      "updated_at": "2021-07-09T12:24:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Account administrators can set up configuration to receive push notifications on Android and iOS devices from New Relic Alerts. You can receive alerts from any policy by attaching a user channel to the policy. Requirements This feature is available only to users on the original user model, not to users on the New Relic One user model. As a workaround, you can use the email notification channel. Turn notifications on or off When you log in to your New Relic account from an Android or iOS app, your device is automatically associated with your user channel. Be sure to add the associated user channel to the alert policy. View alert incident details The notification automatically appears on your device's lock screen. To start the New Relic app: Android devices: Tap the notification from the notification drawer. OR iOS devices: Swipe the screen. From the New Relic app's Alerts menu, select any alert to view error details for the associated application. Optional: Select Acknowledge. Optional: To view additional details, select Overview, Violations, or Event log. The main menu's Alerts list shows alerts in the following order, sorted by time: Active incidents Resolved incidents from today Resolved incidents and events from the past week, organized by day Troubleshoot alert settings If alerts are not working on your mobile device: Verify that you meet the requirements. Verify that alerts are enabled. Check your mobile device's notification settings, to ensure New Relic is permitted to send alerts. If the notification settings for your mobile device are correct, but you still do not receive notifications, delete the device from your account, then uninstall and reinstall the New Relic application. Check notification settings for your mobile device. Follow the procedure for your mobile device. Device To check notification settings: Android From your Android device's Settings, select Sound and notification. Check the settings for sound volume. Optional: Enable Also vibrate for calls. Check the settings for Interruptions. Check the settings for Notification. Check the settings for App notifications: Select the New Relic app, then check the settings for Block and Priority. iOS Ensure Do Not Disturb is off: From the iOS Settings app, select Do Not Disturb, and check that the Manual switch is off. Ensure the New Relic app is allowed to send notifications: From the iOS Settings app, select Notifications, and locate the New Relic app from the app list. Ensure that the Allow Notifications switch is on. Ensure that the alert style is set to Banners or Alerts. Optional: To enable audio alerts, set Sounds to on. Delete the Android or iOS device from your New Relic account. To delete the mobile device from your New Relic account, use the public graphql api api.newrelic.com/graphiql in a web browser: Query current devices by selecting actor -> mobilePushNotification -> devices and selecting appVersion, deviceId, and deviceName. Run this query to get the list of devices. Mutate to remove a device by selecting mutation -> mobilePushNotificationRemoveDevice, and passing in the deviceId from the list above. Or you can remove the device from the in-app Settings option from the menu -> Settings Look under Push notification devices, and remove from there. On iOS, slide from right to left to Delete a device, on Android, tap Delete Continue with the steps to reinstall the New Relic app from your device. Uninstall the New Relic mobile app. Follow the procedure to uninstall the New Relic app from your device, then reinstall it. Device To uninstall the New Relic app: Android From your Android device's Settings, select Apps, then select the New Relic app. Select Uninstall. Continue with the steps to reinstall the New Relic app. iOS From your iOS home screen, tap and hold the New Relic icon until it shakes. To delete the app, select the X icon. Continue with the steps to reinstall the New Relic app. Reinstall the New Relic mobile app. To reinstall the New Relic mobile app: From your Android device, select Google Play Store. OR From your iOS device's home screen, select App Store. Search for New Relic. Download the app. When the download finishes, sign in to your New Relic mobile app with your New Relic account.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 211.23553,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alerting</em> with <em>New</em> <em>Relic</em> <em>mobile</em> <em>apps</em>",
        "sections": "<em>Alerting</em> with <em>New</em> <em>Relic</em> <em>mobile</em> <em>apps</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> <em>apps</em>",
        "body": " channel to the <em>alert</em> policy. View <em>alert</em> incident details The notification automatically appears on your device&#x27;s lock screen. To start the <em>New</em> <em>Relic</em> <em>app</em>: Android devices: Tap the notification from the notification drawer. OR iOS devices: Swipe the screen. From the <em>New</em> <em>Relic</em> <em>app</em>&#x27;s <em>Alerts</em> menu, select"
      },
      "id": "603e9efd64441f19a14e88ab"
    },
    {
      "sections": [
        "User settings and authentication",
        "User authentication",
        "User settings",
        "Sign in with additional username",
        "Switch between accounts",
        "Remove or re-add a user name"
      ],
      "title": "User settings and authentication",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "Authentication and alerts"
      ],
      "external_id": "0b40ac4c2e769279d25d0ebb2ea77cebda8d8ea7",
      "image": "https://docs.newrelic.com/static/88ff328efc4a127601923bc728fea229/8c557/device-ipad-switch-user.png",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/authentication-alerts/user-settings-authentication/",
      "published_at": "2021-10-24T16:00:05Z",
      "updated_at": "2021-05-16T06:27:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This explains how to authenticate your New Relic mobile app account, and how to add users to or remove them from your mobile device. User authentication Depending on your New Relic account, additional installation or authentication steps may be required when you install the New Relic mobile app. New Relic account Additional requirements New users If you do not already have a New Relic account: From your desktop web browser, create a New Relic account. Install your application with the appropriate New Relic agent. As part of new account setup, you will receive an email with a password reset link. The password reset link expires after 20 minutes for mobile apps. Existing New Relic users No additional requirements; your applications, hosts, installed plugins, and key transactions automatically appear after you sign in. Users with New Relic partner accounts Depending on the partner, you may need to complete a different authentication process. Azure Store users: Due to the deep integration between Azure Storefront and New Relic, Azure Storefront users cannot access their accounts on the New Relic Android or iOS apps. Users with SAML-SSO enabled accounts When you sign in to the New Relic mobile app, your session automatically redirects to your web browser. From there you can sign in to your New Relic SAML-SSO account. If you see any errors when using SAML-SSO accounts on your mobile device, verify that you are able to sign in to one.newrelic.com with a desktop web browser. If no, contact your administrator. If yes, get support at support.newrelic.com. User settings After you sign in, all New Relic accounts and applications associated with the user appear automatically. Sign in with additional username Follow the procedure for your mobile device. Mobile device To sign in to the app with an additional user name: Android To switch users: Log out from the Android device: Main menu > (selected username) > Logout > Confirm. Log in with a new account. iPhone From the app menu, select your account name, then select the Users menu. From the Users menu, select the plus icon. Sign in with the additional username. iPad To access the Users menu: Select the user icon or slide right. From the Users menu, select the plus icon. Sign in with the additional username. Switch between accounts To switch between accounts associated with your username: From the Users menu, select the user name. Select the account name. Remove or re-add a user name To remove a specific username from this device: From the Users menu, select Logout. To remove a user from this device, select the user's red minus icon. Select the user's Log out icon. To add a user again, sign in with that username again. Select the user icon or slide right to show the New Relic iPad app's Users menu.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.3156,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "User settings <em>and</em> <em>authentication</em>",
        "sections": "User settings <em>and</em> <em>authentication</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> <em>apps</em>",
        "body": "This explains how to authenticate your <em>New</em> <em>Relic</em> <em>mobile</em> <em>app</em> account, and how to add users to or remove them from your <em>mobile</em> device. User <em>authentication</em> Depending on your <em>New</em> <em>Relic</em> account, additional installation or <em>authentication</em> steps may be required when you install the <em>New</em> <em>Relic</em> <em>mobile</em> <em>app</em>"
      },
      "id": "604415a728ccbc8fb52c6068"
    },
    {
      "sections": [
        "Troubleshoot SSO accounts using mobile devices",
        "No user name or password",
        "Errors after signing in",
        "Reauthentication problems"
      ],
      "title": "Troubleshoot SSO accounts using mobile devices",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic mobile apps",
        "Authentication and alerts"
      ],
      "external_id": "9ebb373182ce5fea83ba5a6baa03b2c7bccf0174",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/authentication-alerts/troubleshoot-sso-accounts-using-mobile-devices/",
      "published_at": "2021-10-24T17:45:43Z",
      "updated_at": "2021-05-16T06:23:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Typically when you sign in to the New Relic mobile app, your session redirects automatically to your web browser. From there you can sign in to your New Relic account. Here are troubleshooting tips if you have problems using the New Relic mobile app with your SAML-SSO enabled account. No user name or password You may not have a user name or password for New Relic because some SAML providers will overwrite your password, or because your administrator has not sent you this information. In these situations: From the mobile app's Log in, select the I don't have a password link. Use your mobile device to open your email account. From your email account, retrieve the New Relic authentication email within 20 minutes. Select the Authenticate button or the link below it in the email. Errors after signing in If you see any errors after successfully signing in to your SSO provider with your mobile device, verify that you are able to sign in to one.newrelic.com with a desktop web browser. If no, contact your administrator. If yes, get support at support.newrelic.com. Reauthentication problems If you are using reauthentication on a SAML-SSO account, you must log in to your default account. (All other accounts will be grayed out.) If you attempt to switch to a grayed-out account, an error message will appear, explaining this is currently not supported.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.31541,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Troubleshoot SSO accounts using <em>mobile</em> devices",
        "sections": "Troubleshoot SSO accounts using <em>mobile</em> devices",
        "tags": "<em>New</em> <em>Relic</em> <em>mobile</em> <em>apps</em>",
        "body": "Typically when you sign in to the <em>New</em> <em>Relic</em> <em>mobile</em> <em>app</em>, your session redirects automatically to your web browser. From there you can sign in to your <em>New</em> <em>Relic</em> account. Here are troubleshooting tips if you have problems using the <em>New</em> <em>Relic</em> <em>mobile</em> <em>app</em> with your SAML-SSO enabled account. No user name"
      },
      "id": "604415e0196a67fc3f960f42"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-cordova-phonegap/get-started/introduction-new-relic-cordova": [
    {
      "sections": [
        "Get data into New Relic",
        "New Relic-built agents and integrations",
        "Report custom data"
      ],
      "title": "Get data into New Relic",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Get started"
      ],
      "external_id": "016a25d46dedc5da1455b29d8557ce68a4345756",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/get-started/introduction-new-relic-data-ingest-apis-sdks/",
      "published_at": "2021-10-24T19:36:34Z",
      "updated_at": "2021-10-23T17:32:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "There are many ways to get data into your New Relic account. Any New Relic user can use any of our data ingest methods to report data to our platform. New Relic-built agents and integrations When you enable New Relic solutions like APM, browser monitoring, mobile monitoring, infrastructure monitoring, or any of our wide array of integrations, by default you'll receive data from your monitored applications, hosts, services, or other entities. Some options for getting started: Log into one.newrelic.com and click Add more data to get some guidance on setting up New Relic solutions. To browse our solutions, see New Relic integrations. Report custom data If you need to report data that our agents and integrations don't provide, we have tools that will allow you to bring in any type of data you need. To learn more, see Intro to custom data.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 149.99026,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Get</em> data into <em>New</em> <em>Relic</em>",
        "sections": "<em>Get</em> data into <em>New</em> <em>Relic</em>",
        "tags": "<em>Get</em> <em>started</em>",
        "body": "There are many ways to <em>get</em> data into your <em>New</em> <em>Relic</em> account. Any <em>New</em> <em>Relic</em> user can use any of our data ingest methods to report data to our platform. <em>New</em> <em>Relic</em>-built agents and integrations When you enable <em>New</em> <em>Relic</em> solutions like APM, browser <em>monitoring</em>, <em>mobile</em> <em>monitoring</em>, infrastructure"
      },
      "id": "6174474328ccbcdff4c6b77e"
    },
    {
      "sections": [
        "Get started with New Relic observability",
        "Youâ€™re in control because you understand your system",
        "All the answers in one place",
        "Start anywhere"
      ],
      "title": "Get started with New Relic observability",
      "type": "docs",
      "tags": [
        "Observe everything",
        "Get started"
      ],
      "external_id": "30f87d5f702f926efec49b59591679fa93627ad5",
      "image": "https://docs.newrelic.com/static/44970161aec793f3141cfcdc0fc96a57/c1b63/observability-2.png",
      "url": "https://docs.newrelic.com/docs/using-new-relic/welcome-new-relic/get-started/get-started-full-stack-observability/",
      "published_at": "2021-10-24T11:46:39Z",
      "updated_at": "2021-10-23T16:46:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "True observability is the power of knowing what's happening across your digital system and why, at any time, whatever solution youâ€™re using. Itâ€™s getting the whole picture of everything that enables your applications and devices to deliver value to your customers, from the container running a microservice in the cloud to a mobile website's shopping cart button. Youâ€™re in control because you understand your system New Relic helps you cut through the layers of complexity surrounding your systems by bringing together and connecting data from any instrumented source and environment, without having to jump between tools. You can interrogate your data for patterns, discover them using our data platform, or get proactive results from our machine learning tools. New Relic provides answers to essential questions in one place. All the answers in one place As a full user you get access to our entire set of observability tools. All our tools are interconnected and accessible in New Relic One. All the data you bring to New Relic through agents and integrations are metrics, events, logs, and traces that feed our platform's analytics and monitoring capabilities. New Relic links your data in a meaningful way so that you can explore it, build dashboards, and set up alerts. Our more curated observability UI experiences allow to visualize, analyze, and troubleshoot your entire software stack in one unified platform. The New Relic Explorer consolidates all the entities in your system, and how they're connected, in a single place, so you can easily detect performance trends and issues. By automatically connecting infrastructure health with application performance and end-user behavior, you can cut through the noise to find the signal. Start anywhere Being fully-connected, New Relic allows you to start your observability journey from any element of your stack. For example, you can get to crucial infrastructure logs from traces of an application running on a problematic Kubernetes pod. Use the Explorer in New Relic One to access and observe the full stack of your software, see performance data and alerting status at a glance, and check relationships. We provide you with a simple, yet powerful visual tool to monitor all your entities, that is, anything we can identify that reports data. In the New Relic ecosystem, entities include basic components like applications, hosts, containers, or database services, but it can also refer to custom groupings of such elements. You can also create your own entities. The more entities you instrument, the more data you'll bring in. The more data you've brought to New Relic, the more you'll understand your metrics, events, logs, and traces. You want to instrument Start with Keep exploring Front-end applications Mobile applications User behavior and flows New Relic Explorer Browser monitoring Mobile monitoring Synthetic monitoring Single page monitoring Scripted browsers Containerized minions Workloads Backend applications Serverless applications New Relic Explorer Application monitoring Serverless monitoring Learning about Apdex Distributed tracing Logs in context APM data to infrastructure Workloads Infrastructure hosts and services (on-premise, cloud, orchestrated) Container environments and orchestration tools (Kubernetes, ECS, etc.) Infrastructure monitoring Infrastructure integrations Kubernetes integration Docker integration ECS integration Log forwarding APM data to infrastructure Custom integrations Kubernetes cluster explorer Infrastructure alerts Workloads",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.99307,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Get</em> <em>started</em> with <em>New</em> <em>Relic</em> observability",
        "sections": "<em>Get</em> <em>started</em> with <em>New</em> <em>Relic</em> observability",
        "tags": "<em>Get</em> <em>started</em>",
        "body": ". You want to instrument <em>Start</em> with Keep exploring Front-end applications <em>Mobile</em> applications User behavior and flows <em>New</em> <em>Relic</em> Explorer Browser <em>monitoring</em> <em>Mobile</em> <em>monitoring</em> Synthetic <em>monitoring</em> Single page <em>monitoring</em> Scripted browsers Containerized minions Workloads Backend applications Serverless"
      },
      "id": "61743c6764441f60375fd317"
    },
    {
      "sections": [
        "Introduction to Android monitoring",
        "Install the Android agent",
        "Extend your instrumentation",
        "See your errors in CodeStream"
      ],
      "title": "Introduction to Android monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Get started"
      ],
      "external_id": "ae1aceb4e03cd9acadc71fa9fedf674a3f8cc3cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/get-started/introduction-new-relic-mobile-android/",
      "published_at": "2021-10-24T16:17:45Z",
      "updated_at": "2021-10-23T01:47:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring for Android monitors your mobile app, giving you a comprehensive view of your app's performance. It works for Android apps written using Java or Kotlin. Install the Android agent Before you install the Android agent, make sure your app follows the compatibility requirements. As part of the installation process, mobile monitoring automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. Follow the Android installation and configuration procedures for your environment as applicable. If you have problems with your Android installation, or if you do not see data in the mobile monitoring UI for your Android app, follow the troubleshooting procedures. Extend your instrumentation After you install the agent, extend the agent's instrumentation by using the mobile monitoring UI and following up on information in New Relic Insights. To access: In mobile monitoring: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. Android SDK API Use the Android SDK API for mobile monitoring to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. See your errors in CodeStream You can also see your Android application's directly in your IDE using CodeStream and errors inbox. To do this, install CodeStream, connect CodeStream and New Relic and create Git tags that match your appVersion.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.93417,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to Android <em>monitoring</em>",
        "sections": "Introduction to Android <em>monitoring</em>",
        "tags": "<em>Mobile</em> <em>monitoring</em>",
        "body": " on information in <em>New</em> <em>Relic</em> Insights. To access: In <em>mobile</em> <em>monitoring</em>: In NRQL and dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. Then, view the custom events that you created in NRQL or dashboards. Network"
      },
      "id": "6043a48f196a6784e6960f6d"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/api-guides/ios-agent-configuration-feature-flags": [
    {
      "sections": [
        "Upload dSYM files",
        "Automatic script",
        "Identify missing dSYMs",
        "Upload dSYM files through the mobile monitoring UI",
        "Manually upload dSYM files",
        "Via Python script (agent versions 6.0.0 or higher)",
        "Via command line",
        "Troubleshooting",
        "Auto-upload failure",
        "Missing dSYMs"
      ],
      "title": "Upload dSYM files",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "3655f49cf0e1ae693de0f8ea45bf4e5e6437e399",
      "image": "https://docs.newrelic.com/static/5c859575f391fbb1eaa18243a8c97000/8c557/Screen-Shot-2014-09-23-at-11.30.35-AM_0.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/upload-dsyms-bitcode-apps/",
      "published_at": "2021-10-24T16:52:30Z",
      "updated_at": "2021-09-27T15:06:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your app's dSYM files are stored in Xcode's dSYM archive path folder. This is the folder where the iOS agent gets the dSYM files that are used to symbolicate your crash reports. New Relic provides a post-build script as part of the iOS agent's install process and the tvOS agent's install process. This script automatically uploads your app's dSYM files. Automatic script The script automatically uploads dSYM files only for release builds. Non-release builds must upload their files either manually or through the mobile monitoring UI. Bitcode-enabled apps have their dSYM files generated by Apple. You must download the dSYM files for Bitcode-enabled apps from Apple and upload them to New Relic. If you see unreadable machine code in the Crashes page, your dSYM files may not be uploaded correctly. In some cases, you may need to manually upload dSYM files. The automatic script uses Python 2. As of October 2019 with macOS 10.15 (Catalina), Python won't be installed by default. If you're using the automatic script (recommended), you may need to manually install Python 2. If you're using Homebrew, see Python on Homebrew. Identify missing dSYMs When a Bitcode-enabled app is uploaded to Apple for App Store review or ad-hoc distribution, dSYMs need to be manually downloaded from Apple and uploaded to New Relic to allow the mobile crash reports to be properly symbolicated. These dSYMs can be downloaded through the archives organizer in Xcode within several minutes of uploading the app. In this situation follow the procedures to find the archive and download dSYMs. If an app is missing a dSYM file, you'll see three indicators in the mobile monitoring UI: Banner notification: A banner warning appears on the Crash report page. The warning reads: We were unable to locate your dsym. Copy Upload prompt: From the Crash type summary page you will be automatically prompted to upload a dSYM file if it is missing. Machine code: The crash stack trace on the Crash report page displays machine code and not a human-readable error message. Upload dSYM files through the mobile monitoring UI You can easily upload your dSYM files directly from the New Relic One UI. The maximum file size is 600 MB. To upload your dSYM files: Go to one.newrelic.com and click Mobile. Then select your app from the list. View Crash analysis. Select a specific crash from the Crash types list. Click Upload dSYM. You can either drag and drop your dSYMs directly, or select the file form your computer. Manually upload dSYM files In some circumstances, New Relic's automatic upload of dSYM files may fail. If a dSYM upload is attempted and fails, it creates a build error with a detailed message. For example, if there's a network failure and the dSYM upload isn't completed, Xcode will report an error. For additional information about how New Relic handles dSYM uploads, see New Relic's Online Technical Community. If the automatic upload fails, you can manually upload your dSYM file. If you have multiple dSYM files, they can be within a single zip with a maximum file size of 600 MB. The YOUR_NEW_RELIC_APPLICATION_TOKEN value in the commands below is the same key used for +[NewRelic startWithApplicationToken:] (in Objective-C) or NewRelic.start(withApplicationToken:) (in Swift). To manually upload your dSYM files: Via Python script (agent versions 6.0.0 or higher) In iOS agent versions 6.0.0 or higher, the agent includes a Python script that automatically processes and uploads symbols. You can call this script from the command line: NewRelicAgent.framework/Resources/generateMap.py \"DSYM_ARCHIVE_PATH\" \"YOUR_NEW_RELIC_APPLICATION_TOKEN\" Copy Via command line To manually upload individual dSYM files from the command line: Zip up your dSYM file or files using the following command. Replace ~ /ZIPPED_DSYM_PATH with your new dSYM archive path and file name (for example, Users/my-name/desktop). Also replace ~ /dSYM_PATH with your existing dSYM file path. /usr/bin/zip --recurse-paths --quiet \"~/ZIPPED_DSYM_PATH\" \"~/dSYM_PATH\" Copy Upload the dSYM zip file using the following command: For US accounts: curl -F dsym=@\"~/DSYM_ZIP_PATH\" -H \"X-APP-LICENSE-KEY: YOUR_NEW_RELIC_APPLICATION_TOKEN\" https://mobile-symbol-upload.newrelic.com/symbol Copy For EU accounts: curl -F dsym=@\"~/DSYM_ZIP_PATH\" -H \"X-APP-LICENSE-KEY: YOUR_NEW_RELIC_APPLICATION_TOKEN\" https://mobile-symbol-upload.eu01.nr-data.net/symbol Copy Troubleshooting Auto-upload failure If a dSYM auto-upload failed, the Report Navigator may have a fully formed cURL command. You can use this cURL command to reattempt an upload. Depending on the error, you may also need to follow some of the dSYM manual upload steps. Here is an example of a successful dSYM upload in the Report Navigator: Example: A successful dSYM upload in the Report Navigator. Missing dSYMs If dSYM files are missing, you may need to check Xcode build settings to ensure the file is being generated. Frameworks which are built locally have separate build settings and may need to be updated as well. Build settings: Debug Information Format : Dwarf with dSYM File Deployment Postprocessing: Yes Strip Linked Product: Yes Strip Debug Symbols During Copy : Yes Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.31993,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Upload dSYM files through the <em>mobile</em> <em>monitoring</em> UI",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Your app&#x27;s dSYM files are stored in Xcode&#x27;s dSYM archive path folder. This is the folder where the <em>iOS</em> agent gets the dSYM files that are used to symbolicate your crash reports. <em>New</em> <em>Relic</em> provides a post-build script as part of the <em>iOS</em> agent&#x27;s install process and the tv<em>OS</em> agent&#x27;s install process"
      },
      "id": "60441960e7b9d24f705799ca"
    },
    {
      "sections": [
        "CocoaPods installation",
        "Install your iOS application",
        "Configure using Objective-C",
        "Important",
        "Configure using Swift",
        "Change the logging level (optional)"
      ],
      "title": "CocoaPods installation",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Installation"
      ],
      "external_id": "9a062745f628f66e34f865a47d58713f12e59ac9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/installation/cocoapods-installation/",
      "published_at": "2021-10-24T16:53:24Z",
      "updated_at": "2021-10-01T20:15:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "These procedures apply to iOS apps using Cocoapods. For other types, see iOS installation and configuration. Install your iOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. To install and configure your iOS application: Go to one.newrelic.com. If applicable: From the Mobile Apps list, select Add a new app. From the Get Started page, select iOS as the platform for mobile monitoring. Type a name for your mobile app, then select Continue. If your installation does not automatically include the prefix header, follow the steps to add the prefix header to your project. Continue with the steps to configure New Relic for mobile monitoring. Configure using Objective-C These procedures to configure your iOS app with CocoaPods and Objective-C also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy In your APP_NAME-Prefix.pch project file (generally found in the Supporting Files folder), include the New Relic header inside the #ifdef __OBJC__ #endif block: #import <NewRelic/NewRelic.h> Copy In your AppDelegate.m file, add this call as the first line of application:didFinishLaunchingWithOptions, replacing APP_TOKEN with your application token: [NewRelic startWithApplicationToken:@\"APP_TOKEN\"]; Copy Important The agent must be on the first line of didFinishLaunchingWithOptions and run on the main thread to ensure proper instrumentation. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Add a build script to your target's Build Phases. Ensure the new build script is the very last build script. Then paste the following, replacing APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"APP_TOKEN\" Copy Clean and build your app, then run it in the simulator or other device. Configure using Swift These procedures to configure your iOS app with CocoaPods and Swift also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy Create a bridging header: Select File > New > File > Objective-C File. Name the file Placeholder.m, then select Next. Select Create, and confirm Xcode's prompt to generate the bridging header. In your APP_NAME-Bridging-Header.h, add the New Relic header: #import \"NewRelic/NewRelic.h\" Copy In your AppDelegate.swift file, add this call as the first line of application:didFinishLaunchingWithOptions, replacing APP_TOKEN with your application token: NewRelic.start(withApplicationToken:\"APP_TOKEN\") Copy Important To ensure proper instrumentation, you must call the agent on the first line of didFinishLaunchingWithOptions(), and run the agent on the main thread. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Add a build script to your target's Build Phases. Ensure the new build script is the very last build script. Then paste the following, replacing APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"APP_TOKEN\" Copy Clean and build your app, then run it in the simulator or other device. Change the logging level (optional) Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add this method call before calling NewRelic.start(withApplicationToken): [NRLogger setLogLevels:NRLogLevelALL]; Copy For Swift apps: NRLogger.setLogLevels(NRLogLevelALL.rawValue) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 161.04848,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "CocoaPods <em>installation</em>",
        "sections": "<em>Install</em> your <em>iOS</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " <em>mobile</em> app you <em>monitor</em> in <em>New</em> <em>Relic</em>. To install and configure your <em>iOS</em> application: Go to one.newrelic.com. If applicable: From the <em>Mobile</em> Apps list, select Add a <em>new</em> app. From the Get Started page, select <em>iOS</em> as the platform for <em>mobile</em> <em>monitoring</em>. Type a name for your <em>mobile</em> app, then select Continue"
      },
      "id": "603ea15d64441fef3d4e8867"
    },
    {
      "sections": [
        "Retrieve dSYMs for Bitcode apps",
        "Identify missing dSYMs",
        "Download dSYM files using iTunes Connect",
        "Download dSYM files using Xcode's app archive",
        "Upload dSYMs"
      ],
      "title": "Retrieve dSYMs for Bitcode apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "34e375873e36095062eccef6d99f26be7562308f",
      "image": "https://docs.newrelic.com/static/041368cdc60d9252ad80c2c37321b805/ec3e2/screen-dsym2.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/retrieve-dsyms-bitcode-apps/",
      "published_at": "2021-10-24T16:51:42Z",
      "updated_at": "2021-07-09T19:35:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Bitcode is a feature that gives Apple the ability to re-compile iOS and tvOS applications for specific users' hardware. This provides a smaller download size for end users. For more about this process, see Apple's Bitcode and app thinning documentation. When Apple compiles an app, the dSYM files are also compiled. For New Relic to be able to symbolicate crashes of your Bitcode-enabled app, these dSYM files need to be downloaded from Apple and then uploaded to New Relic. Identify missing dSYMs When a Bitcode-enabled app is uploaded to Apple for App Store review or ad-hoc distribution, dSYMs need to be manually downloaded from Apple and uploaded to New Relic to allow the mobile crash reports to be properly symbolicated. These dSYMs can be downloaded through the archives organizer in Xcode within several minutes of uploading the app. In this situation follow the procedures to find the archive and download dSYMs. If an app is missing a dSYM file, you'll see three indicators in the mobile monitoring UI: Banner notification: A banner warning appears on the Crash report page. The warning reads: We were unable to locate your dsym. Copy Upload prompt: from the Crash type summary page you will be automatically prompted to upload a dSYM file if it is missing. Machine code: The crash stack trace on the Crash report page displays machine code and not a human-readable error message. Download dSYM files using iTunes Connect To download the dSYM files you need for your app: Log in to Apple iTunes Connect. Select My Apps > (selected app) > Activity. From the list of builds for your application, select the build number you need for the dSYM. Select Download dSYM. Then, to upload the resulting zip file directly to New Relic: Follow the instructions to manually upload dSYM, and skip step 1. Unpack one dSYM contained in this zip file to retrieve a build UUID that you can upload. (Follow the last step in the manual upload instructions.) Once New Relic receives the zip file, the build UUIDs for all other dSYMs contained in that zip file will be identified. Download dSYM files using Xcode's app archive Use the app version and build number to identify the applicable app archive in the Xcode Organizer and download the dSYMs. Using Xcode to download dSYMs: From the Archives tab, select the app and version/build, then select Download dSYMs. Open the Xcode Organizer: From the Xcode menu, select Window > Organizer > Archives > (select a mobile app). From Version, select the archive that matches the app version (listed first) and build number (following the app version in parentheses). Select Download dSYMs. The dSYMs will be downloaded from Apple if available and if the file names contain a series of letters and numbers. If the dSYM files are named after the the dependencies in your project, the download will not be successful. Upload dSYMs Once you have located the dSYMs, follow the instructions to upload a dSYM for each zipped dSYM.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 148.4336,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Identify</em> missing dSYMs",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Bitcode is a feature that gives Apple the ability to re-compile <em>iOS</em> and tv<em>OS</em> applications for specific users&#x27; hardware. This provides a smaller download size for end users. For more about this process, see Apple&#x27;s Bitcode and app thinning documentation. When Apple compiles an app, the dSYM files"
      },
      "id": "6044144228ccbc04a2303885"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/api-guides/ios-sdk-api-guide": [
    {
      "sections": [
        "CocoaPods installation",
        "Install your iOS application",
        "Configure using Objective-C",
        "Important",
        "Configure using Swift",
        "Change the logging level (optional)"
      ],
      "title": "CocoaPods installation",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Installation"
      ],
      "external_id": "9a062745f628f66e34f865a47d58713f12e59ac9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/installation/cocoapods-installation/",
      "published_at": "2021-10-24T16:53:24Z",
      "updated_at": "2021-10-01T20:15:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "These procedures apply to iOS apps using Cocoapods. For other types, see iOS installation and configuration. Install your iOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. To install and configure your iOS application: Go to one.newrelic.com. If applicable: From the Mobile Apps list, select Add a new app. From the Get Started page, select iOS as the platform for mobile monitoring. Type a name for your mobile app, then select Continue. If your installation does not automatically include the prefix header, follow the steps to add the prefix header to your project. Continue with the steps to configure New Relic for mobile monitoring. Configure using Objective-C These procedures to configure your iOS app with CocoaPods and Objective-C also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy In your APP_NAME-Prefix.pch project file (generally found in the Supporting Files folder), include the New Relic header inside the #ifdef __OBJC__ #endif block: #import <NewRelic/NewRelic.h> Copy In your AppDelegate.m file, add this call as the first line of application:didFinishLaunchingWithOptions, replacing APP_TOKEN with your application token: [NewRelic startWithApplicationToken:@\"APP_TOKEN\"]; Copy Important The agent must be on the first line of didFinishLaunchingWithOptions and run on the main thread to ensure proper instrumentation. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Add a build script to your target's Build Phases. Ensure the new build script is the very last build script. Then paste the following, replacing APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"APP_TOKEN\" Copy Clean and build your app, then run it in the simulator or other device. Configure using Swift These procedures to configure your iOS app with CocoaPods and Swift also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy Create a bridging header: Select File > New > File > Objective-C File. Name the file Placeholder.m, then select Next. Select Create, and confirm Xcode's prompt to generate the bridging header. In your APP_NAME-Bridging-Header.h, add the New Relic header: #import \"NewRelic/NewRelic.h\" Copy In your AppDelegate.swift file, add this call as the first line of application:didFinishLaunchingWithOptions, replacing APP_TOKEN with your application token: NewRelic.start(withApplicationToken:\"APP_TOKEN\") Copy Important To ensure proper instrumentation, you must call the agent on the first line of didFinishLaunchingWithOptions(), and run the agent on the main thread. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Add a build script to your target's Build Phases. Ensure the new build script is the very last build script. Then paste the following, replacing APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"APP_TOKEN\" Copy Clean and build your app, then run it in the simulator or other device. Change the logging level (optional) Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add this method call before calling NewRelic.start(withApplicationToken): [NRLogger setLogLevels:NRLogLevelALL]; Copy For Swift apps: NRLogger.setLogLevels(NRLogLevelALL.rawValue) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.3889,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "CocoaPods <em>installation</em>",
        "sections": "<em>Install</em> your <em>iOS</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " <em>mobile</em> app you <em>monitor</em> in <em>New</em> <em>Relic</em>. To install and configure your <em>iOS</em> application: Go to one.newrelic.com. If applicable: From the <em>Mobile</em> Apps list, select Add a <em>new</em> app. From the Get Started page, select <em>iOS</em> as the platform for <em>mobile</em> <em>monitoring</em>. Type a name for your <em>mobile</em> app, then select Continue"
      },
      "id": "603ea15d64441fef3d4e8867"
    },
    {
      "sections": [
        "Upload dSYM files",
        "Automatic script",
        "Identify missing dSYMs",
        "Upload dSYM files through the mobile monitoring UI",
        "Manually upload dSYM files",
        "Via Python script (agent versions 6.0.0 or higher)",
        "Via command line",
        "Troubleshooting",
        "Auto-upload failure",
        "Missing dSYMs"
      ],
      "title": "Upload dSYM files",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "3655f49cf0e1ae693de0f8ea45bf4e5e6437e399",
      "image": "https://docs.newrelic.com/static/5c859575f391fbb1eaa18243a8c97000/8c557/Screen-Shot-2014-09-23-at-11.30.35-AM_0.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/upload-dsyms-bitcode-apps/",
      "published_at": "2021-10-24T16:52:30Z",
      "updated_at": "2021-09-27T15:06:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your app's dSYM files are stored in Xcode's dSYM archive path folder. This is the folder where the iOS agent gets the dSYM files that are used to symbolicate your crash reports. New Relic provides a post-build script as part of the iOS agent's install process and the tvOS agent's install process. This script automatically uploads your app's dSYM files. Automatic script The script automatically uploads dSYM files only for release builds. Non-release builds must upload their files either manually or through the mobile monitoring UI. Bitcode-enabled apps have their dSYM files generated by Apple. You must download the dSYM files for Bitcode-enabled apps from Apple and upload them to New Relic. If you see unreadable machine code in the Crashes page, your dSYM files may not be uploaded correctly. In some cases, you may need to manually upload dSYM files. The automatic script uses Python 2. As of October 2019 with macOS 10.15 (Catalina), Python won't be installed by default. If you're using the automatic script (recommended), you may need to manually install Python 2. If you're using Homebrew, see Python on Homebrew. Identify missing dSYMs When a Bitcode-enabled app is uploaded to Apple for App Store review or ad-hoc distribution, dSYMs need to be manually downloaded from Apple and uploaded to New Relic to allow the mobile crash reports to be properly symbolicated. These dSYMs can be downloaded through the archives organizer in Xcode within several minutes of uploading the app. In this situation follow the procedures to find the archive and download dSYMs. If an app is missing a dSYM file, you'll see three indicators in the mobile monitoring UI: Banner notification: A banner warning appears on the Crash report page. The warning reads: We were unable to locate your dsym. Copy Upload prompt: From the Crash type summary page you will be automatically prompted to upload a dSYM file if it is missing. Machine code: The crash stack trace on the Crash report page displays machine code and not a human-readable error message. Upload dSYM files through the mobile monitoring UI You can easily upload your dSYM files directly from the New Relic One UI. The maximum file size is 600 MB. To upload your dSYM files: Go to one.newrelic.com and click Mobile. Then select your app from the list. View Crash analysis. Select a specific crash from the Crash types list. Click Upload dSYM. You can either drag and drop your dSYMs directly, or select the file form your computer. Manually upload dSYM files In some circumstances, New Relic's automatic upload of dSYM files may fail. If a dSYM upload is attempted and fails, it creates a build error with a detailed message. For example, if there's a network failure and the dSYM upload isn't completed, Xcode will report an error. For additional information about how New Relic handles dSYM uploads, see New Relic's Online Technical Community. If the automatic upload fails, you can manually upload your dSYM file. If you have multiple dSYM files, they can be within a single zip with a maximum file size of 600 MB. The YOUR_NEW_RELIC_APPLICATION_TOKEN value in the commands below is the same key used for +[NewRelic startWithApplicationToken:] (in Objective-C) or NewRelic.start(withApplicationToken:) (in Swift). To manually upload your dSYM files: Via Python script (agent versions 6.0.0 or higher) In iOS agent versions 6.0.0 or higher, the agent includes a Python script that automatically processes and uploads symbols. You can call this script from the command line: NewRelicAgent.framework/Resources/generateMap.py \"DSYM_ARCHIVE_PATH\" \"YOUR_NEW_RELIC_APPLICATION_TOKEN\" Copy Via command line To manually upload individual dSYM files from the command line: Zip up your dSYM file or files using the following command. Replace ~ /ZIPPED_DSYM_PATH with your new dSYM archive path and file name (for example, Users/my-name/desktop). Also replace ~ /dSYM_PATH with your existing dSYM file path. /usr/bin/zip --recurse-paths --quiet \"~/ZIPPED_DSYM_PATH\" \"~/dSYM_PATH\" Copy Upload the dSYM zip file using the following command: For US accounts: curl -F dsym=@\"~/DSYM_ZIP_PATH\" -H \"X-APP-LICENSE-KEY: YOUR_NEW_RELIC_APPLICATION_TOKEN\" https://mobile-symbol-upload.newrelic.com/symbol Copy For EU accounts: curl -F dsym=@\"~/DSYM_ZIP_PATH\" -H \"X-APP-LICENSE-KEY: YOUR_NEW_RELIC_APPLICATION_TOKEN\" https://mobile-symbol-upload.eu01.nr-data.net/symbol Copy Troubleshooting Auto-upload failure If a dSYM auto-upload failed, the Report Navigator may have a fully formed cURL command. You can use this cURL command to reattempt an upload. Depending on the error, you may also need to follow some of the dSYM manual upload steps. Here is an example of a successful dSYM upload in the Report Navigator: Example: A successful dSYM upload in the Report Navigator. Missing dSYMs If dSYM files are missing, you may need to check Xcode build settings to ensure the file is being generated. Frameworks which are built locally have separate build settings and may need to be updated as well. Build settings: Debug Information Format : Dwarf with dSYM File Deployment Postprocessing: Yes Strip Linked Product: Yes Strip Debug Symbols During Copy : Yes Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.7114,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Upload dSYM files through the <em>mobile</em> <em>monitoring</em> UI",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Your app&#x27;s dSYM files are stored in Xcode&#x27;s dSYM archive path folder. This is the folder where the <em>iOS</em> agent gets the dSYM files that are used to symbolicate your crash reports. <em>New</em> <em>Relic</em> provides a post-build script as part of the <em>iOS</em> agent&#x27;s install process and the tv<em>OS</em> agent&#x27;s install process"
      },
      "id": "60441960e7b9d24f705799ca"
    },
    {
      "sections": [
        "iOS manual installation",
        "Install your iOS application",
        "Add the New Relic framework to your app",
        "Important",
        "Optional: Execute a demo crash",
        "Optional: Change the logging level"
      ],
      "title": "iOS manual installation",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Installation"
      ],
      "external_id": "0a674eb7f3756cd5d124c6dcf2344edf38e40a8a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/installation/ios-manual-installation/",
      "published_at": "2021-10-24T16:52:30Z",
      "updated_at": "2021-07-27T15:09:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To install and configure New Relic functionality with your iOS applications, follow these procedures. If your iOS app uses Cocoapods, follow the Cocoapods installation procedures. Install your iOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. To install and configure your iOS application: Go to one.newrelic.com. If applicable: From the Mobile Apps index, select Add a new app. From the Get started page, select XCFramework as the platform for mobile monitoring. Type a name for your mobile app, and select Continue. Continue with the steps to configure New Relic. Add the New Relic framework to your app Download and unzip the iOS SDK for New Relic. To add the New Relic framework to your Xcode project: Use Finder to drag the NewRelicAgent.framework folder into your Xcode project, and drop it onto your project in the Project navigator window, under Frameworks, Libraries, and Embedded Content. Make sure Embed & Sign is selected under the Embed dropdown menu. Implement the agent using the appropriate method: Important To ensure proper instrumentation, you must call the agent on the first line of didFinishLaunchingWithOptions(), and run the agent on the main thread. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Language Procedure Objective-C To start the agent: Import the New Relic header at the top of your prefix.pch. Add +[NewRelic startWithApplicationToken:@\"<appToken>\"] to the top of -application:didFinishLaunchingWithOptions: in your AppDelegate.m, using the unique application token that is automatically generated. Swift Create a bridging header file: Select File > New > File > Objective-C File. Name the file Placeholder.m, then select Next. Select Create, and confirm Xcode's prompt to generate the bridging header. Delete Placeholder.m. Import the New Relic agent by adding #import \"NewRelic/NewRelic.h\" to the top of MyApp-Bridging-Header.h. Add NewRelic.start(withApplicationToken: \">appToken>\") to the top of application(_:didFinishLaunchingWithOptions:) in your AppDelegate.swift using the unique application token that is automatically generated. Add a build script to your target's Build Phases. Ensure the new build script is the very last build phase, then paste the following, replacing PUT_NEW_RELIC_APP_TOKEN_HERE with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"PUT_NEW_RELIC_APP_TOKEN_HERE\" Copy Clean and build your app, and then run it in the simulator or other device. Optional: Execute a demo crash If you have trouble getting your app to crash, the New Relic agent provides an API to execute a demo crash. Recommendation: Add one of these lines of code to a button click event handler as applicable: Language Code Objective-C Crash: [NewRelic crashNow]; Copy Crash with log message: [NewRelic crashNow:@\"<reason>\"]; Copy Swift Crash: NewRelic.crashNow() Copy Crash with log message: NewRelic.crashNow(_ message:) Copy Optional: Change the logging level Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add the following method: Language Code Objective-C Just before calling startWithApplicationToken in AppDelegate.m, add: [NRLogger setLogLevels:NRLogLevelALL]; Copy Swift Just before calling start(withApplicationToken:) in AppDelegate.swift, add: NRLogger.setLogLevels(NRLogLevelALL.rawValue) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 119.01738,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> manual <em>installation</em>",
        "sections": "<em>iOS</em> manual <em>installation</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " token. This is a 40-character hexadecimal string for authenticating each <em>mobile</em> app you <em>monitor</em> in <em>New</em> <em>Relic</em>. To install and configure your <em>iOS</em> application: Go to one.newrelic.com. If applicable: From the <em>Mobile</em> Apps index, select Add a <em>new</em> app. From the Get started page, select XCFramework"
      },
      "id": "603ea44864441f80904e8899"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/configuration/adding-prefix-header-ios-project": [
    {
      "sections": [
        "Upload dSYM files",
        "Automatic script",
        "Identify missing dSYMs",
        "Upload dSYM files through the mobile monitoring UI",
        "Manually upload dSYM files",
        "Via Python script (agent versions 6.0.0 or higher)",
        "Via command line",
        "Troubleshooting",
        "Auto-upload failure",
        "Missing dSYMs"
      ],
      "title": "Upload dSYM files",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "3655f49cf0e1ae693de0f8ea45bf4e5e6437e399",
      "image": "https://docs.newrelic.com/static/5c859575f391fbb1eaa18243a8c97000/8c557/Screen-Shot-2014-09-23-at-11.30.35-AM_0.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/upload-dsyms-bitcode-apps/",
      "published_at": "2021-10-24T16:52:30Z",
      "updated_at": "2021-09-27T15:06:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your app's dSYM files are stored in Xcode's dSYM archive path folder. This is the folder where the iOS agent gets the dSYM files that are used to symbolicate your crash reports. New Relic provides a post-build script as part of the iOS agent's install process and the tvOS agent's install process. This script automatically uploads your app's dSYM files. Automatic script The script automatically uploads dSYM files only for release builds. Non-release builds must upload their files either manually or through the mobile monitoring UI. Bitcode-enabled apps have their dSYM files generated by Apple. You must download the dSYM files for Bitcode-enabled apps from Apple and upload them to New Relic. If you see unreadable machine code in the Crashes page, your dSYM files may not be uploaded correctly. In some cases, you may need to manually upload dSYM files. The automatic script uses Python 2. As of October 2019 with macOS 10.15 (Catalina), Python won't be installed by default. If you're using the automatic script (recommended), you may need to manually install Python 2. If you're using Homebrew, see Python on Homebrew. Identify missing dSYMs When a Bitcode-enabled app is uploaded to Apple for App Store review or ad-hoc distribution, dSYMs need to be manually downloaded from Apple and uploaded to New Relic to allow the mobile crash reports to be properly symbolicated. These dSYMs can be downloaded through the archives organizer in Xcode within several minutes of uploading the app. In this situation follow the procedures to find the archive and download dSYMs. If an app is missing a dSYM file, you'll see three indicators in the mobile monitoring UI: Banner notification: A banner warning appears on the Crash report page. The warning reads: We were unable to locate your dsym. Copy Upload prompt: From the Crash type summary page you will be automatically prompted to upload a dSYM file if it is missing. Machine code: The crash stack trace on the Crash report page displays machine code and not a human-readable error message. Upload dSYM files through the mobile monitoring UI You can easily upload your dSYM files directly from the New Relic One UI. The maximum file size is 600 MB. To upload your dSYM files: Go to one.newrelic.com and click Mobile. Then select your app from the list. View Crash analysis. Select a specific crash from the Crash types list. Click Upload dSYM. You can either drag and drop your dSYMs directly, or select the file form your computer. Manually upload dSYM files In some circumstances, New Relic's automatic upload of dSYM files may fail. If a dSYM upload is attempted and fails, it creates a build error with a detailed message. For example, if there's a network failure and the dSYM upload isn't completed, Xcode will report an error. For additional information about how New Relic handles dSYM uploads, see New Relic's Online Technical Community. If the automatic upload fails, you can manually upload your dSYM file. If you have multiple dSYM files, they can be within a single zip with a maximum file size of 600 MB. The YOUR_NEW_RELIC_APPLICATION_TOKEN value in the commands below is the same key used for +[NewRelic startWithApplicationToken:] (in Objective-C) or NewRelic.start(withApplicationToken:) (in Swift). To manually upload your dSYM files: Via Python script (agent versions 6.0.0 or higher) In iOS agent versions 6.0.0 or higher, the agent includes a Python script that automatically processes and uploads symbols. You can call this script from the command line: NewRelicAgent.framework/Resources/generateMap.py \"DSYM_ARCHIVE_PATH\" \"YOUR_NEW_RELIC_APPLICATION_TOKEN\" Copy Via command line To manually upload individual dSYM files from the command line: Zip up your dSYM file or files using the following command. Replace ~ /ZIPPED_DSYM_PATH with your new dSYM archive path and file name (for example, Users/my-name/desktop). Also replace ~ /dSYM_PATH with your existing dSYM file path. /usr/bin/zip --recurse-paths --quiet \"~/ZIPPED_DSYM_PATH\" \"~/dSYM_PATH\" Copy Upload the dSYM zip file using the following command: For US accounts: curl -F dsym=@\"~/DSYM_ZIP_PATH\" -H \"X-APP-LICENSE-KEY: YOUR_NEW_RELIC_APPLICATION_TOKEN\" https://mobile-symbol-upload.newrelic.com/symbol Copy For EU accounts: curl -F dsym=@\"~/DSYM_ZIP_PATH\" -H \"X-APP-LICENSE-KEY: YOUR_NEW_RELIC_APPLICATION_TOKEN\" https://mobile-symbol-upload.eu01.nr-data.net/symbol Copy Troubleshooting Auto-upload failure If a dSYM auto-upload failed, the Report Navigator may have a fully formed cURL command. You can use this cURL command to reattempt an upload. Depending on the error, you may also need to follow some of the dSYM manual upload steps. Here is an example of a successful dSYM upload in the Report Navigator: Example: A successful dSYM upload in the Report Navigator. Missing dSYMs If dSYM files are missing, you may need to check Xcode build settings to ensure the file is being generated. Frameworks which are built locally have separate build settings and may need to be updated as well. Build settings: Debug Information Format : Dwarf with dSYM File Deployment Postprocessing: Yes Strip Linked Product: Yes Strip Debug Symbols During Copy : Yes Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.31992,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Upload dSYM files through the <em>mobile</em> <em>monitoring</em> UI",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Your app&#x27;s dSYM files are stored in Xcode&#x27;s dSYM archive path folder. This is the folder where the <em>iOS</em> agent gets the dSYM files that are used to symbolicate your crash reports. <em>New</em> <em>Relic</em> provides a post-build script as part of the <em>iOS</em> agent&#x27;s install process and the tv<em>OS</em> agent&#x27;s install process"
      },
      "id": "60441960e7b9d24f705799ca"
    },
    {
      "sections": [
        "CocoaPods installation",
        "Install your iOS application",
        "Configure using Objective-C",
        "Important",
        "Configure using Swift",
        "Change the logging level (optional)"
      ],
      "title": "CocoaPods installation",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Installation"
      ],
      "external_id": "9a062745f628f66e34f865a47d58713f12e59ac9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/installation/cocoapods-installation/",
      "published_at": "2021-10-24T16:53:24Z",
      "updated_at": "2021-10-01T20:15:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "These procedures apply to iOS apps using Cocoapods. For other types, see iOS installation and configuration. Install your iOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. To install and configure your iOS application: Go to one.newrelic.com. If applicable: From the Mobile Apps list, select Add a new app. From the Get Started page, select iOS as the platform for mobile monitoring. Type a name for your mobile app, then select Continue. If your installation does not automatically include the prefix header, follow the steps to add the prefix header to your project. Continue with the steps to configure New Relic for mobile monitoring. Configure using Objective-C These procedures to configure your iOS app with CocoaPods and Objective-C also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy In your APP_NAME-Prefix.pch project file (generally found in the Supporting Files folder), include the New Relic header inside the #ifdef __OBJC__ #endif block: #import <NewRelic/NewRelic.h> Copy In your AppDelegate.m file, add this call as the first line of application:didFinishLaunchingWithOptions, replacing APP_TOKEN with your application token: [NewRelic startWithApplicationToken:@\"APP_TOKEN\"]; Copy Important The agent must be on the first line of didFinishLaunchingWithOptions and run on the main thread to ensure proper instrumentation. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Add a build script to your target's Build Phases. Ensure the new build script is the very last build script. Then paste the following, replacing APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"APP_TOKEN\" Copy Clean and build your app, then run it in the simulator or other device. Configure using Swift These procedures to configure your iOS app with CocoaPods and Swift also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy Create a bridging header: Select File > New > File > Objective-C File. Name the file Placeholder.m, then select Next. Select Create, and confirm Xcode's prompt to generate the bridging header. In your APP_NAME-Bridging-Header.h, add the New Relic header: #import \"NewRelic/NewRelic.h\" Copy In your AppDelegate.swift file, add this call as the first line of application:didFinishLaunchingWithOptions, replacing APP_TOKEN with your application token: NewRelic.start(withApplicationToken:\"APP_TOKEN\") Copy Important To ensure proper instrumentation, you must call the agent on the first line of didFinishLaunchingWithOptions(), and run the agent on the main thread. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Add a build script to your target's Build Phases. Ensure the new build script is the very last build script. Then paste the following, replacing APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"APP_TOKEN\" Copy Clean and build your app, then run it in the simulator or other device. Change the logging level (optional) Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add this method call before calling NewRelic.start(withApplicationToken): [NRLogger setLogLevels:NRLogLevelALL]; Copy For Swift apps: NRLogger.setLogLevels(NRLogLevelALL.rawValue) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 161.04846,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "CocoaPods <em>installation</em>",
        "sections": "<em>Install</em> your <em>iOS</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " <em>mobile</em> app you <em>monitor</em> in <em>New</em> <em>Relic</em>. To install and configure your <em>iOS</em> application: Go to one.newrelic.com. If applicable: From the <em>Mobile</em> Apps list, select Add a <em>new</em> app. From the Get Started page, select <em>iOS</em> as the platform for <em>mobile</em> <em>monitoring</em>. Type a name for your <em>mobile</em> app, then select Continue"
      },
      "id": "603ea15d64441fef3d4e8867"
    },
    {
      "sections": [
        "Retrieve dSYMs for Bitcode apps",
        "Identify missing dSYMs",
        "Download dSYM files using iTunes Connect",
        "Download dSYM files using Xcode's app archive",
        "Upload dSYMs"
      ],
      "title": "Retrieve dSYMs for Bitcode apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "34e375873e36095062eccef6d99f26be7562308f",
      "image": "https://docs.newrelic.com/static/041368cdc60d9252ad80c2c37321b805/ec3e2/screen-dsym2.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/retrieve-dsyms-bitcode-apps/",
      "published_at": "2021-10-24T16:51:42Z",
      "updated_at": "2021-07-09T19:35:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Bitcode is a feature that gives Apple the ability to re-compile iOS and tvOS applications for specific users' hardware. This provides a smaller download size for end users. For more about this process, see Apple's Bitcode and app thinning documentation. When Apple compiles an app, the dSYM files are also compiled. For New Relic to be able to symbolicate crashes of your Bitcode-enabled app, these dSYM files need to be downloaded from Apple and then uploaded to New Relic. Identify missing dSYMs When a Bitcode-enabled app is uploaded to Apple for App Store review or ad-hoc distribution, dSYMs need to be manually downloaded from Apple and uploaded to New Relic to allow the mobile crash reports to be properly symbolicated. These dSYMs can be downloaded through the archives organizer in Xcode within several minutes of uploading the app. In this situation follow the procedures to find the archive and download dSYMs. If an app is missing a dSYM file, you'll see three indicators in the mobile monitoring UI: Banner notification: A banner warning appears on the Crash report page. The warning reads: We were unable to locate your dsym. Copy Upload prompt: from the Crash type summary page you will be automatically prompted to upload a dSYM file if it is missing. Machine code: The crash stack trace on the Crash report page displays machine code and not a human-readable error message. Download dSYM files using iTunes Connect To download the dSYM files you need for your app: Log in to Apple iTunes Connect. Select My Apps > (selected app) > Activity. From the list of builds for your application, select the build number you need for the dSYM. Select Download dSYM. Then, to upload the resulting zip file directly to New Relic: Follow the instructions to manually upload dSYM, and skip step 1. Unpack one dSYM contained in this zip file to retrieve a build UUID that you can upload. (Follow the last step in the manual upload instructions.) Once New Relic receives the zip file, the build UUIDs for all other dSYMs contained in that zip file will be identified. Download dSYM files using Xcode's app archive Use the app version and build number to identify the applicable app archive in the Xcode Organizer and download the dSYMs. Using Xcode to download dSYMs: From the Archives tab, select the app and version/build, then select Download dSYMs. Open the Xcode Organizer: From the Xcode menu, select Window > Organizer > Archives > (select a mobile app). From Version, select the archive that matches the app version (listed first) and build number (following the app version in parentheses). Select Download dSYMs. The dSYMs will be downloaded from Apple if available and if the file names contain a series of letters and numbers. If the dSYM files are named after the the dependencies in your project, the download will not be successful. Upload dSYMs Once you have located the dSYMs, follow the instructions to upload a dSYM for each zipped dSYM.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 148.4336,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Identify</em> missing dSYMs",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Bitcode is a feature that gives Apple the ability to re-compile <em>iOS</em> and tv<em>OS</em> applications for specific users&#x27; hardware. This provides a smaller download size for end users. For more about this process, see Apple&#x27;s Bitcode and app thinning documentation. When Apple compiles an app, the dSYM files"
      },
      "id": "6044144228ccbc04a2303885"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/configuration/enable-swift-interaction-traces": [
    {
      "sections": [
        "Upload dSYM files",
        "Automatic script",
        "Identify missing dSYMs",
        "Upload dSYM files through the mobile monitoring UI",
        "Manually upload dSYM files",
        "Via Python script (agent versions 6.0.0 or higher)",
        "Via command line",
        "Troubleshooting",
        "Auto-upload failure",
        "Missing dSYMs"
      ],
      "title": "Upload dSYM files",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "3655f49cf0e1ae693de0f8ea45bf4e5e6437e399",
      "image": "https://docs.newrelic.com/static/5c859575f391fbb1eaa18243a8c97000/8c557/Screen-Shot-2014-09-23-at-11.30.35-AM_0.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/upload-dsyms-bitcode-apps/",
      "published_at": "2021-10-24T16:52:30Z",
      "updated_at": "2021-09-27T15:06:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your app's dSYM files are stored in Xcode's dSYM archive path folder. This is the folder where the iOS agent gets the dSYM files that are used to symbolicate your crash reports. New Relic provides a post-build script as part of the iOS agent's install process and the tvOS agent's install process. This script automatically uploads your app's dSYM files. Automatic script The script automatically uploads dSYM files only for release builds. Non-release builds must upload their files either manually or through the mobile monitoring UI. Bitcode-enabled apps have their dSYM files generated by Apple. You must download the dSYM files for Bitcode-enabled apps from Apple and upload them to New Relic. If you see unreadable machine code in the Crashes page, your dSYM files may not be uploaded correctly. In some cases, you may need to manually upload dSYM files. The automatic script uses Python 2. As of October 2019 with macOS 10.15 (Catalina), Python won't be installed by default. If you're using the automatic script (recommended), you may need to manually install Python 2. If you're using Homebrew, see Python on Homebrew. Identify missing dSYMs When a Bitcode-enabled app is uploaded to Apple for App Store review or ad-hoc distribution, dSYMs need to be manually downloaded from Apple and uploaded to New Relic to allow the mobile crash reports to be properly symbolicated. These dSYMs can be downloaded through the archives organizer in Xcode within several minutes of uploading the app. In this situation follow the procedures to find the archive and download dSYMs. If an app is missing a dSYM file, you'll see three indicators in the mobile monitoring UI: Banner notification: A banner warning appears on the Crash report page. The warning reads: We were unable to locate your dsym. Copy Upload prompt: From the Crash type summary page you will be automatically prompted to upload a dSYM file if it is missing. Machine code: The crash stack trace on the Crash report page displays machine code and not a human-readable error message. Upload dSYM files through the mobile monitoring UI You can easily upload your dSYM files directly from the New Relic One UI. The maximum file size is 600 MB. To upload your dSYM files: Go to one.newrelic.com and click Mobile. Then select your app from the list. View Crash analysis. Select a specific crash from the Crash types list. Click Upload dSYM. You can either drag and drop your dSYMs directly, or select the file form your computer. Manually upload dSYM files In some circumstances, New Relic's automatic upload of dSYM files may fail. If a dSYM upload is attempted and fails, it creates a build error with a detailed message. For example, if there's a network failure and the dSYM upload isn't completed, Xcode will report an error. For additional information about how New Relic handles dSYM uploads, see New Relic's Online Technical Community. If the automatic upload fails, you can manually upload your dSYM file. If you have multiple dSYM files, they can be within a single zip with a maximum file size of 600 MB. The YOUR_NEW_RELIC_APPLICATION_TOKEN value in the commands below is the same key used for +[NewRelic startWithApplicationToken:] (in Objective-C) or NewRelic.start(withApplicationToken:) (in Swift). To manually upload your dSYM files: Via Python script (agent versions 6.0.0 or higher) In iOS agent versions 6.0.0 or higher, the agent includes a Python script that automatically processes and uploads symbols. You can call this script from the command line: NewRelicAgent.framework/Resources/generateMap.py \"DSYM_ARCHIVE_PATH\" \"YOUR_NEW_RELIC_APPLICATION_TOKEN\" Copy Via command line To manually upload individual dSYM files from the command line: Zip up your dSYM file or files using the following command. Replace ~ /ZIPPED_DSYM_PATH with your new dSYM archive path and file name (for example, Users/my-name/desktop). Also replace ~ /dSYM_PATH with your existing dSYM file path. /usr/bin/zip --recurse-paths --quiet \"~/ZIPPED_DSYM_PATH\" \"~/dSYM_PATH\" Copy Upload the dSYM zip file using the following command: For US accounts: curl -F dsym=@\"~/DSYM_ZIP_PATH\" -H \"X-APP-LICENSE-KEY: YOUR_NEW_RELIC_APPLICATION_TOKEN\" https://mobile-symbol-upload.newrelic.com/symbol Copy For EU accounts: curl -F dsym=@\"~/DSYM_ZIP_PATH\" -H \"X-APP-LICENSE-KEY: YOUR_NEW_RELIC_APPLICATION_TOKEN\" https://mobile-symbol-upload.eu01.nr-data.net/symbol Copy Troubleshooting Auto-upload failure If a dSYM auto-upload failed, the Report Navigator may have a fully formed cURL command. You can use this cURL command to reattempt an upload. Depending on the error, you may also need to follow some of the dSYM manual upload steps. Here is an example of a successful dSYM upload in the Report Navigator: Example: A successful dSYM upload in the Report Navigator. Missing dSYMs If dSYM files are missing, you may need to check Xcode build settings to ensure the file is being generated. Frameworks which are built locally have separate build settings and may need to be updated as well. Build settings: Debug Information Format : Dwarf with dSYM File Deployment Postprocessing: Yes Strip Linked Product: Yes Strip Debug Symbols During Copy : Yes Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.31992,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Upload dSYM files through the <em>mobile</em> <em>monitoring</em> UI",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Your app&#x27;s dSYM files are stored in Xcode&#x27;s dSYM archive path folder. This is the folder where the <em>iOS</em> agent gets the dSYM files that are used to symbolicate your crash reports. <em>New</em> <em>Relic</em> provides a post-build script as part of the <em>iOS</em> agent&#x27;s install process and the tv<em>OS</em> agent&#x27;s install process"
      },
      "id": "60441960e7b9d24f705799ca"
    },
    {
      "sections": [
        "CocoaPods installation",
        "Install your iOS application",
        "Configure using Objective-C",
        "Important",
        "Configure using Swift",
        "Change the logging level (optional)"
      ],
      "title": "CocoaPods installation",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Installation"
      ],
      "external_id": "9a062745f628f66e34f865a47d58713f12e59ac9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/installation/cocoapods-installation/",
      "published_at": "2021-10-24T16:53:24Z",
      "updated_at": "2021-10-01T20:15:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "These procedures apply to iOS apps using Cocoapods. For other types, see iOS installation and configuration. Install your iOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. To install and configure your iOS application: Go to one.newrelic.com. If applicable: From the Mobile Apps list, select Add a new app. From the Get Started page, select iOS as the platform for mobile monitoring. Type a name for your mobile app, then select Continue. If your installation does not automatically include the prefix header, follow the steps to add the prefix header to your project. Continue with the steps to configure New Relic for mobile monitoring. Configure using Objective-C These procedures to configure your iOS app with CocoaPods and Objective-C also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy In your APP_NAME-Prefix.pch project file (generally found in the Supporting Files folder), include the New Relic header inside the #ifdef __OBJC__ #endif block: #import <NewRelic/NewRelic.h> Copy In your AppDelegate.m file, add this call as the first line of application:didFinishLaunchingWithOptions, replacing APP_TOKEN with your application token: [NewRelic startWithApplicationToken:@\"APP_TOKEN\"]; Copy Important The agent must be on the first line of didFinishLaunchingWithOptions and run on the main thread to ensure proper instrumentation. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Add a build script to your target's Build Phases. Ensure the new build script is the very last build script. Then paste the following, replacing APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"APP_TOKEN\" Copy Clean and build your app, then run it in the simulator or other device. Configure using Swift These procedures to configure your iOS app with CocoaPods and Swift also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy Create a bridging header: Select File > New > File > Objective-C File. Name the file Placeholder.m, then select Next. Select Create, and confirm Xcode's prompt to generate the bridging header. In your APP_NAME-Bridging-Header.h, add the New Relic header: #import \"NewRelic/NewRelic.h\" Copy In your AppDelegate.swift file, add this call as the first line of application:didFinishLaunchingWithOptions, replacing APP_TOKEN with your application token: NewRelic.start(withApplicationToken:\"APP_TOKEN\") Copy Important To ensure proper instrumentation, you must call the agent on the first line of didFinishLaunchingWithOptions(), and run the agent on the main thread. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Add a build script to your target's Build Phases. Ensure the new build script is the very last build script. Then paste the following, replacing APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"APP_TOKEN\" Copy Clean and build your app, then run it in the simulator or other device. Change the logging level (optional) Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add this method call before calling NewRelic.start(withApplicationToken): [NRLogger setLogLevels:NRLogLevelALL]; Copy For Swift apps: NRLogger.setLogLevels(NRLogLevelALL.rawValue) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 161.04846,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "CocoaPods <em>installation</em>",
        "sections": "<em>Install</em> your <em>iOS</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " <em>mobile</em> app you <em>monitor</em> in <em>New</em> <em>Relic</em>. To install and configure your <em>iOS</em> application: Go to one.newrelic.com. If applicable: From the <em>Mobile</em> Apps list, select Add a <em>new</em> app. From the Get Started page, select <em>iOS</em> as the platform for <em>mobile</em> <em>monitoring</em>. Type a name for your <em>mobile</em> app, then select Continue"
      },
      "id": "603ea15d64441fef3d4e8867"
    },
    {
      "sections": [
        "Retrieve dSYMs for Bitcode apps",
        "Identify missing dSYMs",
        "Download dSYM files using iTunes Connect",
        "Download dSYM files using Xcode's app archive",
        "Upload dSYMs"
      ],
      "title": "Retrieve dSYMs for Bitcode apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "34e375873e36095062eccef6d99f26be7562308f",
      "image": "https://docs.newrelic.com/static/041368cdc60d9252ad80c2c37321b805/ec3e2/screen-dsym2.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/retrieve-dsyms-bitcode-apps/",
      "published_at": "2021-10-24T16:51:42Z",
      "updated_at": "2021-07-09T19:35:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Bitcode is a feature that gives Apple the ability to re-compile iOS and tvOS applications for specific users' hardware. This provides a smaller download size for end users. For more about this process, see Apple's Bitcode and app thinning documentation. When Apple compiles an app, the dSYM files are also compiled. For New Relic to be able to symbolicate crashes of your Bitcode-enabled app, these dSYM files need to be downloaded from Apple and then uploaded to New Relic. Identify missing dSYMs When a Bitcode-enabled app is uploaded to Apple for App Store review or ad-hoc distribution, dSYMs need to be manually downloaded from Apple and uploaded to New Relic to allow the mobile crash reports to be properly symbolicated. These dSYMs can be downloaded through the archives organizer in Xcode within several minutes of uploading the app. In this situation follow the procedures to find the archive and download dSYMs. If an app is missing a dSYM file, you'll see three indicators in the mobile monitoring UI: Banner notification: A banner warning appears on the Crash report page. The warning reads: We were unable to locate your dsym. Copy Upload prompt: from the Crash type summary page you will be automatically prompted to upload a dSYM file if it is missing. Machine code: The crash stack trace on the Crash report page displays machine code and not a human-readable error message. Download dSYM files using iTunes Connect To download the dSYM files you need for your app: Log in to Apple iTunes Connect. Select My Apps > (selected app) > Activity. From the list of builds for your application, select the build number you need for the dSYM. Select Download dSYM. Then, to upload the resulting zip file directly to New Relic: Follow the instructions to manually upload dSYM, and skip step 1. Unpack one dSYM contained in this zip file to retrieve a build UUID that you can upload. (Follow the last step in the manual upload instructions.) Once New Relic receives the zip file, the build UUIDs for all other dSYMs contained in that zip file will be identified. Download dSYM files using Xcode's app archive Use the app version and build number to identify the applicable app archive in the Xcode Organizer and download the dSYMs. Using Xcode to download dSYMs: From the Archives tab, select the app and version/build, then select Download dSYMs. Open the Xcode Organizer: From the Xcode menu, select Window > Organizer > Archives > (select a mobile app). From Version, select the archive that matches the app version (listed first) and build number (following the app version in parentheses). Select Download dSYMs. The dSYMs will be downloaded from Apple if available and if the file names contain a series of letters and numbers. If the dSYM files are named after the the dependencies in your project, the download will not be successful. Upload dSYMs Once you have located the dSYMs, follow the instructions to upload a dSYM for each zipped dSYM.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 148.4336,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Identify</em> missing dSYMs",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Bitcode is a feature that gives Apple the ability to re-compile <em>iOS</em> and tv<em>OS</em> applications for specific users&#x27; hardware. This provides a smaller download size for end users. For more about this process, see Apple&#x27;s Bitcode and app thinning documentation. When Apple compiles an app, the dSYM files"
      },
      "id": "6044144228ccbc04a2303885"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/configuration/ios-device-id-obfuscation": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/attribute-dictionary/",
      "sections": [
        "New Relic data dictionary",
        "AjaxRequest",
        "AwsLambdaInvocation",
        "AwsLambdaInvocationError",
        "BrowserInteraction",
        "BrowserTiming",
        "ContainerSample",
        "DistributedTraceSummary",
        "InfrastructureEvent",
        "JavaScriptError",
        "Metric",
        "Mobile",
        "MobileCrash",
        "MobileHandledException",
        "MobileRequest",
        "MobileRequestError",
        "MobileSession",
        "NetworkSample",
        "NrAiIncident",
        "NrAuditEvent",
        "NrConsumption",
        "NrDailyUsage",
        "NrIntegrationError",
        "NrMTDConsumption",
        "NrUsage",
        "PageAction",
        "PageView",
        "PageViewTiming",
        "ProcessSample",
        "Span",
        "StorageSample",
        "SyntheticCheck",
        "SyntheticRequest",
        "SyntheticsPrivateLocationStatus",
        "SyntheticsPrivateMinion",
        "SystemSample",
        "Transaction",
        "TransactionError",
        "WorkloadStatus"
      ],
      "published_at": "2021-10-24T23:18:19Z",
      "title": "New Relic data dictionary",
      "updated_at": "2021-10-24T01:40:30Z",
      "type": "docs",
      "external_id": "cbca3a897621bcbb31159067d6d4ec27c5178fe4",
      "document_type": "views_page_content",
      "popularity": 1,
      "body": "AjaxRequest Data source : Browser agent An AjaxRequest event is created automatically when an Ajax request occurs during a BrowserInteraction event. The event attributes track geographic and browser info. Attribute name Definition Data types appId ID The ID of your application, as recorded by New Relic. AjaxRequest BrowserInteraction BrowserTiming PageAction PageView PageViewTiming appName The name of the application that handled the request as shown in New Relic Browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnLatitude The latitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's latitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnLongitude The longitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's longitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnOrganization The organization that owns the Autonomous System Number. Often an ISP, sometimes a private company or institution. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming browserInteractionId ID A unique value generated for each browser interaction captured by the New Relic agent. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError browserInteractionName The name of the interaction. This is either the targetGroupedUrl or the custom name set via the API. AjaxRequest BrowserInteraction BrowserTiming city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileSession PageAction PageView PageViewTiming countryCode The country from which the browser initiated the page load. For a list of country codes, see ISO 3166-1 alpha-2. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming deviceType The type of device that loaded the page: mobile, tablet, or desktop. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageView eventId ID A value that you can link to multiple BrowserInteraction events so you can view the interactions that occurred surrounding a specific event. For example, you can see the browser interactions that occurred prior to a JS error. AjaxRequest BrowserInteraction BrowserTiming groupedPageURL The grouped URL of the view that made the AJAX request. For example: myapp.com/acct/*/dash. AjaxRequest BrowserTiming groupedRequestUrl The grouped URL of the AJAX request. For example: myapp.com/acct/*/ajax. AjaxRequest Span hostname The fully qualified domain name (FQDN) of the request URL. AjaxRequest httpMethod enum The HTTP method of the AJAX request. Example: POST. AjaxRequest httpResponseCode enum The HTTP response code. Example: 200. AjaxRequest jsDuration seconds (s) The total duration, in seconds, spent on JavaScript execution. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. This attribute doesn't exist for initial page load events. AjaxRequest BrowserInteraction BrowserTiming pageUrl The URL of the page that was loaded for the PageView. For example: http://www.newrelic.com. This URL does not include query parameters. AjaxRequest BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span parentEventId ID A unique value generated for each interaction with the page. You can use this value to group interactions together. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError port enum The request port. AjaxRequest Span priority Likelihood this event will be saved. AjaxRequest regionCode The specific administrative division within a country where the PageView event occurred. In the United States, regions correspond to state codes, such as WA or NY. Outside the United States, a country's regions correspond to numerical codes. In the United States, regions correspond to state codes ; for example, WA or NY. Outside the United States, a country's regions correspond to numerical codes . AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming requestBodySize bytes (B) The payload size of the request body, in bytes. AjaxRequest requestUrl The URL of the AJAX request. For example: myapp.com/acct/1/ajax. AjaxRequest responseBodySize bytes (B) The payload size of the response body, in bytes. AjaxRequest session A unique identifier for a single session. The session cookie expires when the user closes the browser (for example, they fully exit Chrome.) A new session identifier will be assigned when the user opens up a new instance of the browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span timeSinceBrowserInteractionStart seconds (s) The time in seconds between the start of the BrowserInteraction and the start of the request. AjaxRequest BrowserTiming timeToLastCallbackEnd seconds (s) The duration, in seconds, from the start of the request (timestamp) to the end of the last callback. This is not just an additive function; the callback time can overlap with the wait time. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. AjaxRequest BrowserInteraction BrowserTiming timeToLoadEventStart seconds (s) The time, in seconds, from the start of the AJAX request to the start of its load event. This value represents the duration of the AJAX request with single page app (SPA) monitoring. For more information, see the Mozilla developer documentation about XMLHttpRequest load events. AjaxRequest timeToSettle seconds (s) The time, in seconds, from the start of the request to when all resulting callbacks (including callbacks of subsequent AJAX requests) are complete. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. AjaxRequest BrowserTiming timestamp The time (date, hour, minute, second) at which the interaction occurred. AjaxRequest BrowserInteraction BrowserTiming PageAction PageView PageViewTiming Span userAgentName The browserâ€™s name, such as Chrome and Firefox, obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentOS The browserâ€™s reported operating system, such as Windows or Linux, that it is running on. This is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentVersion The browserâ€™s reported software version, which is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming AwsLambdaInvocation Data source : AWS Lambda This event is reported by New Relic monitoring for AWS Lambda. This event captures overall function timing and associated metadata. A single AwsLambdaInvocation event is generated for each invocation. Attribute name Definition Data types aws.lambda.arn The Amazon Resource Name (ARN) of the instrumented Lambda function. AwsLambdaInvocationError AwsLambdaInvocation aws.lambda.coldStart A Boolean indicating if the AWS Lambda invocation is a cold start. AwsLambdaInvocationError AwsLambdaInvocation aws.lambda.eventSource.arn The Amazon Resource Name (ARN) of the entity that invoked the instrumented Lambda function. AwsLambdaInvocationError AwsLambdaInvocation aws.requestId ID AWS identifier of the invocation. AwsLambdaInvocationError AwsLambdaInvocation databaseCallCount count The number of database calls made by this transaction. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError databaseDuration seconds (s) The database response time in seconds. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError duration seconds (s) The total invocation time for the transaction, in seconds. (Data source: AWS Lambda) AwsLambdaInvocationError AwsLambdaInvocation externalCallCount count The number of external calls made by this transaction. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError externalDuration seconds (s) The total response time of all external (out-of-process) services, in seconds. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError newRelic.ingestPoint Where the data point entered the platform (such as browser.spans, or api.traces). AwsLambdaInvocationError AwsLambdaInvocation Span parent.account ID If a distributed tracing payload is received, this is the account identifier for the transaction's upstream caller. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError parent.app ID If a distributed tracing payload is received, this is the application identifier. APM agents retrieve this value in the connect response under the key primary_application_id. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError parent.transportType When a distributed tracing payload is received, the method of transport for the payload. Example values: Unknown, HTTP, HTTPS, Kafka, JMS, IronMQ, AMQP, Queue, or Other. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError parent.type If a distributed trace payload was received, the parent's data source type. Example values: App, Browser, Mobile. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.headers.accept The types as read from the HTTP Accept request header. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.headers.contentLength bytes (B) Incoming request size in bytes as read from the Content-Length HTTP request header. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.headers.contentType Incoming request content-type as read from the HTTP request header Content-Type. Example value: application/octet-stream. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.headers.host The name from the HTTP host request header. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.headers.referer The incoming request referer as read from the Referer request header. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.headers.userAgent The contents of the User-Agent HTTP header. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.method The HTTP request method used. Example values: POST, GET. AwsLambdaInvocationError AwsLambdaInvocation Span Transaction TransactionError response.headers.contentLength bytes (B) The outgoing response size in bytes as read from the Content-Length response header. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError response.headers.contentType For an HTTP response, the data type of the returned response. Example values: text/html, application/json. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError response.status bytes (B) The response code for an HTTP request AwsLambdaInvocation totalTime seconds (s) The sum of all async components' duration, in seconds. An async component is a method or function where there is no instrumented encapsulating method or function. AwsLambdaInvocation Transaction traceId ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. AwsLambdaInvocationError AwsLambdaInvocation MobileRequest MobileRequestError Span type The New Relic event type. Example values: Transaction, Span. AwsLambdaInvocationError AwsLambdaInvocation AwsLambdaInvocationError Data source : AWS Lambda This event is reported by New Relic monitoring for AWS Lambda. It's generated when an error occurs during a Lambda function invocation. Attribute name Definition Data types aws.lambda.arn The Amazon Resource Name (ARN) of the instrumented Lambda function. AwsLambdaInvocationError AwsLambdaInvocation aws.lambda.coldStart A Boolean indicating if the AWS Lambda invocation is a cold start. AwsLambdaInvocationError AwsLambdaInvocation aws.lambda.eventSource.arn The Amazon Resource Name (ARN) of the entity that invoked the instrumented Lambda function. AwsLambdaInvocationError AwsLambdaInvocation aws.requestId ID AWS identifier of the invocation. AwsLambdaInvocationError AwsLambdaInvocation databaseCallCount count The number of database calls made by this transaction. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError databaseDuration seconds (s) The database response time in seconds. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError duration seconds (s) The total invocation time for the transaction, in seconds. (Data source: AWS Lambda) AwsLambdaInvocationError AwsLambdaInvocation error.class The class name or type for the error. This will be server and platform specific. AwsLambdaInvocationError TransactionError error.message The error message for the transaction. This will be server and platform specific. AwsLambdaInvocationError TransactionError externalCallCount count The number of external calls made by this transaction. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError externalDuration seconds (s) The total response time of all external (out-of-process) services, in seconds. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError newRelic.ingestPoint Where the data point entered the platform (such as browser.spans, or api.traces). AwsLambdaInvocationError AwsLambdaInvocation Span parent.account ID If a distributed tracing payload is received, this is the account identifier for the transaction's upstream caller. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError parent.app ID If a distributed tracing payload is received, this is the application identifier. APM agents retrieve this value in the connect response under the key primary_application_id. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError parent.transportType When a distributed tracing payload is received, the method of transport for the payload. Example values: Unknown, HTTP, HTTPS, Kafka, JMS, IronMQ, AMQP, Queue, or Other. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError parent.type If a distributed trace payload was received, the parent's data source type. Example values: App, Browser, Mobile. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.headers.accept The types as read from the HTTP Accept request header. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.headers.contentLength bytes (B) Incoming request size in bytes as read from the Content-Length HTTP request header. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.headers.contentType Incoming request content-type as read from the HTTP request header Content-Type. Example value: application/octet-stream. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.headers.host The name from the HTTP host request header. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.headers.referer The incoming request referer as read from the Referer request header. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.headers.userAgent The contents of the User-Agent HTTP header. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError request.method The HTTP request method used. Example values: POST, GET. AwsLambdaInvocationError AwsLambdaInvocation Span Transaction TransactionError response.headers.contentLength bytes (B) The outgoing response size in bytes as read from the Content-Length response header. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError response.headers.contentType For an HTTP response, the data type of the returned response. Example values: text/html, application/json. AwsLambdaInvocationError AwsLambdaInvocation Transaction TransactionError stackTrace The error stack trace. The format will be different depending on the agent language. AwsLambdaInvocationError traceId ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. AwsLambdaInvocationError AwsLambdaInvocation MobileRequest MobileRequestError Span transactionName Name of the transaction in which the error occurred. Example value: Controller/customers/show. Value may be 'Unknown' if an error occurs outside of a transaction. AwsLambdaInvocationError TransactionError type The New Relic event type. Example values: Transaction, Span. AwsLambdaInvocationError AwsLambdaInvocation BrowserInteraction Data source : Browser agent A BrowserInteraction represents a unit of work in a browser session, triggered by a user interacting with the webpage. It captures information about the session, AJAX calls and custom JavaScript timing that occurred as a result of the interaction. Initial load and route changes are captured as special types of browser interactions, and are used for SPA monitoring. Attribute name Definition Data types actionText The text of the HTML element that was clicked when a browser interaction started. BrowserInteraction ajaxCount count A count of all XHRs included in the timing of a SPA interaction. BrowserInteraction appId ID The ID of your application, as recorded by New Relic. AjaxRequest BrowserInteraction BrowserTiming PageAction PageView PageViewTiming appName The name of the application that handled the request as shown in New Relic Browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnLatitude The latitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's latitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnLongitude The longitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's longitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnOrganization The organization that owns the Autonomous System Number. Often an ISP, sometimes a private company or institution. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming backendTransactionName The name of the backend transaction that served the initial page load. BrowserInteraction browserInteractionId ID A unique value generated for each browser interaction captured by the New Relic agent. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError browserInteractionName The name of the interaction. This is either the targetGroupedUrl or the custom name set via the API. AjaxRequest BrowserInteraction BrowserTiming category The type of interaction; either initial page load, route change, or custom. BrowserInteraction city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileSession PageAction PageView PageViewTiming countryCode The country from which the browser initiated the page load. For a list of country codes, see ISO 3166-1 alpha-2. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming deviceType The type of device that loaded the page: mobile, tablet, or desktop. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageView domain The domain portion of the request URL. BrowserInteraction JavaScriptError PageView PageViewTiming duration seconds (s) The total time elapsed of the interaction event BrowserInteraction eventId ID A value that you can link to multiple BrowserInteraction events so you can view the interactions that occurred surrounding a specific event. For example, you can see the browser interactions that occurred prior to a JS error. AjaxRequest BrowserInteraction BrowserTiming firstContentfulPaint firstContentfulPaint is the point when the browser renders the first bit of content from the DOM, which may be text, an image, SVG, or a <canvas> element. Google's User-centric Performance Metrics contains detailed information about its Paint Timing API and firstContentfulPaint. See Compatibility and requirements for New Relic Browser for additional information about firstContentfulPaint browser compatibility. BrowserInteraction PageView firstPaint firstPaint marks the point when the browser renders anything that is visually different from what was on the screen prior to navigation. This includes non-default background paint and the enclosing box of an iframe. Google's User-centric Performance Metrics contains detailed information about its Paint Timing API and firstPaint. See Compatibility and requirements for New Relic Browser for additional information about firstPaint browser compatibility. BrowserInteraction PageView jsDuration seconds (s) The total duration, in seconds, spent on JavaScript execution. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. This attribute doesn't exist for initial page load events. AjaxRequest BrowserInteraction BrowserTiming monitorAccountId The Synthetics account from which you are running the monitor. BrowserInteraction JavaScriptError monitorId ID A unique number identifying a particular monitor. BrowserInteraction JavaScriptError SyntheticCheck monitorJobId ID The ID of a single Synthetics monitor run, which began at a specific time and originated from a specific location. BrowserInteraction JavaScriptError parentEventId ID A unique value generated for each interaction with the page. You can use this value to group interactions together. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError previousGroupedUrl The grouped version of the URL in the browser at the start of the interaction. BrowserInteraction previousRouteName The route name of the page at the start of the interaction. This is the last value passed by setCurrentRouteName before the start of the interaction. BrowserInteraction previousURL The ungrouped URL in the browser at the start of the interaction. BrowserInteraction regionCode The specific administrative division within a country where the PageView event occurred. In the United States, regions correspond to state codes, such as WA or NY. Outside the United States, a country's regions correspond to numerical codes. In the United States, regions correspond to state codes ; for example, WA or NY. Outside the United States, a country's regions correspond to numerical codes . AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming session A unique identifier for a single session. The session cookie expires when the user closes the browser (for example, they fully exit Chrome.) A new session identifier will be assigned when the user opens up a new instance of the browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span targetGroupedUrl The grouped version of the URL in the browser at the end of the interaction. BrowserInteraction targetRouteName The route name for the page at the end of the interaction. The last value passed by setCurrentRouteName before the end of the interaction. BrowserInteraction targetUrl The ungrouped URL in the browser at the end of the interaction. BrowserInteraction timeToConnectEnd seconds (s) The time, in seconds, from the start of the interaction to the connectEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToConnectStart seconds (s) The time, in seconds, from the start of the interaction to the connectStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomComplete seconds (s) The time, in seconds, from the start of the interaction to the domComplete, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomContentLoadedEventEnd seconds (s) The time, in seconds, from the start of the interaction to the domContentLoadedEventEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomContentLoadedEventStart seconds (s) The time, in seconds, from the start of the interaction to the domContentLoadedEventStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomInteractive seconds (s) The time, in seconds, from the start of the interaction to the domInteractive, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomLoading seconds (s) The time, in seconds, from the start of the interaction to the domLoading, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomainLookupEnd seconds (s) The time, in seconds, from the start of the interaction to the domainLookupEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomainLookupStart seconds (s) The time, in seconds, from the start of the interaction to the domainLookupStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToFetchStart seconds (s) The time, in seconds, from the start of the interaction to the fetchStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToLastCallbackEnd seconds (s) The duration, in seconds, from the start of the request (timestamp) to the end of the last callback. This is not just an additive function; the callback time can overlap with the wait time. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. AjaxRequest BrowserInteraction BrowserTiming timeToLoadEventEnd seconds (s) The time, in seconds, from the start of the interaction to the loadEventEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToLoadEventStart seconds (s) The time, in seconds, from the start of the interaction to the loadEventStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information, see our documentation about instrumentation for the Navigation Timing API. BrowserInteraction timeToRedirectEnd seconds (s) The time, in seconds, from the start of the interaction to the redirectEnd, as defined by the Navigation Timing API. This attribute exists only for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToRedirectStart seconds (s) The time, in seconds, from the start of the interaction to the redirectStart, as defined by the Navigation Timing API. This attribute exists only for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToRequestStart seconds (s) The time, in seconds, from the start of the interaction to the requestStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToResponseEnd seconds (s) The time, in seconds, from the start of the interaction to the responseEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToResponseStart seconds (s) The time, in seconds, from the start of the interaction to the responseStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToSecureConnectionStart seconds (s) The time, in seconds, from the start of the interaction to the secureConnectionStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToUnloadEventEnd seconds (s) The time, in seconds, from the start of the interaction to the unloadEventEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToUnloadEventStart seconds (s) The time, in seconds, from the start of the interaction to the unloadEventStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timestamp The time (date, hour, minute, second) at which the interaction occurred. AjaxRequest BrowserInteraction BrowserTiming PageAction PageView PageViewTiming Span trigger The cause of the route change or page load. The default values are click, submit, popstate, or initial page load. For a custom event created with the API, the default value for trigger will be api. This value can also be set via the API. BrowserInteraction userAgentName The browserâ€™s name, such as Chrome and Firefox, obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentOS The browserâ€™s reported operating system, such as Windows or Linux, that it is running on. This is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentVersion The browserâ€™s reported software version, which is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming BrowserTiming Data source : Browser agent BrowserTiming is a custom event that captures SPA timing data for browser interactions started using the custom createTracer SPA API method. BrowserTiming contains many of the same attributes used by other events, especially AjaxRequest. Attribute name Definition Data types appId ID The ID of your application, as recorded by New Relic. AjaxRequest BrowserInteraction BrowserTiming PageAction PageView PageViewTiming appName The name of the application that handled the request as shown in New Relic Browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnLatitude The latitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's latitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnLongitude The longitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's longitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnOrganization The organization that owns the Autonomous System Number. Often an ISP, sometimes a private company or institution. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming browserInteractionId ID A unique value generated for each browser interaction captured by the New Relic agent. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError browserInteractionName The name of the interaction. This is either the targetGroupedUrl or the custom name set via the API. AjaxRequest BrowserInteraction BrowserTiming browserTimingName The name of the event. This is taken from the name argument of createTracer. BrowserTiming city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileSession PageAction PageView PageViewTiming countryCode The country from which the browser initiated the page load. For a list of country codes, see ISO 3166-1 alpha-2. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming deviceType The type of device that loaded the page: mobile, tablet, or desktop. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageView eventId ID A value that you can link to multiple BrowserInteraction events so you can view the interactions that occurred surrounding a specific event. For example, you can see the browser interactions that occurred prior to a JS error. AjaxRequest BrowserInteraction BrowserTiming groupedPageURL The grouped URL of the view that made the AJAX request. For example: myapp.com/acct/*/dash. AjaxRequest BrowserTiming jsDuration seconds (s) The total duration, in seconds, spent on JavaScript execution. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. This attribute doesn't exist for initial page load events. AjaxRequest BrowserInteraction BrowserTiming pageUrl The URL of the page that was loaded for the PageView. For example: http://www.newrelic.com. This URL does not include query parameters. AjaxRequest BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span parentEventId ID A unique value generated for each interaction with the page. You can use this value to group interactions together. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError regionCode The specific administrative division within a country where the PageView event occurred. In the United States, regions correspond to state codes, such as WA or NY. Outside the United States, a country's regions correspond to numerical codes. In the United States, regions correspond to state codes ; for example, WA or NY. Outside the United States, a country's regions correspond to numerical codes . AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming session A unique identifier for a single session. The session cookie expires when the user closes the browser (for example, they fully exit Chrome.) A new session identifier will be assigned when the user opens up a new instance of the browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span timeSinceBrowserInteractionStart seconds (s) The time in seconds between the start of the BrowserInteraction and the start of the request. AjaxRequest BrowserTiming timeToLastCallbackEnd seconds (s) The duration, in seconds, from the start of the request (timestamp) to the end of the last callback. This is not just an additive function; the callback time can overlap with the wait time. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. AjaxRequest BrowserInteraction BrowserTiming timeToSettle seconds (s) The time, in seconds, from the start of the request to when all resulting callbacks (including callbacks of subsequent AJAX requests) are complete. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. AjaxRequest BrowserTiming timeToTracedCallbackStart seconds (s) The time in seconds from the start of the custom tracer until the start of the traced callback. This attribute is unique to the BrowserTiming event. BrowserTiming timestamp The time (date, hour, minute, second) at which the interaction occurred. AjaxRequest BrowserInteraction BrowserTiming PageAction PageView PageViewTiming Span tracedCallbackDuration seconds (s) The duration in seconds of the traced callback. This attribute is unique to the BrowserTiming event. BrowserTiming userAgentName The browserâ€™s name, such as Chrome and Firefox, obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentOS The browserâ€™s reported operating system, such as Windows or Linux, that it is running on. This is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentVersion The browserâ€™s reported software version, which is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming ContainerSample Data source : Infrastructure This event is reported by the New Relic Infrastructure agent. It collects data from all the Docker containers on the host (which may or may not be running). It includes the container's ID, name, image, image name, and metrics about CPU, memory and networking. We take a snapshot of this data every 15 seconds for each container and package it into this event, which is then sent to New Relic. This data appears on the Containers UI page. Attribute name Definition Data types StorageDataAvailableBytes bytes (B) Data space available in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageDataTotalBytes bytes (B) Total Data space in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageDataUsagePercent percentage (%) Percent of Data space used in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageDataUsedBytes bytes (B) Data space used by the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageMetadataAvailableBytes bytes (B) Metadata space available in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageMetadataTotalBytes bytes (B) Total Metadata space in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageMetadataUsagePercent percentage (%) Percent of Metadata space used in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageMetadataUsedBytes bytes (B) Metadata space used by the Storage Driver. Only Device Mapper driver is supported. ContainerSample commandLine The command line used in the container. ContainerSample containerId ID The unique Docker container ID. ContainerSample cpuKernelPercent percentage (%) CPU time percentage used in kernel space. ContainerSample cpuLimitCores count Number of cores available for the container. ContainerSample cpuPercent percentage (%) CPU usage percentage used. ContainerSample cpuShares count Number of CPU shares assigned to the container. ContainerSample cpuThrottlePeriods count Total number of periods throttled. ContainerSample cpuThrottleTimeMs milliseconds (ms) Total throttling time in milliseconds. ContainerSample cpuUsedCores percentage (%) CPU usage per core. ContainerSample cpuUsedCoresPercent percentage (%) CPU usage percentage per core. ContainerSample cpuUserPercent percentage (%) CPU time percentage used in user space. ContainerSample criticalViolationCount count The number of times that alert conditions violated critical thresholds, causing critical violations and opening incidents. If this attribute does not exist on the sample, it has zero violations. ContainerSample NetworkSample ProcessSample StorageSample SystemSample image ID The Docker image ID for the image the container is based on. ContainerSample imageName The Docker image name for the container. ContainerSample label_KEY Docker labels associated with this container (where KEY represents a custom label's key value). ContainerSample memoryCacheBytes count The amount of memory used by the container that can be associated precisely with a block on a block device. ContainerSample memoryKernelUsageBytes bytes (B) The amount of current kernel memory allocation. ContainerSample memoryResidentSizeBytes bytes (B) The amount of memory that doesn't correspond to anything on disk: stacks, heaps, and anonymous memory maps. ContainerSample memorySizeLimitBytes bytes (B) The total amount of memory the container is allowed to use. ContainerSample memorySoftLimitBytes bytes (B) The soft limit of memory usage equivalent to the memory reservation of the container. ContainerSample memorySwapLimitBytes bytes (B) The total amount of memory the container is using, including swap. ContainerSample memorySwapLimitUsagePercent percentage (%) This metric is calculated as the percentage of memorySwapUsageBytes over memorySwapLimitBytes, if the limit exists. ContainerSample memorySwapOnlyUsageBytes bytes (B) The amount of swap memory the container is using. This memory doesn't include non-swap memory. ContainerSample memorySwapUsageBytes bytes (B) The amount of memory swap the container is using, including swap. ContainerSample memoryUsageBytes bytes (B) This metric doesn't account for swap usage. ContainerSample memoryUsageLimitPercent percentage (%) This metric is calculated as the memoryUsageBytes percentage over memorySizeLimitBytes, if the limit exists. ContainerSample name The Docker container name. ContainerSample networkRxBytes bytes (B) Total number of received bytes. ContainerSample networkRxBytesPerSecond rate Number of received bytes per second. ContainerSample networkRxDropped count Total number of received packets dropped. ContainerSample networkRxDroppedPerSecond rate Number of received packets dropped per second. ContainerSample networkRxError count Total number of received packets with error. ContainerSample networkRxErrorsPerSecond rate Number of received packets with error per second. ContainerSample networkRxPackets count Total number of received packets. ContainerSample networkRxPacketsPerSecond rate Number of received packets with error per second. ContainerSample networkTxBytesPerSecond rate Number of transmitted bytes per second. ContainerSample networkTxDropped count Total number of transmitted packets dropped. ContainerSample networkTxDroppedPerSecond rate Number of transmitted packets dropped per second. ContainerSample networkTxErrors count Total number of transmitted packets with error. ContainerSample networkTxErrorsPerSecond rate Number of transmitted packets with error per second. ContainerSample networkTxPackets count Total number of transmitted packets. ContainerSample networkTxPacketsPerSecond rate Number of transmitted packets per second. ContainerSample networksTxBytes count Total number of bytes transmitted. ContainerSample restartCount count The number of times the container was restarted. ContainerSample state It can be: created, restarting, running, removing, paused, exited, or dead. ContainerSample status Holds the current container state. ContainerSample warningViolationCount count The number of times that alert conditions violated warning thresholds, causing warning violations. ContainerSample NetworkSample ProcessSample StorageSample SystemSample DistributedTraceSummary Data source : Distributed Tracing This event contains summary data about a distributed trace and provides an aggregated view of distributed tracing data. DistributedTraceSummary events are generated by New Relic and are triggered by distributed tracing data from agents or the Trace API. Attribute name Definition Data types accountIds A comma delimited list of newrelic accountIds that took part in this trace. DistributedTraceSummary backend.duration.ms milliseconds (ms) The total elapsed time in milliseconds of all backend services in this trace. DistributedTraceSummary backend.timestamp milliseconds (ms) The timestamp of the first span in this trace from a backend entity. In distributed tracing, any events that are not from client-side applications contributed to the backend duration. DistributedTraceSummary duration.ms The duration of the entire distributed trace, including both backend and client-side entities. the earliest span to the latest. DistributedTraceSummary entityCount count The number of unique entities that took part in this trace. DistributedTraceSummary entityGuids A comma delimited list of entity GUIDs for entities that participated in this trace. These GUIDs are assigned by New Relic for the New Relic-monitored entity (host, application, etc.). Each GUID is stored as a Base64 encoded value. DistributedTraceSummary errorCount count The number of events in this distributed trace that were identified as errors. DistributedTraceSummary newRelic.traceFilter.type The name of the trace filter used by the Infinite Tracing trace observer to select this trace. DistributedTraceSummary Span root.entity.accountId The New Relic account ID that the root entity of this trace reports data to. DistributedTraceSummary root.entity.guid The entity GUID associated with the root entity of this trace. DistributedTraceSummary root.entity.name The name of the root entity of this trace. DistributedTraceSummary root.span.duration.ms milliseconds (ms) The elapsed time in milliseconds of the root span of this trace. The root of a distributed trace is the first span, and will have a null value for parent.id. DistributedTraceSummary root.span.id The unique identifier of the root span of this trace. The root of a distributed trace is the first span, and it has a null value for parent.id. DistributedTraceSummary root.span.name The name of the root span of this trace. DistributedTraceSummary root.span.timestamp milliseconds (ms) The timestamp of the root span of this trace. The root of a distributed trace is the first span, and will have a null value for parent.id. DistributedTraceSummary spanCount count The number of events in this distributed trace. Events in a distributed trace can have several event types, including Span, Transaction, and TransactionError. DistributedTraceSummary timestamp milliseconds (ms) The timestamp of the root span in this distributed trace. DistributedTraceSummary trace.id ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. DistributedTraceSummary MobileRequest MobileRequestError Span Transaction TransactionError InfrastructureEvent Data sources : InfrastructureCloudTrail InfrastructureEvent describes changes (deltas) that occur in a system's live state. When an inventory or system state is added, removed, or changed, Infrastructure will produce an InfrastructureEvent that logs that activity. Attribute name Definition Data types category A New Relic category used to organize events in the UI. For example: automation, notification, and service. InfrastructureEvent changeType A simple classification of the type of change made to the entity: added, modified, or removed. InfrastructureEvent changedPath The fully specified name of the item that changed. This is constructed by taking the source and adding one or more additional path elements that uniquely identify the item that changed. InfrastructureEvent deltaId Delta refers to a recorded change in the system. The deltaId is a number used by New Relic to organize incoming inventory change data. InfrastructureEvent eventId The unique ID of the event, generated by New Relic. InfrastructureEvent format The type of infrastructure event. Each format type includes attributes that may be used to render the event in the UI. InfrastructureEvent newStatus The new agent status: disconnected or connected. InfrastructureEvent newValue If a change is made to the entity, this attribute contains the new value of the inventory that was changed. This will have no value if no change has been made. The value will display approximately 4K bytes of data. InfrastructureEvent oldValue If a change is made to the entity, this attribute contains the old value of the inventory that was changed. This will be blank if no change has been made. InfrastructureEvent provider For integrations that use generic event types (like the DatastoreSample event), the provider value specifies the source of the data (the service, or a sub-category of data from that service). Some Insights events are generic and are used by several integrations. For example, the DatastoreSample event is used by several integrations, including the AWS DynamoDB integration and the AWS RDS integration. In these cases, the provider attribute value represents the source of that attribute. This will usually be the service that data comes from or, for integrations that use several provider values, a certain sub-category of data from that service. When a provider value is present for a generic event, that event will have additional integration-specific attributes attached to it. Hereâ€™s an example of an Insights NRQL query that returns the attributes present for a DatastoreSample event reported by the AWS RDS integration: SELECT * from DatastoreSample where provider = 'RdsDbCluster' InfrastructureEvent source The fully specified origin of this inventory item. This is typically in the form category/plugin, where plugin is the generic word used for the tool that gathered this data. InfrastructureEvent summary A summary of the change that happened. Uses a human-friendly string, such as Agent disconnected. InfrastructureEvent violationUpdateType The type of change to the violation: For example: open or closed. InfrastructureEvent JavaScriptError Data source : Browser agent As JavaScript errors are triggered, we capture details as events. The JavaScriptError event contains information to help you segment errors to understand how they impact performance. Attribute name Definition Data types appId ID The identification number for the reporting browser agent. JavaScriptError appName The name of the application that handled the request as shown in New Relic Browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnLatitude The latitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's latitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnLongitude The longitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's longitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnOrganization The organization that owns the Autonomous System Number. Often an ISP, sometimes a private company or institution. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming browserInteractionId ID A unique value generated for each browser interaction captured by the New Relic agent. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError browserStackHash ID An unique identifier generated for a stack trace. The browserStackHash for a stack trace is different across different browsers. An identical stack trace will generate the same identifier. JavaScriptError city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileSession PageAction PageView PageViewTiming countryCode The country from which the browser initiated the page load. For a list of country codes, see ISO 3166-1 alpha-2. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming deviceType The type of device that loaded the page: mobile, tablet, or desktop. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageView domain The domain portion of the request URL. BrowserInteraction JavaScriptError PageView PageViewTiming entityGuid The unique identifier of the monitor referenced in New Relic One. JavaScriptError SyntheticCheck SyntheticRequest errorClass The error type of the JavaScript Error object. Examples: ReferenceError, SyntaxError, and UncaughtException. JavaScriptError errorMessage The error message that was delivered. JavaScriptError firstErrorInSession A value to indicate whether or not this was the first JS error in the session. Example: true. JavaScriptError monitorAccountId The Synthetics account from which you are running the monitor. BrowserInteraction JavaScriptError monitorId ID A unique number identifying a particular monitor. BrowserInteraction JavaScriptError SyntheticCheck monitorJobId ID The ID of a single Synthetics monitor run, which began at a specific time and originated from a specific location. BrowserInteraction JavaScriptError pageUrl The URL of the page that was loaded for the PageView. For example: http://www.newrelic.com. This URL does not include query parameters. AjaxRequest BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span parentEventId ID A unique value generated for each interaction with the page. You can use this value to group interactions together. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError regionCode The specific administrative division within a country where the PageView event occurred. In the United States, regions correspond to state codes, such as WA or NY. Outside the United States, a country's regions correspond to numerical codes. In the United States, regions correspond to state codes ; for example, WA or NY. Outside the United States, a country's regions correspond to numerical codes . AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming releaseIds ID The releases in which the app was updated. Example: {\\\"jQuery\\\":\\\"v3.1.1\\\",\\\"multiverse\\\":\\\"96e9ac7\\\"}. JavaScriptError requestUri The URI of the requested resource. JavaScriptError session A unique identifier for a single session. The session cookie expires when the user closes the browser (for example, they fully exit Chrome.) A new session identifier will be assigned when the user opens up a new instance of the browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span stackHash ID A unique identifier generated by the Browser agent for a stack trace. The stackHash for a stack trace is the same across different browsers. An identical stack trace will generate the same identifier. JavaScriptError stackTrace A collection of the active stack frames when the error occurred. JavaScriptError stackTraceGzip A compressed version of the stackTrace attribute. JavaScriptError timestamp The time that the error occurred, in Unix time. JavaScriptError transactionName The full metric name of the transaction in which the error occurred, or Unknown if the error occurs outside of a transaction. JavaScriptError userAgentName The browserâ€™s name, such as Chrome and Firefox, obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentOS The browserâ€™s reported operating system, such as Windows or Linux, that it is running on. This is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentVersion The browserâ€™s reported software version, which is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming Metric Data source : Metrics Represents a metric data point (e.g., a measurement over a range of time, or a sample at a specific point in time) with multiple attributes attached, which allow for in-depth analysis and querying. This metric data comes from our Metric API, our Telemetry SDKs, and some of our open-source exporters/integrations. Attribute name Definition Data types endTimestamp milliseconds (ms) The end of the time range associated with the metric, in Unix time, in milliseconds. This is calculated by adding the metric interval to the timestamp of the metric (timestamp + interval.ms). Metric interval.ms milliseconds (ms) The length of the time window. Metric metricName Name of the metric. Metric newrelic.source The source of this data. For example: metricAPI. Metric timestamp milliseconds (ms) The start time for the metric, in Unix time. Metric Mobile Data source : Mobile A Mobile event is created when a crash occurs, when an interaction ends or has run for 1 second, or if a session completes after the app is closed, backgrounded, or has run for 10 minutes. Mobile events were once the only event type and were generated for every event, but now there are several specialized event types. Recommendation: Upgrade to the most recent mobile monitoring agent version to take full advantage of the new event types. Attribute name Definition Data types category The type of data, either session or interaction. Mobile MobileSession interactionDuration For interaction category events only. This is the total time for the interaction to render on the device. In addition to render time, this usually includes all external calls associated with the interaction. Currently, this attribute is measured in seconds for Android devices and in milliseconds for iOS devices. Mobile name For interaction category events only. This is the label of the interaction associated with the event. It is by default assigned by New Relic. For example: ApplicationsListFragment or Display iOS_Example.MasterViewController. Mobile reportedTimestampMs For interaction category events only. The UTC based timestamp for when the event was sent to New Relic. This is different from the attribute â€˜timestampâ€™, which is when the event began. Mobile MobileCrash Data source : Mobile The MobileCrash event is created when an app crashes. MobileCrash includes attributes such as crash line number, class, and crash message. Attribute name Definition Data types appBuild Indicates the technical build number of the app binary. As a developer, you can use this attribute to identify specific builds of your app. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appId ID A unique identifier for a monitored app, based on the app token. For example: 35091. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appName The name of the monitored app. For example: My Mobile App - iOS. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appToken The mobile application license token. MobileCrash appVersion The version number of the monitored app. For example: 2.2.9. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersionId ID An identifier for the specific version of the app. For example: 1713477. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession architecture The processor architecture of the device. For example: armv7 or arm64. MobileCrash asnOwner The telecom owner of the ASN. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession bundleId ID The unique string used to identify the application. MobileCrash MobileSession carrier The network over which the app transferred data, such as Wi-Fi, Verizon, or Sprint. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession crashException The exception associated with the crash, if one is present. For example: java.lang.NullPointerException. MobileCrash crashFingerprint ID The New Relic-generated fingerprint used to uniquely identify the crash and other crashes identical to this one. MobileCrash crashLocationFile The file in which the crash occurred. MobileCrash crashMessage The message associated with the crash, if one is present. MobileCrash deviceManufacturer The manufacturer of the device, such as Motorola or HTC. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceModel The model number of the device, such as XT1039 or SM-G900F. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceName The device's name. MobileCrash deviceUuid ID A unique identifier assigned at the time of app installation by New Relic. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of uuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession diskAvailable bytes (B) Space available on the device, in bytes. MobileCrash interactionHistory The client interactions with the application that led to the crash. MobileCrash isFirstOccurrence A boolean value indicating whether or not this was the first occurrence of the crash. MobileCrash lastInteraction The last interaction before a crash or harvest event, if one is present. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession memUsageMb megabytes (MB) The total amount of memory, in MB, used by the application. Updated every 60 seconds. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession modelNumber The model of the device. This is the same as the session-level deviceModel attribute. MobileCrash networkStatus The type of network that the device was on at the time of crash, such as wifi or LTE. MobileCrash newRelicVersion The version number of the agent running on the application. For example: 4.232.0. Duplicate of newRelicAgentVersion. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession occurrenceId ID The ID for this instance of the crash. MobileCrash orientation The orientation of the device, such as landscape or portrait. MobileCrash osBuild For Android only. The specific build of the Android OS. MobileCrash MobileHandledException osMajorVersion The simplified version number of the app's host operating system, such as iOS 11, as compared to iOS 11.0.4. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osName The name of the app's host operating system, for example, iOS or Android. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osVersion The exact version number of the app's host operating system, such as iOS 11.0.4, as compared to iOS 11. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession parentProcess The parent process that launched the crashing process. MobileCrash parentProcessId ID The parent identification number (PID) of the parent process. MobileCrash platform The platform type of the mobile monitoring agent, such as native or Cordova. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession processId ID The PID of the previously running process on the device. MobileCrash processName The name of the previously running process. MobileCrash processPath The path to the binary. MobileCrash reportedTimestampMs The UTC timestamp for when the event was received by New Relic. (This is different from timestamp, which is when the MobileSession event began that crashed.) MobileCrash runTime For Android only. The Android Runtime version where the exception/crash was generated. MobileCrash MobileHandledException sessionCrashed A boolean value indicating whether or not that session crashed. MobileCrash MobileSession sessionId ID A unique identifier for a single user session. A new sessionId is created each time the app is brought into the foreground. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession symbolicated A boolean value indicating whether or not the crash was properly symbolicated. MobileCrash timeSinceLastInteraction milliseconds (ms) The time, in milliseconds, since the interaction before a crash event. MobileCrash userImageUuids ID The array of build UUIDs for applications and libraries. MobileCrash uuid ID A unique identifier assigned by New Relic for a specific app on a particular device. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of deviceUuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession MobileHandledException Data source : Mobile MobileHandledException is sent when an exception is caught and is used for non-fatal exceptions reported to New Relic using the recordHandledException API for Android or iOS. Attribute name Definition Data types appBuild Indicates the technical build number of the app binary. As a developer, you can use this attribute to identify specific builds of your app. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appId ID A unique identifier for a monitored app, based on the app token. For example: 35091. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appName The name of the monitored app. For example: My Mobile App - iOS. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersion The version number of the monitored app. For example: 2.2.9. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersionId ID An identifier for the specific version of the app. For example: 1713477. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnOwner The telecom owner of the ASN. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession carrier The network over which the app transferred data, such as Wi-Fi, Verizon, or Sprint. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileSession PageAction PageView PageViewTiming countryCode The country from which the device ran the application. For a list of country codes, see ISO 3166-1 alpha-2. MobileHandledException MobileRequest MobileRequestError MobileSession device The specific type of the device: iPhone 8, iPad Pro, etc. Duplicate of deviceType. MobileHandledException MobileRequest MobileRequestError MobileSession deviceManufacturer The manufacturer of the device, such as Motorola or HTC. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceModel The model number of the device, such as XT1039 or SM-G900F. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceType The specific type of device: iPhone 8, iPad Pro, etc. Duplicate of device. MobileHandledException MobileRequest MobileRequestError MobileSession deviceUuid ID A unique identifier assigned at the time of app installation by New Relic. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of uuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession exceptionAppBuildUuid ID The build uuid of the application binary in which the exception was caught. MobileHandledException exceptionCause The unsymbolicated, platform-specific cause of the exception. MobileHandledException exceptionLocation New Relic defined location of an exception. Contains a combination of exception file name, class, line number, and method. MobileHandledException exceptionLocationClass The class that generated the exception. Only present if symbolication succeeded. MobileHandledException exceptionLocationFile The class that generated the exception. Only present if symbolication succeeded. MobileHandledException exceptionLocationLibraryOffset For XCFramework agent only. The library offset of the library that generated the exception. Only present if symbolication succeeded. MobileHandledException exceptionLocationLine Comes from the exception: The line number where the exception was generated. Only present if symbolication succeeded. MobileHandledException exceptionLocationMethod The method that generated the exception. Only present if symbolication succeeded. MobileHandledException exceptionMessage The unsymbolicated message from the exception. It can be user-generated or a generic system message. For Android, this is the Throwable message. MobileHandledException exceptionName The unsymbolicated exception type. MobileHandledException fingerprint ID The New Relic-generated identifier used to group like exceptions. MobileHandledException handledExceptionUuid ID The unique ID of the exception event. MobileHandledException lastInteraction The last interaction before a crash or harvest event, if one is present. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession libraryName For XCFramework agent only. The library name where the exception was generated. MobileHandledException libraryStartAddr For XCFramework agent only. The library start address where the exception was generated. MobileHandledException memUsageMb megabytes (MB) The total amount of memory, in MB, used by the application. Updated every 60 seconds. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession newRelicVersion The version number of the agent running on the application. For example: 4.232.0. Duplicate of newRelicAgentVersion. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession occurrenceTimestamp Agent-reported epoch timestamp of the handled exception. MobileHandledException osBuild For Android only. The specific build of the Android OS. MobileCrash MobileHandledException osMajorVersion The simplified version number of the app's host operating system, such as iOS 11, as compared to iOS 11.0.4. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osName The name of the app's host operating system, for example, iOS or Android. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osVersion The exact version number of the app's host operating system, such as iOS 11.0.4, as compared to iOS 11. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession platform The platform type of the mobile monitoring agent, such as native or Cordova. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession regionCode The specific region within a country where the monitored app is located. In the United States, regions are states. The regionCode is based on IP address and may not always match your region. MobileHandledException MobileRequest MobileRequestError MobileSession runTime For Android only. The Android Runtime version where the exception/crash was generated. MobileCrash MobileHandledException sessionId ID A unique identifier for a single user session. A new sessionId is created each time the app is brought into the foreground. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession timestamp Epoch timestamp of the handled exception. This exception timestamp represents the time New Relic created the event, if it's older than two days or some other unexpected time. MobileHandledException uuid ID A unique identifier assigned by New Relic for a specific app on a particular device. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of deviceUuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession MobileRequest Data source : Mobile A MobileRequest event is created when an HTTP request successfully completes, resulting in a response code below 400. Attribute name Definition Data types appBuild Indicates the technical build number of the app binary. As a developer, you can use this attribute to identify specific builds of your app. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appId ID A unique identifier for a monitored app, based on the app token. For example: 35091. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appName The name of the monitored app. For example: My Mobile App - iOS. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersion The version number of the monitored app. For example: 2.2.9. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersionId ID An identifier for the specific version of the app. For example: 1713477. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnOwner The telecom owner of the ASN. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession bytesReceived bytes (B) Optional: If the application received a response from the requestUrl, the size of that response in bytes. MobileRequest MobileRequestError bytesSent bytes (B) Optional: If the application sent a request to the requestUrl, the size of that request in bytes. MobileRequest MobileRequestError carrier The network over which the app transferred data, such as Wi-Fi, Verizon, or Sprint. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession connectionType The type of connection which the device was using, such as 2G or 3G. MobileRequest MobileRequestError countryCode The country from which the device ran the application. For a list of country codes, see ISO 3166-1 alpha-2. MobileHandledException MobileRequest MobileRequestError MobileSession device The specific type of the device: iPhone 8, iPad Pro, etc. Duplicate of deviceType. MobileHandledException MobileRequest MobileRequestError MobileSession deviceGroup The category of the device, such as iPhone or Tablet. MobileRequest MobileRequestError MobileSession deviceManufacturer The manufacturer of the device, such as Motorola or HTC. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceModel The model number of the device, such as XT1039 or SM-G900F. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceSize The display size of the device: Small, normal, large, xlarge. MobileRequest MobileRequestError deviceType The specific type of device: iPhone 8, iPad Pro, etc. Duplicate of device. MobileHandledException MobileRequest MobileRequestError MobileSession deviceUuid ID A unique identifier assigned at the time of app installation by New Relic. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of uuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession duration seconds (s) Optional: The time to complete the request, measured in fractional seconds. MobileRequest MobileRequestError guid ID The unique identifier for the segment. This is equivalent to spanID in OpenTracing semantics. MobileRequest MobileRequestError Span lastInteraction The last interaction before a crash or harvest event, if one is present. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession memUsageMb megabytes (MB) The total amount of memory, in MB, used by the application. Updated every 60 seconds. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession newRelicVersion The version number of the agent running on the application. For example: 4.232.0. Duplicate of newRelicAgentVersion. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osMajorVersion The simplified version number of the app's host operating system, such as iOS 11, as compared to iOS 11.0.4. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osName The name of the app's host operating system, for example, iOS or Android. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osVersion The exact version number of the app's host operating system, such as iOS 11.0.4, as compared to iOS 11. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession platform The platform type of the mobile monitoring agent, such as native or Cordova. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession regionCode The specific region within a country where the monitored app is located. In the United States, regions are states. The regionCode is based on IP address and may not always match your region. MobileHandledException MobileRequest MobileRequestError MobileSession requestDomain The domain that the application attempted to access when the event occurred. MobileRequest MobileRequestError requestFingerprint ID The New Relic-generated identifier used to group like request events. MobileRequest requestMethod The REST method (GET, PUT, POST, etc.) that the application attempted when the event occurred. MobileRequest MobileRequestError requestPath The path that the application attempted to access when the event occurred. MobileRequest MobileRequestError requestUrl The URL that the application attempted to access when the event occurred. MobileRequest MobileRequestError requestUuid ID A unique identifer for the request event. MobileRequest MobileRequestError responseTime seconds (s) The time between the request and the response in fractional seconds. MobileRequest MobileRequestError sessionId ID A unique identifier for a single user session. A new sessionId is created each time the app is brought into the foreground. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession statusCode Optional: The HTTP status code for the HTTP event. MobileRequest MobileRequestError timestamp The UTC epoch time at which an event began. MobileRequest MobileRequestError MobileSession trace.id ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. DistributedTraceSummary MobileRequest MobileRequestError Span Transaction TransactionError traceId ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. AwsLambdaInvocationError AwsLambdaInvocation MobileRequest MobileRequestError Span uuid ID A unique identifier assigned by New Relic for a specific app on a particular device. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of deviceUuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession MobileRequestError Data source : Mobile A MobileRequestError is used for HTTP errors or network failures. HTTP errors are HTTP requests that have a status code greater than 400. A network failure is a HTTP request that results in no response. The event is sent when the HTTP request completes. Attribute name Definition Data types appBuild Indicates the technical build number of the app binary. As a developer, you can use this attribute to identify specific builds of your app. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appId ID A unique identifier for a monitored app, based on the app token. For example: 35091. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appName The name of the monitored app. For example: My Mobile App - iOS. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersion The version number of the monitored app. For example: 2.2.9. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersionId ID An identifier for the specific version of the app. For example: 1713477. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnOwner The telecom owner of the ASN. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession bytesReceived bytes (B) Optional: If the application received a response from the requestUrl, the size of that response in bytes. MobileRequest MobileRequestError bytesSent bytes (B) Optional: If the application sent a request to the requestUrl, the size of that request in bytes. MobileRequest MobileRequestError carrier The network over which the app transferred data, such as Wi-Fi, Verizon, or Sprint. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession connectionType The type of connection which the device was using, such as 2G or 3G. MobileRequest MobileRequestError countryCode The country from which the device ran the application. For a list of country codes, see ISO 3166-1 alpha-2. MobileHandledException MobileRequest MobileRequestError MobileSession device The specific type of the device: iPhone 8, iPad Pro, etc. Duplicate of deviceType. MobileHandledException MobileRequest MobileRequestError MobileSession deviceGroup The category of the device, such as iPhone or Tablet. MobileRequest MobileRequestError MobileSession deviceManufacturer The manufacturer of the device, such as Motorola or HTC. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceModel The model number of the device, such as XT1039 or SM-G900F. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceSize The display size of the device: Small, normal, large, xlarge. MobileRequest MobileRequestError deviceType The specific type of device: iPhone 8, iPad Pro, etc. Duplicate of device. MobileHandledException MobileRequest MobileRequestError MobileSession deviceUuid ID A unique identifier assigned at the time of app installation by New Relic. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of uuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession duration seconds (s) Optional: The time to complete the request, measured in fractional seconds. MobileRequest MobileRequestError errorType Either HTTPError or NetworkFailure, depending on whether the error is a result of a failed request to a host or a failure on the cellular network. MobileRequestError guid ID The unique identifier for the segment. This is equivalent to spanID in OpenTracing semantics. MobileRequest MobileRequestError Span lastInteraction The last interaction before a crash or harvest event, if one is present. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession memUsageMb megabytes (MB) The total amount of memory, in MB, used by the application. Updated every 60 seconds. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession networkError The error message associated with the iOS NSURL Error code. See networkErrorCode for more information. MobileRequestError networkErrorCode If the error is a network error, this is the iOS network error code. For Android applications, this is the mapped value. MobileRequestError newRelicVersion The version number of the agent running on the application. For example: 4.232.0. Duplicate of newRelicAgentVersion. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osMajorVersion The simplified version number of the app's host operating system, such as iOS 11, as compared to iOS 11.0.4. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osName The name of the app's host operating system, for example, iOS or Android. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osVersion The exact version number of the app's host operating system, such as iOS 11.0.4, as compared to iOS 11. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession platform The platform type of the mobile monitoring agent, such as native or Cordova. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession regionCode The specific region within a country where the monitored app is located. In the United States, regions are states. The regionCode is based on IP address and may not always match your region. MobileHandledException MobileRequest MobileRequestError MobileSession requestDomain The domain that the application attempted to access when the event occurred. MobileRequest MobileRequestError requestErrorFingerprint ID The New Relic-generated identifier used to group like request error events. MobileRequestError requestMethod The REST method (GET, PUT, POST, etc.) that the application attempted when the event occurred. MobileRequest MobileRequestError requestPath The path that the application attempted to access when the event occurred. MobileRequest MobileRequestError requestUrl The URL that the application attempted to access when the event occurred. MobileRequest MobileRequestError requestUuid ID A unique identifer for the request event. MobileRequest MobileRequestError responseBody Optional: The response that is sent from the requestDomain for the HTTP error, up to 4096 bytes. MobileRequestError responseTime seconds (s) The time between the request and the response in fractional seconds. MobileRequest MobileRequestError sessionId ID A unique identifier for a single user session. A new sessionId is created each time the app is brought into the foreground. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession statusCode Optional: The HTTP status code for the HTTP event. MobileRequest MobileRequestError timestamp The UTC epoch time at which an event began. MobileRequest MobileRequestError MobileSession trace.id ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. DistributedTraceSummary MobileRequest MobileRequestError Span Transaction TransactionError traceId ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. AwsLambdaInvocationError AwsLambdaInvocation MobileRequest MobileRequestError Span uuid ID A unique identifier assigned by New Relic for a specific app on a particular device. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of deviceUuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession MobileSession Data source : Mobile A MobileSession event is sent when an app is closed, backgrounded, or when 10 minutes of active use has elapsed. This is the source of the general session data used by the other mobile monitoring events. MobileSession captures attributes such as device type, device OS, and geographical information. Attribute name Definition Data types appBuild Indicates the technical build number of the app binary. As a developer, you can use this attribute to identify specific builds of your app. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appId ID A unique identifier for a monitored app, based on the app token. For example: 35091. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appName The name of the monitored app. For example: My Mobile App - iOS. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersion The version number of the monitored app. For example: 2.2.9. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersionId ID An identifier for the specific version of the app. For example: 1713477. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnOwner The telecom owner of the ASN. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession bundleId ID The unique string used to identify the application. MobileCrash MobileSession carrier The network over which the app transferred data, such as Wi-Fi, Verizon, or Sprint. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession category The type of data, either session or interaction. Mobile MobileSession city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileSession PageAction PageView PageViewTiming countryCode The country from which the device ran the application. For a list of country codes, see ISO 3166-1 alpha-2. MobileHandledException MobileRequest MobileRequestError MobileSession device The specific type of the device: iPhone 8, iPad Pro, etc. Duplicate of deviceType. MobileHandledException MobileRequest MobileRequestError MobileSession deviceGroup The category of the device, such as iPhone or Tablet. MobileRequest MobileRequestError MobileSession deviceManufacturer The manufacturer of the device, such as Motorola or HTC. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceModel The model number of the device, such as XT1039 or SM-G900F. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceType The specific type of device: iPhone 8, iPad Pro, etc. Duplicate of device. MobileHandledException MobileRequest MobileRequestError MobileSession deviceUuid ID A unique identifier assigned at the time of app installation by New Relic. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of uuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession install Indicates true only if the current session is the first session after app install. MobileSession lastInteraction The last interaction before a crash or harvest event, if one is present. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession memUsageMb megabytes (MB) The total amount of memory, in MB, used by the application. Updated every 60 seconds. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession newRelicAgent The New Relic agent running on the application. For example: the iOSAgent or the androidAgent. MobileSession newRelicVersion The version number of the agent running on the application. For example: 4.232.0. Duplicate of newRelicAgentVersion. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osMajorVersion The simplified version number of the app's host operating system, such as iOS 11, as compared to iOS 11.0.4. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osName The name of the app's host operating system, for example, iOS or Android. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osVersion The exact version number of the app's host operating system, such as iOS 11.0.4, as compared to iOS 11. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession platform The platform type of the mobile monitoring agent, such as native or Cordova. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession regionCode The specific region within a country where the monitored app is located. In the United States, regions are states. The regionCode is based on IP address and may not always match your region. MobileHandledException MobileRequest MobileRequestError MobileSession sessionCrashed A boolean value indicating whether or not that session crashed. MobileCrash MobileSession sessionDuration seconds (s) The length of time for which the user used the application in seconds. If the session crashes, sessionDuration is not captured (although other events and attributes are still recorded). For sessions longer than 10 minutes, events in the Interaction and Custom event categories are sent to Insights while the session is ongoing, and therefore do not have sessionDuration attributes. Events recorded near the end of the session will include the duration, as will the Session event category. MobileSession sessionId ID A unique identifier for a single user session. A new sessionId is created each time the app is brought into the foreground. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession timeSinceLoad seconds (s) The time, in seconds, from the beginning of the mobile session to the time the event occurred. MobileSession timestamp The UTC epoch time at which an event began. MobileRequest MobileRequestError MobileSession upgradeFrom Indictates previous version number only if this is the first launch after app upgrade. MobileSession uuid ID A unique identifier assigned by New Relic for a specific app on a particular device. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of deviceUuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession NetworkSample Data source : Infrastructure NetworkSample event captures the descriptive and state information for each network device associated with a server. It includes the device's interface and address information, as well as current usage data. New Relic samples this data every 10 seconds for each attached network interface and packages it into a NetworkSample event, then sends the raw data to New Relic's collectors every 60 seconds. Attribute name Definition Data types agentName The name of the agent (Infrastructure). NetworkSample ProcessSample StorageSample SystemSample agentVersion The version of the New Relic Infrastructure agent. NetworkSample ProcessSample StorageSample SystemSample criticalViolationCount count The number of times that alert conditions violated critical thresholds, causing critical violations and opening incidents. If this attribute does not exist on the sample, it has zero violations. ContainerSample NetworkSample ProcessSample StorageSample SystemSample entityID ID New Relic's unique ID number for the entity that is reporting data. This is used by New Relic to distinguish between customers and their entities. NetworkSample ProcessSample StorageSample SystemSample fullHostname The fully qualified (DNS) hostname. NetworkSample ProcessSample StorageSample SystemSample hardwareAddress The unique hardware address of the interface. NetworkSample hostname The short version of the entity's name. NetworkSample ProcessSample StorageSample SystemSample interfaceName The interface name as reported by the operating system. NetworkSample ipV4Address The IP version 4 address. NetworkSample ipV6Address The IP version 6 address. NetworkSample kernelVersion The Linux kernel version, in string format. This attribute is available only for systems on a Linux platform. NetworkSample ProcessSample StorageSample SystemSample linuxDistribution The name of the Linux distribution the server is using. This attribute is available only for systems on a Linux platform. NetworkSample ProcessSample StorageSample SystemSample operatingSystem The operating system on which the agent is installed. NetworkSample ProcessSample StorageSample SystemSample receiveBytesPerSecond bytes (B) The number of bytes per second received during the sampling period. NetworkSample receiveDroppedPerSecond count The number of received packets per second dropped during the sampling period. NetworkSample receiveErrorsPerSecond count The number of receive errors per second on the interface during the sampling period. NetworkSample receivePacketsPerSecond count The number of packets per second (",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 317.91626,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>InfrastructureEvent</em>",
        "body": " or <em>iOS</em>. Attribute name Definition Data types appBuild Indicates the technical build number of the app binary. As a developer, you can use this attribute to identify specific builds of your app. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession app<em>Id</em> <em>ID</em> A unique"
      },
      "id": "603f53b164441f41894e8875"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/understand-data/event-data/events-reported-mobile-monitoring/",
      "sections": [
        "Events reported by mobile monitoring"
      ],
      "published_at": "2021-10-24T20:19:28Z",
      "title": "Events reported by mobile monitoring",
      "updated_at": "2021-10-23T17:24:35Z",
      "type": "docs",
      "external_id": "6173c71cf5e35866f9af6c04f16811ed0ce8a0c0",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring in New Relic reports event data that is displayed in some UI displays and is also available for querying and charting. Select an event name in the following table to see its attributes. Event Description Mobile A Mobile event is created when a crash occurs, when an interaction ends or has run for 1 second, or if a session completes after the app is closed, backgrounded, or has run for 10 minutes. Mobile events were once the only event type and were generated for every event, but now there are several specialized event types. MobileBreadcrumb There are no attributes listed for this event because it's a custom event; attributes will include the session attributes and any custom attributes added. MobileCrash The MobileCrash event is created when an app crashes. MobileCrash includes attributes such as crash line number, class, and crash message. MobileHandledException MobileHandledException is sent when an exception is caught and is used for non-fatal exceptions reported to New Relic using the recordHandledException API call for Android or iOS. The exceptions will be visible in queries of this event and on the Handled exceptions UI page, including stack traces. MobileRequest A MobileRequest event is created when an HTTP request successfully completes, resulting in a response code below 400. New Relic MobileRequest data is enabled by default for: Android version 5.15.2 or higher iOS version 6.0.0 or higher For earlier versions, starting with Android version 5.14.0 or iOS version 5.14.0, you must enable the feature. Upgrade to the latest Android or iOS version, or enable the NetworkRequests feature flag by using the Android or iOS configuration settings. MobileRequestError A MobileRequestError is used for HTTP errors or network failures. HTTP errors are HTTP requests that have a status code greater than 400. A network failure is an HTTP request that results in no response. The event is sent when the HTTP request completes. MobileSession A MobileSession event is sent when an app is closed, backgrounded, or when 10 minutes of active use has elapsed. This is the source of the general session data used by the other mobile monitoring events. MobileSession captures attributes such as device type, device OS, and geographical information. Custom events There is no attribute list for this event type because it is a custom event; attributes will include the session attributes and any custom attributes that you add. Related documentation: Report custom events Extend data retention See example NRQL queries",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 312.83978,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " MobileHandledException is sent when an exception is caught and is used for non-fatal exceptions reported to New Relic using the recordHandledException API call for Android or <em>iOS</em>. The exceptions will be visible in queries of this event and on the Handled exceptions UI page, including stack traces"
      },
      "id": "609f8faf196a675bef22b1ad"
    },
    {
      "sections": [
        "Report mobile monitoring custom events and attributes",
        "Create custom attributes and events",
        "Mobile event and attribute query examples",
        "Custom event example: Track purchases",
        "Tip",
        "Attribute example: Track a specific user",
        "Attribute example: Track a specific store id",
        "Custom attribute example: Track a specific action",
        "Important",
        "Size limits and restricted characters",
        "Set the time to send data",
        "Privacy considerations"
      ],
      "title": "Report mobile monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "65970eacbedb3360fd1c7394affc8cbc42f2ab0c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/report-mobile-monitoring-custom-events-attributes/",
      "published_at": "2021-10-24T14:59:18Z",
      "updated_at": "2021-10-23T21:59:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring in New Relic sends some default event data from your mobile app to New Relic, such as data about interactions, sessions, crashes, and request errors. You can also create your own custom attributes and events for more detailed querying and analysis. Create custom attributes and events You can create custom session-level attributes for default mobile monitoring events using the mobile agent SDKs. For example, to record a username attribute for some part of your iOS or Android app, you would use the setAttribute API (Android | iOS). These attributes are session-related information and are shared by multiple mobile event types. You can also create entirely new custom event types and assign them their own custom attributes, using the recordCustomEvent API (Android | iOS). To help with crash analysis, you can use the SDK to create MobileBreadcrumb and MobileHandledException events. These events are available for querying and also displayed in the crash event trail UI. For more on creating custom attributes and custom events, see: Android SDK API guide iOS SDK API guide NRQL query examples MobileRequestError examples MobileRequest examples Limits and restricted characters Mobile event and attribute query examples Here are some examples of using NRQL to query your mobile app events and attributes: Custom event example: Track purchases To track purchases in your app, use recordCustomEvent to create an event type (such as \"UserAction\") and associate attributes such as \"name\" (with value \"Purchase\"), price, quantity, and SKU. Tip For performance reasons, you should limit the total number of event types to maybe one or two. The recordCustomEvent parameter eventType is meant to be used for high-level categories. For example, you might create an event typeGestures, and then create many different custom event names under the Gesture event type. Create an event on iOS: BOOL purchaseRecorded = [NewRelic recordCustomEvent:@\"UserAction\" attributes:@{@\"name\": @\"Purchase\", @\"sku\": @\"12345LPD\", @\"quantity\": @1, @\"unitPrice\": @99.99, @\"total\": @99.99}]; Copy Create an event on Android: Map<String, Object> userActionAttributes = new HashMap<String, Object>(); userActionAttributes.put(\"name\", \"Purchase\"); userActionAttributes.put(\"sku\", \"12345LPD\"); userActionAttributes.put(\"quantity\", 1); userActionAttributes.put(\"unitPrice\", 99.99); userActionAttributes.put(\"total\", 99.99); boolean userActionRecorded = NewRelic.recordCustomEvent(\"UserAction\", userActionAttributes); Copy New Relic reports a custom event of type UserAction and name Purchase, which allows you to query all purchases made in your app in the last day: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Replace deprecated recordEvent method: As of Android agent version 5.12.0 and iOS agent version 5.12.0, use the recordCustomEvent method to create these custom events. If you have replaced the deprecated recordEvent method for your custom events, be sure to also replace its corresponding NRQL query with the new format. Look for queries used with recordEvent method, such as this: SELECT * from Mobile where category = 'Custom' and name = 'Purchase' since 1 day ago Copy Replace them with the query format used with recordCustomEvent: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Attribute example: Track a specific user You can create a custom attribute to track a custom user identifier across the session, and then query for all that user's interactions. To add an attribute for the userId, call the setUserId method: Set the userId on iOS: BOOL userIdWasSet = [NewRelic setUserId:@\"jsmith\"]; Copy Set the userId on Android: boolean userIdWasSet = NewRelic.setUserId(\"jsmith\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that username in the last day: SELECT * from Mobile WHERE userId = 'jsmith' since 1 day ago Copy Attribute example: Track a specific store id You can create a custom attribute to track a store id across the session, and then query for all that store's interactions. To add an attribute for the storeId, call the setAttribute method: Set the storeId on iOS: BOOL attributeSet = [NewRelic setAttribute:@\"storeId\" value:@\"NY0531\"]; Copy Set the storeId on Android: boolean attributeSet = NewRelic.setAttribute(\"storeId\", \"NY0531\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that storeId in the last day: SELECT * from Mobile WHERE storeId = 'NY0531' since 1 day ago Copy Custom attribute example: Track a specific action You can use custom attributes to track the number of times that a specific action occurs in your application. For example, you can track the number of times a button was clicked or the number of times a level was completed in a game. To track completing a game level, call incrementAttribute with no value specified. This creates an attribute with a default value of 1: Create a counter on iOS: BOOL levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Create a counter on Android: boolean levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Each subsequent call to incrementAttribute adds 1 to the attribute level: Increment a counter on iOS: levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Increment a counter on Android: levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Important Be sure to reset the value to 0 when starting over. To reset the level back to 1 or 0, call setAttribute: Reset a counter on iOS: levelReset = [NewRelic setAttribute:@\"level\" value:@1]; Copy Reset a counter on Android: levelReset = NewRelic.setAttribute(\"level\", 1); Copy When querying, use this level attribute to filter your data. For example, if you have a username and level attribute, use the max() function to find the highest level the user had reached: SELECT max(level) from Mobile where username = 'jsmith' Copy Size limits and restricted characters Limits for custom attributes added to default mobile events: Attributes: 128 maximum String attributes: 4 KB maximum length (empty string values are not accepted) Limits for custom events: Attributes: 254 maximum per event (number includes default session attributes) String attributes: 4 KB maximum length (empty string values are not accepted) Naming syntax and rules: See Rules for custom data. Set the time to send data By default, New Relic transmits event data in any of these situations: A session has been ongoing for 600 seconds. The app session ends by backgrounding. The app crashes. If the app crashes, New Relic gathers the attributes and events for that session and sends them to Insights. (On iOS, this happens the next time the app is launched). You can then use Insights to query and analyze the event and attribute data. To set the maximum time (in seconds) that the agent will store events in memory, use the following SDK calls: iOS method: + (void) setMaxEventBufferTime:(unsigned int)seconds; Copy Android method: public static void setMaxEventBufferTime(int maxBufferTimeInSec); Copy Privacy considerations If you want to collect personal data via custom attributes, please consult with your privacy or legal teams. Be sure to follow your organization's obligations for notices and consent regulations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 286.38953,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Attribute example: Track a specific store <em>id</em>",
        "tags": "<em>Insights</em>",
        "body": " = &#x27;Purchase&#x27; since 1 day ago Copy Attribute example: Track a specific user You can create a custom attribute to track a custom user identifier across the session, and then query for all that user&#x27;s interactions. To add an attribute for the user<em>Id</em>, call the setUser<em>Id</em> method: Set the user<em>Id</em> on <em>iOS</em>: BOOL"
      },
      "id": "609fa5cf28ccbc508d9832d3"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/configuration/ios-tvos-crash-reporting": [
    {
      "sections": [
        "Upload dSYM files",
        "Automatic script",
        "Identify missing dSYMs",
        "Upload dSYM files through the mobile monitoring UI",
        "Manually upload dSYM files",
        "Via Python script (agent versions 6.0.0 or higher)",
        "Via command line",
        "Troubleshooting",
        "Auto-upload failure",
        "Missing dSYMs"
      ],
      "title": "Upload dSYM files",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "3655f49cf0e1ae693de0f8ea45bf4e5e6437e399",
      "image": "https://docs.newrelic.com/static/5c859575f391fbb1eaa18243a8c97000/8c557/Screen-Shot-2014-09-23-at-11.30.35-AM_0.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/upload-dsyms-bitcode-apps/",
      "published_at": "2021-10-24T16:52:30Z",
      "updated_at": "2021-09-27T15:06:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your app's dSYM files are stored in Xcode's dSYM archive path folder. This is the folder where the iOS agent gets the dSYM files that are used to symbolicate your crash reports. New Relic provides a post-build script as part of the iOS agent's install process and the tvOS agent's install process. This script automatically uploads your app's dSYM files. Automatic script The script automatically uploads dSYM files only for release builds. Non-release builds must upload their files either manually or through the mobile monitoring UI. Bitcode-enabled apps have their dSYM files generated by Apple. You must download the dSYM files for Bitcode-enabled apps from Apple and upload them to New Relic. If you see unreadable machine code in the Crashes page, your dSYM files may not be uploaded correctly. In some cases, you may need to manually upload dSYM files. The automatic script uses Python 2. As of October 2019 with macOS 10.15 (Catalina), Python won't be installed by default. If you're using the automatic script (recommended), you may need to manually install Python 2. If you're using Homebrew, see Python on Homebrew. Identify missing dSYMs When a Bitcode-enabled app is uploaded to Apple for App Store review or ad-hoc distribution, dSYMs need to be manually downloaded from Apple and uploaded to New Relic to allow the mobile crash reports to be properly symbolicated. These dSYMs can be downloaded through the archives organizer in Xcode within several minutes of uploading the app. In this situation follow the procedures to find the archive and download dSYMs. If an app is missing a dSYM file, you'll see three indicators in the mobile monitoring UI: Banner notification: A banner warning appears on the Crash report page. The warning reads: We were unable to locate your dsym. Copy Upload prompt: From the Crash type summary page you will be automatically prompted to upload a dSYM file if it is missing. Machine code: The crash stack trace on the Crash report page displays machine code and not a human-readable error message. Upload dSYM files through the mobile monitoring UI You can easily upload your dSYM files directly from the New Relic One UI. The maximum file size is 600 MB. To upload your dSYM files: Go to one.newrelic.com and click Mobile. Then select your app from the list. View Crash analysis. Select a specific crash from the Crash types list. Click Upload dSYM. You can either drag and drop your dSYMs directly, or select the file form your computer. Manually upload dSYM files In some circumstances, New Relic's automatic upload of dSYM files may fail. If a dSYM upload is attempted and fails, it creates a build error with a detailed message. For example, if there's a network failure and the dSYM upload isn't completed, Xcode will report an error. For additional information about how New Relic handles dSYM uploads, see New Relic's Online Technical Community. If the automatic upload fails, you can manually upload your dSYM file. If you have multiple dSYM files, they can be within a single zip with a maximum file size of 600 MB. The YOUR_NEW_RELIC_APPLICATION_TOKEN value in the commands below is the same key used for +[NewRelic startWithApplicationToken:] (in Objective-C) or NewRelic.start(withApplicationToken:) (in Swift). To manually upload your dSYM files: Via Python script (agent versions 6.0.0 or higher) In iOS agent versions 6.0.0 or higher, the agent includes a Python script that automatically processes and uploads symbols. You can call this script from the command line: NewRelicAgent.framework/Resources/generateMap.py \"DSYM_ARCHIVE_PATH\" \"YOUR_NEW_RELIC_APPLICATION_TOKEN\" Copy Via command line To manually upload individual dSYM files from the command line: Zip up your dSYM file or files using the following command. Replace ~ /ZIPPED_DSYM_PATH with your new dSYM archive path and file name (for example, Users/my-name/desktop). Also replace ~ /dSYM_PATH with your existing dSYM file path. /usr/bin/zip --recurse-paths --quiet \"~/ZIPPED_DSYM_PATH\" \"~/dSYM_PATH\" Copy Upload the dSYM zip file using the following command: For US accounts: curl -F dsym=@\"~/DSYM_ZIP_PATH\" -H \"X-APP-LICENSE-KEY: YOUR_NEW_RELIC_APPLICATION_TOKEN\" https://mobile-symbol-upload.newrelic.com/symbol Copy For EU accounts: curl -F dsym=@\"~/DSYM_ZIP_PATH\" -H \"X-APP-LICENSE-KEY: YOUR_NEW_RELIC_APPLICATION_TOKEN\" https://mobile-symbol-upload.eu01.nr-data.net/symbol Copy Troubleshooting Auto-upload failure If a dSYM auto-upload failed, the Report Navigator may have a fully formed cURL command. You can use this cURL command to reattempt an upload. Depending on the error, you may also need to follow some of the dSYM manual upload steps. Here is an example of a successful dSYM upload in the Report Navigator: Example: A successful dSYM upload in the Report Navigator. Missing dSYMs If dSYM files are missing, you may need to check Xcode build settings to ensure the file is being generated. Frameworks which are built locally have separate build settings and may need to be updated as well. Build settings: Debug Information Format : Dwarf with dSYM File Deployment Postprocessing: Yes Strip Linked Product: Yes Strip Debug Symbols During Copy : Yes Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.31992,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Upload dSYM files through the <em>mobile</em> <em>monitoring</em> UI",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Your app&#x27;s dSYM files are stored in Xcode&#x27;s dSYM archive path folder. This is the folder where the <em>iOS</em> agent gets the dSYM files that are used to symbolicate your crash reports. <em>New</em> <em>Relic</em> provides a post-build script as part of the <em>iOS</em> agent&#x27;s install process and the tv<em>OS</em> agent&#x27;s install process"
      },
      "id": "60441960e7b9d24f705799ca"
    },
    {
      "sections": [
        "CocoaPods installation",
        "Install your iOS application",
        "Configure using Objective-C",
        "Important",
        "Configure using Swift",
        "Change the logging level (optional)"
      ],
      "title": "CocoaPods installation",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Installation"
      ],
      "external_id": "9a062745f628f66e34f865a47d58713f12e59ac9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/installation/cocoapods-installation/",
      "published_at": "2021-10-24T16:53:24Z",
      "updated_at": "2021-10-01T20:15:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "These procedures apply to iOS apps using Cocoapods. For other types, see iOS installation and configuration. Install your iOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. To install and configure your iOS application: Go to one.newrelic.com. If applicable: From the Mobile Apps list, select Add a new app. From the Get Started page, select iOS as the platform for mobile monitoring. Type a name for your mobile app, then select Continue. If your installation does not automatically include the prefix header, follow the steps to add the prefix header to your project. Continue with the steps to configure New Relic for mobile monitoring. Configure using Objective-C These procedures to configure your iOS app with CocoaPods and Objective-C also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy In your APP_NAME-Prefix.pch project file (generally found in the Supporting Files folder), include the New Relic header inside the #ifdef __OBJC__ #endif block: #import <NewRelic/NewRelic.h> Copy In your AppDelegate.m file, add this call as the first line of application:didFinishLaunchingWithOptions, replacing APP_TOKEN with your application token: [NewRelic startWithApplicationToken:@\"APP_TOKEN\"]; Copy Important The agent must be on the first line of didFinishLaunchingWithOptions and run on the main thread to ensure proper instrumentation. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Add a build script to your target's Build Phases. Ensure the new build script is the very last build script. Then paste the following, replacing APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"APP_TOKEN\" Copy Clean and build your app, then run it in the simulator or other device. Configure using Swift These procedures to configure your iOS app with CocoaPods and Swift also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy Create a bridging header: Select File > New > File > Objective-C File. Name the file Placeholder.m, then select Next. Select Create, and confirm Xcode's prompt to generate the bridging header. In your APP_NAME-Bridging-Header.h, add the New Relic header: #import \"NewRelic/NewRelic.h\" Copy In your AppDelegate.swift file, add this call as the first line of application:didFinishLaunchingWithOptions, replacing APP_TOKEN with your application token: NewRelic.start(withApplicationToken:\"APP_TOKEN\") Copy Important To ensure proper instrumentation, you must call the agent on the first line of didFinishLaunchingWithOptions(), and run the agent on the main thread. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Add a build script to your target's Build Phases. Ensure the new build script is the very last build script. Then paste the following, replacing APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"APP_TOKEN\" Copy Clean and build your app, then run it in the simulator or other device. Change the logging level (optional) Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add this method call before calling NewRelic.start(withApplicationToken): [NRLogger setLogLevels:NRLogLevelALL]; Copy For Swift apps: NRLogger.setLogLevels(NRLogLevelALL.rawValue) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 161.04845,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "CocoaPods <em>installation</em>",
        "sections": "<em>Install</em> your <em>iOS</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " <em>mobile</em> app you <em>monitor</em> in <em>New</em> <em>Relic</em>. To install and configure your <em>iOS</em> application: Go to one.newrelic.com. If applicable: From the <em>Mobile</em> Apps list, select Add a <em>new</em> app. From the Get Started page, select <em>iOS</em> as the platform for <em>mobile</em> <em>monitoring</em>. Type a name for your <em>mobile</em> app, then select Continue"
      },
      "id": "603ea15d64441fef3d4e8867"
    },
    {
      "sections": [
        "Retrieve dSYMs for Bitcode apps",
        "Identify missing dSYMs",
        "Download dSYM files using iTunes Connect",
        "Download dSYM files using Xcode's app archive",
        "Upload dSYMs"
      ],
      "title": "Retrieve dSYMs for Bitcode apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "34e375873e36095062eccef6d99f26be7562308f",
      "image": "https://docs.newrelic.com/static/041368cdc60d9252ad80c2c37321b805/ec3e2/screen-dsym2.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/retrieve-dsyms-bitcode-apps/",
      "published_at": "2021-10-24T16:51:42Z",
      "updated_at": "2021-07-09T19:35:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Bitcode is a feature that gives Apple the ability to re-compile iOS and tvOS applications for specific users' hardware. This provides a smaller download size for end users. For more about this process, see Apple's Bitcode and app thinning documentation. When Apple compiles an app, the dSYM files are also compiled. For New Relic to be able to symbolicate crashes of your Bitcode-enabled app, these dSYM files need to be downloaded from Apple and then uploaded to New Relic. Identify missing dSYMs When a Bitcode-enabled app is uploaded to Apple for App Store review or ad-hoc distribution, dSYMs need to be manually downloaded from Apple and uploaded to New Relic to allow the mobile crash reports to be properly symbolicated. These dSYMs can be downloaded through the archives organizer in Xcode within several minutes of uploading the app. In this situation follow the procedures to find the archive and download dSYMs. If an app is missing a dSYM file, you'll see three indicators in the mobile monitoring UI: Banner notification: A banner warning appears on the Crash report page. The warning reads: We were unable to locate your dsym. Copy Upload prompt: from the Crash type summary page you will be automatically prompted to upload a dSYM file if it is missing. Machine code: The crash stack trace on the Crash report page displays machine code and not a human-readable error message. Download dSYM files using iTunes Connect To download the dSYM files you need for your app: Log in to Apple iTunes Connect. Select My Apps > (selected app) > Activity. From the list of builds for your application, select the build number you need for the dSYM. Select Download dSYM. Then, to upload the resulting zip file directly to New Relic: Follow the instructions to manually upload dSYM, and skip step 1. Unpack one dSYM contained in this zip file to retrieve a build UUID that you can upload. (Follow the last step in the manual upload instructions.) Once New Relic receives the zip file, the build UUIDs for all other dSYMs contained in that zip file will be identified. Download dSYM files using Xcode's app archive Use the app version and build number to identify the applicable app archive in the Xcode Organizer and download the dSYMs. Using Xcode to download dSYMs: From the Archives tab, select the app and version/build, then select Download dSYMs. Open the Xcode Organizer: From the Xcode menu, select Window > Organizer > Archives > (select a mobile app). From Version, select the archive that matches the app version (listed first) and build number (following the app version in parentheses). Select Download dSYMs. The dSYMs will be downloaded from Apple if available and if the file names contain a series of letters and numbers. If the dSYM files are named after the the dependencies in your project, the download will not be successful. Upload dSYMs Once you have located the dSYMs, follow the instructions to upload a dSYM for each zipped dSYM.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 148.4336,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Identify</em> missing dSYMs",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Bitcode is a feature that gives Apple the ability to re-compile <em>iOS</em> and tv<em>OS</em> applications for specific users&#x27; hardware. This provides a smaller download size for end users. For more about this process, see Apple&#x27;s Bitcode and app thinning documentation. When Apple compiles an app, the dSYM files"
      },
      "id": "6044144228ccbc04a2303885"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/configuration/retrieve-dsyms-bitcode-apps": [
    {
      "sections": [
        "Upload dSYM files",
        "Automatic script",
        "Identify missing dSYMs",
        "Upload dSYM files through the mobile monitoring UI",
        "Manually upload dSYM files",
        "Via Python script (agent versions 6.0.0 or higher)",
        "Via command line",
        "Troubleshooting",
        "Auto-upload failure",
        "Missing dSYMs"
      ],
      "title": "Upload dSYM files",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "3655f49cf0e1ae693de0f8ea45bf4e5e6437e399",
      "image": "https://docs.newrelic.com/static/5c859575f391fbb1eaa18243a8c97000/8c557/Screen-Shot-2014-09-23-at-11.30.35-AM_0.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/upload-dsyms-bitcode-apps/",
      "published_at": "2021-10-24T16:52:30Z",
      "updated_at": "2021-09-27T15:06:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your app's dSYM files are stored in Xcode's dSYM archive path folder. This is the folder where the iOS agent gets the dSYM files that are used to symbolicate your crash reports. New Relic provides a post-build script as part of the iOS agent's install process and the tvOS agent's install process. This script automatically uploads your app's dSYM files. Automatic script The script automatically uploads dSYM files only for release builds. Non-release builds must upload their files either manually or through the mobile monitoring UI. Bitcode-enabled apps have their dSYM files generated by Apple. You must download the dSYM files for Bitcode-enabled apps from Apple and upload them to New Relic. If you see unreadable machine code in the Crashes page, your dSYM files may not be uploaded correctly. In some cases, you may need to manually upload dSYM files. The automatic script uses Python 2. As of October 2019 with macOS 10.15 (Catalina), Python won't be installed by default. If you're using the automatic script (recommended), you may need to manually install Python 2. If you're using Homebrew, see Python on Homebrew. Identify missing dSYMs When a Bitcode-enabled app is uploaded to Apple for App Store review or ad-hoc distribution, dSYMs need to be manually downloaded from Apple and uploaded to New Relic to allow the mobile crash reports to be properly symbolicated. These dSYMs can be downloaded through the archives organizer in Xcode within several minutes of uploading the app. In this situation follow the procedures to find the archive and download dSYMs. If an app is missing a dSYM file, you'll see three indicators in the mobile monitoring UI: Banner notification: A banner warning appears on the Crash report page. The warning reads: We were unable to locate your dsym. Copy Upload prompt: From the Crash type summary page you will be automatically prompted to upload a dSYM file if it is missing. Machine code: The crash stack trace on the Crash report page displays machine code and not a human-readable error message. Upload dSYM files through the mobile monitoring UI You can easily upload your dSYM files directly from the New Relic One UI. The maximum file size is 600 MB. To upload your dSYM files: Go to one.newrelic.com and click Mobile. Then select your app from the list. View Crash analysis. Select a specific crash from the Crash types list. Click Upload dSYM. You can either drag and drop your dSYMs directly, or select the file form your computer. Manually upload dSYM files In some circumstances, New Relic's automatic upload of dSYM files may fail. If a dSYM upload is attempted and fails, it creates a build error with a detailed message. For example, if there's a network failure and the dSYM upload isn't completed, Xcode will report an error. For additional information about how New Relic handles dSYM uploads, see New Relic's Online Technical Community. If the automatic upload fails, you can manually upload your dSYM file. If you have multiple dSYM files, they can be within a single zip with a maximum file size of 600 MB. The YOUR_NEW_RELIC_APPLICATION_TOKEN value in the commands below is the same key used for +[NewRelic startWithApplicationToken:] (in Objective-C) or NewRelic.start(withApplicationToken:) (in Swift). To manually upload your dSYM files: Via Python script (agent versions 6.0.0 or higher) In iOS agent versions 6.0.0 or higher, the agent includes a Python script that automatically processes and uploads symbols. You can call this script from the command line: NewRelicAgent.framework/Resources/generateMap.py \"DSYM_ARCHIVE_PATH\" \"YOUR_NEW_RELIC_APPLICATION_TOKEN\" Copy Via command line To manually upload individual dSYM files from the command line: Zip up your dSYM file or files using the following command. Replace ~ /ZIPPED_DSYM_PATH with your new dSYM archive path and file name (for example, Users/my-name/desktop). Also replace ~ /dSYM_PATH with your existing dSYM file path. /usr/bin/zip --recurse-paths --quiet \"~/ZIPPED_DSYM_PATH\" \"~/dSYM_PATH\" Copy Upload the dSYM zip file using the following command: For US accounts: curl -F dsym=@\"~/DSYM_ZIP_PATH\" -H \"X-APP-LICENSE-KEY: YOUR_NEW_RELIC_APPLICATION_TOKEN\" https://mobile-symbol-upload.newrelic.com/symbol Copy For EU accounts: curl -F dsym=@\"~/DSYM_ZIP_PATH\" -H \"X-APP-LICENSE-KEY: YOUR_NEW_RELIC_APPLICATION_TOKEN\" https://mobile-symbol-upload.eu01.nr-data.net/symbol Copy Troubleshooting Auto-upload failure If a dSYM auto-upload failed, the Report Navigator may have a fully formed cURL command. You can use this cURL command to reattempt an upload. Depending on the error, you may also need to follow some of the dSYM manual upload steps. Here is an example of a successful dSYM upload in the Report Navigator: Example: A successful dSYM upload in the Report Navigator. Missing dSYMs If dSYM files are missing, you may need to check Xcode build settings to ensure the file is being generated. Frameworks which are built locally have separate build settings and may need to be updated as well. Build settings: Debug Information Format : Dwarf with dSYM File Deployment Postprocessing: Yes Strip Linked Product: Yes Strip Debug Symbols During Copy : Yes Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.31989,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Upload dSYM files through the <em>mobile</em> <em>monitoring</em> UI",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Your app&#x27;s dSYM files are stored in Xcode&#x27;s dSYM archive path folder. This is the folder where the <em>iOS</em> agent gets the dSYM files that are used to symbolicate your crash reports. <em>New</em> <em>Relic</em> provides a post-build script as part of the <em>iOS</em> agent&#x27;s install process and the tv<em>OS</em> agent&#x27;s install process"
      },
      "id": "60441960e7b9d24f705799ca"
    },
    {
      "sections": [
        "CocoaPods installation",
        "Install your iOS application",
        "Configure using Objective-C",
        "Important",
        "Configure using Swift",
        "Change the logging level (optional)"
      ],
      "title": "CocoaPods installation",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Installation"
      ],
      "external_id": "9a062745f628f66e34f865a47d58713f12e59ac9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/installation/cocoapods-installation/",
      "published_at": "2021-10-24T16:53:24Z",
      "updated_at": "2021-10-01T20:15:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "These procedures apply to iOS apps using Cocoapods. For other types, see iOS installation and configuration. Install your iOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. To install and configure your iOS application: Go to one.newrelic.com. If applicable: From the Mobile Apps list, select Add a new app. From the Get Started page, select iOS as the platform for mobile monitoring. Type a name for your mobile app, then select Continue. If your installation does not automatically include the prefix header, follow the steps to add the prefix header to your project. Continue with the steps to configure New Relic for mobile monitoring. Configure using Objective-C These procedures to configure your iOS app with CocoaPods and Objective-C also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy In your APP_NAME-Prefix.pch project file (generally found in the Supporting Files folder), include the New Relic header inside the #ifdef __OBJC__ #endif block: #import <NewRelic/NewRelic.h> Copy In your AppDelegate.m file, add this call as the first line of application:didFinishLaunchingWithOptions, replacing APP_TOKEN with your application token: [NewRelic startWithApplicationToken:@\"APP_TOKEN\"]; Copy Important The agent must be on the first line of didFinishLaunchingWithOptions and run on the main thread to ensure proper instrumentation. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Add a build script to your target's Build Phases. Ensure the new build script is the very last build script. Then paste the following, replacing APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"APP_TOKEN\" Copy Clean and build your app, then run it in the simulator or other device. Configure using Swift These procedures to configure your iOS app with CocoaPods and Swift also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy Create a bridging header: Select File > New > File > Objective-C File. Name the file Placeholder.m, then select Next. Select Create, and confirm Xcode's prompt to generate the bridging header. In your APP_NAME-Bridging-Header.h, add the New Relic header: #import \"NewRelic/NewRelic.h\" Copy In your AppDelegate.swift file, add this call as the first line of application:didFinishLaunchingWithOptions, replacing APP_TOKEN with your application token: NewRelic.start(withApplicationToken:\"APP_TOKEN\") Copy Important To ensure proper instrumentation, you must call the agent on the first line of didFinishLaunchingWithOptions(), and run the agent on the main thread. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Add a build script to your target's Build Phases. Ensure the new build script is the very last build script. Then paste the following, replacing APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"APP_TOKEN\" Copy Clean and build your app, then run it in the simulator or other device. Change the logging level (optional) Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add this method call before calling NewRelic.start(withApplicationToken): [NRLogger setLogLevels:NRLogLevelALL]; Copy For Swift apps: NRLogger.setLogLevels(NRLogLevelALL.rawValue) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 161.04843,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "CocoaPods <em>installation</em>",
        "sections": "<em>Install</em> your <em>iOS</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " <em>mobile</em> app you <em>monitor</em> in <em>New</em> <em>Relic</em>. To install and configure your <em>iOS</em> application: Go to one.newrelic.com. If applicable: From the <em>Mobile</em> Apps list, select Add a <em>new</em> app. From the Get Started page, select <em>iOS</em> as the platform for <em>mobile</em> <em>monitoring</em>. Type a name for your <em>mobile</em> app, then select Continue"
      },
      "id": "603ea15d64441fef3d4e8867"
    },
    {
      "sections": [
        "iOS and tvOS crash reporting",
        "dSYM files",
        "Debug the crash reporter",
        "Disable crash reporting"
      ],
      "title": "iOS and tvOS crash reporting",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "b2b79e6f9e78f6113bb20032c674996c746e14d4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/ios-tvos-crash-reporting/",
      "published_at": "2021-10-24T16:50:42Z",
      "updated_at": "2021-07-09T18:14:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For agent version 4 or higher, New Relic produces crash reports for your mobile applications. When an iOS or tvOS application crashes, the operating system creates a crash report and stores it on the device. New Relic uploads this report the next time the app launches. Using this report and any relevant dSYM files, the crash report includes the complete stack trace with human-readable information. You can then log into New Relic and see each crash, including the method and line where it crashed, plus device and environment details. dSYM files When you create a release build of an iOS or tvOS application, the names of methods and classes are stripped, leaving only machine-readable memory addresses. When the application crashes, the stack trace consists of this machine-readable code. A dSYM file is an Xcode project file for debug symbols. It contains the debugging symbols that allow for translation of the initial crash report to human-readable information. This process is known as symbolication. New Relic has dynamic framework support for dSYM uploading. If your app uses a dynamic framework with multiple dSYM files, New Relic automatically uploads and uses those files. For more information, see Retrieve and download dSYMs or Upload dSYM files. Debug the crash reporter Crash reporting is enabled by default, but there are some circumstances where it will be disabled: If the debugger is enabled: There can only be one uncaught exception handler registered at a time per application. If running with the debugger attached, New Relic will not capture and report crashes. If another crash reporter is enabled: If another uncaught exception handler is registered after New Relic starts, this error message is logged: The New Relic exception handler has been replaced. This may result in crashes no longer reporting to New Relic. Copy Disable crash reporting To disable New Relic crash reporting, call the following API method: Language Procedure Objective-C Call prior to [NewRelic startWithApplicationToken:...]; [NewRelic disableFeatures:NRFeatureFlag_CrashReporting]; Copy Swift Call prior to NewRelic.start(withApplicationToken:) NewRelic.disableFeatures(NRMAFeatureFlags.NRFeatureFlag_CrashReporting) Copy For more information about this call, see the NewRelic.h file. For more on applicable feature flags, see the NewRelicFeatureFlags.h file.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 148.42725,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> and tvOS crash reporting",
        "sections": "<em>iOS</em> and tvOS crash reporting",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "For agent version 4 or higher, <em>New</em> <em>Relic</em> produces crash reports for your <em>mobile</em> applications. When an <em>iOS</em> or tv<em>OS</em> application crashes, the operating system creates a crash report and stores it on the device. <em>New</em> <em>Relic</em> uploads this report the next time the app launches. Using this report and any"
      },
      "id": "603ec58128ccbc9b51eba7d2"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/configuration/upload-dsyms-bitcode-apps": [
    {
      "sections": [
        "CocoaPods installation",
        "Install your iOS application",
        "Configure using Objective-C",
        "Important",
        "Configure using Swift",
        "Change the logging level (optional)"
      ],
      "title": "CocoaPods installation",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Installation"
      ],
      "external_id": "9a062745f628f66e34f865a47d58713f12e59ac9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/installation/cocoapods-installation/",
      "published_at": "2021-10-24T16:53:24Z",
      "updated_at": "2021-10-01T20:15:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "These procedures apply to iOS apps using Cocoapods. For other types, see iOS installation and configuration. Install your iOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. To install and configure your iOS application: Go to one.newrelic.com. If applicable: From the Mobile Apps list, select Add a new app. From the Get Started page, select iOS as the platform for mobile monitoring. Type a name for your mobile app, then select Continue. If your installation does not automatically include the prefix header, follow the steps to add the prefix header to your project. Continue with the steps to configure New Relic for mobile monitoring. Configure using Objective-C These procedures to configure your iOS app with CocoaPods and Objective-C also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy In your APP_NAME-Prefix.pch project file (generally found in the Supporting Files folder), include the New Relic header inside the #ifdef __OBJC__ #endif block: #import <NewRelic/NewRelic.h> Copy In your AppDelegate.m file, add this call as the first line of application:didFinishLaunchingWithOptions, replacing APP_TOKEN with your application token: [NewRelic startWithApplicationToken:@\"APP_TOKEN\"]; Copy Important The agent must be on the first line of didFinishLaunchingWithOptions and run on the main thread to ensure proper instrumentation. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Add a build script to your target's Build Phases. Ensure the new build script is the very last build script. Then paste the following, replacing APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"APP_TOKEN\" Copy Clean and build your app, then run it in the simulator or other device. Configure using Swift These procedures to configure your iOS app with CocoaPods and Swift also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy Create a bridging header: Select File > New > File > Objective-C File. Name the file Placeholder.m, then select Next. Select Create, and confirm Xcode's prompt to generate the bridging header. In your APP_NAME-Bridging-Header.h, add the New Relic header: #import \"NewRelic/NewRelic.h\" Copy In your AppDelegate.swift file, add this call as the first line of application:didFinishLaunchingWithOptions, replacing APP_TOKEN with your application token: NewRelic.start(withApplicationToken:\"APP_TOKEN\") Copy Important To ensure proper instrumentation, you must call the agent on the first line of didFinishLaunchingWithOptions(), and run the agent on the main thread. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Add a build script to your target's Build Phases. Ensure the new build script is the very last build script. Then paste the following, replacing APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"APP_TOKEN\" Copy Clean and build your app, then run it in the simulator or other device. Change the logging level (optional) Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add this method call before calling NewRelic.start(withApplicationToken): [NRLogger setLogLevels:NRLogLevelALL]; Copy For Swift apps: NRLogger.setLogLevels(NRLogLevelALL.rawValue) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 161.04843,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "CocoaPods <em>installation</em>",
        "sections": "<em>Install</em> your <em>iOS</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " <em>mobile</em> app you <em>monitor</em> in <em>New</em> <em>Relic</em>. To install and configure your <em>iOS</em> application: Go to one.newrelic.com. If applicable: From the <em>Mobile</em> Apps list, select Add a <em>new</em> app. From the Get Started page, select <em>iOS</em> as the platform for <em>mobile</em> <em>monitoring</em>. Type a name for your <em>mobile</em> app, then select Continue"
      },
      "id": "603ea15d64441fef3d4e8867"
    },
    {
      "sections": [
        "Retrieve dSYMs for Bitcode apps",
        "Identify missing dSYMs",
        "Download dSYM files using iTunes Connect",
        "Download dSYM files using Xcode's app archive",
        "Upload dSYMs"
      ],
      "title": "Retrieve dSYMs for Bitcode apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "34e375873e36095062eccef6d99f26be7562308f",
      "image": "https://docs.newrelic.com/static/041368cdc60d9252ad80c2c37321b805/ec3e2/screen-dsym2.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/retrieve-dsyms-bitcode-apps/",
      "published_at": "2021-10-24T16:51:42Z",
      "updated_at": "2021-07-09T19:35:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Bitcode is a feature that gives Apple the ability to re-compile iOS and tvOS applications for specific users' hardware. This provides a smaller download size for end users. For more about this process, see Apple's Bitcode and app thinning documentation. When Apple compiles an app, the dSYM files are also compiled. For New Relic to be able to symbolicate crashes of your Bitcode-enabled app, these dSYM files need to be downloaded from Apple and then uploaded to New Relic. Identify missing dSYMs When a Bitcode-enabled app is uploaded to Apple for App Store review or ad-hoc distribution, dSYMs need to be manually downloaded from Apple and uploaded to New Relic to allow the mobile crash reports to be properly symbolicated. These dSYMs can be downloaded through the archives organizer in Xcode within several minutes of uploading the app. In this situation follow the procedures to find the archive and download dSYMs. If an app is missing a dSYM file, you'll see three indicators in the mobile monitoring UI: Banner notification: A banner warning appears on the Crash report page. The warning reads: We were unable to locate your dsym. Copy Upload prompt: from the Crash type summary page you will be automatically prompted to upload a dSYM file if it is missing. Machine code: The crash stack trace on the Crash report page displays machine code and not a human-readable error message. Download dSYM files using iTunes Connect To download the dSYM files you need for your app: Log in to Apple iTunes Connect. Select My Apps > (selected app) > Activity. From the list of builds for your application, select the build number you need for the dSYM. Select Download dSYM. Then, to upload the resulting zip file directly to New Relic: Follow the instructions to manually upload dSYM, and skip step 1. Unpack one dSYM contained in this zip file to retrieve a build UUID that you can upload. (Follow the last step in the manual upload instructions.) Once New Relic receives the zip file, the build UUIDs for all other dSYMs contained in that zip file will be identified. Download dSYM files using Xcode's app archive Use the app version and build number to identify the applicable app archive in the Xcode Organizer and download the dSYMs. Using Xcode to download dSYMs: From the Archives tab, select the app and version/build, then select Download dSYMs. Open the Xcode Organizer: From the Xcode menu, select Window > Organizer > Archives > (select a mobile app). From Version, select the archive that matches the app version (listed first) and build number (following the app version in parentheses). Select Download dSYMs. The dSYMs will be downloaded from Apple if available and if the file names contain a series of letters and numbers. If the dSYM files are named after the the dependencies in your project, the download will not be successful. Upload dSYMs Once you have located the dSYMs, follow the instructions to upload a dSYM for each zipped dSYM.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 148.43358,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Identify</em> missing dSYMs",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Bitcode is a feature that gives Apple the ability to re-compile <em>iOS</em> and tv<em>OS</em> applications for specific users&#x27; hardware. This provides a smaller download size for end users. For more about this process, see Apple&#x27;s Bitcode and app thinning documentation. When Apple compiles an app, the dSYM files"
      },
      "id": "6044144228ccbc04a2303885"
    },
    {
      "sections": [
        "iOS and tvOS crash reporting",
        "dSYM files",
        "Debug the crash reporter",
        "Disable crash reporting"
      ],
      "title": "iOS and tvOS crash reporting",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "b2b79e6f9e78f6113bb20032c674996c746e14d4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/ios-tvos-crash-reporting/",
      "published_at": "2021-10-24T16:50:42Z",
      "updated_at": "2021-07-09T18:14:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For agent version 4 or higher, New Relic produces crash reports for your mobile applications. When an iOS or tvOS application crashes, the operating system creates a crash report and stores it on the device. New Relic uploads this report the next time the app launches. Using this report and any relevant dSYM files, the crash report includes the complete stack trace with human-readable information. You can then log into New Relic and see each crash, including the method and line where it crashed, plus device and environment details. dSYM files When you create a release build of an iOS or tvOS application, the names of methods and classes are stripped, leaving only machine-readable memory addresses. When the application crashes, the stack trace consists of this machine-readable code. A dSYM file is an Xcode project file for debug symbols. It contains the debugging symbols that allow for translation of the initial crash report to human-readable information. This process is known as symbolication. New Relic has dynamic framework support for dSYM uploading. If your app uses a dynamic framework with multiple dSYM files, New Relic automatically uploads and uses those files. For more information, see Retrieve and download dSYMs or Upload dSYM files. Debug the crash reporter Crash reporting is enabled by default, but there are some circumstances where it will be disabled: If the debugger is enabled: There can only be one uncaught exception handler registered at a time per application. If running with the debugger attached, New Relic will not capture and report crashes. If another crash reporter is enabled: If another uncaught exception handler is registered after New Relic starts, this error message is logged: The New Relic exception handler has been replaced. This may result in crashes no longer reporting to New Relic. Copy Disable crash reporting To disable New Relic crash reporting, call the following API method: Language Procedure Objective-C Call prior to [NewRelic startWithApplicationToken:...]; [NewRelic disableFeatures:NRFeatureFlag_CrashReporting]; Copy Swift Call prior to NewRelic.start(withApplicationToken:) NewRelic.disableFeatures(NRMAFeatureFlags.NRFeatureFlag_CrashReporting) Copy For more information about this call, see the NewRelic.h file. For more on applicable feature flags, see the NewRelicFeatureFlags.h file.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 148.42725,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> and tvOS crash reporting",
        "sections": "<em>iOS</em> and tvOS crash reporting",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "For agent version 4 or higher, <em>New</em> <em>Relic</em> produces crash reports for your <em>mobile</em> applications. When an <em>iOS</em> or tv<em>OS</em> application crashes, the operating system creates a crash report and stores it on the device. <em>New</em> <em>Relic</em> uploads this report the next time the app launches. Using this report and any"
      },
      "id": "603ec58128ccbc9b51eba7d2"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios": [
    {
      "sections": [
        "CocoaPods installation",
        "Install your iOS application",
        "Configure using Objective-C",
        "Important",
        "Configure using Swift",
        "Change the logging level (optional)"
      ],
      "title": "CocoaPods installation",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Installation"
      ],
      "external_id": "9a062745f628f66e34f865a47d58713f12e59ac9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/installation/cocoapods-installation/",
      "published_at": "2021-10-24T16:53:24Z",
      "updated_at": "2021-10-01T20:15:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "These procedures apply to iOS apps using Cocoapods. For other types, see iOS installation and configuration. Install your iOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. To install and configure your iOS application: Go to one.newrelic.com. If applicable: From the Mobile Apps list, select Add a new app. From the Get Started page, select iOS as the platform for mobile monitoring. Type a name for your mobile app, then select Continue. If your installation does not automatically include the prefix header, follow the steps to add the prefix header to your project. Continue with the steps to configure New Relic for mobile monitoring. Configure using Objective-C These procedures to configure your iOS app with CocoaPods and Objective-C also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy In your APP_NAME-Prefix.pch project file (generally found in the Supporting Files folder), include the New Relic header inside the #ifdef __OBJC__ #endif block: #import <NewRelic/NewRelic.h> Copy In your AppDelegate.m file, add this call as the first line of application:didFinishLaunchingWithOptions, replacing APP_TOKEN with your application token: [NewRelic startWithApplicationToken:@\"APP_TOKEN\"]; Copy Important The agent must be on the first line of didFinishLaunchingWithOptions and run on the main thread to ensure proper instrumentation. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Add a build script to your target's Build Phases. Ensure the new build script is the very last build script. Then paste the following, replacing APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"APP_TOKEN\" Copy Clean and build your app, then run it in the simulator or other device. Configure using Swift These procedures to configure your iOS app with CocoaPods and Swift also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy Create a bridging header: Select File > New > File > Objective-C File. Name the file Placeholder.m, then select Next. Select Create, and confirm Xcode's prompt to generate the bridging header. In your APP_NAME-Bridging-Header.h, add the New Relic header: #import \"NewRelic/NewRelic.h\" Copy In your AppDelegate.swift file, add this call as the first line of application:didFinishLaunchingWithOptions, replacing APP_TOKEN with your application token: NewRelic.start(withApplicationToken:\"APP_TOKEN\") Copy Important To ensure proper instrumentation, you must call the agent on the first line of didFinishLaunchingWithOptions(), and run the agent on the main thread. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Add a build script to your target's Build Phases. Ensure the new build script is the very last build script. Then paste the following, replacing APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"APP_TOKEN\" Copy Clean and build your app, then run it in the simulator or other device. Change the logging level (optional) Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add this method call before calling NewRelic.start(withApplicationToken): [NRLogger setLogLevels:NRLogLevelALL]; Copy For Swift apps: NRLogger.setLogLevels(NRLogLevelALL.rawValue) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 167.48047,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "CocoaPods <em>installation</em>",
        "sections": "<em>Install</em> your <em>iOS</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " <em>mobile</em> app you <em>monitor</em> in <em>New</em> <em>Relic</em>. To install and configure your <em>iOS</em> application: Go to one.newrelic.com. If applicable: From the <em>Mobile</em> Apps list, select Add a <em>new</em> app. From the <em>Get</em> <em>Started</em> page, select <em>iOS</em> as the platform for <em>mobile</em> <em>monitoring</em>. Type a name for your <em>mobile</em> app, then select Continue"
      },
      "id": "603ea15d64441fef3d4e8867"
    },
    {
      "sections": [
        "Get data into New Relic",
        "New Relic-built agents and integrations",
        "Report custom data"
      ],
      "title": "Get data into New Relic",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Get started"
      ],
      "external_id": "016a25d46dedc5da1455b29d8557ce68a4345756",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/get-started/introduction-new-relic-data-ingest-apis-sdks/",
      "published_at": "2021-10-24T19:36:34Z",
      "updated_at": "2021-10-23T17:32:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "There are many ways to get data into your New Relic account. Any New Relic user can use any of our data ingest methods to report data to our platform. New Relic-built agents and integrations When you enable New Relic solutions like APM, browser monitoring, mobile monitoring, infrastructure monitoring, or any of our wide array of integrations, by default you'll receive data from your monitored applications, hosts, services, or other entities. Some options for getting started: Log into one.newrelic.com and click Add more data to get some guidance on setting up New Relic solutions. To browse our solutions, see New Relic integrations. Report custom data If you need to report data that our agents and integrations don't provide, we have tools that will allow you to bring in any type of data you need. To learn more, see Intro to custom data.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.55975,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Get</em> data <em>into</em> <em>New</em> <em>Relic</em>",
        "sections": "<em>Get</em> data <em>into</em> <em>New</em> <em>Relic</em>",
        "tags": "<em>Get</em> <em>started</em>",
        "body": "There are many ways to <em>get</em> data into your <em>New</em> <em>Relic</em> account. Any <em>New</em> <em>Relic</em> user can use any of our data ingest methods to report data to our platform. <em>New</em> <em>Relic</em>-built agents and integrations When you enable <em>New</em> <em>Relic</em> solutions like APM, browser <em>monitoring</em>, <em>mobile</em> <em>monitoring</em>, infrastructure"
      },
      "id": "6174474328ccbcdff4c6b77e"
    },
    {
      "sections": [
        "Get started with New Relic observability",
        "Youâ€™re in control because you understand your system",
        "All the answers in one place",
        "Start anywhere"
      ],
      "title": "Get started with New Relic observability",
      "type": "docs",
      "tags": [
        "Observe everything",
        "Get started"
      ],
      "external_id": "30f87d5f702f926efec49b59591679fa93627ad5",
      "image": "https://docs.newrelic.com/static/44970161aec793f3141cfcdc0fc96a57/c1b63/observability-2.png",
      "url": "https://docs.newrelic.com/docs/using-new-relic/welcome-new-relic/get-started/get-started-full-stack-observability/",
      "published_at": "2021-10-24T11:46:39Z",
      "updated_at": "2021-10-23T16:46:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "True observability is the power of knowing what's happening across your digital system and why, at any time, whatever solution youâ€™re using. Itâ€™s getting the whole picture of everything that enables your applications and devices to deliver value to your customers, from the container running a microservice in the cloud to a mobile website's shopping cart button. Youâ€™re in control because you understand your system New Relic helps you cut through the layers of complexity surrounding your systems by bringing together and connecting data from any instrumented source and environment, without having to jump between tools. You can interrogate your data for patterns, discover them using our data platform, or get proactive results from our machine learning tools. New Relic provides answers to essential questions in one place. All the answers in one place As a full user you get access to our entire set of observability tools. All our tools are interconnected and accessible in New Relic One. All the data you bring to New Relic through agents and integrations are metrics, events, logs, and traces that feed our platform's analytics and monitoring capabilities. New Relic links your data in a meaningful way so that you can explore it, build dashboards, and set up alerts. Our more curated observability UI experiences allow to visualize, analyze, and troubleshoot your entire software stack in one unified platform. The New Relic Explorer consolidates all the entities in your system, and how they're connected, in a single place, so you can easily detect performance trends and issues. By automatically connecting infrastructure health with application performance and end-user behavior, you can cut through the noise to find the signal. Start anywhere Being fully-connected, New Relic allows you to start your observability journey from any element of your stack. For example, you can get to crucial infrastructure logs from traces of an application running on a problematic Kubernetes pod. Use the Explorer in New Relic One to access and observe the full stack of your software, see performance data and alerting status at a glance, and check relationships. We provide you with a simple, yet powerful visual tool to monitor all your entities, that is, anything we can identify that reports data. In the New Relic ecosystem, entities include basic components like applications, hosts, containers, or database services, but it can also refer to custom groupings of such elements. You can also create your own entities. The more entities you instrument, the more data you'll bring in. The more data you've brought to New Relic, the more you'll understand your metrics, events, logs, and traces. You want to instrument Start with Keep exploring Front-end applications Mobile applications User behavior and flows New Relic Explorer Browser monitoring Mobile monitoring Synthetic monitoring Single page monitoring Scripted browsers Containerized minions Workloads Backend applications Serverless applications New Relic Explorer Application monitoring Serverless monitoring Learning about Apdex Distributed tracing Logs in context APM data to infrastructure Workloads Infrastructure hosts and services (on-premise, cloud, orchestrated) Container environments and orchestration tools (Kubernetes, ECS, etc.) Infrastructure monitoring Infrastructure integrations Kubernetes integration Docker integration ECS integration Log forwarding APM data to infrastructure Custom integrations Kubernetes cluster explorer Infrastructure alerts Workloads",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 146.49954,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Get</em> <em>started</em> with <em>New</em> <em>Relic</em> observability",
        "sections": "<em>Get</em> <em>started</em> with <em>New</em> <em>Relic</em> observability",
        "tags": "<em>Get</em> <em>started</em>",
        "body": ". You want to instrument <em>Start</em> with Keep exploring Front-end applications <em>Mobile</em> applications User behavior and flows <em>New</em> <em>Relic</em> Explorer Browser <em>monitoring</em> <em>Mobile</em> <em>monitoring</em> Synthetic <em>monitoring</em> Single page <em>monitoring</em> Scripted browsers Containerized minions Workloads Backend applications Serverless"
      },
      "id": "61743c6764441f60375fd317"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/get-started/new-relic-ios-compatibility-requirements": [
    {
      "sections": [
        "CocoaPods installation",
        "Install your iOS application",
        "Configure using Objective-C",
        "Important",
        "Configure using Swift",
        "Change the logging level (optional)"
      ],
      "title": "CocoaPods installation",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Installation"
      ],
      "external_id": "9a062745f628f66e34f865a47d58713f12e59ac9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/installation/cocoapods-installation/",
      "published_at": "2021-10-24T16:53:24Z",
      "updated_at": "2021-10-01T20:15:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "These procedures apply to iOS apps using Cocoapods. For other types, see iOS installation and configuration. Install your iOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. To install and configure your iOS application: Go to one.newrelic.com. If applicable: From the Mobile Apps list, select Add a new app. From the Get Started page, select iOS as the platform for mobile monitoring. Type a name for your mobile app, then select Continue. If your installation does not automatically include the prefix header, follow the steps to add the prefix header to your project. Continue with the steps to configure New Relic for mobile monitoring. Configure using Objective-C These procedures to configure your iOS app with CocoaPods and Objective-C also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy In your APP_NAME-Prefix.pch project file (generally found in the Supporting Files folder), include the New Relic header inside the #ifdef __OBJC__ #endif block: #import <NewRelic/NewRelic.h> Copy In your AppDelegate.m file, add this call as the first line of application:didFinishLaunchingWithOptions, replacing APP_TOKEN with your application token: [NewRelic startWithApplicationToken:@\"APP_TOKEN\"]; Copy Important The agent must be on the first line of didFinishLaunchingWithOptions and run on the main thread to ensure proper instrumentation. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Add a build script to your target's Build Phases. Ensure the new build script is the very last build script. Then paste the following, replacing APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"APP_TOKEN\" Copy Clean and build your app, then run it in the simulator or other device. Configure using Swift These procedures to configure your iOS app with CocoaPods and Swift also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy Create a bridging header: Select File > New > File > Objective-C File. Name the file Placeholder.m, then select Next. Select Create, and confirm Xcode's prompt to generate the bridging header. In your APP_NAME-Bridging-Header.h, add the New Relic header: #import \"NewRelic/NewRelic.h\" Copy In your AppDelegate.swift file, add this call as the first line of application:didFinishLaunchingWithOptions, replacing APP_TOKEN with your application token: NewRelic.start(withApplicationToken:\"APP_TOKEN\") Copy Important To ensure proper instrumentation, you must call the agent on the first line of didFinishLaunchingWithOptions(), and run the agent on the main thread. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Add a build script to your target's Build Phases. Ensure the new build script is the very last build script. Then paste the following, replacing APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"APP_TOKEN\" Copy Clean and build your app, then run it in the simulator or other device. Change the logging level (optional) Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add this method call before calling NewRelic.start(withApplicationToken): [NRLogger setLogLevels:NRLogLevelALL]; Copy For Swift apps: NRLogger.setLogLevels(NRLogLevelALL.rawValue) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 167.48047,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "CocoaPods <em>installation</em>",
        "sections": "<em>Install</em> your <em>iOS</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " <em>mobile</em> app you <em>monitor</em> in <em>New</em> <em>Relic</em>. To install and configure your <em>iOS</em> application: Go to one.newrelic.com. If applicable: From the <em>Mobile</em> Apps list, select Add a <em>new</em> app. From the <em>Get</em> <em>Started</em> page, select <em>iOS</em> as the platform for <em>mobile</em> <em>monitoring</em>. Type a name for your <em>mobile</em> app, then select Continue"
      },
      "id": "603ea15d64441fef3d4e8867"
    },
    {
      "sections": [
        "Get data into New Relic",
        "New Relic-built agents and integrations",
        "Report custom data"
      ],
      "title": "Get data into New Relic",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Get started"
      ],
      "external_id": "016a25d46dedc5da1455b29d8557ce68a4345756",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/get-started/introduction-new-relic-data-ingest-apis-sdks/",
      "published_at": "2021-10-24T19:36:34Z",
      "updated_at": "2021-10-23T17:32:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "There are many ways to get data into your New Relic account. Any New Relic user can use any of our data ingest methods to report data to our platform. New Relic-built agents and integrations When you enable New Relic solutions like APM, browser monitoring, mobile monitoring, infrastructure monitoring, or any of our wide array of integrations, by default you'll receive data from your monitored applications, hosts, services, or other entities. Some options for getting started: Log into one.newrelic.com and click Add more data to get some guidance on setting up New Relic solutions. To browse our solutions, see New Relic integrations. Report custom data If you need to report data that our agents and integrations don't provide, we have tools that will allow you to bring in any type of data you need. To learn more, see Intro to custom data.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.55975,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Get</em> data <em>into</em> <em>New</em> <em>Relic</em>",
        "sections": "<em>Get</em> data <em>into</em> <em>New</em> <em>Relic</em>",
        "tags": "<em>Get</em> <em>started</em>",
        "body": "There are many ways to <em>get</em> data into your <em>New</em> <em>Relic</em> account. Any <em>New</em> <em>Relic</em> user can use any of our data ingest methods to report data to our platform. <em>New</em> <em>Relic</em>-built agents and integrations When you enable <em>New</em> <em>Relic</em> solutions like APM, browser <em>monitoring</em>, <em>mobile</em> <em>monitoring</em>, infrastructure"
      },
      "id": "6174474328ccbcdff4c6b77e"
    },
    {
      "sections": [
        "Get started with New Relic observability",
        "Youâ€™re in control because you understand your system",
        "All the answers in one place",
        "Start anywhere"
      ],
      "title": "Get started with New Relic observability",
      "type": "docs",
      "tags": [
        "Observe everything",
        "Get started"
      ],
      "external_id": "30f87d5f702f926efec49b59591679fa93627ad5",
      "image": "https://docs.newrelic.com/static/44970161aec793f3141cfcdc0fc96a57/c1b63/observability-2.png",
      "url": "https://docs.newrelic.com/docs/using-new-relic/welcome-new-relic/get-started/get-started-full-stack-observability/",
      "published_at": "2021-10-24T11:46:39Z",
      "updated_at": "2021-10-23T16:46:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "True observability is the power of knowing what's happening across your digital system and why, at any time, whatever solution youâ€™re using. Itâ€™s getting the whole picture of everything that enables your applications and devices to deliver value to your customers, from the container running a microservice in the cloud to a mobile website's shopping cart button. Youâ€™re in control because you understand your system New Relic helps you cut through the layers of complexity surrounding your systems by bringing together and connecting data from any instrumented source and environment, without having to jump between tools. You can interrogate your data for patterns, discover them using our data platform, or get proactive results from our machine learning tools. New Relic provides answers to essential questions in one place. All the answers in one place As a full user you get access to our entire set of observability tools. All our tools are interconnected and accessible in New Relic One. All the data you bring to New Relic through agents and integrations are metrics, events, logs, and traces that feed our platform's analytics and monitoring capabilities. New Relic links your data in a meaningful way so that you can explore it, build dashboards, and set up alerts. Our more curated observability UI experiences allow to visualize, analyze, and troubleshoot your entire software stack in one unified platform. The New Relic Explorer consolidates all the entities in your system, and how they're connected, in a single place, so you can easily detect performance trends and issues. By automatically connecting infrastructure health with application performance and end-user behavior, you can cut through the noise to find the signal. Start anywhere Being fully-connected, New Relic allows you to start your observability journey from any element of your stack. For example, you can get to crucial infrastructure logs from traces of an application running on a problematic Kubernetes pod. Use the Explorer in New Relic One to access and observe the full stack of your software, see performance data and alerting status at a glance, and check relationships. We provide you with a simple, yet powerful visual tool to monitor all your entities, that is, anything we can identify that reports data. In the New Relic ecosystem, entities include basic components like applications, hosts, containers, or database services, but it can also refer to custom groupings of such elements. You can also create your own entities. The more entities you instrument, the more data you'll bring in. The more data you've brought to New Relic, the more you'll understand your metrics, events, logs, and traces. You want to instrument Start with Keep exploring Front-end applications Mobile applications User behavior and flows New Relic Explorer Browser monitoring Mobile monitoring Synthetic monitoring Single page monitoring Scripted browsers Containerized minions Workloads Backend applications Serverless applications New Relic Explorer Application monitoring Serverless monitoring Learning about Apdex Distributed tracing Logs in context APM data to infrastructure Workloads Infrastructure hosts and services (on-premise, cloud, orchestrated) Container environments and orchestration tools (Kubernetes, ECS, etc.) Infrastructure monitoring Infrastructure integrations Kubernetes integration Docker integration ECS integration Log forwarding APM data to infrastructure Custom integrations Kubernetes cluster explorer Infrastructure alerts Workloads",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 146.49954,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Get</em> <em>started</em> with <em>New</em> <em>Relic</em> observability",
        "sections": "<em>Get</em> <em>started</em> with <em>New</em> <em>Relic</em> observability",
        "tags": "<em>Get</em> <em>started</em>",
        "body": ". You want to instrument <em>Start</em> with Keep exploring Front-end applications <em>Mobile</em> applications User behavior and flows <em>New</em> <em>Relic</em> Explorer Browser <em>monitoring</em> <em>Mobile</em> <em>monitoring</em> Synthetic <em>monitoring</em> Single page <em>monitoring</em> Scripted browsers Containerized minions Workloads Backend applications Serverless"
      },
      "id": "61743c6764441f60375fd317"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/installation/cocoapods-installation": [
    {
      "sections": [
        "iOS manual installation",
        "Install your iOS application",
        "Add the New Relic framework to your app",
        "Important",
        "Optional: Execute a demo crash",
        "Optional: Change the logging level"
      ],
      "title": "iOS manual installation",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Installation"
      ],
      "external_id": "0a674eb7f3756cd5d124c6dcf2344edf38e40a8a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/installation/ios-manual-installation/",
      "published_at": "2021-10-24T16:52:30Z",
      "updated_at": "2021-07-27T15:09:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To install and configure New Relic functionality with your iOS applications, follow these procedures. If your iOS app uses Cocoapods, follow the Cocoapods installation procedures. Install your iOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. To install and configure your iOS application: Go to one.newrelic.com. If applicable: From the Mobile Apps index, select Add a new app. From the Get started page, select XCFramework as the platform for mobile monitoring. Type a name for your mobile app, and select Continue. Continue with the steps to configure New Relic. Add the New Relic framework to your app Download and unzip the iOS SDK for New Relic. To add the New Relic framework to your Xcode project: Use Finder to drag the NewRelicAgent.framework folder into your Xcode project, and drop it onto your project in the Project navigator window, under Frameworks, Libraries, and Embedded Content. Make sure Embed & Sign is selected under the Embed dropdown menu. Implement the agent using the appropriate method: Important To ensure proper instrumentation, you must call the agent on the first line of didFinishLaunchingWithOptions(), and run the agent on the main thread. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Language Procedure Objective-C To start the agent: Import the New Relic header at the top of your prefix.pch. Add +[NewRelic startWithApplicationToken:@\"<appToken>\"] to the top of -application:didFinishLaunchingWithOptions: in your AppDelegate.m, using the unique application token that is automatically generated. Swift Create a bridging header file: Select File > New > File > Objective-C File. Name the file Placeholder.m, then select Next. Select Create, and confirm Xcode's prompt to generate the bridging header. Delete Placeholder.m. Import the New Relic agent by adding #import \"NewRelic/NewRelic.h\" to the top of MyApp-Bridging-Header.h. Add NewRelic.start(withApplicationToken: \">appToken>\") to the top of application(_:didFinishLaunchingWithOptions:) in your AppDelegate.swift using the unique application token that is automatically generated. Add a build script to your target's Build Phases. Ensure the new build script is the very last build phase, then paste the following, replacing PUT_NEW_RELIC_APP_TOKEN_HERE with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"PUT_NEW_RELIC_APP_TOKEN_HERE\" Copy Clean and build your app, and then run it in the simulator or other device. Optional: Execute a demo crash If you have trouble getting your app to crash, the New Relic agent provides an API to execute a demo crash. Recommendation: Add one of these lines of code to a button click event handler as applicable: Language Code Objective-C Crash: [NewRelic crashNow]; Copy Crash with log message: [NewRelic crashNow:@\"<reason>\"]; Copy Swift Crash: NewRelic.crashNow() Copy Crash with log message: NewRelic.crashNow(_ message:) Copy Optional: Change the logging level Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add the following method: Language Code Objective-C Just before calling startWithApplicationToken in AppDelegate.m, add: [NRLogger setLogLevels:NRLogLevelALL]; Copy Swift Just before calling start(withApplicationToken:) in AppDelegate.swift, add: NRLogger.setLogLevels(NRLogLevelALL.rawValue) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 146.84671,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> manual <em>installation</em>",
        "sections": "<em>iOS</em> manual <em>installation</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " token. This is a 40-character hexadecimal string for authenticating each <em>mobile</em> app you <em>monitor</em> in <em>New</em> <em>Relic</em>. To install and configure your <em>iOS</em> application: Go to one.newrelic.com. If applicable: From the <em>Mobile</em> Apps index, select Add a <em>new</em> app. From the Get started page, select XCFramework"
      },
      "id": "603ea44864441f80904e8899"
    },
    {
      "sections": [
        "Upgrade the iOS agent",
        "Replace your iOS framework"
      ],
      "title": "Upgrade the iOS agent",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Installation"
      ],
      "external_id": "f51e93fbddfa6fd7b531f2b8dc071cfebb8c7fc9",
      "image": "https://docs.newrelic.com/static/ce6f593163d7f9a6c7a72509d4d947bd/8c557/screen-mobile-monitoring-upgrade-ios_0.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/installation/upgrade-new-relic-mobiles-ios-sdk/",
      "published_at": "2021-10-24T16:07:06Z",
      "updated_at": "2021-07-09T14:20:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You must be an account Admin to install, configure, and upgrade the iOS agent. For information about the latest version, refer to the release notes. Replace your iOS framework Admins: You must replace the earlier version of your iOS agent framework before upgrading to a newer version of the iOS SDK. Here is an example of the workflow to remove your existing iOS agent framework so you can replace it with a newer version. From the Project Navigator (CMD 1) in Xcode, search for NewRelicAgent.framework. Right-click or control-click NewRelicAgent.framework, and select Show in Finder. Drag NewRelicAgent.framework to the trash. Verify that the Xcode project highlights the reference to NewRelicAgent.framework in red. Right-click or control-click NewRelicAgent.framework, and select Delete to remove the obsolete reference from the project. Continue with the standard installation procedures for iOS app monitoring at one.newrelic.com > Mobile > (select an app) > Settings > Installation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 144.4917,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Upgrade the <em>iOS</em> agent",
        "sections": "Upgrade the <em>iOS</em> agent",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " <em>NewRelic</em>Agent.framework to the trash. Verify that the Xcode project highlights the reference to <em>NewRelic</em>Agent.framework in red. Right-click or control-click <em>NewRelic</em>Agent.framework, and select Delete to remove the obsolete reference from the project. Continue with the standard <em>installation</em> procedures for <em>iOS</em> app <em>monitoring</em> at one.newrelic.com &gt; <em>Mobile</em> &gt; (select an app) &gt; Settings &gt; <em>Installation</em>."
      },
      "id": "603eab6a196a672442a83da7"
    },
    {
      "sections": [
        "Upload dSYM files",
        "Automatic script",
        "Identify missing dSYMs",
        "Upload dSYM files through the mobile monitoring UI",
        "Manually upload dSYM files",
        "Via Python script (agent versions 6.0.0 or higher)",
        "Via command line",
        "Troubleshooting",
        "Auto-upload failure",
        "Missing dSYMs"
      ],
      "title": "Upload dSYM files",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "3655f49cf0e1ae693de0f8ea45bf4e5e6437e399",
      "image": "https://docs.newrelic.com/static/5c859575f391fbb1eaa18243a8c97000/8c557/Screen-Shot-2014-09-23-at-11.30.35-AM_0.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/upload-dsyms-bitcode-apps/",
      "published_at": "2021-10-24T16:52:30Z",
      "updated_at": "2021-09-27T15:06:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your app's dSYM files are stored in Xcode's dSYM archive path folder. This is the folder where the iOS agent gets the dSYM files that are used to symbolicate your crash reports. New Relic provides a post-build script as part of the iOS agent's install process and the tvOS agent's install process. This script automatically uploads your app's dSYM files. Automatic script The script automatically uploads dSYM files only for release builds. Non-release builds must upload their files either manually or through the mobile monitoring UI. Bitcode-enabled apps have their dSYM files generated by Apple. You must download the dSYM files for Bitcode-enabled apps from Apple and upload them to New Relic. If you see unreadable machine code in the Crashes page, your dSYM files may not be uploaded correctly. In some cases, you may need to manually upload dSYM files. The automatic script uses Python 2. As of October 2019 with macOS 10.15 (Catalina), Python won't be installed by default. If you're using the automatic script (recommended), you may need to manually install Python 2. If you're using Homebrew, see Python on Homebrew. Identify missing dSYMs When a Bitcode-enabled app is uploaded to Apple for App Store review or ad-hoc distribution, dSYMs need to be manually downloaded from Apple and uploaded to New Relic to allow the mobile crash reports to be properly symbolicated. These dSYMs can be downloaded through the archives organizer in Xcode within several minutes of uploading the app. In this situation follow the procedures to find the archive and download dSYMs. If an app is missing a dSYM file, you'll see three indicators in the mobile monitoring UI: Banner notification: A banner warning appears on the Crash report page. The warning reads: We were unable to locate your dsym. Copy Upload prompt: From the Crash type summary page you will be automatically prompted to upload a dSYM file if it is missing. Machine code: The crash stack trace on the Crash report page displays machine code and not a human-readable error message. Upload dSYM files through the mobile monitoring UI You can easily upload your dSYM files directly from the New Relic One UI. The maximum file size is 600 MB. To upload your dSYM files: Go to one.newrelic.com and click Mobile. Then select your app from the list. View Crash analysis. Select a specific crash from the Crash types list. Click Upload dSYM. You can either drag and drop your dSYMs directly, or select the file form your computer. Manually upload dSYM files In some circumstances, New Relic's automatic upload of dSYM files may fail. If a dSYM upload is attempted and fails, it creates a build error with a detailed message. For example, if there's a network failure and the dSYM upload isn't completed, Xcode will report an error. For additional information about how New Relic handles dSYM uploads, see New Relic's Online Technical Community. If the automatic upload fails, you can manually upload your dSYM file. If you have multiple dSYM files, they can be within a single zip with a maximum file size of 600 MB. The YOUR_NEW_RELIC_APPLICATION_TOKEN value in the commands below is the same key used for +[NewRelic startWithApplicationToken:] (in Objective-C) or NewRelic.start(withApplicationToken:) (in Swift). To manually upload your dSYM files: Via Python script (agent versions 6.0.0 or higher) In iOS agent versions 6.0.0 or higher, the agent includes a Python script that automatically processes and uploads symbols. You can call this script from the command line: NewRelicAgent.framework/Resources/generateMap.py \"DSYM_ARCHIVE_PATH\" \"YOUR_NEW_RELIC_APPLICATION_TOKEN\" Copy Via command line To manually upload individual dSYM files from the command line: Zip up your dSYM file or files using the following command. Replace ~ /ZIPPED_DSYM_PATH with your new dSYM archive path and file name (for example, Users/my-name/desktop). Also replace ~ /dSYM_PATH with your existing dSYM file path. /usr/bin/zip --recurse-paths --quiet \"~/ZIPPED_DSYM_PATH\" \"~/dSYM_PATH\" Copy Upload the dSYM zip file using the following command: For US accounts: curl -F dsym=@\"~/DSYM_ZIP_PATH\" -H \"X-APP-LICENSE-KEY: YOUR_NEW_RELIC_APPLICATION_TOKEN\" https://mobile-symbol-upload.newrelic.com/symbol Copy For EU accounts: curl -F dsym=@\"~/DSYM_ZIP_PATH\" -H \"X-APP-LICENSE-KEY: YOUR_NEW_RELIC_APPLICATION_TOKEN\" https://mobile-symbol-upload.eu01.nr-data.net/symbol Copy Troubleshooting Auto-upload failure If a dSYM auto-upload failed, the Report Navigator may have a fully formed cURL command. You can use this cURL command to reattempt an upload. Depending on the error, you may also need to follow some of the dSYM manual upload steps. Here is an example of a successful dSYM upload in the Report Navigator: Example: A successful dSYM upload in the Report Navigator. Missing dSYMs If dSYM files are missing, you may need to check Xcode build settings to ensure the file is being generated. Frameworks which are built locally have separate build settings and may need to be updated as well. Build settings: Debug Information Format : Dwarf with dSYM File Deployment Postprocessing: Yes Strip Linked Product: Yes Strip Debug Symbols During Copy : Yes Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.81871,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Upload dSYM files through the <em>mobile</em> <em>monitoring</em> UI",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Your app&#x27;s dSYM files are stored in Xcode&#x27;s dSYM archive path folder. This is the folder where the <em>iOS</em> agent gets the dSYM files that are used to symbolicate your crash reports. <em>New</em> <em>Relic</em> provides a post-build script as part of the <em>iOS</em> agent&#x27;s install process and the tv<em>OS</em> agent&#x27;s install process"
      },
      "id": "60441960e7b9d24f705799ca"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/installation/ios-manual-installation": [
    {
      "sections": [
        "CocoaPods installation",
        "Install your iOS application",
        "Configure using Objective-C",
        "Important",
        "Configure using Swift",
        "Change the logging level (optional)"
      ],
      "title": "CocoaPods installation",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Installation"
      ],
      "external_id": "9a062745f628f66e34f865a47d58713f12e59ac9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/installation/cocoapods-installation/",
      "published_at": "2021-10-24T16:53:24Z",
      "updated_at": "2021-10-01T20:15:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "These procedures apply to iOS apps using Cocoapods. For other types, see iOS installation and configuration. Install your iOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. To install and configure your iOS application: Go to one.newrelic.com. If applicable: From the Mobile Apps list, select Add a new app. From the Get Started page, select iOS as the platform for mobile monitoring. Type a name for your mobile app, then select Continue. If your installation does not automatically include the prefix header, follow the steps to add the prefix header to your project. Continue with the steps to configure New Relic for mobile monitoring. Configure using Objective-C These procedures to configure your iOS app with CocoaPods and Objective-C also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy In your APP_NAME-Prefix.pch project file (generally found in the Supporting Files folder), include the New Relic header inside the #ifdef __OBJC__ #endif block: #import <NewRelic/NewRelic.h> Copy In your AppDelegate.m file, add this call as the first line of application:didFinishLaunchingWithOptions, replacing APP_TOKEN with your application token: [NewRelic startWithApplicationToken:@\"APP_TOKEN\"]; Copy Important The agent must be on the first line of didFinishLaunchingWithOptions and run on the main thread to ensure proper instrumentation. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Add a build script to your target's Build Phases. Ensure the new build script is the very last build script. Then paste the following, replacing APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"APP_TOKEN\" Copy Clean and build your app, then run it in the simulator or other device. Configure using Swift These procedures to configure your iOS app with CocoaPods and Swift also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy Create a bridging header: Select File > New > File > Objective-C File. Name the file Placeholder.m, then select Next. Select Create, and confirm Xcode's prompt to generate the bridging header. In your APP_NAME-Bridging-Header.h, add the New Relic header: #import \"NewRelic/NewRelic.h\" Copy In your AppDelegate.swift file, add this call as the first line of application:didFinishLaunchingWithOptions, replacing APP_TOKEN with your application token: NewRelic.start(withApplicationToken:\"APP_TOKEN\") Copy Important To ensure proper instrumentation, you must call the agent on the first line of didFinishLaunchingWithOptions(), and run the agent on the main thread. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Add a build script to your target's Build Phases. Ensure the new build script is the very last build script. Then paste the following, replacing APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"APP_TOKEN\" Copy Clean and build your app, then run it in the simulator or other device. Change the logging level (optional) Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add this method call before calling NewRelic.start(withApplicationToken): [NRLogger setLogLevels:NRLogLevelALL]; Copy For Swift apps: NRLogger.setLogLevels(NRLogLevelALL.rawValue) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 179.38449,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "CocoaPods <em>installation</em>",
        "sections": "<em>Install</em> your <em>iOS</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " <em>mobile</em> app you <em>monitor</em> in <em>New</em> <em>Relic</em>. To install and configure your <em>iOS</em> application: Go to one.newrelic.com. If applicable: From the <em>Mobile</em> Apps list, select Add a <em>new</em> app. From the Get Started page, select <em>iOS</em> as the platform for <em>mobile</em> <em>monitoring</em>. Type a name for your <em>mobile</em> app, then select Continue"
      },
      "id": "603ea15d64441fef3d4e8867"
    },
    {
      "sections": [
        "Upgrade the iOS agent",
        "Replace your iOS framework"
      ],
      "title": "Upgrade the iOS agent",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Installation"
      ],
      "external_id": "f51e93fbddfa6fd7b531f2b8dc071cfebb8c7fc9",
      "image": "https://docs.newrelic.com/static/ce6f593163d7f9a6c7a72509d4d947bd/8c557/screen-mobile-monitoring-upgrade-ios_0.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/installation/upgrade-new-relic-mobiles-ios-sdk/",
      "published_at": "2021-10-24T16:07:06Z",
      "updated_at": "2021-07-09T14:20:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You must be an account Admin to install, configure, and upgrade the iOS agent. For information about the latest version, refer to the release notes. Replace your iOS framework Admins: You must replace the earlier version of your iOS agent framework before upgrading to a newer version of the iOS SDK. Here is an example of the workflow to remove your existing iOS agent framework so you can replace it with a newer version. From the Project Navigator (CMD 1) in Xcode, search for NewRelicAgent.framework. Right-click or control-click NewRelicAgent.framework, and select Show in Finder. Drag NewRelicAgent.framework to the trash. Verify that the Xcode project highlights the reference to NewRelicAgent.framework in red. Right-click or control-click NewRelicAgent.framework, and select Delete to remove the obsolete reference from the project. Continue with the standard installation procedures for iOS app monitoring at one.newrelic.com > Mobile > (select an app) > Settings > Installation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 144.4917,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Upgrade the <em>iOS</em> agent",
        "sections": "Upgrade the <em>iOS</em> agent",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " <em>NewRelic</em>Agent.framework to the trash. Verify that the Xcode project highlights the reference to <em>NewRelic</em>Agent.framework in red. Right-click or control-click <em>NewRelic</em>Agent.framework, and select Delete to remove the obsolete reference from the project. Continue with the standard <em>installation</em> procedures for <em>iOS</em> app <em>monitoring</em> at one.newrelic.com &gt; <em>Mobile</em> &gt; (select an app) &gt; Settings &gt; <em>Installation</em>."
      },
      "id": "603eab6a196a672442a83da7"
    },
    {
      "sections": [
        "Upload dSYM files",
        "Automatic script",
        "Identify missing dSYMs",
        "Upload dSYM files through the mobile monitoring UI",
        "Manually upload dSYM files",
        "Via Python script (agent versions 6.0.0 or higher)",
        "Via command line",
        "Troubleshooting",
        "Auto-upload failure",
        "Missing dSYMs"
      ],
      "title": "Upload dSYM files",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "3655f49cf0e1ae693de0f8ea45bf4e5e6437e399",
      "image": "https://docs.newrelic.com/static/5c859575f391fbb1eaa18243a8c97000/8c557/Screen-Shot-2014-09-23-at-11.30.35-AM_0.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/upload-dsyms-bitcode-apps/",
      "published_at": "2021-10-24T16:52:30Z",
      "updated_at": "2021-09-27T15:06:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your app's dSYM files are stored in Xcode's dSYM archive path folder. This is the folder where the iOS agent gets the dSYM files that are used to symbolicate your crash reports. New Relic provides a post-build script as part of the iOS agent's install process and the tvOS agent's install process. This script automatically uploads your app's dSYM files. Automatic script The script automatically uploads dSYM files only for release builds. Non-release builds must upload their files either manually or through the mobile monitoring UI. Bitcode-enabled apps have their dSYM files generated by Apple. You must download the dSYM files for Bitcode-enabled apps from Apple and upload them to New Relic. If you see unreadable machine code in the Crashes page, your dSYM files may not be uploaded correctly. In some cases, you may need to manually upload dSYM files. The automatic script uses Python 2. As of October 2019 with macOS 10.15 (Catalina), Python won't be installed by default. If you're using the automatic script (recommended), you may need to manually install Python 2. If you're using Homebrew, see Python on Homebrew. Identify missing dSYMs When a Bitcode-enabled app is uploaded to Apple for App Store review or ad-hoc distribution, dSYMs need to be manually downloaded from Apple and uploaded to New Relic to allow the mobile crash reports to be properly symbolicated. These dSYMs can be downloaded through the archives organizer in Xcode within several minutes of uploading the app. In this situation follow the procedures to find the archive and download dSYMs. If an app is missing a dSYM file, you'll see three indicators in the mobile monitoring UI: Banner notification: A banner warning appears on the Crash report page. The warning reads: We were unable to locate your dsym. Copy Upload prompt: From the Crash type summary page you will be automatically prompted to upload a dSYM file if it is missing. Machine code: The crash stack trace on the Crash report page displays machine code and not a human-readable error message. Upload dSYM files through the mobile monitoring UI You can easily upload your dSYM files directly from the New Relic One UI. The maximum file size is 600 MB. To upload your dSYM files: Go to one.newrelic.com and click Mobile. Then select your app from the list. View Crash analysis. Select a specific crash from the Crash types list. Click Upload dSYM. You can either drag and drop your dSYMs directly, or select the file form your computer. Manually upload dSYM files In some circumstances, New Relic's automatic upload of dSYM files may fail. If a dSYM upload is attempted and fails, it creates a build error with a detailed message. For example, if there's a network failure and the dSYM upload isn't completed, Xcode will report an error. For additional information about how New Relic handles dSYM uploads, see New Relic's Online Technical Community. If the automatic upload fails, you can manually upload your dSYM file. If you have multiple dSYM files, they can be within a single zip with a maximum file size of 600 MB. The YOUR_NEW_RELIC_APPLICATION_TOKEN value in the commands below is the same key used for +[NewRelic startWithApplicationToken:] (in Objective-C) or NewRelic.start(withApplicationToken:) (in Swift). To manually upload your dSYM files: Via Python script (agent versions 6.0.0 or higher) In iOS agent versions 6.0.0 or higher, the agent includes a Python script that automatically processes and uploads symbols. You can call this script from the command line: NewRelicAgent.framework/Resources/generateMap.py \"DSYM_ARCHIVE_PATH\" \"YOUR_NEW_RELIC_APPLICATION_TOKEN\" Copy Via command line To manually upload individual dSYM files from the command line: Zip up your dSYM file or files using the following command. Replace ~ /ZIPPED_DSYM_PATH with your new dSYM archive path and file name (for example, Users/my-name/desktop). Also replace ~ /dSYM_PATH with your existing dSYM file path. /usr/bin/zip --recurse-paths --quiet \"~/ZIPPED_DSYM_PATH\" \"~/dSYM_PATH\" Copy Upload the dSYM zip file using the following command: For US accounts: curl -F dsym=@\"~/DSYM_ZIP_PATH\" -H \"X-APP-LICENSE-KEY: YOUR_NEW_RELIC_APPLICATION_TOKEN\" https://mobile-symbol-upload.newrelic.com/symbol Copy For EU accounts: curl -F dsym=@\"~/DSYM_ZIP_PATH\" -H \"X-APP-LICENSE-KEY: YOUR_NEW_RELIC_APPLICATION_TOKEN\" https://mobile-symbol-upload.eu01.nr-data.net/symbol Copy Troubleshooting Auto-upload failure If a dSYM auto-upload failed, the Report Navigator may have a fully formed cURL command. You can use this cURL command to reattempt an upload. Depending on the error, you may also need to follow some of the dSYM manual upload steps. Here is an example of a successful dSYM upload in the Report Navigator: Example: A successful dSYM upload in the Report Navigator. Missing dSYMs If dSYM files are missing, you may need to check Xcode build settings to ensure the file is being generated. Frameworks which are built locally have separate build settings and may need to be updated as well. Build settings: Debug Information Format : Dwarf with dSYM File Deployment Postprocessing: Yes Strip Linked Product: Yes Strip Debug Symbols During Copy : Yes Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.81871,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Upload dSYM files through the <em>mobile</em> <em>monitoring</em> UI",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Your app&#x27;s dSYM files are stored in Xcode&#x27;s dSYM archive path folder. This is the folder where the <em>iOS</em> agent gets the dSYM files that are used to symbolicate your crash reports. <em>New</em> <em>Relic</em> provides a post-build script as part of the <em>iOS</em> agent&#x27;s install process and the tv<em>OS</em> agent&#x27;s install process"
      },
      "id": "60441960e7b9d24f705799ca"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/installation/spm-installation": [
    {
      "sections": [
        "Install the infrastructure monitoring agent for Linux",
        "Quick start",
        "Tip",
        "Step-by-step instructions",
        "Debian",
        "Ubuntu",
        "Amazon Linux, CentOS, RHEL",
        "SLES",
        "Important",
        "Amazon Linux",
        "CentOS / RHEL & Oracle Linux",
        "Root (default)",
        "Privileged user",
        "Unprivileged user",
        "Install using configuration management tools",
        "Install for Docker containers on instrumented hosts",
        "Install using Azure extensions",
        "Install using tarball files",
        "Update the agent",
        "What's next?"
      ],
      "title": "Install the infrastructure monitoring agent for Linux",
      "type": "docs",
      "tags": [
        "Infrastructure",
        "Install the infrastructure agent",
        "Linux installation"
      ],
      "external_id": "060512e99d6143e7a7e8e6d16ba96cdcc7534e57",
      "image": "https://docs.newrelic.com/static/8de19e871ebba1c3d12258efc569dc6f/103b3/amazon-linux.png",
      "url": "https://docs.newrelic.com/docs/infrastructure/install-infrastructure-agent/linux-installation/install-infrastructure-monitoring-agent-linux/",
      "published_at": "2021-10-24T20:52:41Z",
      "updated_at": "2021-10-24T20:52:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our infrastructure monitoring agent for Linux can be installed using several package managers. You can use our launcher, or follow the instructions in this document to complete a basic installation. No matter which installation option you choose, make sure you've created a free New Relic account (No credit card required). Quick start The quickest way to get started with our infrastructure monitoring agent is through our guided install. Tip Try our guided install for yourself. (If you're hosted in the EU, use our EU guided install.) Step-by-step instructions If guided install doesn't work, you can install the agent manually. Before installing infrastructure, be sure to: Review the requirements. Have a valid New Relic license key. To install infrastructure in Linux, follow these instructions: Create the configuration file and add your license key: echo \"license_key: YOUR_LICENSE_KEY\" | sudo tee -a /etc/newrelic-infra.yml Copy Determine the distribution version number: Debian cat /etc/os-release Copy Ubuntu cat /etc/lsb-release Copy Amazon Linux, CentOS, RHEL cat /etc/os-release Copy SLES cat /etc/os-release | grep VERSION_ID Copy Enable New Relic's GPG key. Debian curl -s https://download.newrelic.com/infrastructure_agent/gpg/newrelic-infra.gpg | sudo apt-key add - Copy Ubuntu curl -s https://download.newrelic.com/infrastructure_agent/gpg/newrelic-infra.gpg | sudo apt-key add - Copy Amazon Linux, CentOS, RHEL yum automatically installs the GPG key using the value in gpgkey. SLES curl https://download.newrelic.com/infrastructure_agent/gpg/newrelic-infra.gpg -s | sudo gpg --import Copy Important There's a known issue with the zypper package manager where GPG keys may not be validated as expected. If you get errors such as Signature verification failed, see New Relic's Explorers Hub for more information. Add the infrastructure monitoring agent repository: Debian Debian 8 (\"Jessie\") printf \"deb https://download.newrelic.com/infrastructure_agent/linux/apt jessie main\" | sudo tee -a /etc/apt/sources.list.d/newrelic-infra.list Copy Debian 9 (\"Stretch\") printf \"deb https://download.newrelic.com/infrastructure_agent/linux/apt stretch main\" | sudo tee -a /etc/apt/sources.list.d/newrelic-infra.list Copy Debian 10 (\"Buster\") printf \"deb https://download.newrelic.com/infrastructure_agent/linux/apt buster main\" | sudo tee -a /etc/apt/sources.list.d/newrelic-infra.list Copy Debian 11 (\"Bullseye\") printf \"deb https://download.newrelic.com/infrastructure_agent/linux/apt bullseye main\" | sudo tee -a /etc/apt/sources.list.d/newrelic-infra.list Copy Ubuntu Ubuntu 16 (\"Xenial\") printf \"deb https://download.newrelic.com/infrastructure_agent/linux/apt xenial main\" | sudo tee -a /etc/apt/sources.list.d/newrelic-infra.list Copy Ubuntu 18 (\"Bionic\") printf \"deb https://download.newrelic.com/infrastructure_agent/linux/apt bionic main\" | sudo tee -a /etc/apt/sources.list.d/newrelic-infra.list Copy Ubuntu 20 (\"Focal\") printf \"deb https://download.newrelic.com/infrastructure_agent/linux/apt focal main\" | sudo tee -a /etc/apt/sources.list.d/newrelic-infra.list Copy Ubuntu 20.10 (\"Groovy\") printf \"deb https://download.newrelic.com/infrastructure_agent/linux/apt groovy main\" | sudo tee -a /etc/apt/sources.list.d/newrelic-infra.list Copy Ubuntu 21.04 (\"Hirsute Hippo\") printf \"deb https://download.newrelic.com/infrastructure_agent/linux/apt hirsute main\" | sudo tee -a /etc/apt/sources.list.d/newrelic-infra.list Copy Amazon Linux Amazon Linux 2 (x86) sudo curl -o /etc/yum.repos.d/newrelic-infra.repo https://download.newrelic.com/infrastructure_agent/linux/yum/amazonlinux/2/x86_64/newrelic-infra.repo Copy Amazon Linux 2 (arm64) sudo curl -o /etc/yum.repos.d/newrelic-infra.repo https://download.newrelic.com/infrastructure_agent/linux/yum/amazonlinux/2/aarch64/newrelic-infra.repo Copy CentOS / RHEL & Oracle Linux CentOS, RHEL, Oracle Linux 7.x (x86) sudo curl -o /etc/yum.repos.d/newrelic-infra.repo https://download.newrelic.com/infrastructure_agent/linux/yum/el/7/x86_64/newrelic-infra.repo Copy CentOS RHEL, Oracle Linux 7.x (arm64) sudo curl -o /etc/yum.repos.d/newrelic-infra.repo https://download.newrelic.com/infrastructure_agent/linux/yum/el/7/aarch64/newrelic-infra.repo Copy CentOS, RHEL, Oracle Linux (x86) sudo curl -o /etc/yum.repos.d/newrelic-infra.repo https://download.newrelic.com/infrastructure_agent/linux/yum/el/8/x86_64/newrelic-infra.repo Copy CentOS, RHEL, Oracle Linux 8.x (arm64) sudo curl -o /etc/yum.repos.d/newrelic-infra.repo https://download.newrelic.com/infrastructure_agent/linux/yum/el/8/aarch64/newrelic-infra.repo Copy SLES SLES 11.4 (x86) sudo curl -o /etc/zypp/repos.d/newrelic-infra.repo https://download.newrelic.com/infrastructure_agent/linux/zypp/sles/11.4/x86_64/newrelic-infra.repo Copy SLES 12.1 (x86) sudo curl -o /etc/zypp/repos.d/newrelic-infra.repo https://download.newrelic.com/infrastructure_agent/linux/zypp/sles/12.1/x86_64/newrelic-infra.repo Copy SLES 12.1 (ARM) sudo curl -o /etc/zypp/repos.d/newrelic-infra.repo https://download.newrelic.com/infrastructure_agent/linux/zypp/sles/12.1/aarch64/newrelic-infra.repo Copy SLES 12.2 (x86) sudo curl -o /etc/zypp/repos.d/newrelic-infra.repo https://download.newrelic.com/infrastructure_agent/linux/zypp/sles/12.2/x86_64/newrelic-infra.repo Copy SLES 12.2 (ARM) sudo curl -o /etc/zypp/repos.d/newrelic-infra.repo https://download.newrelic.com/infrastructure_agent/linux/zypp/sles/12.2/aarch64/newrelic-infra.repo Copy SLES 12.3 (x86) sudo curl -o /etc/zypp/repos.d/newrelic-infra.repo https://download.newrelic.com/infrastructure_agent/linux/zypp/sles/12.3/x86_64/newrelic-infra.repo Copy SLES 12.3 (ARM) sudo curl -o /etc/zypp/repos.d/newrelic-infra.repo https://download.newrelic.com/infrastructure_agent/linux/zypp/sles/12.3/aarch64/newrelic-infra.repo Copy SLES 12.4 (x86) sudo curl -o /etc/zypp/repos.d/newrelic-infra.repo https://download.newrelic.com/infrastructure_agent/linux/zypp/sles/12.4/x86_64/newrelic-infra.repo Copy SLES 12.4 (ARM) sudo curl -o /etc/zypp/repos.d/newrelic-infra.repo https://download.newrelic.com/infrastructure_agent/linux/zypp/sles/12.4/aarch64/newrelic-infra.repo Copy SLES 12.5 (x86) sudo curl -o /etc/zypp/repos.d/newrelic-infra.repo https://download.newrelic.com/infrastructure_agent/linux/zypp/sles/12.5/x86_64/newrelic-infra.repo Copy SLES 12.5 (ARM) sudo curl -o /etc/zypp/repos.d/newrelic-infra.repo https://download.newrelic.com/infrastructure_agent/linux/zypp/sles/12.5/aarch64/newrelic-infra.repo Copy SLES 15.1 (x86) sudo curl -o /etc/zypp/repos.d/newrelic-infra.repo https://download.newrelic.com/infrastructure_agent/linux/zypp/sles/15.1/x86_64/newrelic-infra.repo Copy SLES 15.1 (ARM) sudo curl -o /etc/zypp/repos.d/newrelic-infra.repo https://download.newrelic.com/infrastructure_agent/linux/zypp/sles/15.1/aarch64/newrelic-infra.repo Copy SLES 15.2 (x86) sudo curl -o /etc/zypp/repos.d/newrelic-infra.repo https://download.newrelic.com/infrastructure_agent/linux/zypp/sles/15.2/x86_64/newrelic-infra.repo Copy SLES 15.2 (ARM) sudo curl -o /etc/zypp/repos.d/newrelic-infra.repo https://download.newrelic.com/infrastructure_agent/linux/zypp/sles/15.2/aarch64/newrelic-infra.repo Copy SLES 15.3 (x86) sudo curl -o /etc/zypp/repos.d/newrelic-infra.repo https://download.newrelic.com/infrastructure_agent/linux/zypp/sles/15.3/x86_64/newrelic-infra.repo Copy SLES 15.3 (ARM) sudo curl -o /etc/zypp/repos.d/newrelic-infra.repo https://download.newrelic.com/infrastructure_agent/linux/zypp/sles/15.3/aarch64/newrelic-infra.repo Copy Refresh the repositories: Debian sudo apt-get update Copy Ubuntu sudo apt-get update Copy Amazon Linux, CentOS, RHEL sudo yum -q makecache -y --disablerepo='*' --enablerepo='newrelic-infra' Copy SLES sudo zypper -n ref -r newrelic-infra Copy Install the newrelic-infra package in root (default), privileged user, or unprivileged user mode. For more information on each running mode, see Linux agent running modes. Root (default) Debian and Ubuntu: sudo apt-get install newrelic-infra -y Copy Amazon Linux, CentOS, RHEL: sudo yum install newrelic-infra -y Copy SLES: sudo zypper -n install newrelic-infra Copy Privileged user Install the libcap library and set the NRIA_MODE environment variable to PRIVILEGED. Debian and Ubuntu: sudo apt-get install libcap2-bin Copy sudo NRIA_MODE=\"PRIVILEGED\" apt-get install newrelic-infra Copy Amazon Linux, CentOS, RHEL: sudo yum install libcap Copy sudo NRIA_MODE=\"PRIVILEGED\" yum install newrelic-infra Copy SLES: sudo zypper install libcap-progs Copy sudo NRIA_MODE=\"PRIVILEGED\" zypper install newrelic-infra Copy Unprivileged user Install the libcap library and set the NRIA_MODE environment variable to UNPRIVILEGED. Debian and Ubuntu: sudo apt-get install libcap2-bin Copy sudo NRIA_MODE=\"UNPRIVILEGED\" apt-get install newrelic-infra Copy Amazon Linux, CentOS, RHEL: sudo yum install libcap Copy sudo NRIA_MODE=\"UNPRIVILEGED\" yum install newrelic-infra Copy SLES: sudo zypper install libcap-progs Copy sudo NRIA_MODE=\"UNPRIVILEGED\" zypper install newrelic-infra Copy Once the infrastructure monitoring agent is installed or updated, you can start, stop, or check the agent status. Important As of version 1.4.0, the infrastructure monitoring agent package includes the additional newrelic-infra-ctl binary, which is used to help troubleshoot a running agent. Although this binary is not required to execute the agent, we recommend to add it in your path. Install using configuration management tools To install the infrastructure monitoring agent with a configuration management tool, see the documentation for: Ansible Chef Docker (install as container) Elastic Beanstalk Puppet Install for Docker containers on instrumented hosts See Docker instrumentation for infrastructure monitoring. Install using Azure extensions See Azure extensions for infrastructure monitoring. Install using tarball files For custom setup scenarios, you can install the infrastructure monitoring agent using our tarball files in assisted or manual modes. This is especially useful when you need to adapt the default installation settings to your environment, or to install the infrastructure monitoring agent on distributions that lack the newrelic-infra package in their repositories. Important Installing the agent using tarball files is officially supported only for the AWS Graviton 2 processor. Update the agent Follow standard procedures to update the infrastructure monitoring agent. If you are using sudo to install or update the agent, use the -E argument to allow bypassing the environment variables, or specify the NRIA_MODE environment variable just after sudo. export NRIA_MODE=\"SET_MODE_HERE\" Copy OR sudo -E YOUR_PACKAGE_MANAGER_UPDATE_COMMAND Copy What's next? Generate some traffic and wait a few minutes, then view your hosts in the New Relic One UI. If necessary, follow our troubleshooting procedures if no data appears. Important The hostname for your server cannot be localhost. Data will not be reported for servers with that name. Make sure the host name uses a unique name. The only required configuration option is the license_key setting, which is created as part of the installation procedures. You may also want to: Add custom attributes to annotate your infrastructure data. Connect your AWS account if your servers are hosted on Amazon EC2. Enable log forwarding. Add other New Relic infrastructure integrations to collect data from external services.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 354.50153,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> the infrastructure monitoring agent for Linux",
        "sections": "<em>Install</em> using configuration <em>management</em> tools",
        "tags": "Linux <em>installation</em>",
        "body": "Our infrastructure monitoring agent for Linux can be installed using several <em>package</em> managers. You can use our launcher, or follow the instructions in this document to complete a basic <em>installation</em>. No matter which <em>installation</em> option you choose, make sure you&#x27;ve created a free New Relic account"
      },
      "id": "6043edce64441f5335378f15"
    },
    {
      "sections": [
        "Update the PHP agent",
        "Use the newrelic-php5 package",
        "Tip",
        "Update using your package manager",
        "RedHat or CentOS",
        "Ubuntu or Debian",
        "Update unsupported agent versions",
        "Important",
        "Troubleshooting after update",
        "For more help"
      ],
      "title": "Update the PHP agent",
      "type": "docs",
      "tags": [
        "Agents",
        "PHP agent",
        "Installation"
      ],
      "external_id": "baf6b18412229bab77695136999a7dd8c6a35a71",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/php-agent/installation/update-php-agent/",
      "published_at": "2021-10-23T22:50:59Z",
      "updated_at": "2021-10-23T22:48:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To take full advantage of New Relic's latest features, enhancements, and important security patches, we recommend you update your PHP agent to the latest version. For additional information about specific agent updates, refer to the PHP agent release notes. This document explains how to update the agent for: RedHat and CentOS Ubuntu and Debian To update via tar archive, follow the tar archive installation procedures. (Procedures to install and update with the tar archive are the same.) Use the newrelic-php5 package The package name for the New Relic for PHP agent is newrelic-php5. Tip Although the name references PHP 5, this package works for all supported PHP versions, including PHP 7 versions. Update using your package manager To update the PHP agent: Replace the agent files using your preferred package manager for your system: RedHat or CentOS Manager Procedures yum If you are using the New Relic repositories directly, update to the latest agent using the following command: sudo yum update newrelic-php5 Copy 32-bit rpm Download the newest version of the .rpm files from the New Relic downloads page, and run the following command. Make sure to replace X.X.X.X with the latest New Relic for PHP version number. rpm -i newrelic-php5-common-X.X.X.X-1.noarch.rpm newrelic-daemon-X.X.X.X-1.i386.rpm newrelic-php5-X.X.X.X-1.i386.rpm Copy 64-bit rpm Download the newest version of the .rpm files from the New Relic downloads page, and run the following command. Make sure to replace X.X.X.X with the latest New Relic for PHP version number. rpm -i newrelic-php5-common-X.X.X.X-1.noarch.rpm newrelic-daemon-X.X.X.X-1.x86_64.rpm newrelic-php5-X.X.X.X-1.x86_64.rpm Copy Ubuntu or Debian Manager Procedures apt-get If you are using the New Relic repositories directly, update to the latest agent using the following command: apt-get update apt-get install newrelic-php5 Copy 32-bit dpkg Download the newest version of the .deb files from the New Relic downloads page, and run the following command. Make sure to replace X.X.X.X with the latest New Relic for PHP version number. dpkg -i newrelic-php5-common_X.X.X.X_all.deb newrelic-daemon_X.X.X.X_i386.deb newrelic-php5_X.X.X.X_i386.deb Copy 64-bit dpkg Download the newest version of the .deb files from the New Relic downloads page, and run the following command. Make sure to replace X.X.X.X with the latest New Relic for PHP version number. dpkg -i newrelic-php5-common_X.X.X.X_all.deb newrelic-daemon_X.X.X.X_amd64.deb newrelic-php5_X.X.X.X_amd64.deb Copy RedHat or CentOS: Run the newrelic-install script, and follow the install script's confirmation prompt before overwriting an old installation. sudo newrelic-install install Copy Ubuntu or Debian: Follow the package manager's prompts to run the newrelic-install script as part of its installation process. Stop any residual newrelic-daemon processes by running kill $(pgrep newrelic-daemon) Copy If the newrelic-daemon is configured to start in external mode, use your operating system's service manager to restart it. Restart your web server (Apache, Nginx, PHP-FPM, etc.). Wait a few minutes for your application to send data to New Relic. Update unsupported agent versions Important If you are updating from an older agent version, including major version jumps, review the following list for changes in functionality. Migration Comments 8.0.0.204 Release notes: PHP agent 8.0.0.204 TLS replaces the newrelic.daemon.ssl ini setting. To increase security, the newrelic.daemon.ssl ini setting has been removed. Transport Layer Security (TLS) will now always be used in communication with the New Relic collector. 7.0.0.186 Release notes: PHP agent 7.0.0.186 PHP 5.2 is no longer supported. New Relic highly encourages you to use a supported version of PHP (5.6 or higher). If you want to continue running the New Relic PHP agent with PHP 5.2, we recommend using agent version 6.9. However, in this case, we can only offer limited support. 5.0.0.115 Release notes: PHP agent 5.0.0.115 Daemon command line flags have been renamed. For customers who start the daemon manually, you can find the newly renamed command line flags with the -h or --help flags. The following old flags will be removed in a future release: [ -p pidfile] [ -d level] [ -c config] [ -l logfile] [ -P port] [ -s] [ -n] [ -b SSL-certificate-bundle] [ -S SSL-certificate-path] [ -H host] [ -x proxy] [ -a auditlog] Troubleshooting after update If you updated PHP and the agent stopped working or reporting data, follow the troubleshooting procedures. For more help If you need more help, check out these support and learning resources: Suggest a change and learn how to contribute to our PHP agent open source repository. Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 338.35693,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Update using your <em>package</em> <em>manager</em>",
        "tags": "<em>Installation</em>",
        "body": " Ubuntu or Debian: Follow the <em>package</em> <em>manager</em>&#x27;s prompts to run the newrelic-install script as part of its <em>installation</em> process. Stop any residual newrelic-daemon processes by running kill $(pgrep newrelic-daemon) Copy If the newrelic-daemon is configured to start in external mode, use your operating"
      },
      "id": "6174913528ccbc853bc6c0a0"
    },
    {
      "sections": [
        "Introduction to New Relic for Python",
        "Monitor app performance",
        "Install the Python agent",
        "Monitor non-web scripts, background tasks, and functions",
        "What's next after installation?",
        "Troubleshooting",
        "Check the source code"
      ],
      "title": "Introduction to New Relic for Python",
      "type": "docs",
      "tags": [
        "Agents",
        "Python agent",
        "Getting started"
      ],
      "external_id": "e3621b5589469c2b3b20d5d140027e5c105e1dd3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/python-agent/getting-started/introduction-new-relic-python/",
      "published_at": "2021-10-24T11:20:53Z",
      "updated_at": "2021-10-23T23:39:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Python agent monitors your Python application to help you identify and solve performance issues. You can also extend your performance monitoring to collect and analyze business data to help you improve the customer experience and make data-driven business decisions. With flexible options for custom instrumentation and APIs, The Python agent offers multiple building blocks to customize the data you need from your app. Our Python works with a wide variety of web frameworks and hosting mechanisms, including Django, Gunicorn, WSGI, CherryPy, uWSGI, and more. You can also install the Python agent in a Google App Engine flexible environment. Monitor app performance After you install the Python agent, it begins to collect data about your app. You can view the data as charts and tables in New Relic One. View the big picture of your app. Monitor your app's Apdex (user satisfaction). Get a high-level summary of your app with Summary page. Enable distributed tracing to see activity across an architecture having many services. Install Infrastructure monitoring and view detailed server/host data for your app. Find errors and problems quickly. Track key transactions specific to your business. Create custom dashboards for important metrics. Alert your team when an error or problem occurs before it affects your users. View performance after a deployment. Drill down into performance details. Examine code-level transaction traces. Examine database query traces. Examine error traces. Use thread profiler sessions to see detailed stack traces of sampled threads Other helpful tools include: Tools Description Browser monitoring Integrate the Python agent with browser monitoring to gain visibility into end-user browser activity. Simple scripts and background tasks Monitor job-based or task queuing systems, like Celery, or other standalone non-web functions. Business data analysis with data exploration. Use the Python agent with our data explorer to organize, query, and visualize your data to answer key questions about application performance and customer experience. Use default transaction attributes, or add your own. Query your data using the New Relic Query Language (NRQL). Send your own event data. Create and share customizable, interactive dashboards. Install the Python agent Before you install the Python agent, make sure your system meets the system requirements. You must also create a New Relic account. We support a number of web frameworks and libraries right out of the box, including Django, WSGI, and Gunicorn. If you use one of the supported web frameworks, installation is easy. If you use an unsupported framework, the process will involve some additions to your app code and/or web server files. For a quick and simple install process that will work for the majority of setups, follow these simple steps: Download and install the Python package. Create config file. Integrate the Python agent with your application. Read the Quick Start guide Add Python data Monitor non-web scripts, background tasks, and functions The Python agent also lets you monitor non-web scripts, worker processes, tasks, and functions. The installation process for these non-web transactions is similar to the one used for a web app, with one major difference: instead of going through the standard integration process described in the install instructions, you would manually \"wrap\" any function you want to monitor. For more information, see Non-web tasks and processes. For instructions on monitoring Celery tasks, see Celery background tasks. What's next after installation? Once you get the agent up and running, some suggested next steps are: Explore your data in and get comfortable with the user interface. Read our docs on our other observability solutions and the APM page. Change your application's name, or other configuration options. Learn about setting up custom instrumentation for application activity not monitored by default. Consider these open source telemetry tools: OpenCensus exporter and Python Telemetry SDK. Troubleshooting After you complete the install process, your data should appear in the APM UI within five minutes. If it does not, use these troubleshooting resources: If no data appears, follow these troubleshooting steps. If you experience issues when installing or running the Python agent on a new host, test that the package is installed correctly and that it can contact New Relic's data collector service. For other problems, see the full list of troubleshooting documentation. Check the source code The Python agent is open source software. That means you can browse its source code and send improvements, or create your own fork and build it. For more information, see the README.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 288.01205,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "What&#x27;s next after <em>installation</em>?",
        "body": " also create a New Relic account. We support a number of web frameworks and libraries right out of the box, including Django, WSGI, and Gunicorn. If you use one of the supported web frameworks, <em>installation</em> is easy. If you use an unsupported framework, the process will involve some additions to your"
      },
      "id": "61749d4d196a6727702f1368"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/installation/upgrade-new-relic-mobiles-ios-sdk": [
    {
      "sections": [
        "CocoaPods installation",
        "Install your iOS application",
        "Configure using Objective-C",
        "Important",
        "Configure using Swift",
        "Change the logging level (optional)"
      ],
      "title": "CocoaPods installation",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Installation"
      ],
      "external_id": "9a062745f628f66e34f865a47d58713f12e59ac9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/installation/cocoapods-installation/",
      "published_at": "2021-10-24T16:53:24Z",
      "updated_at": "2021-10-01T20:15:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "These procedures apply to iOS apps using Cocoapods. For other types, see iOS installation and configuration. Install your iOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. To install and configure your iOS application: Go to one.newrelic.com. If applicable: From the Mobile Apps list, select Add a new app. From the Get Started page, select iOS as the platform for mobile monitoring. Type a name for your mobile app, then select Continue. If your installation does not automatically include the prefix header, follow the steps to add the prefix header to your project. Continue with the steps to configure New Relic for mobile monitoring. Configure using Objective-C These procedures to configure your iOS app with CocoaPods and Objective-C also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy In your APP_NAME-Prefix.pch project file (generally found in the Supporting Files folder), include the New Relic header inside the #ifdef __OBJC__ #endif block: #import <NewRelic/NewRelic.h> Copy In your AppDelegate.m file, add this call as the first line of application:didFinishLaunchingWithOptions, replacing APP_TOKEN with your application token: [NewRelic startWithApplicationToken:@\"APP_TOKEN\"]; Copy Important The agent must be on the first line of didFinishLaunchingWithOptions and run on the main thread to ensure proper instrumentation. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Add a build script to your target's Build Phases. Ensure the new build script is the very last build script. Then paste the following, replacing APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"APP_TOKEN\" Copy Clean and build your app, then run it in the simulator or other device. Configure using Swift These procedures to configure your iOS app with CocoaPods and Swift also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy Create a bridging header: Select File > New > File > Objective-C File. Name the file Placeholder.m, then select Next. Select Create, and confirm Xcode's prompt to generate the bridging header. In your APP_NAME-Bridging-Header.h, add the New Relic header: #import \"NewRelic/NewRelic.h\" Copy In your AppDelegate.swift file, add this call as the first line of application:didFinishLaunchingWithOptions, replacing APP_TOKEN with your application token: NewRelic.start(withApplicationToken:\"APP_TOKEN\") Copy Important To ensure proper instrumentation, you must call the agent on the first line of didFinishLaunchingWithOptions(), and run the agent on the main thread. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Add a build script to your target's Build Phases. Ensure the new build script is the very last build script. Then paste the following, replacing APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"APP_TOKEN\" Copy Clean and build your app, then run it in the simulator or other device. Change the logging level (optional) Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add this method call before calling NewRelic.start(withApplicationToken): [NRLogger setLogLevels:NRLogLevelALL]; Copy For Swift apps: NRLogger.setLogLevels(NRLogLevelALL.rawValue) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 179.38448,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "CocoaPods <em>installation</em>",
        "sections": "<em>Install</em> your <em>iOS</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " <em>mobile</em> app you <em>monitor</em> in <em>New</em> <em>Relic</em>. To install and configure your <em>iOS</em> application: Go to one.newrelic.com. If applicable: From the <em>Mobile</em> Apps list, select Add a <em>new</em> app. From the Get Started page, select <em>iOS</em> as the platform for <em>mobile</em> <em>monitoring</em>. Type a name for your <em>mobile</em> app, then select Continue"
      },
      "id": "603ea15d64441fef3d4e8867"
    },
    {
      "sections": [
        "iOS manual installation",
        "Install your iOS application",
        "Add the New Relic framework to your app",
        "Important",
        "Optional: Execute a demo crash",
        "Optional: Change the logging level"
      ],
      "title": "iOS manual installation",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Installation"
      ],
      "external_id": "0a674eb7f3756cd5d124c6dcf2344edf38e40a8a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/installation/ios-manual-installation/",
      "published_at": "2021-10-24T16:52:30Z",
      "updated_at": "2021-07-27T15:09:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To install and configure New Relic functionality with your iOS applications, follow these procedures. If your iOS app uses Cocoapods, follow the Cocoapods installation procedures. Install your iOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. To install and configure your iOS application: Go to one.newrelic.com. If applicable: From the Mobile Apps index, select Add a new app. From the Get started page, select XCFramework as the platform for mobile monitoring. Type a name for your mobile app, and select Continue. Continue with the steps to configure New Relic. Add the New Relic framework to your app Download and unzip the iOS SDK for New Relic. To add the New Relic framework to your Xcode project: Use Finder to drag the NewRelicAgent.framework folder into your Xcode project, and drop it onto your project in the Project navigator window, under Frameworks, Libraries, and Embedded Content. Make sure Embed & Sign is selected under the Embed dropdown menu. Implement the agent using the appropriate method: Important To ensure proper instrumentation, you must call the agent on the first line of didFinishLaunchingWithOptions(), and run the agent on the main thread. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Language Procedure Objective-C To start the agent: Import the New Relic header at the top of your prefix.pch. Add +[NewRelic startWithApplicationToken:@\"<appToken>\"] to the top of -application:didFinishLaunchingWithOptions: in your AppDelegate.m, using the unique application token that is automatically generated. Swift Create a bridging header file: Select File > New > File > Objective-C File. Name the file Placeholder.m, then select Next. Select Create, and confirm Xcode's prompt to generate the bridging header. Delete Placeholder.m. Import the New Relic agent by adding #import \"NewRelic/NewRelic.h\" to the top of MyApp-Bridging-Header.h. Add NewRelic.start(withApplicationToken: \">appToken>\") to the top of application(_:didFinishLaunchingWithOptions:) in your AppDelegate.swift using the unique application token that is automatically generated. Add a build script to your target's Build Phases. Ensure the new build script is the very last build phase, then paste the following, replacing PUT_NEW_RELIC_APP_TOKEN_HERE with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"PUT_NEW_RELIC_APP_TOKEN_HERE\" Copy Clean and build your app, and then run it in the simulator or other device. Optional: Execute a demo crash If you have trouble getting your app to crash, the New Relic agent provides an API to execute a demo crash. Recommendation: Add one of these lines of code to a button click event handler as applicable: Language Code Objective-C Crash: [NewRelic crashNow]; Copy Crash with log message: [NewRelic crashNow:@\"<reason>\"]; Copy Swift Crash: NewRelic.crashNow() Copy Crash with log message: NewRelic.crashNow(_ message:) Copy Optional: Change the logging level Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add the following method: Language Code Objective-C Just before calling startWithApplicationToken in AppDelegate.m, add: [NRLogger setLogLevels:NRLogLevelALL]; Copy Swift Just before calling start(withApplicationToken:) in AppDelegate.swift, add: NRLogger.setLogLevels(NRLogLevelALL.rawValue) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 146.84671,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>iOS</em> manual <em>installation</em>",
        "sections": "<em>iOS</em> manual <em>installation</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " token. This is a 40-character hexadecimal string for authenticating each <em>mobile</em> app you <em>monitor</em> in <em>New</em> <em>Relic</em>. To install and configure your <em>iOS</em> application: Go to one.newrelic.com. If applicable: From the <em>Mobile</em> Apps index, select Add a <em>new</em> app. From the Get started page, select XCFramework"
      },
      "id": "603ea44864441f80904e8899"
    },
    {
      "sections": [
        "Upload dSYM files",
        "Automatic script",
        "Identify missing dSYMs",
        "Upload dSYM files through the mobile monitoring UI",
        "Manually upload dSYM files",
        "Via Python script (agent versions 6.0.0 or higher)",
        "Via command line",
        "Troubleshooting",
        "Auto-upload failure",
        "Missing dSYMs"
      ],
      "title": "Upload dSYM files",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "3655f49cf0e1ae693de0f8ea45bf4e5e6437e399",
      "image": "https://docs.newrelic.com/static/5c859575f391fbb1eaa18243a8c97000/8c557/Screen-Shot-2014-09-23-at-11.30.35-AM_0.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/upload-dsyms-bitcode-apps/",
      "published_at": "2021-10-24T16:52:30Z",
      "updated_at": "2021-09-27T15:06:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your app's dSYM files are stored in Xcode's dSYM archive path folder. This is the folder where the iOS agent gets the dSYM files that are used to symbolicate your crash reports. New Relic provides a post-build script as part of the iOS agent's install process and the tvOS agent's install process. This script automatically uploads your app's dSYM files. Automatic script The script automatically uploads dSYM files only for release builds. Non-release builds must upload their files either manually or through the mobile monitoring UI. Bitcode-enabled apps have their dSYM files generated by Apple. You must download the dSYM files for Bitcode-enabled apps from Apple and upload them to New Relic. If you see unreadable machine code in the Crashes page, your dSYM files may not be uploaded correctly. In some cases, you may need to manually upload dSYM files. The automatic script uses Python 2. As of October 2019 with macOS 10.15 (Catalina), Python won't be installed by default. If you're using the automatic script (recommended), you may need to manually install Python 2. If you're using Homebrew, see Python on Homebrew. Identify missing dSYMs When a Bitcode-enabled app is uploaded to Apple for App Store review or ad-hoc distribution, dSYMs need to be manually downloaded from Apple and uploaded to New Relic to allow the mobile crash reports to be properly symbolicated. These dSYMs can be downloaded through the archives organizer in Xcode within several minutes of uploading the app. In this situation follow the procedures to find the archive and download dSYMs. If an app is missing a dSYM file, you'll see three indicators in the mobile monitoring UI: Banner notification: A banner warning appears on the Crash report page. The warning reads: We were unable to locate your dsym. Copy Upload prompt: From the Crash type summary page you will be automatically prompted to upload a dSYM file if it is missing. Machine code: The crash stack trace on the Crash report page displays machine code and not a human-readable error message. Upload dSYM files through the mobile monitoring UI You can easily upload your dSYM files directly from the New Relic One UI. The maximum file size is 600 MB. To upload your dSYM files: Go to one.newrelic.com and click Mobile. Then select your app from the list. View Crash analysis. Select a specific crash from the Crash types list. Click Upload dSYM. You can either drag and drop your dSYMs directly, or select the file form your computer. Manually upload dSYM files In some circumstances, New Relic's automatic upload of dSYM files may fail. If a dSYM upload is attempted and fails, it creates a build error with a detailed message. For example, if there's a network failure and the dSYM upload isn't completed, Xcode will report an error. For additional information about how New Relic handles dSYM uploads, see New Relic's Online Technical Community. If the automatic upload fails, you can manually upload your dSYM file. If you have multiple dSYM files, they can be within a single zip with a maximum file size of 600 MB. The YOUR_NEW_RELIC_APPLICATION_TOKEN value in the commands below is the same key used for +[NewRelic startWithApplicationToken:] (in Objective-C) or NewRelic.start(withApplicationToken:) (in Swift). To manually upload your dSYM files: Via Python script (agent versions 6.0.0 or higher) In iOS agent versions 6.0.0 or higher, the agent includes a Python script that automatically processes and uploads symbols. You can call this script from the command line: NewRelicAgent.framework/Resources/generateMap.py \"DSYM_ARCHIVE_PATH\" \"YOUR_NEW_RELIC_APPLICATION_TOKEN\" Copy Via command line To manually upload individual dSYM files from the command line: Zip up your dSYM file or files using the following command. Replace ~ /ZIPPED_DSYM_PATH with your new dSYM archive path and file name (for example, Users/my-name/desktop). Also replace ~ /dSYM_PATH with your existing dSYM file path. /usr/bin/zip --recurse-paths --quiet \"~/ZIPPED_DSYM_PATH\" \"~/dSYM_PATH\" Copy Upload the dSYM zip file using the following command: For US accounts: curl -F dsym=@\"~/DSYM_ZIP_PATH\" -H \"X-APP-LICENSE-KEY: YOUR_NEW_RELIC_APPLICATION_TOKEN\" https://mobile-symbol-upload.newrelic.com/symbol Copy For EU accounts: curl -F dsym=@\"~/DSYM_ZIP_PATH\" -H \"X-APP-LICENSE-KEY: YOUR_NEW_RELIC_APPLICATION_TOKEN\" https://mobile-symbol-upload.eu01.nr-data.net/symbol Copy Troubleshooting Auto-upload failure If a dSYM auto-upload failed, the Report Navigator may have a fully formed cURL command. You can use this cURL command to reattempt an upload. Depending on the error, you may also need to follow some of the dSYM manual upload steps. Here is an example of a successful dSYM upload in the Report Navigator: Example: A successful dSYM upload in the Report Navigator. Missing dSYMs If dSYM files are missing, you may need to check Xcode build settings to ensure the file is being generated. Frameworks which are built locally have separate build settings and may need to be updated as well. Build settings: Debug Information Format : Dwarf with dSYM File Deployment Postprocessing: Yes Strip Linked Product: Yes Strip Debug Symbols During Copy : Yes Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.8187,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Upload dSYM files through the <em>mobile</em> <em>monitoring</em> UI",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Your app&#x27;s dSYM files are stored in Xcode&#x27;s dSYM archive path folder. This is the folder where the <em>iOS</em> agent gets the dSYM files that are used to symbolicate your crash reports. <em>New</em> <em>Relic</em> provides a post-build script as part of the <em>iOS</em> agent&#x27;s install process and the tv<em>OS</em> agent&#x27;s install process"
      },
      "id": "60441960e7b9d24f705799ca"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/crashnow-ios-sdk-api": [
    {
      "sections": [
        "Adding a prefix header to an iOS project"
      ],
      "title": "Adding a prefix header to an iOS project",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "11df0352a96527157fdd932f7a5bacf0beb8a0ae",
      "image": "https://docs.newrelic.com/static/89991d3f20208fe696e48b3143745df9/8c557/screen-ios-sdk-api-prefix-header.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/adding-prefix-header-ios-project/",
      "published_at": "2021-10-24T16:49:48Z",
      "updated_at": "2021-07-09T08:43:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Installing New Relic's iOS SDK API requires you to modify your project's prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File > New > File... From iOS template options, select Other > PCH file. Name the file < target_name>-Prefix.pch, and then select Create. From your targetâ€™s Build settings, select All, and then add the following to the Prefix Header field: $(SRCROOT)/<target_name>-Prefix.pch Copy Here is an example of using XcodeÂ to add a Prefix Header file to your iOS project for the iOS SDK API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 255.09283,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Adding a prefix header to an <em>iOS</em> project",
        "sections": "Adding a prefix header to an <em>iOS</em> project",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Installing <em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> <em>SDK</em> <em>API</em> requires you to modify your project&#x27;s prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File &gt; <em>New</em> &gt; File... From <em>iOS</em> template options, select Other &gt; PCH file. Name the file &lt; target_name&gt;-Prefix.pch"
      },
      "id": "6044195fe7b9d2f201579a09"
    },
    {
      "sections": [
        "Introduction to iOS monitoring",
        "Compatibility and requirements",
        "Install the agent",
        "Extend your instrumentation",
        "Troubleshoot your installation"
      ],
      "title": "Introduction to iOS monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "243234aeaa02a13856775f6f154cab24a1e5db26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios/",
      "published_at": "2021-10-24T16:51:42Z",
      "updated_at": "2021-07-08T01:46:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring for iOS gives you a comprehensive view of your app's performance. It works for iOS apps written using Objective-C, Swift, or both languages. For a general overview of mobile monitoring functionality, see Introduction to mobile monitoring. Compatibility and requirements Before you install the iOS agent, review the compatibility and requirements. Install the agent As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. There are two ways you can install the iOS agent: We recommend you install and configure the iOS agent using the CocoaPods installation method. You can also manually install and configure the iOS agent by adding the New Relic framework to your app. Extend your instrumentation After you install the agent, you can extend the agent's default instrumentation with various types of custom data: To access: In the mobile UI: In New Relic One dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. You can also query the custom events that you created in New Relic One dashboards and NRQL. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. iOS SDK API Use the iOS SDK API to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. Troubleshoot your installation If the agent isn't reporting data, try these troubleshooting suggestions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 232.07886,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "sections": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for <em>iOS</em> gives you a comprehensive view of your app&#x27;s performance. It works for <em>iOS</em> apps written using Objective-C, Swift, or both languages. For a general overview of <em>mobile</em> <em>monitoring</em> functionality, see Introduction to <em>mobile</em> <em>monitoring</em>. Compatibility and requirements"
      },
      "id": "6043a48fe7b9d2ad8d5799db"
    },
    {
      "sections": [
        "Report mobile monitoring custom events and attributes",
        "Create custom attributes and events",
        "Mobile event and attribute query examples",
        "Custom event example: Track purchases",
        "Tip",
        "Attribute example: Track a specific user",
        "Attribute example: Track a specific store id",
        "Custom attribute example: Track a specific action",
        "Important",
        "Size limits and restricted characters",
        "Set the time to send data",
        "Privacy considerations"
      ],
      "title": "Report mobile monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "65970eacbedb3360fd1c7394affc8cbc42f2ab0c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/report-mobile-monitoring-custom-events-attributes/",
      "published_at": "2021-10-24T14:59:18Z",
      "updated_at": "2021-10-23T21:59:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring in New Relic sends some default event data from your mobile app to New Relic, such as data about interactions, sessions, crashes, and request errors. You can also create your own custom attributes and events for more detailed querying and analysis. Create custom attributes and events You can create custom session-level attributes for default mobile monitoring events using the mobile agent SDKs. For example, to record a username attribute for some part of your iOS or Android app, you would use the setAttribute API (Android | iOS). These attributes are session-related information and are shared by multiple mobile event types. You can also create entirely new custom event types and assign them their own custom attributes, using the recordCustomEvent API (Android | iOS). To help with crash analysis, you can use the SDK to create MobileBreadcrumb and MobileHandledException events. These events are available for querying and also displayed in the crash event trail UI. For more on creating custom attributes and custom events, see: Android SDK API guide iOS SDK API guide NRQL query examples MobileRequestError examples MobileRequest examples Limits and restricted characters Mobile event and attribute query examples Here are some examples of using NRQL to query your mobile app events and attributes: Custom event example: Track purchases To track purchases in your app, use recordCustomEvent to create an event type (such as \"UserAction\") and associate attributes such as \"name\" (with value \"Purchase\"), price, quantity, and SKU. Tip For performance reasons, you should limit the total number of event types to maybe one or two. The recordCustomEvent parameter eventType is meant to be used for high-level categories. For example, you might create an event typeGestures, and then create many different custom event names under the Gesture event type. Create an event on iOS: BOOL purchaseRecorded = [NewRelic recordCustomEvent:@\"UserAction\" attributes:@{@\"name\": @\"Purchase\", @\"sku\": @\"12345LPD\", @\"quantity\": @1, @\"unitPrice\": @99.99, @\"total\": @99.99}]; Copy Create an event on Android: Map<String, Object> userActionAttributes = new HashMap<String, Object>(); userActionAttributes.put(\"name\", \"Purchase\"); userActionAttributes.put(\"sku\", \"12345LPD\"); userActionAttributes.put(\"quantity\", 1); userActionAttributes.put(\"unitPrice\", 99.99); userActionAttributes.put(\"total\", 99.99); boolean userActionRecorded = NewRelic.recordCustomEvent(\"UserAction\", userActionAttributes); Copy New Relic reports a custom event of type UserAction and name Purchase, which allows you to query all purchases made in your app in the last day: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Replace deprecated recordEvent method: As of Android agent version 5.12.0 and iOS agent version 5.12.0, use the recordCustomEvent method to create these custom events. If you have replaced the deprecated recordEvent method for your custom events, be sure to also replace its corresponding NRQL query with the new format. Look for queries used with recordEvent method, such as this: SELECT * from Mobile where category = 'Custom' and name = 'Purchase' since 1 day ago Copy Replace them with the query format used with recordCustomEvent: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Attribute example: Track a specific user You can create a custom attribute to track a custom user identifier across the session, and then query for all that user's interactions. To add an attribute for the userId, call the setUserId method: Set the userId on iOS: BOOL userIdWasSet = [NewRelic setUserId:@\"jsmith\"]; Copy Set the userId on Android: boolean userIdWasSet = NewRelic.setUserId(\"jsmith\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that username in the last day: SELECT * from Mobile WHERE userId = 'jsmith' since 1 day ago Copy Attribute example: Track a specific store id You can create a custom attribute to track a store id across the session, and then query for all that store's interactions. To add an attribute for the storeId, call the setAttribute method: Set the storeId on iOS: BOOL attributeSet = [NewRelic setAttribute:@\"storeId\" value:@\"NY0531\"]; Copy Set the storeId on Android: boolean attributeSet = NewRelic.setAttribute(\"storeId\", \"NY0531\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that storeId in the last day: SELECT * from Mobile WHERE storeId = 'NY0531' since 1 day ago Copy Custom attribute example: Track a specific action You can use custom attributes to track the number of times that a specific action occurs in your application. For example, you can track the number of times a button was clicked or the number of times a level was completed in a game. To track completing a game level, call incrementAttribute with no value specified. This creates an attribute with a default value of 1: Create a counter on iOS: BOOL levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Create a counter on Android: boolean levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Each subsequent call to incrementAttribute adds 1 to the attribute level: Increment a counter on iOS: levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Increment a counter on Android: levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Important Be sure to reset the value to 0 when starting over. To reset the level back to 1 or 0, call setAttribute: Reset a counter on iOS: levelReset = [NewRelic setAttribute:@\"level\" value:@1]; Copy Reset a counter on Android: levelReset = NewRelic.setAttribute(\"level\", 1); Copy When querying, use this level attribute to filter your data. For example, if you have a username and level attribute, use the max() function to find the highest level the user had reached: SELECT max(level) from Mobile where username = 'jsmith' Copy Size limits and restricted characters Limits for custom attributes added to default mobile events: Attributes: 128 maximum String attributes: 4 KB maximum length (empty string values are not accepted) Limits for custom events: Attributes: 254 maximum per event (number includes default session attributes) String attributes: 4 KB maximum length (empty string values are not accepted) Naming syntax and rules: See Rules for custom data. Set the time to send data By default, New Relic transmits event data in any of these situations: A session has been ongoing for 600 seconds. The app session ends by backgrounding. The app crashes. If the app crashes, New Relic gathers the attributes and events for that session and sends them to Insights. (On iOS, this happens the next time the app is launched). You can then use Insights to query and analyze the event and attribute data. To set the maximum time (in seconds) that the agent will store events in memory, use the following SDK calls: iOS method: + (void) setMaxEventBufferTime:(unsigned int)seconds; Copy Android method: public static void setMaxEventBufferTime(int maxBufferTimeInSec); Copy Privacy considerations If you want to collect personal data via custom attributes, please consult with your privacy or legal teams. Be sure to follow your organization's obligations for notices and consent regulations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 231.46832,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report <em>mobile</em> <em>monitoring</em> custom events and attributes",
        "sections": "Report <em>mobile</em> <em>monitoring</em> custom events and attributes",
        "tags": "<em>Insights</em>",
        "body": " information and are shared by multiple <em>mobile</em> event types. You can also create entirely <em>new</em> custom event types and assign them their own custom attributes, using the recordCustomEvent <em>API</em> (Android | <em>iOS</em>). To help with crash analysis, you can use the <em>SDK</em> to create <em>Mobile</em>Breadcrumb and <em>Mobile</em>"
      },
      "id": "609fa5cf28ccbc508d9832d3"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/current-session-id": [
    {
      "sections": [
        "Adding a prefix header to an iOS project"
      ],
      "title": "Adding a prefix header to an iOS project",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "11df0352a96527157fdd932f7a5bacf0beb8a0ae",
      "image": "https://docs.newrelic.com/static/89991d3f20208fe696e48b3143745df9/8c557/screen-ios-sdk-api-prefix-header.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/adding-prefix-header-ios-project/",
      "published_at": "2021-10-24T16:49:48Z",
      "updated_at": "2021-07-09T08:43:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Installing New Relic's iOS SDK API requires you to modify your project's prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File > New > File... From iOS template options, select Other > PCH file. Name the file < target_name>-Prefix.pch, and then select Create. From your targetâ€™s Build settings, select All, and then add the following to the Prefix Header field: $(SRCROOT)/<target_name>-Prefix.pch Copy Here is an example of using XcodeÂ to add a Prefix Header file to your iOS project for the iOS SDK API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 255.09283,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Adding a prefix header to an <em>iOS</em> project",
        "sections": "Adding a prefix header to an <em>iOS</em> project",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Installing <em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> <em>SDK</em> <em>API</em> requires you to modify your project&#x27;s prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File &gt; <em>New</em> &gt; File... From <em>iOS</em> template options, select Other &gt; PCH file. Name the file &lt; target_name&gt;-Prefix.pch"
      },
      "id": "6044195fe7b9d2f201579a09"
    },
    {
      "sections": [
        "Introduction to iOS monitoring",
        "Compatibility and requirements",
        "Install the agent",
        "Extend your instrumentation",
        "Troubleshoot your installation"
      ],
      "title": "Introduction to iOS monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "243234aeaa02a13856775f6f154cab24a1e5db26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios/",
      "published_at": "2021-10-24T16:51:42Z",
      "updated_at": "2021-07-08T01:46:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring for iOS gives you a comprehensive view of your app's performance. It works for iOS apps written using Objective-C, Swift, or both languages. For a general overview of mobile monitoring functionality, see Introduction to mobile monitoring. Compatibility and requirements Before you install the iOS agent, review the compatibility and requirements. Install the agent As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. There are two ways you can install the iOS agent: We recommend you install and configure the iOS agent using the CocoaPods installation method. You can also manually install and configure the iOS agent by adding the New Relic framework to your app. Extend your instrumentation After you install the agent, you can extend the agent's default instrumentation with various types of custom data: To access: In the mobile UI: In New Relic One dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. You can also query the custom events that you created in New Relic One dashboards and NRQL. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. iOS SDK API Use the iOS SDK API to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. Troubleshoot your installation If the agent isn't reporting data, try these troubleshooting suggestions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 232.07886,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "sections": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for <em>iOS</em> gives you a comprehensive view of your app&#x27;s performance. It works for <em>iOS</em> apps written using Objective-C, Swift, or both languages. For a general overview of <em>mobile</em> <em>monitoring</em> functionality, see Introduction to <em>mobile</em> <em>monitoring</em>. Compatibility and requirements"
      },
      "id": "6043a48fe7b9d2ad8d5799db"
    },
    {
      "sections": [
        "Report mobile monitoring custom events and attributes",
        "Create custom attributes and events",
        "Mobile event and attribute query examples",
        "Custom event example: Track purchases",
        "Tip",
        "Attribute example: Track a specific user",
        "Attribute example: Track a specific store id",
        "Custom attribute example: Track a specific action",
        "Important",
        "Size limits and restricted characters",
        "Set the time to send data",
        "Privacy considerations"
      ],
      "title": "Report mobile monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "65970eacbedb3360fd1c7394affc8cbc42f2ab0c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/report-mobile-monitoring-custom-events-attributes/",
      "published_at": "2021-10-24T14:59:18Z",
      "updated_at": "2021-10-23T21:59:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring in New Relic sends some default event data from your mobile app to New Relic, such as data about interactions, sessions, crashes, and request errors. You can also create your own custom attributes and events for more detailed querying and analysis. Create custom attributes and events You can create custom session-level attributes for default mobile monitoring events using the mobile agent SDKs. For example, to record a username attribute for some part of your iOS or Android app, you would use the setAttribute API (Android | iOS). These attributes are session-related information and are shared by multiple mobile event types. You can also create entirely new custom event types and assign them their own custom attributes, using the recordCustomEvent API (Android | iOS). To help with crash analysis, you can use the SDK to create MobileBreadcrumb and MobileHandledException events. These events are available for querying and also displayed in the crash event trail UI. For more on creating custom attributes and custom events, see: Android SDK API guide iOS SDK API guide NRQL query examples MobileRequestError examples MobileRequest examples Limits and restricted characters Mobile event and attribute query examples Here are some examples of using NRQL to query your mobile app events and attributes: Custom event example: Track purchases To track purchases in your app, use recordCustomEvent to create an event type (such as \"UserAction\") and associate attributes such as \"name\" (with value \"Purchase\"), price, quantity, and SKU. Tip For performance reasons, you should limit the total number of event types to maybe one or two. The recordCustomEvent parameter eventType is meant to be used for high-level categories. For example, you might create an event typeGestures, and then create many different custom event names under the Gesture event type. Create an event on iOS: BOOL purchaseRecorded = [NewRelic recordCustomEvent:@\"UserAction\" attributes:@{@\"name\": @\"Purchase\", @\"sku\": @\"12345LPD\", @\"quantity\": @1, @\"unitPrice\": @99.99, @\"total\": @99.99}]; Copy Create an event on Android: Map<String, Object> userActionAttributes = new HashMap<String, Object>(); userActionAttributes.put(\"name\", \"Purchase\"); userActionAttributes.put(\"sku\", \"12345LPD\"); userActionAttributes.put(\"quantity\", 1); userActionAttributes.put(\"unitPrice\", 99.99); userActionAttributes.put(\"total\", 99.99); boolean userActionRecorded = NewRelic.recordCustomEvent(\"UserAction\", userActionAttributes); Copy New Relic reports a custom event of type UserAction and name Purchase, which allows you to query all purchases made in your app in the last day: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Replace deprecated recordEvent method: As of Android agent version 5.12.0 and iOS agent version 5.12.0, use the recordCustomEvent method to create these custom events. If you have replaced the deprecated recordEvent method for your custom events, be sure to also replace its corresponding NRQL query with the new format. Look for queries used with recordEvent method, such as this: SELECT * from Mobile where category = 'Custom' and name = 'Purchase' since 1 day ago Copy Replace them with the query format used with recordCustomEvent: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Attribute example: Track a specific user You can create a custom attribute to track a custom user identifier across the session, and then query for all that user's interactions. To add an attribute for the userId, call the setUserId method: Set the userId on iOS: BOOL userIdWasSet = [NewRelic setUserId:@\"jsmith\"]; Copy Set the userId on Android: boolean userIdWasSet = NewRelic.setUserId(\"jsmith\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that username in the last day: SELECT * from Mobile WHERE userId = 'jsmith' since 1 day ago Copy Attribute example: Track a specific store id You can create a custom attribute to track a store id across the session, and then query for all that store's interactions. To add an attribute for the storeId, call the setAttribute method: Set the storeId on iOS: BOOL attributeSet = [NewRelic setAttribute:@\"storeId\" value:@\"NY0531\"]; Copy Set the storeId on Android: boolean attributeSet = NewRelic.setAttribute(\"storeId\", \"NY0531\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that storeId in the last day: SELECT * from Mobile WHERE storeId = 'NY0531' since 1 day ago Copy Custom attribute example: Track a specific action You can use custom attributes to track the number of times that a specific action occurs in your application. For example, you can track the number of times a button was clicked or the number of times a level was completed in a game. To track completing a game level, call incrementAttribute with no value specified. This creates an attribute with a default value of 1: Create a counter on iOS: BOOL levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Create a counter on Android: boolean levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Each subsequent call to incrementAttribute adds 1 to the attribute level: Increment a counter on iOS: levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Increment a counter on Android: levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Important Be sure to reset the value to 0 when starting over. To reset the level back to 1 or 0, call setAttribute: Reset a counter on iOS: levelReset = [NewRelic setAttribute:@\"level\" value:@1]; Copy Reset a counter on Android: levelReset = NewRelic.setAttribute(\"level\", 1); Copy When querying, use this level attribute to filter your data. For example, if you have a username and level attribute, use the max() function to find the highest level the user had reached: SELECT max(level) from Mobile where username = 'jsmith' Copy Size limits and restricted characters Limits for custom attributes added to default mobile events: Attributes: 128 maximum String attributes: 4 KB maximum length (empty string values are not accepted) Limits for custom events: Attributes: 254 maximum per event (number includes default session attributes) String attributes: 4 KB maximum length (empty string values are not accepted) Naming syntax and rules: See Rules for custom data. Set the time to send data By default, New Relic transmits event data in any of these situations: A session has been ongoing for 600 seconds. The app session ends by backgrounding. The app crashes. If the app crashes, New Relic gathers the attributes and events for that session and sends them to Insights. (On iOS, this happens the next time the app is launched). You can then use Insights to query and analyze the event and attribute data. To set the maximum time (in seconds) that the agent will store events in memory, use the following SDK calls: iOS method: + (void) setMaxEventBufferTime:(unsigned int)seconds; Copy Android method: public static void setMaxEventBufferTime(int maxBufferTimeInSec); Copy Privacy considerations If you want to collect personal data via custom attributes, please consult with your privacy or legal teams. Be sure to follow your organization's obligations for notices and consent regulations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 231.46814,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report <em>mobile</em> <em>monitoring</em> custom events and attributes",
        "sections": "Report <em>mobile</em> <em>monitoring</em> custom events and attributes",
        "tags": "<em>Insights</em>",
        "body": " information and are shared by multiple <em>mobile</em> event types. You can also create entirely <em>new</em> custom event types and assign them their own custom attributes, using the recordCustomEvent <em>API</em> (Android | <em>iOS</em>). To help with crash analysis, you can use the <em>SDK</em> to create <em>Mobile</em>Breadcrumb and <em>Mobile</em>"
      },
      "id": "609fa5cf28ccbc508d9832d3"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/increment-attribute": [
    {
      "sections": [
        "Adding a prefix header to an iOS project"
      ],
      "title": "Adding a prefix header to an iOS project",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "11df0352a96527157fdd932f7a5bacf0beb8a0ae",
      "image": "https://docs.newrelic.com/static/89991d3f20208fe696e48b3143745df9/8c557/screen-ios-sdk-api-prefix-header.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/adding-prefix-header-ios-project/",
      "published_at": "2021-10-24T16:49:48Z",
      "updated_at": "2021-07-09T08:43:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Installing New Relic's iOS SDK API requires you to modify your project's prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File > New > File... From iOS template options, select Other > PCH file. Name the file < target_name>-Prefix.pch, and then select Create. From your targetâ€™s Build settings, select All, and then add the following to the Prefix Header field: $(SRCROOT)/<target_name>-Prefix.pch Copy Here is an example of using XcodeÂ to add a Prefix Header file to your iOS project for the iOS SDK API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 255.09283,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Adding a prefix header to an <em>iOS</em> project",
        "sections": "Adding a prefix header to an <em>iOS</em> project",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Installing <em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> <em>SDK</em> <em>API</em> requires you to modify your project&#x27;s prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File &gt; <em>New</em> &gt; File... From <em>iOS</em> template options, select Other &gt; PCH file. Name the file &lt; target_name&gt;-Prefix.pch"
      },
      "id": "6044195fe7b9d2f201579a09"
    },
    {
      "sections": [
        "Introduction to iOS monitoring",
        "Compatibility and requirements",
        "Install the agent",
        "Extend your instrumentation",
        "Troubleshoot your installation"
      ],
      "title": "Introduction to iOS monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "243234aeaa02a13856775f6f154cab24a1e5db26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios/",
      "published_at": "2021-10-24T16:51:42Z",
      "updated_at": "2021-07-08T01:46:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring for iOS gives you a comprehensive view of your app's performance. It works for iOS apps written using Objective-C, Swift, or both languages. For a general overview of mobile monitoring functionality, see Introduction to mobile monitoring. Compatibility and requirements Before you install the iOS agent, review the compatibility and requirements. Install the agent As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. There are two ways you can install the iOS agent: We recommend you install and configure the iOS agent using the CocoaPods installation method. You can also manually install and configure the iOS agent by adding the New Relic framework to your app. Extend your instrumentation After you install the agent, you can extend the agent's default instrumentation with various types of custom data: To access: In the mobile UI: In New Relic One dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. You can also query the custom events that you created in New Relic One dashboards and NRQL. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. iOS SDK API Use the iOS SDK API to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. Troubleshoot your installation If the agent isn't reporting data, try these troubleshooting suggestions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 232.07886,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "sections": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for <em>iOS</em> gives you a comprehensive view of your app&#x27;s performance. It works for <em>iOS</em> apps written using Objective-C, Swift, or both languages. For a general overview of <em>mobile</em> <em>monitoring</em> functionality, see Introduction to <em>mobile</em> <em>monitoring</em>. Compatibility and requirements"
      },
      "id": "6043a48fe7b9d2ad8d5799db"
    },
    {
      "sections": [
        "Report mobile monitoring custom events and attributes",
        "Create custom attributes and events",
        "Mobile event and attribute query examples",
        "Custom event example: Track purchases",
        "Tip",
        "Attribute example: Track a specific user",
        "Attribute example: Track a specific store id",
        "Custom attribute example: Track a specific action",
        "Important",
        "Size limits and restricted characters",
        "Set the time to send data",
        "Privacy considerations"
      ],
      "title": "Report mobile monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "65970eacbedb3360fd1c7394affc8cbc42f2ab0c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/report-mobile-monitoring-custom-events-attributes/",
      "published_at": "2021-10-24T14:59:18Z",
      "updated_at": "2021-10-23T21:59:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring in New Relic sends some default event data from your mobile app to New Relic, such as data about interactions, sessions, crashes, and request errors. You can also create your own custom attributes and events for more detailed querying and analysis. Create custom attributes and events You can create custom session-level attributes for default mobile monitoring events using the mobile agent SDKs. For example, to record a username attribute for some part of your iOS or Android app, you would use the setAttribute API (Android | iOS). These attributes are session-related information and are shared by multiple mobile event types. You can also create entirely new custom event types and assign them their own custom attributes, using the recordCustomEvent API (Android | iOS). To help with crash analysis, you can use the SDK to create MobileBreadcrumb and MobileHandledException events. These events are available for querying and also displayed in the crash event trail UI. For more on creating custom attributes and custom events, see: Android SDK API guide iOS SDK API guide NRQL query examples MobileRequestError examples MobileRequest examples Limits and restricted characters Mobile event and attribute query examples Here are some examples of using NRQL to query your mobile app events and attributes: Custom event example: Track purchases To track purchases in your app, use recordCustomEvent to create an event type (such as \"UserAction\") and associate attributes such as \"name\" (with value \"Purchase\"), price, quantity, and SKU. Tip For performance reasons, you should limit the total number of event types to maybe one or two. The recordCustomEvent parameter eventType is meant to be used for high-level categories. For example, you might create an event typeGestures, and then create many different custom event names under the Gesture event type. Create an event on iOS: BOOL purchaseRecorded = [NewRelic recordCustomEvent:@\"UserAction\" attributes:@{@\"name\": @\"Purchase\", @\"sku\": @\"12345LPD\", @\"quantity\": @1, @\"unitPrice\": @99.99, @\"total\": @99.99}]; Copy Create an event on Android: Map<String, Object> userActionAttributes = new HashMap<String, Object>(); userActionAttributes.put(\"name\", \"Purchase\"); userActionAttributes.put(\"sku\", \"12345LPD\"); userActionAttributes.put(\"quantity\", 1); userActionAttributes.put(\"unitPrice\", 99.99); userActionAttributes.put(\"total\", 99.99); boolean userActionRecorded = NewRelic.recordCustomEvent(\"UserAction\", userActionAttributes); Copy New Relic reports a custom event of type UserAction and name Purchase, which allows you to query all purchases made in your app in the last day: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Replace deprecated recordEvent method: As of Android agent version 5.12.0 and iOS agent version 5.12.0, use the recordCustomEvent method to create these custom events. If you have replaced the deprecated recordEvent method for your custom events, be sure to also replace its corresponding NRQL query with the new format. Look for queries used with recordEvent method, such as this: SELECT * from Mobile where category = 'Custom' and name = 'Purchase' since 1 day ago Copy Replace them with the query format used with recordCustomEvent: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Attribute example: Track a specific user You can create a custom attribute to track a custom user identifier across the session, and then query for all that user's interactions. To add an attribute for the userId, call the setUserId method: Set the userId on iOS: BOOL userIdWasSet = [NewRelic setUserId:@\"jsmith\"]; Copy Set the userId on Android: boolean userIdWasSet = NewRelic.setUserId(\"jsmith\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that username in the last day: SELECT * from Mobile WHERE userId = 'jsmith' since 1 day ago Copy Attribute example: Track a specific store id You can create a custom attribute to track a store id across the session, and then query for all that store's interactions. To add an attribute for the storeId, call the setAttribute method: Set the storeId on iOS: BOOL attributeSet = [NewRelic setAttribute:@\"storeId\" value:@\"NY0531\"]; Copy Set the storeId on Android: boolean attributeSet = NewRelic.setAttribute(\"storeId\", \"NY0531\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that storeId in the last day: SELECT * from Mobile WHERE storeId = 'NY0531' since 1 day ago Copy Custom attribute example: Track a specific action You can use custom attributes to track the number of times that a specific action occurs in your application. For example, you can track the number of times a button was clicked or the number of times a level was completed in a game. To track completing a game level, call incrementAttribute with no value specified. This creates an attribute with a default value of 1: Create a counter on iOS: BOOL levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Create a counter on Android: boolean levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Each subsequent call to incrementAttribute adds 1 to the attribute level: Increment a counter on iOS: levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Increment a counter on Android: levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Important Be sure to reset the value to 0 when starting over. To reset the level back to 1 or 0, call setAttribute: Reset a counter on iOS: levelReset = [NewRelic setAttribute:@\"level\" value:@1]; Copy Reset a counter on Android: levelReset = NewRelic.setAttribute(\"level\", 1); Copy When querying, use this level attribute to filter your data. For example, if you have a username and level attribute, use the max() function to find the highest level the user had reached: SELECT max(level) from Mobile where username = 'jsmith' Copy Size limits and restricted characters Limits for custom attributes added to default mobile events: Attributes: 128 maximum String attributes: 4 KB maximum length (empty string values are not accepted) Limits for custom events: Attributes: 254 maximum per event (number includes default session attributes) String attributes: 4 KB maximum length (empty string values are not accepted) Naming syntax and rules: See Rules for custom data. Set the time to send data By default, New Relic transmits event data in any of these situations: A session has been ongoing for 600 seconds. The app session ends by backgrounding. The app crashes. If the app crashes, New Relic gathers the attributes and events for that session and sends them to Insights. (On iOS, this happens the next time the app is launched). You can then use Insights to query and analyze the event and attribute data. To set the maximum time (in seconds) that the agent will store events in memory, use the following SDK calls: iOS method: + (void) setMaxEventBufferTime:(unsigned int)seconds; Copy Android method: public static void setMaxEventBufferTime(int maxBufferTimeInSec); Copy Privacy considerations If you want to collect personal data via custom attributes, please consult with your privacy or legal teams. Be sure to follow your organization's obligations for notices and consent regulations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 231.46814,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report <em>mobile</em> <em>monitoring</em> custom events and attributes",
        "sections": "Report <em>mobile</em> <em>monitoring</em> custom events and attributes",
        "tags": "<em>Insights</em>",
        "body": " information and are shared by multiple <em>mobile</em> event types. You can also create entirely <em>new</em> custom event types and assign them their own custom attributes, using the recordCustomEvent <em>API</em> (Android | <em>iOS</em>). To help with crash analysis, you can use the <em>SDK</em> to create <em>Mobile</em>Breadcrumb and <em>Mobile</em>"
      },
      "id": "609fa5cf28ccbc508d9832d3"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/index": [
    {
      "sections": [
        "Report mobile monitoring custom events and attributes",
        "Create custom attributes and events",
        "Mobile event and attribute query examples",
        "Custom event example: Track purchases",
        "Tip",
        "Attribute example: Track a specific user",
        "Attribute example: Track a specific store id",
        "Custom attribute example: Track a specific action",
        "Important",
        "Size limits and restricted characters",
        "Set the time to send data",
        "Privacy considerations"
      ],
      "title": "Report mobile monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "65970eacbedb3360fd1c7394affc8cbc42f2ab0c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/report-mobile-monitoring-custom-events-attributes/",
      "published_at": "2021-10-24T14:59:18Z",
      "updated_at": "2021-10-23T21:59:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring in New Relic sends some default event data from your mobile app to New Relic, such as data about interactions, sessions, crashes, and request errors. You can also create your own custom attributes and events for more detailed querying and analysis. Create custom attributes and events You can create custom session-level attributes for default mobile monitoring events using the mobile agent SDKs. For example, to record a username attribute for some part of your iOS or Android app, you would use the setAttribute API (Android | iOS). These attributes are session-related information and are shared by multiple mobile event types. You can also create entirely new custom event types and assign them their own custom attributes, using the recordCustomEvent API (Android | iOS). To help with crash analysis, you can use the SDK to create MobileBreadcrumb and MobileHandledException events. These events are available for querying and also displayed in the crash event trail UI. For more on creating custom attributes and custom events, see: Android SDK API guide iOS SDK API guide NRQL query examples MobileRequestError examples MobileRequest examples Limits and restricted characters Mobile event and attribute query examples Here are some examples of using NRQL to query your mobile app events and attributes: Custom event example: Track purchases To track purchases in your app, use recordCustomEvent to create an event type (such as \"UserAction\") and associate attributes such as \"name\" (with value \"Purchase\"), price, quantity, and SKU. Tip For performance reasons, you should limit the total number of event types to maybe one or two. The recordCustomEvent parameter eventType is meant to be used for high-level categories. For example, you might create an event typeGestures, and then create many different custom event names under the Gesture event type. Create an event on iOS: BOOL purchaseRecorded = [NewRelic recordCustomEvent:@\"UserAction\" attributes:@{@\"name\": @\"Purchase\", @\"sku\": @\"12345LPD\", @\"quantity\": @1, @\"unitPrice\": @99.99, @\"total\": @99.99}]; Copy Create an event on Android: Map<String, Object> userActionAttributes = new HashMap<String, Object>(); userActionAttributes.put(\"name\", \"Purchase\"); userActionAttributes.put(\"sku\", \"12345LPD\"); userActionAttributes.put(\"quantity\", 1); userActionAttributes.put(\"unitPrice\", 99.99); userActionAttributes.put(\"total\", 99.99); boolean userActionRecorded = NewRelic.recordCustomEvent(\"UserAction\", userActionAttributes); Copy New Relic reports a custom event of type UserAction and name Purchase, which allows you to query all purchases made in your app in the last day: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Replace deprecated recordEvent method: As of Android agent version 5.12.0 and iOS agent version 5.12.0, use the recordCustomEvent method to create these custom events. If you have replaced the deprecated recordEvent method for your custom events, be sure to also replace its corresponding NRQL query with the new format. Look for queries used with recordEvent method, such as this: SELECT * from Mobile where category = 'Custom' and name = 'Purchase' since 1 day ago Copy Replace them with the query format used with recordCustomEvent: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Attribute example: Track a specific user You can create a custom attribute to track a custom user identifier across the session, and then query for all that user's interactions. To add an attribute for the userId, call the setUserId method: Set the userId on iOS: BOOL userIdWasSet = [NewRelic setUserId:@\"jsmith\"]; Copy Set the userId on Android: boolean userIdWasSet = NewRelic.setUserId(\"jsmith\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that username in the last day: SELECT * from Mobile WHERE userId = 'jsmith' since 1 day ago Copy Attribute example: Track a specific store id You can create a custom attribute to track a store id across the session, and then query for all that store's interactions. To add an attribute for the storeId, call the setAttribute method: Set the storeId on iOS: BOOL attributeSet = [NewRelic setAttribute:@\"storeId\" value:@\"NY0531\"]; Copy Set the storeId on Android: boolean attributeSet = NewRelic.setAttribute(\"storeId\", \"NY0531\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that storeId in the last day: SELECT * from Mobile WHERE storeId = 'NY0531' since 1 day ago Copy Custom attribute example: Track a specific action You can use custom attributes to track the number of times that a specific action occurs in your application. For example, you can track the number of times a button was clicked or the number of times a level was completed in a game. To track completing a game level, call incrementAttribute with no value specified. This creates an attribute with a default value of 1: Create a counter on iOS: BOOL levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Create a counter on Android: boolean levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Each subsequent call to incrementAttribute adds 1 to the attribute level: Increment a counter on iOS: levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Increment a counter on Android: levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Important Be sure to reset the value to 0 when starting over. To reset the level back to 1 or 0, call setAttribute: Reset a counter on iOS: levelReset = [NewRelic setAttribute:@\"level\" value:@1]; Copy Reset a counter on Android: levelReset = NewRelic.setAttribute(\"level\", 1); Copy When querying, use this level attribute to filter your data. For example, if you have a username and level attribute, use the max() function to find the highest level the user had reached: SELECT max(level) from Mobile where username = 'jsmith' Copy Size limits and restricted characters Limits for custom attributes added to default mobile events: Attributes: 128 maximum String attributes: 4 KB maximum length (empty string values are not accepted) Limits for custom events: Attributes: 254 maximum per event (number includes default session attributes) String attributes: 4 KB maximum length (empty string values are not accepted) Naming syntax and rules: See Rules for custom data. Set the time to send data By default, New Relic transmits event data in any of these situations: A session has been ongoing for 600 seconds. The app session ends by backgrounding. The app crashes. If the app crashes, New Relic gathers the attributes and events for that session and sends them to Insights. (On iOS, this happens the next time the app is launched). You can then use Insights to query and analyze the event and attribute data. To set the maximum time (in seconds) that the agent will store events in memory, use the following SDK calls: iOS method: + (void) setMaxEventBufferTime:(unsigned int)seconds; Copy Android method: public static void setMaxEventBufferTime(int maxBufferTimeInSec); Copy Privacy considerations If you want to collect personal data via custom attributes, please consult with your privacy or legal teams. Be sure to follow your organization's obligations for notices and consent regulations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1978.4974,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Attribute example: Track a specific store <em>id</em>",
        "tags": "<em>Insights</em>",
        "body": " information and are shared by multiple mobile event types. You can also create entirely new custom event types and assign them their own custom attributes, using the recordCustomEvent <em>API</em> (Android | <em>iOS</em>). To help with crash analysis, you can use the <em>SDK</em> to create MobileBreadcrumb and MobileHandledException"
      },
      "id": "609fa5cf28ccbc508d9832d3"
    },
    {
      "sections": [
        "Adding a prefix header to an iOS project"
      ],
      "title": "Adding a prefix header to an iOS project",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "11df0352a96527157fdd932f7a5bacf0beb8a0ae",
      "image": "https://docs.newrelic.com/static/89991d3f20208fe696e48b3143745df9/8c557/screen-ios-sdk-api-prefix-header.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/adding-prefix-header-ios-project/",
      "published_at": "2021-10-24T16:49:48Z",
      "updated_at": "2021-07-09T08:43:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Installing New Relic's iOS SDK API requires you to modify your project's prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File > New > File... From iOS template options, select Other > PCH file. Name the file < target_name>-Prefix.pch, and then select Create. From your targetâ€™s Build settings, select All, and then add the following to the Prefix Header field: $(SRCROOT)/<target_name>-Prefix.pch Copy Here is an example of using XcodeÂ to add a Prefix Header file to your iOS project for the iOS SDK API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1392.5139,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Adding a prefix header to an <em>iOS</em> project",
        "sections": "Adding a prefix header to an <em>iOS</em> project",
        "tags": "New Relic Mobile <em>iOS</em>",
        "body": "Installing New Relic&#x27;s <em>iOS</em> <em>SDK</em> <em>API</em> requires you to modify your project&#x27;s prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File &gt; New &gt; File... From <em>iOS</em> template options, select Other &gt; PCH file. Name the file &lt; target_name&gt;-Prefix.pch"
      },
      "id": "6044195fe7b9d2f201579a09"
    },
    {
      "sections": [
        "Introduction to iOS monitoring",
        "Compatibility and requirements",
        "Install the agent",
        "Extend your instrumentation",
        "Troubleshoot your installation"
      ],
      "title": "Introduction to iOS monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "243234aeaa02a13856775f6f154cab24a1e5db26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios/",
      "published_at": "2021-10-24T16:51:42Z",
      "updated_at": "2021-07-08T01:46:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring for iOS gives you a comprehensive view of your app's performance. It works for iOS apps written using Objective-C, Swift, or both languages. For a general overview of mobile monitoring functionality, see Introduction to mobile monitoring. Compatibility and requirements Before you install the iOS agent, review the compatibility and requirements. Install the agent As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. There are two ways you can install the iOS agent: We recommend you install and configure the iOS agent using the CocoaPods installation method. You can also manually install and configure the iOS agent by adding the New Relic framework to your app. Extend your instrumentation After you install the agent, you can extend the agent's default instrumentation with various types of custom data: To access: In the mobile UI: In New Relic One dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. You can also query the custom events that you created in New Relic One dashboards and NRQL. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. iOS SDK API Use the iOS SDK API to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. Troubleshoot your installation If the agent isn't reporting data, try these troubleshooting suggestions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1315.1345,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> monitoring",
        "sections": "<em>Introduction</em> to <em>iOS</em> monitoring",
        "tags": "New Relic Mobile <em>iOS</em>",
        "body": " detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. <em>iOS</em> <em>SDK</em> <em>API</em> Use the <em>iOS</em> <em>SDK</em> <em>API</em> to instrument parts of your code that are not instrumented by default"
      },
      "id": "6043a48fe7b9d2ad8d5799db"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/record-breadcrumb": [
    {
      "sections": [
        "Adding a prefix header to an iOS project"
      ],
      "title": "Adding a prefix header to an iOS project",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "11df0352a96527157fdd932f7a5bacf0beb8a0ae",
      "image": "https://docs.newrelic.com/static/89991d3f20208fe696e48b3143745df9/8c557/screen-ios-sdk-api-prefix-header.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/adding-prefix-header-ios-project/",
      "published_at": "2021-10-24T16:49:48Z",
      "updated_at": "2021-07-09T08:43:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Installing New Relic's iOS SDK API requires you to modify your project's prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File > New > File... From iOS template options, select Other > PCH file. Name the file < target_name>-Prefix.pch, and then select Create. From your targetâ€™s Build settings, select All, and then add the following to the Prefix Header field: $(SRCROOT)/<target_name>-Prefix.pch Copy Here is an example of using XcodeÂ to add a Prefix Header file to your iOS project for the iOS SDK API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 255.09282,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Adding a prefix header to an <em>iOS</em> project",
        "sections": "Adding a prefix header to an <em>iOS</em> project",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Installing <em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> <em>SDK</em> <em>API</em> requires you to modify your project&#x27;s prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File &gt; <em>New</em> &gt; File... From <em>iOS</em> template options, select Other &gt; PCH file. Name the file &lt; target_name&gt;-Prefix.pch"
      },
      "id": "6044195fe7b9d2f201579a09"
    },
    {
      "sections": [
        "Introduction to iOS monitoring",
        "Compatibility and requirements",
        "Install the agent",
        "Extend your instrumentation",
        "Troubleshoot your installation"
      ],
      "title": "Introduction to iOS monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "243234aeaa02a13856775f6f154cab24a1e5db26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios/",
      "published_at": "2021-10-24T16:51:42Z",
      "updated_at": "2021-07-08T01:46:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring for iOS gives you a comprehensive view of your app's performance. It works for iOS apps written using Objective-C, Swift, or both languages. For a general overview of mobile monitoring functionality, see Introduction to mobile monitoring. Compatibility and requirements Before you install the iOS agent, review the compatibility and requirements. Install the agent As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. There are two ways you can install the iOS agent: We recommend you install and configure the iOS agent using the CocoaPods installation method. You can also manually install and configure the iOS agent by adding the New Relic framework to your app. Extend your instrumentation After you install the agent, you can extend the agent's default instrumentation with various types of custom data: To access: In the mobile UI: In New Relic One dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. You can also query the custom events that you created in New Relic One dashboards and NRQL. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. iOS SDK API Use the iOS SDK API to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. Troubleshoot your installation If the agent isn't reporting data, try these troubleshooting suggestions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 232.07886,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "sections": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for <em>iOS</em> gives you a comprehensive view of your app&#x27;s performance. It works for <em>iOS</em> apps written using Objective-C, Swift, or both languages. For a general overview of <em>mobile</em> <em>monitoring</em> functionality, see Introduction to <em>mobile</em> <em>monitoring</em>. Compatibility and requirements"
      },
      "id": "6043a48fe7b9d2ad8d5799db"
    },
    {
      "sections": [
        "Report mobile monitoring custom events and attributes",
        "Create custom attributes and events",
        "Mobile event and attribute query examples",
        "Custom event example: Track purchases",
        "Tip",
        "Attribute example: Track a specific user",
        "Attribute example: Track a specific store id",
        "Custom attribute example: Track a specific action",
        "Important",
        "Size limits and restricted characters",
        "Set the time to send data",
        "Privacy considerations"
      ],
      "title": "Report mobile monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "65970eacbedb3360fd1c7394affc8cbc42f2ab0c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/report-mobile-monitoring-custom-events-attributes/",
      "published_at": "2021-10-24T14:59:18Z",
      "updated_at": "2021-10-23T21:59:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring in New Relic sends some default event data from your mobile app to New Relic, such as data about interactions, sessions, crashes, and request errors. You can also create your own custom attributes and events for more detailed querying and analysis. Create custom attributes and events You can create custom session-level attributes for default mobile monitoring events using the mobile agent SDKs. For example, to record a username attribute for some part of your iOS or Android app, you would use the setAttribute API (Android | iOS). These attributes are session-related information and are shared by multiple mobile event types. You can also create entirely new custom event types and assign them their own custom attributes, using the recordCustomEvent API (Android | iOS). To help with crash analysis, you can use the SDK to create MobileBreadcrumb and MobileHandledException events. These events are available for querying and also displayed in the crash event trail UI. For more on creating custom attributes and custom events, see: Android SDK API guide iOS SDK API guide NRQL query examples MobileRequestError examples MobileRequest examples Limits and restricted characters Mobile event and attribute query examples Here are some examples of using NRQL to query your mobile app events and attributes: Custom event example: Track purchases To track purchases in your app, use recordCustomEvent to create an event type (such as \"UserAction\") and associate attributes such as \"name\" (with value \"Purchase\"), price, quantity, and SKU. Tip For performance reasons, you should limit the total number of event types to maybe one or two. The recordCustomEvent parameter eventType is meant to be used for high-level categories. For example, you might create an event typeGestures, and then create many different custom event names under the Gesture event type. Create an event on iOS: BOOL purchaseRecorded = [NewRelic recordCustomEvent:@\"UserAction\" attributes:@{@\"name\": @\"Purchase\", @\"sku\": @\"12345LPD\", @\"quantity\": @1, @\"unitPrice\": @99.99, @\"total\": @99.99}]; Copy Create an event on Android: Map<String, Object> userActionAttributes = new HashMap<String, Object>(); userActionAttributes.put(\"name\", \"Purchase\"); userActionAttributes.put(\"sku\", \"12345LPD\"); userActionAttributes.put(\"quantity\", 1); userActionAttributes.put(\"unitPrice\", 99.99); userActionAttributes.put(\"total\", 99.99); boolean userActionRecorded = NewRelic.recordCustomEvent(\"UserAction\", userActionAttributes); Copy New Relic reports a custom event of type UserAction and name Purchase, which allows you to query all purchases made in your app in the last day: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Replace deprecated recordEvent method: As of Android agent version 5.12.0 and iOS agent version 5.12.0, use the recordCustomEvent method to create these custom events. If you have replaced the deprecated recordEvent method for your custom events, be sure to also replace its corresponding NRQL query with the new format. Look for queries used with recordEvent method, such as this: SELECT * from Mobile where category = 'Custom' and name = 'Purchase' since 1 day ago Copy Replace them with the query format used with recordCustomEvent: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Attribute example: Track a specific user You can create a custom attribute to track a custom user identifier across the session, and then query for all that user's interactions. To add an attribute for the userId, call the setUserId method: Set the userId on iOS: BOOL userIdWasSet = [NewRelic setUserId:@\"jsmith\"]; Copy Set the userId on Android: boolean userIdWasSet = NewRelic.setUserId(\"jsmith\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that username in the last day: SELECT * from Mobile WHERE userId = 'jsmith' since 1 day ago Copy Attribute example: Track a specific store id You can create a custom attribute to track a store id across the session, and then query for all that store's interactions. To add an attribute for the storeId, call the setAttribute method: Set the storeId on iOS: BOOL attributeSet = [NewRelic setAttribute:@\"storeId\" value:@\"NY0531\"]; Copy Set the storeId on Android: boolean attributeSet = NewRelic.setAttribute(\"storeId\", \"NY0531\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that storeId in the last day: SELECT * from Mobile WHERE storeId = 'NY0531' since 1 day ago Copy Custom attribute example: Track a specific action You can use custom attributes to track the number of times that a specific action occurs in your application. For example, you can track the number of times a button was clicked or the number of times a level was completed in a game. To track completing a game level, call incrementAttribute with no value specified. This creates an attribute with a default value of 1: Create a counter on iOS: BOOL levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Create a counter on Android: boolean levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Each subsequent call to incrementAttribute adds 1 to the attribute level: Increment a counter on iOS: levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Increment a counter on Android: levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Important Be sure to reset the value to 0 when starting over. To reset the level back to 1 or 0, call setAttribute: Reset a counter on iOS: levelReset = [NewRelic setAttribute:@\"level\" value:@1]; Copy Reset a counter on Android: levelReset = NewRelic.setAttribute(\"level\", 1); Copy When querying, use this level attribute to filter your data. For example, if you have a username and level attribute, use the max() function to find the highest level the user had reached: SELECT max(level) from Mobile where username = 'jsmith' Copy Size limits and restricted characters Limits for custom attributes added to default mobile events: Attributes: 128 maximum String attributes: 4 KB maximum length (empty string values are not accepted) Limits for custom events: Attributes: 254 maximum per event (number includes default session attributes) String attributes: 4 KB maximum length (empty string values are not accepted) Naming syntax and rules: See Rules for custom data. Set the time to send data By default, New Relic transmits event data in any of these situations: A session has been ongoing for 600 seconds. The app session ends by backgrounding. The app crashes. If the app crashes, New Relic gathers the attributes and events for that session and sends them to Insights. (On iOS, this happens the next time the app is launched). You can then use Insights to query and analyze the event and attribute data. To set the maximum time (in seconds) that the agent will store events in memory, use the following SDK calls: iOS method: + (void) setMaxEventBufferTime:(unsigned int)seconds; Copy Android method: public static void setMaxEventBufferTime(int maxBufferTimeInSec); Copy Privacy considerations If you want to collect personal data via custom attributes, please consult with your privacy or legal teams. Be sure to follow your organization's obligations for notices and consent regulations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 231.46799,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report <em>mobile</em> <em>monitoring</em> custom events and attributes",
        "sections": "Report <em>mobile</em> <em>monitoring</em> custom events and attributes",
        "tags": "<em>Insights</em>",
        "body": " information and are shared by multiple <em>mobile</em> event types. You can also create entirely <em>new</em> custom event types and assign them their own custom attributes, using the recordCustomEvent <em>API</em> (Android | <em>iOS</em>). To help with crash analysis, you can use the <em>SDK</em> to create <em>Mobile</em>Breadcrumb and <em>Mobile</em>"
      },
      "id": "609fa5cf28ccbc508d9832d3"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/record-handled-exception": [
    {
      "sections": [
        "Adding a prefix header to an iOS project"
      ],
      "title": "Adding a prefix header to an iOS project",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "11df0352a96527157fdd932f7a5bacf0beb8a0ae",
      "image": "https://docs.newrelic.com/static/89991d3f20208fe696e48b3143745df9/8c557/screen-ios-sdk-api-prefix-header.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/adding-prefix-header-ios-project/",
      "published_at": "2021-10-24T16:49:48Z",
      "updated_at": "2021-07-09T08:43:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Installing New Relic's iOS SDK API requires you to modify your project's prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File > New > File... From iOS template options, select Other > PCH file. Name the file < target_name>-Prefix.pch, and then select Create. From your targetâ€™s Build settings, select All, and then add the following to the Prefix Header field: $(SRCROOT)/<target_name>-Prefix.pch Copy Here is an example of using XcodeÂ to add a Prefix Header file to your iOS project for the iOS SDK API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 255.09282,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Adding a prefix header to an <em>iOS</em> project",
        "sections": "Adding a prefix header to an <em>iOS</em> project",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Installing <em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> <em>SDK</em> <em>API</em> requires you to modify your project&#x27;s prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File &gt; <em>New</em> &gt; File... From <em>iOS</em> template options, select Other &gt; PCH file. Name the file &lt; target_name&gt;-Prefix.pch"
      },
      "id": "6044195fe7b9d2f201579a09"
    },
    {
      "sections": [
        "Introduction to iOS monitoring",
        "Compatibility and requirements",
        "Install the agent",
        "Extend your instrumentation",
        "Troubleshoot your installation"
      ],
      "title": "Introduction to iOS monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "243234aeaa02a13856775f6f154cab24a1e5db26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios/",
      "published_at": "2021-10-24T16:51:42Z",
      "updated_at": "2021-07-08T01:46:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring for iOS gives you a comprehensive view of your app's performance. It works for iOS apps written using Objective-C, Swift, or both languages. For a general overview of mobile monitoring functionality, see Introduction to mobile monitoring. Compatibility and requirements Before you install the iOS agent, review the compatibility and requirements. Install the agent As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. There are two ways you can install the iOS agent: We recommend you install and configure the iOS agent using the CocoaPods installation method. You can also manually install and configure the iOS agent by adding the New Relic framework to your app. Extend your instrumentation After you install the agent, you can extend the agent's default instrumentation with various types of custom data: To access: In the mobile UI: In New Relic One dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. You can also query the custom events that you created in New Relic One dashboards and NRQL. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. iOS SDK API Use the iOS SDK API to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. Troubleshoot your installation If the agent isn't reporting data, try these troubleshooting suggestions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 232.07886,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "sections": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for <em>iOS</em> gives you a comprehensive view of your app&#x27;s performance. It works for <em>iOS</em> apps written using Objective-C, Swift, or both languages. For a general overview of <em>mobile</em> <em>monitoring</em> functionality, see Introduction to <em>mobile</em> <em>monitoring</em>. Compatibility and requirements"
      },
      "id": "6043a48fe7b9d2ad8d5799db"
    },
    {
      "sections": [
        "Report mobile monitoring custom events and attributes",
        "Create custom attributes and events",
        "Mobile event and attribute query examples",
        "Custom event example: Track purchases",
        "Tip",
        "Attribute example: Track a specific user",
        "Attribute example: Track a specific store id",
        "Custom attribute example: Track a specific action",
        "Important",
        "Size limits and restricted characters",
        "Set the time to send data",
        "Privacy considerations"
      ],
      "title": "Report mobile monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "65970eacbedb3360fd1c7394affc8cbc42f2ab0c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/report-mobile-monitoring-custom-events-attributes/",
      "published_at": "2021-10-24T14:59:18Z",
      "updated_at": "2021-10-23T21:59:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring in New Relic sends some default event data from your mobile app to New Relic, such as data about interactions, sessions, crashes, and request errors. You can also create your own custom attributes and events for more detailed querying and analysis. Create custom attributes and events You can create custom session-level attributes for default mobile monitoring events using the mobile agent SDKs. For example, to record a username attribute for some part of your iOS or Android app, you would use the setAttribute API (Android | iOS). These attributes are session-related information and are shared by multiple mobile event types. You can also create entirely new custom event types and assign them their own custom attributes, using the recordCustomEvent API (Android | iOS). To help with crash analysis, you can use the SDK to create MobileBreadcrumb and MobileHandledException events. These events are available for querying and also displayed in the crash event trail UI. For more on creating custom attributes and custom events, see: Android SDK API guide iOS SDK API guide NRQL query examples MobileRequestError examples MobileRequest examples Limits and restricted characters Mobile event and attribute query examples Here are some examples of using NRQL to query your mobile app events and attributes: Custom event example: Track purchases To track purchases in your app, use recordCustomEvent to create an event type (such as \"UserAction\") and associate attributes such as \"name\" (with value \"Purchase\"), price, quantity, and SKU. Tip For performance reasons, you should limit the total number of event types to maybe one or two. The recordCustomEvent parameter eventType is meant to be used for high-level categories. For example, you might create an event typeGestures, and then create many different custom event names under the Gesture event type. Create an event on iOS: BOOL purchaseRecorded = [NewRelic recordCustomEvent:@\"UserAction\" attributes:@{@\"name\": @\"Purchase\", @\"sku\": @\"12345LPD\", @\"quantity\": @1, @\"unitPrice\": @99.99, @\"total\": @99.99}]; Copy Create an event on Android: Map<String, Object> userActionAttributes = new HashMap<String, Object>(); userActionAttributes.put(\"name\", \"Purchase\"); userActionAttributes.put(\"sku\", \"12345LPD\"); userActionAttributes.put(\"quantity\", 1); userActionAttributes.put(\"unitPrice\", 99.99); userActionAttributes.put(\"total\", 99.99); boolean userActionRecorded = NewRelic.recordCustomEvent(\"UserAction\", userActionAttributes); Copy New Relic reports a custom event of type UserAction and name Purchase, which allows you to query all purchases made in your app in the last day: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Replace deprecated recordEvent method: As of Android agent version 5.12.0 and iOS agent version 5.12.0, use the recordCustomEvent method to create these custom events. If you have replaced the deprecated recordEvent method for your custom events, be sure to also replace its corresponding NRQL query with the new format. Look for queries used with recordEvent method, such as this: SELECT * from Mobile where category = 'Custom' and name = 'Purchase' since 1 day ago Copy Replace them with the query format used with recordCustomEvent: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Attribute example: Track a specific user You can create a custom attribute to track a custom user identifier across the session, and then query for all that user's interactions. To add an attribute for the userId, call the setUserId method: Set the userId on iOS: BOOL userIdWasSet = [NewRelic setUserId:@\"jsmith\"]; Copy Set the userId on Android: boolean userIdWasSet = NewRelic.setUserId(\"jsmith\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that username in the last day: SELECT * from Mobile WHERE userId = 'jsmith' since 1 day ago Copy Attribute example: Track a specific store id You can create a custom attribute to track a store id across the session, and then query for all that store's interactions. To add an attribute for the storeId, call the setAttribute method: Set the storeId on iOS: BOOL attributeSet = [NewRelic setAttribute:@\"storeId\" value:@\"NY0531\"]; Copy Set the storeId on Android: boolean attributeSet = NewRelic.setAttribute(\"storeId\", \"NY0531\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that storeId in the last day: SELECT * from Mobile WHERE storeId = 'NY0531' since 1 day ago Copy Custom attribute example: Track a specific action You can use custom attributes to track the number of times that a specific action occurs in your application. For example, you can track the number of times a button was clicked or the number of times a level was completed in a game. To track completing a game level, call incrementAttribute with no value specified. This creates an attribute with a default value of 1: Create a counter on iOS: BOOL levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Create a counter on Android: boolean levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Each subsequent call to incrementAttribute adds 1 to the attribute level: Increment a counter on iOS: levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Increment a counter on Android: levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Important Be sure to reset the value to 0 when starting over. To reset the level back to 1 or 0, call setAttribute: Reset a counter on iOS: levelReset = [NewRelic setAttribute:@\"level\" value:@1]; Copy Reset a counter on Android: levelReset = NewRelic.setAttribute(\"level\", 1); Copy When querying, use this level attribute to filter your data. For example, if you have a username and level attribute, use the max() function to find the highest level the user had reached: SELECT max(level) from Mobile where username = 'jsmith' Copy Size limits and restricted characters Limits for custom attributes added to default mobile events: Attributes: 128 maximum String attributes: 4 KB maximum length (empty string values are not accepted) Limits for custom events: Attributes: 254 maximum per event (number includes default session attributes) String attributes: 4 KB maximum length (empty string values are not accepted) Naming syntax and rules: See Rules for custom data. Set the time to send data By default, New Relic transmits event data in any of these situations: A session has been ongoing for 600 seconds. The app session ends by backgrounding. The app crashes. If the app crashes, New Relic gathers the attributes and events for that session and sends them to Insights. (On iOS, this happens the next time the app is launched). You can then use Insights to query and analyze the event and attribute data. To set the maximum time (in seconds) that the agent will store events in memory, use the following SDK calls: iOS method: + (void) setMaxEventBufferTime:(unsigned int)seconds; Copy Android method: public static void setMaxEventBufferTime(int maxBufferTimeInSec); Copy Privacy considerations If you want to collect personal data via custom attributes, please consult with your privacy or legal teams. Be sure to follow your organization's obligations for notices and consent regulations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 231.4678,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report <em>mobile</em> <em>monitoring</em> custom events and attributes",
        "sections": "Report <em>mobile</em> <em>monitoring</em> custom events and attributes",
        "tags": "<em>Insights</em>",
        "body": " information and are shared by multiple <em>mobile</em> event types. You can also create entirely <em>new</em> custom event types and assign them their own custom attributes, using the recordCustomEvent <em>API</em> (Android | <em>iOS</em>). To help with crash analysis, you can use the <em>SDK</em> to create <em>Mobile</em>Breadcrumb and <em>Mobile</em>"
      },
      "id": "609fa5cf28ccbc508d9832d3"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/recordcustomevent-ios-sdk-api": [
    {
      "sections": [
        "Adding a prefix header to an iOS project"
      ],
      "title": "Adding a prefix header to an iOS project",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "11df0352a96527157fdd932f7a5bacf0beb8a0ae",
      "image": "https://docs.newrelic.com/static/89991d3f20208fe696e48b3143745df9/8c557/screen-ios-sdk-api-prefix-header.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/adding-prefix-header-ios-project/",
      "published_at": "2021-10-24T16:49:48Z",
      "updated_at": "2021-07-09T08:43:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Installing New Relic's iOS SDK API requires you to modify your project's prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File > New > File... From iOS template options, select Other > PCH file. Name the file < target_name>-Prefix.pch, and then select Create. From your targetâ€™s Build settings, select All, and then add the following to the Prefix Header field: $(SRCROOT)/<target_name>-Prefix.pch Copy Here is an example of using XcodeÂ to add a Prefix Header file to your iOS project for the iOS SDK API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 255.09282,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Adding a prefix header to an <em>iOS</em> project",
        "sections": "Adding a prefix header to an <em>iOS</em> project",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Installing <em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> <em>SDK</em> <em>API</em> requires you to modify your project&#x27;s prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File &gt; <em>New</em> &gt; File... From <em>iOS</em> template options, select Other &gt; PCH file. Name the file &lt; target_name&gt;-Prefix.pch"
      },
      "id": "6044195fe7b9d2f201579a09"
    },
    {
      "sections": [
        "Introduction to iOS monitoring",
        "Compatibility and requirements",
        "Install the agent",
        "Extend your instrumentation",
        "Troubleshoot your installation"
      ],
      "title": "Introduction to iOS monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "243234aeaa02a13856775f6f154cab24a1e5db26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios/",
      "published_at": "2021-10-24T16:51:42Z",
      "updated_at": "2021-07-08T01:46:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring for iOS gives you a comprehensive view of your app's performance. It works for iOS apps written using Objective-C, Swift, or both languages. For a general overview of mobile monitoring functionality, see Introduction to mobile monitoring. Compatibility and requirements Before you install the iOS agent, review the compatibility and requirements. Install the agent As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. There are two ways you can install the iOS agent: We recommend you install and configure the iOS agent using the CocoaPods installation method. You can also manually install and configure the iOS agent by adding the New Relic framework to your app. Extend your instrumentation After you install the agent, you can extend the agent's default instrumentation with various types of custom data: To access: In the mobile UI: In New Relic One dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. You can also query the custom events that you created in New Relic One dashboards and NRQL. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. iOS SDK API Use the iOS SDK API to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. Troubleshoot your installation If the agent isn't reporting data, try these troubleshooting suggestions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 232.07886,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "sections": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for <em>iOS</em> gives you a comprehensive view of your app&#x27;s performance. It works for <em>iOS</em> apps written using Objective-C, Swift, or both languages. For a general overview of <em>mobile</em> <em>monitoring</em> functionality, see Introduction to <em>mobile</em> <em>monitoring</em>. Compatibility and requirements"
      },
      "id": "6043a48fe7b9d2ad8d5799db"
    },
    {
      "sections": [
        "Report mobile monitoring custom events and attributes",
        "Create custom attributes and events",
        "Mobile event and attribute query examples",
        "Custom event example: Track purchases",
        "Tip",
        "Attribute example: Track a specific user",
        "Attribute example: Track a specific store id",
        "Custom attribute example: Track a specific action",
        "Important",
        "Size limits and restricted characters",
        "Set the time to send data",
        "Privacy considerations"
      ],
      "title": "Report mobile monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "65970eacbedb3360fd1c7394affc8cbc42f2ab0c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/report-mobile-monitoring-custom-events-attributes/",
      "published_at": "2021-10-24T14:59:18Z",
      "updated_at": "2021-10-23T21:59:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring in New Relic sends some default event data from your mobile app to New Relic, such as data about interactions, sessions, crashes, and request errors. You can also create your own custom attributes and events for more detailed querying and analysis. Create custom attributes and events You can create custom session-level attributes for default mobile monitoring events using the mobile agent SDKs. For example, to record a username attribute for some part of your iOS or Android app, you would use the setAttribute API (Android | iOS). These attributes are session-related information and are shared by multiple mobile event types. You can also create entirely new custom event types and assign them their own custom attributes, using the recordCustomEvent API (Android | iOS). To help with crash analysis, you can use the SDK to create MobileBreadcrumb and MobileHandledException events. These events are available for querying and also displayed in the crash event trail UI. For more on creating custom attributes and custom events, see: Android SDK API guide iOS SDK API guide NRQL query examples MobileRequestError examples MobileRequest examples Limits and restricted characters Mobile event and attribute query examples Here are some examples of using NRQL to query your mobile app events and attributes: Custom event example: Track purchases To track purchases in your app, use recordCustomEvent to create an event type (such as \"UserAction\") and associate attributes such as \"name\" (with value \"Purchase\"), price, quantity, and SKU. Tip For performance reasons, you should limit the total number of event types to maybe one or two. The recordCustomEvent parameter eventType is meant to be used for high-level categories. For example, you might create an event typeGestures, and then create many different custom event names under the Gesture event type. Create an event on iOS: BOOL purchaseRecorded = [NewRelic recordCustomEvent:@\"UserAction\" attributes:@{@\"name\": @\"Purchase\", @\"sku\": @\"12345LPD\", @\"quantity\": @1, @\"unitPrice\": @99.99, @\"total\": @99.99}]; Copy Create an event on Android: Map<String, Object> userActionAttributes = new HashMap<String, Object>(); userActionAttributes.put(\"name\", \"Purchase\"); userActionAttributes.put(\"sku\", \"12345LPD\"); userActionAttributes.put(\"quantity\", 1); userActionAttributes.put(\"unitPrice\", 99.99); userActionAttributes.put(\"total\", 99.99); boolean userActionRecorded = NewRelic.recordCustomEvent(\"UserAction\", userActionAttributes); Copy New Relic reports a custom event of type UserAction and name Purchase, which allows you to query all purchases made in your app in the last day: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Replace deprecated recordEvent method: As of Android agent version 5.12.0 and iOS agent version 5.12.0, use the recordCustomEvent method to create these custom events. If you have replaced the deprecated recordEvent method for your custom events, be sure to also replace its corresponding NRQL query with the new format. Look for queries used with recordEvent method, such as this: SELECT * from Mobile where category = 'Custom' and name = 'Purchase' since 1 day ago Copy Replace them with the query format used with recordCustomEvent: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Attribute example: Track a specific user You can create a custom attribute to track a custom user identifier across the session, and then query for all that user's interactions. To add an attribute for the userId, call the setUserId method: Set the userId on iOS: BOOL userIdWasSet = [NewRelic setUserId:@\"jsmith\"]; Copy Set the userId on Android: boolean userIdWasSet = NewRelic.setUserId(\"jsmith\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that username in the last day: SELECT * from Mobile WHERE userId = 'jsmith' since 1 day ago Copy Attribute example: Track a specific store id You can create a custom attribute to track a store id across the session, and then query for all that store's interactions. To add an attribute for the storeId, call the setAttribute method: Set the storeId on iOS: BOOL attributeSet = [NewRelic setAttribute:@\"storeId\" value:@\"NY0531\"]; Copy Set the storeId on Android: boolean attributeSet = NewRelic.setAttribute(\"storeId\", \"NY0531\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that storeId in the last day: SELECT * from Mobile WHERE storeId = 'NY0531' since 1 day ago Copy Custom attribute example: Track a specific action You can use custom attributes to track the number of times that a specific action occurs in your application. For example, you can track the number of times a button was clicked or the number of times a level was completed in a game. To track completing a game level, call incrementAttribute with no value specified. This creates an attribute with a default value of 1: Create a counter on iOS: BOOL levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Create a counter on Android: boolean levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Each subsequent call to incrementAttribute adds 1 to the attribute level: Increment a counter on iOS: levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Increment a counter on Android: levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Important Be sure to reset the value to 0 when starting over. To reset the level back to 1 or 0, call setAttribute: Reset a counter on iOS: levelReset = [NewRelic setAttribute:@\"level\" value:@1]; Copy Reset a counter on Android: levelReset = NewRelic.setAttribute(\"level\", 1); Copy When querying, use this level attribute to filter your data. For example, if you have a username and level attribute, use the max() function to find the highest level the user had reached: SELECT max(level) from Mobile where username = 'jsmith' Copy Size limits and restricted characters Limits for custom attributes added to default mobile events: Attributes: 128 maximum String attributes: 4 KB maximum length (empty string values are not accepted) Limits for custom events: Attributes: 254 maximum per event (number includes default session attributes) String attributes: 4 KB maximum length (empty string values are not accepted) Naming syntax and rules: See Rules for custom data. Set the time to send data By default, New Relic transmits event data in any of these situations: A session has been ongoing for 600 seconds. The app session ends by backgrounding. The app crashes. If the app crashes, New Relic gathers the attributes and events for that session and sends them to Insights. (On iOS, this happens the next time the app is launched). You can then use Insights to query and analyze the event and attribute data. To set the maximum time (in seconds) that the agent will store events in memory, use the following SDK calls: iOS method: + (void) setMaxEventBufferTime:(unsigned int)seconds; Copy Android method: public static void setMaxEventBufferTime(int maxBufferTimeInSec); Copy Privacy considerations If you want to collect personal data via custom attributes, please consult with your privacy or legal teams. Be sure to follow your organization's obligations for notices and consent regulations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 231.4678,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report <em>mobile</em> <em>monitoring</em> custom events and attributes",
        "sections": "Report <em>mobile</em> <em>monitoring</em> custom events and attributes",
        "tags": "<em>Insights</em>",
        "body": " information and are shared by multiple <em>mobile</em> event types. You can also create entirely <em>new</em> custom event types and assign them their own custom attributes, using the recordCustomEvent <em>API</em> (Android | <em>iOS</em>). To help with crash analysis, you can use the <em>SDK</em> to create <em>Mobile</em>Breadcrumb and <em>Mobile</em>"
      },
      "id": "609fa5cf28ccbc508d9832d3"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/recorderror-ios-sdk-api": [
    {
      "sections": [
        "Adding a prefix header to an iOS project"
      ],
      "title": "Adding a prefix header to an iOS project",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "11df0352a96527157fdd932f7a5bacf0beb8a0ae",
      "image": "https://docs.newrelic.com/static/89991d3f20208fe696e48b3143745df9/8c557/screen-ios-sdk-api-prefix-header.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/adding-prefix-header-ios-project/",
      "published_at": "2021-10-24T16:49:48Z",
      "updated_at": "2021-07-09T08:43:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Installing New Relic's iOS SDK API requires you to modify your project's prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File > New > File... From iOS template options, select Other > PCH file. Name the file < target_name>-Prefix.pch, and then select Create. From your targetâ€™s Build settings, select All, and then add the following to the Prefix Header field: $(SRCROOT)/<target_name>-Prefix.pch Copy Here is an example of using XcodeÂ to add a Prefix Header file to your iOS project for the iOS SDK API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 255.09282,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Adding a prefix header to an <em>iOS</em> project",
        "sections": "Adding a prefix header to an <em>iOS</em> project",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Installing <em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> <em>SDK</em> <em>API</em> requires you to modify your project&#x27;s prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File &gt; <em>New</em> &gt; File... From <em>iOS</em> template options, select Other &gt; PCH file. Name the file &lt; target_name&gt;-Prefix.pch"
      },
      "id": "6044195fe7b9d2f201579a09"
    },
    {
      "sections": [
        "Introduction to iOS monitoring",
        "Compatibility and requirements",
        "Install the agent",
        "Extend your instrumentation",
        "Troubleshoot your installation"
      ],
      "title": "Introduction to iOS monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "243234aeaa02a13856775f6f154cab24a1e5db26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios/",
      "published_at": "2021-10-24T16:51:42Z",
      "updated_at": "2021-07-08T01:46:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring for iOS gives you a comprehensive view of your app's performance. It works for iOS apps written using Objective-C, Swift, or both languages. For a general overview of mobile monitoring functionality, see Introduction to mobile monitoring. Compatibility and requirements Before you install the iOS agent, review the compatibility and requirements. Install the agent As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. There are two ways you can install the iOS agent: We recommend you install and configure the iOS agent using the CocoaPods installation method. You can also manually install and configure the iOS agent by adding the New Relic framework to your app. Extend your instrumentation After you install the agent, you can extend the agent's default instrumentation with various types of custom data: To access: In the mobile UI: In New Relic One dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. You can also query the custom events that you created in New Relic One dashboards and NRQL. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. iOS SDK API Use the iOS SDK API to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. Troubleshoot your installation If the agent isn't reporting data, try these troubleshooting suggestions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 232.07886,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "sections": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for <em>iOS</em> gives you a comprehensive view of your app&#x27;s performance. It works for <em>iOS</em> apps written using Objective-C, Swift, or both languages. For a general overview of <em>mobile</em> <em>monitoring</em> functionality, see Introduction to <em>mobile</em> <em>monitoring</em>. Compatibility and requirements"
      },
      "id": "6043a48fe7b9d2ad8d5799db"
    },
    {
      "sections": [
        "Report mobile monitoring custom events and attributes",
        "Create custom attributes and events",
        "Mobile event and attribute query examples",
        "Custom event example: Track purchases",
        "Tip",
        "Attribute example: Track a specific user",
        "Attribute example: Track a specific store id",
        "Custom attribute example: Track a specific action",
        "Important",
        "Size limits and restricted characters",
        "Set the time to send data",
        "Privacy considerations"
      ],
      "title": "Report mobile monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "65970eacbedb3360fd1c7394affc8cbc42f2ab0c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/report-mobile-monitoring-custom-events-attributes/",
      "published_at": "2021-10-24T14:59:18Z",
      "updated_at": "2021-10-23T21:59:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring in New Relic sends some default event data from your mobile app to New Relic, such as data about interactions, sessions, crashes, and request errors. You can also create your own custom attributes and events for more detailed querying and analysis. Create custom attributes and events You can create custom session-level attributes for default mobile monitoring events using the mobile agent SDKs. For example, to record a username attribute for some part of your iOS or Android app, you would use the setAttribute API (Android | iOS). These attributes are session-related information and are shared by multiple mobile event types. You can also create entirely new custom event types and assign them their own custom attributes, using the recordCustomEvent API (Android | iOS). To help with crash analysis, you can use the SDK to create MobileBreadcrumb and MobileHandledException events. These events are available for querying and also displayed in the crash event trail UI. For more on creating custom attributes and custom events, see: Android SDK API guide iOS SDK API guide NRQL query examples MobileRequestError examples MobileRequest examples Limits and restricted characters Mobile event and attribute query examples Here are some examples of using NRQL to query your mobile app events and attributes: Custom event example: Track purchases To track purchases in your app, use recordCustomEvent to create an event type (such as \"UserAction\") and associate attributes such as \"name\" (with value \"Purchase\"), price, quantity, and SKU. Tip For performance reasons, you should limit the total number of event types to maybe one or two. The recordCustomEvent parameter eventType is meant to be used for high-level categories. For example, you might create an event typeGestures, and then create many different custom event names under the Gesture event type. Create an event on iOS: BOOL purchaseRecorded = [NewRelic recordCustomEvent:@\"UserAction\" attributes:@{@\"name\": @\"Purchase\", @\"sku\": @\"12345LPD\", @\"quantity\": @1, @\"unitPrice\": @99.99, @\"total\": @99.99}]; Copy Create an event on Android: Map<String, Object> userActionAttributes = new HashMap<String, Object>(); userActionAttributes.put(\"name\", \"Purchase\"); userActionAttributes.put(\"sku\", \"12345LPD\"); userActionAttributes.put(\"quantity\", 1); userActionAttributes.put(\"unitPrice\", 99.99); userActionAttributes.put(\"total\", 99.99); boolean userActionRecorded = NewRelic.recordCustomEvent(\"UserAction\", userActionAttributes); Copy New Relic reports a custom event of type UserAction and name Purchase, which allows you to query all purchases made in your app in the last day: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Replace deprecated recordEvent method: As of Android agent version 5.12.0 and iOS agent version 5.12.0, use the recordCustomEvent method to create these custom events. If you have replaced the deprecated recordEvent method for your custom events, be sure to also replace its corresponding NRQL query with the new format. Look for queries used with recordEvent method, such as this: SELECT * from Mobile where category = 'Custom' and name = 'Purchase' since 1 day ago Copy Replace them with the query format used with recordCustomEvent: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Attribute example: Track a specific user You can create a custom attribute to track a custom user identifier across the session, and then query for all that user's interactions. To add an attribute for the userId, call the setUserId method: Set the userId on iOS: BOOL userIdWasSet = [NewRelic setUserId:@\"jsmith\"]; Copy Set the userId on Android: boolean userIdWasSet = NewRelic.setUserId(\"jsmith\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that username in the last day: SELECT * from Mobile WHERE userId = 'jsmith' since 1 day ago Copy Attribute example: Track a specific store id You can create a custom attribute to track a store id across the session, and then query for all that store's interactions. To add an attribute for the storeId, call the setAttribute method: Set the storeId on iOS: BOOL attributeSet = [NewRelic setAttribute:@\"storeId\" value:@\"NY0531\"]; Copy Set the storeId on Android: boolean attributeSet = NewRelic.setAttribute(\"storeId\", \"NY0531\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that storeId in the last day: SELECT * from Mobile WHERE storeId = 'NY0531' since 1 day ago Copy Custom attribute example: Track a specific action You can use custom attributes to track the number of times that a specific action occurs in your application. For example, you can track the number of times a button was clicked or the number of times a level was completed in a game. To track completing a game level, call incrementAttribute with no value specified. This creates an attribute with a default value of 1: Create a counter on iOS: BOOL levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Create a counter on Android: boolean levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Each subsequent call to incrementAttribute adds 1 to the attribute level: Increment a counter on iOS: levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Increment a counter on Android: levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Important Be sure to reset the value to 0 when starting over. To reset the level back to 1 or 0, call setAttribute: Reset a counter on iOS: levelReset = [NewRelic setAttribute:@\"level\" value:@1]; Copy Reset a counter on Android: levelReset = NewRelic.setAttribute(\"level\", 1); Copy When querying, use this level attribute to filter your data. For example, if you have a username and level attribute, use the max() function to find the highest level the user had reached: SELECT max(level) from Mobile where username = 'jsmith' Copy Size limits and restricted characters Limits for custom attributes added to default mobile events: Attributes: 128 maximum String attributes: 4 KB maximum length (empty string values are not accepted) Limits for custom events: Attributes: 254 maximum per event (number includes default session attributes) String attributes: 4 KB maximum length (empty string values are not accepted) Naming syntax and rules: See Rules for custom data. Set the time to send data By default, New Relic transmits event data in any of these situations: A session has been ongoing for 600 seconds. The app session ends by backgrounding. The app crashes. If the app crashes, New Relic gathers the attributes and events for that session and sends them to Insights. (On iOS, this happens the next time the app is launched). You can then use Insights to query and analyze the event and attribute data. To set the maximum time (in seconds) that the agent will store events in memory, use the following SDK calls: iOS method: + (void) setMaxEventBufferTime:(unsigned int)seconds; Copy Android method: public static void setMaxEventBufferTime(int maxBufferTimeInSec); Copy Privacy considerations If you want to collect personal data via custom attributes, please consult with your privacy or legal teams. Be sure to follow your organization's obligations for notices and consent regulations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 231.46762,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report <em>mobile</em> <em>monitoring</em> custom events and attributes",
        "sections": "Report <em>mobile</em> <em>monitoring</em> custom events and attributes",
        "tags": "<em>Insights</em>",
        "body": " information and are shared by multiple <em>mobile</em> event types. You can also create entirely <em>new</em> custom event types and assign them their own custom attributes, using the recordCustomEvent <em>API</em> (Android | <em>iOS</em>). To help with crash analysis, you can use the <em>SDK</em> to create <em>Mobile</em>Breadcrumb and <em>Mobile</em>"
      },
      "id": "609fa5cf28ccbc508d9832d3"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/recordmetric-ios-sdk-api": [
    {
      "sections": [
        "Adding a prefix header to an iOS project"
      ],
      "title": "Adding a prefix header to an iOS project",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "11df0352a96527157fdd932f7a5bacf0beb8a0ae",
      "image": "https://docs.newrelic.com/static/89991d3f20208fe696e48b3143745df9/8c557/screen-ios-sdk-api-prefix-header.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/adding-prefix-header-ios-project/",
      "published_at": "2021-10-24T16:49:48Z",
      "updated_at": "2021-07-09T08:43:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Installing New Relic's iOS SDK API requires you to modify your project's prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File > New > File... From iOS template options, select Other > PCH file. Name the file < target_name>-Prefix.pch, and then select Create. From your targetâ€™s Build settings, select All, and then add the following to the Prefix Header field: $(SRCROOT)/<target_name>-Prefix.pch Copy Here is an example of using XcodeÂ to add a Prefix Header file to your iOS project for the iOS SDK API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 255.09282,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Adding a prefix header to an <em>iOS</em> project",
        "sections": "Adding a prefix header to an <em>iOS</em> project",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Installing <em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> <em>SDK</em> <em>API</em> requires you to modify your project&#x27;s prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File &gt; <em>New</em> &gt; File... From <em>iOS</em> template options, select Other &gt; PCH file. Name the file &lt; target_name&gt;-Prefix.pch"
      },
      "id": "6044195fe7b9d2f201579a09"
    },
    {
      "sections": [
        "Introduction to iOS monitoring",
        "Compatibility and requirements",
        "Install the agent",
        "Extend your instrumentation",
        "Troubleshoot your installation"
      ],
      "title": "Introduction to iOS monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "243234aeaa02a13856775f6f154cab24a1e5db26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios/",
      "published_at": "2021-10-24T16:51:42Z",
      "updated_at": "2021-07-08T01:46:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring for iOS gives you a comprehensive view of your app's performance. It works for iOS apps written using Objective-C, Swift, or both languages. For a general overview of mobile monitoring functionality, see Introduction to mobile monitoring. Compatibility and requirements Before you install the iOS agent, review the compatibility and requirements. Install the agent As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. There are two ways you can install the iOS agent: We recommend you install and configure the iOS agent using the CocoaPods installation method. You can also manually install and configure the iOS agent by adding the New Relic framework to your app. Extend your instrumentation After you install the agent, you can extend the agent's default instrumentation with various types of custom data: To access: In the mobile UI: In New Relic One dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. You can also query the custom events that you created in New Relic One dashboards and NRQL. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. iOS SDK API Use the iOS SDK API to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. Troubleshoot your installation If the agent isn't reporting data, try these troubleshooting suggestions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 232.07886,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "sections": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for <em>iOS</em> gives you a comprehensive view of your app&#x27;s performance. It works for <em>iOS</em> apps written using Objective-C, Swift, or both languages. For a general overview of <em>mobile</em> <em>monitoring</em> functionality, see Introduction to <em>mobile</em> <em>monitoring</em>. Compatibility and requirements"
      },
      "id": "6043a48fe7b9d2ad8d5799db"
    },
    {
      "sections": [
        "Report mobile monitoring custom events and attributes",
        "Create custom attributes and events",
        "Mobile event and attribute query examples",
        "Custom event example: Track purchases",
        "Tip",
        "Attribute example: Track a specific user",
        "Attribute example: Track a specific store id",
        "Custom attribute example: Track a specific action",
        "Important",
        "Size limits and restricted characters",
        "Set the time to send data",
        "Privacy considerations"
      ],
      "title": "Report mobile monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "65970eacbedb3360fd1c7394affc8cbc42f2ab0c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/report-mobile-monitoring-custom-events-attributes/",
      "published_at": "2021-10-24T14:59:18Z",
      "updated_at": "2021-10-23T21:59:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring in New Relic sends some default event data from your mobile app to New Relic, such as data about interactions, sessions, crashes, and request errors. You can also create your own custom attributes and events for more detailed querying and analysis. Create custom attributes and events You can create custom session-level attributes for default mobile monitoring events using the mobile agent SDKs. For example, to record a username attribute for some part of your iOS or Android app, you would use the setAttribute API (Android | iOS). These attributes are session-related information and are shared by multiple mobile event types. You can also create entirely new custom event types and assign them their own custom attributes, using the recordCustomEvent API (Android | iOS). To help with crash analysis, you can use the SDK to create MobileBreadcrumb and MobileHandledException events. These events are available for querying and also displayed in the crash event trail UI. For more on creating custom attributes and custom events, see: Android SDK API guide iOS SDK API guide NRQL query examples MobileRequestError examples MobileRequest examples Limits and restricted characters Mobile event and attribute query examples Here are some examples of using NRQL to query your mobile app events and attributes: Custom event example: Track purchases To track purchases in your app, use recordCustomEvent to create an event type (such as \"UserAction\") and associate attributes such as \"name\" (with value \"Purchase\"), price, quantity, and SKU. Tip For performance reasons, you should limit the total number of event types to maybe one or two. The recordCustomEvent parameter eventType is meant to be used for high-level categories. For example, you might create an event typeGestures, and then create many different custom event names under the Gesture event type. Create an event on iOS: BOOL purchaseRecorded = [NewRelic recordCustomEvent:@\"UserAction\" attributes:@{@\"name\": @\"Purchase\", @\"sku\": @\"12345LPD\", @\"quantity\": @1, @\"unitPrice\": @99.99, @\"total\": @99.99}]; Copy Create an event on Android: Map<String, Object> userActionAttributes = new HashMap<String, Object>(); userActionAttributes.put(\"name\", \"Purchase\"); userActionAttributes.put(\"sku\", \"12345LPD\"); userActionAttributes.put(\"quantity\", 1); userActionAttributes.put(\"unitPrice\", 99.99); userActionAttributes.put(\"total\", 99.99); boolean userActionRecorded = NewRelic.recordCustomEvent(\"UserAction\", userActionAttributes); Copy New Relic reports a custom event of type UserAction and name Purchase, which allows you to query all purchases made in your app in the last day: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Replace deprecated recordEvent method: As of Android agent version 5.12.0 and iOS agent version 5.12.0, use the recordCustomEvent method to create these custom events. If you have replaced the deprecated recordEvent method for your custom events, be sure to also replace its corresponding NRQL query with the new format. Look for queries used with recordEvent method, such as this: SELECT * from Mobile where category = 'Custom' and name = 'Purchase' since 1 day ago Copy Replace them with the query format used with recordCustomEvent: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Attribute example: Track a specific user You can create a custom attribute to track a custom user identifier across the session, and then query for all that user's interactions. To add an attribute for the userId, call the setUserId method: Set the userId on iOS: BOOL userIdWasSet = [NewRelic setUserId:@\"jsmith\"]; Copy Set the userId on Android: boolean userIdWasSet = NewRelic.setUserId(\"jsmith\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that username in the last day: SELECT * from Mobile WHERE userId = 'jsmith' since 1 day ago Copy Attribute example: Track a specific store id You can create a custom attribute to track a store id across the session, and then query for all that store's interactions. To add an attribute for the storeId, call the setAttribute method: Set the storeId on iOS: BOOL attributeSet = [NewRelic setAttribute:@\"storeId\" value:@\"NY0531\"]; Copy Set the storeId on Android: boolean attributeSet = NewRelic.setAttribute(\"storeId\", \"NY0531\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that storeId in the last day: SELECT * from Mobile WHERE storeId = 'NY0531' since 1 day ago Copy Custom attribute example: Track a specific action You can use custom attributes to track the number of times that a specific action occurs in your application. For example, you can track the number of times a button was clicked or the number of times a level was completed in a game. To track completing a game level, call incrementAttribute with no value specified. This creates an attribute with a default value of 1: Create a counter on iOS: BOOL levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Create a counter on Android: boolean levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Each subsequent call to incrementAttribute adds 1 to the attribute level: Increment a counter on iOS: levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Increment a counter on Android: levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Important Be sure to reset the value to 0 when starting over. To reset the level back to 1 or 0, call setAttribute: Reset a counter on iOS: levelReset = [NewRelic setAttribute:@\"level\" value:@1]; Copy Reset a counter on Android: levelReset = NewRelic.setAttribute(\"level\", 1); Copy When querying, use this level attribute to filter your data. For example, if you have a username and level attribute, use the max() function to find the highest level the user had reached: SELECT max(level) from Mobile where username = 'jsmith' Copy Size limits and restricted characters Limits for custom attributes added to default mobile events: Attributes: 128 maximum String attributes: 4 KB maximum length (empty string values are not accepted) Limits for custom events: Attributes: 254 maximum per event (number includes default session attributes) String attributes: 4 KB maximum length (empty string values are not accepted) Naming syntax and rules: See Rules for custom data. Set the time to send data By default, New Relic transmits event data in any of these situations: A session has been ongoing for 600 seconds. The app session ends by backgrounding. The app crashes. If the app crashes, New Relic gathers the attributes and events for that session and sends them to Insights. (On iOS, this happens the next time the app is launched). You can then use Insights to query and analyze the event and attribute data. To set the maximum time (in seconds) that the agent will store events in memory, use the following SDK calls: iOS method: + (void) setMaxEventBufferTime:(unsigned int)seconds; Copy Android method: public static void setMaxEventBufferTime(int maxBufferTimeInSec); Copy Privacy considerations If you want to collect personal data via custom attributes, please consult with your privacy or legal teams. Be sure to follow your organization's obligations for notices and consent regulations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 231.46762,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report <em>mobile</em> <em>monitoring</em> custom events and attributes",
        "sections": "Report <em>mobile</em> <em>monitoring</em> custom events and attributes",
        "tags": "<em>Insights</em>",
        "body": " information and are shared by multiple <em>mobile</em> event types. You can also create entirely <em>new</em> custom event types and assign them their own custom attributes, using the recordCustomEvent <em>API</em> (Android | <em>iOS</em>). To help with crash analysis, you can use the <em>SDK</em> to create <em>Mobile</em>Breadcrumb and <em>Mobile</em>"
      },
      "id": "609fa5cf28ccbc508d9832d3"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/remove-all-attributes": [
    {
      "sections": [
        "Adding a prefix header to an iOS project"
      ],
      "title": "Adding a prefix header to an iOS project",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "11df0352a96527157fdd932f7a5bacf0beb8a0ae",
      "image": "https://docs.newrelic.com/static/89991d3f20208fe696e48b3143745df9/8c557/screen-ios-sdk-api-prefix-header.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/adding-prefix-header-ios-project/",
      "published_at": "2021-10-24T16:49:48Z",
      "updated_at": "2021-07-09T08:43:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Installing New Relic's iOS SDK API requires you to modify your project's prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File > New > File... From iOS template options, select Other > PCH file. Name the file < target_name>-Prefix.pch, and then select Create. From your targetâ€™s Build settings, select All, and then add the following to the Prefix Header field: $(SRCROOT)/<target_name>-Prefix.pch Copy Here is an example of using XcodeÂ to add a Prefix Header file to your iOS project for the iOS SDK API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 255.09282,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Adding a prefix header to an <em>iOS</em> project",
        "sections": "Adding a prefix header to an <em>iOS</em> project",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Installing <em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> <em>SDK</em> <em>API</em> requires you to modify your project&#x27;s prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File &gt; <em>New</em> &gt; File... From <em>iOS</em> template options, select Other &gt; PCH file. Name the file &lt; target_name&gt;-Prefix.pch"
      },
      "id": "6044195fe7b9d2f201579a09"
    },
    {
      "sections": [
        "Introduction to iOS monitoring",
        "Compatibility and requirements",
        "Install the agent",
        "Extend your instrumentation",
        "Troubleshoot your installation"
      ],
      "title": "Introduction to iOS monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "243234aeaa02a13856775f6f154cab24a1e5db26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios/",
      "published_at": "2021-10-24T16:51:42Z",
      "updated_at": "2021-07-08T01:46:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring for iOS gives you a comprehensive view of your app's performance. It works for iOS apps written using Objective-C, Swift, or both languages. For a general overview of mobile monitoring functionality, see Introduction to mobile monitoring. Compatibility and requirements Before you install the iOS agent, review the compatibility and requirements. Install the agent As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. There are two ways you can install the iOS agent: We recommend you install and configure the iOS agent using the CocoaPods installation method. You can also manually install and configure the iOS agent by adding the New Relic framework to your app. Extend your instrumentation After you install the agent, you can extend the agent's default instrumentation with various types of custom data: To access: In the mobile UI: In New Relic One dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. You can also query the custom events that you created in New Relic One dashboards and NRQL. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. iOS SDK API Use the iOS SDK API to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. Troubleshoot your installation If the agent isn't reporting data, try these troubleshooting suggestions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 232.07884,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "sections": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for <em>iOS</em> gives you a comprehensive view of your app&#x27;s performance. It works for <em>iOS</em> apps written using Objective-C, Swift, or both languages. For a general overview of <em>mobile</em> <em>monitoring</em> functionality, see Introduction to <em>mobile</em> <em>monitoring</em>. Compatibility and requirements"
      },
      "id": "6043a48fe7b9d2ad8d5799db"
    },
    {
      "sections": [
        "Report mobile monitoring custom events and attributes",
        "Create custom attributes and events",
        "Mobile event and attribute query examples",
        "Custom event example: Track purchases",
        "Tip",
        "Attribute example: Track a specific user",
        "Attribute example: Track a specific store id",
        "Custom attribute example: Track a specific action",
        "Important",
        "Size limits and restricted characters",
        "Set the time to send data",
        "Privacy considerations"
      ],
      "title": "Report mobile monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "65970eacbedb3360fd1c7394affc8cbc42f2ab0c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/report-mobile-monitoring-custom-events-attributes/",
      "published_at": "2021-10-24T14:59:18Z",
      "updated_at": "2021-10-23T21:59:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring in New Relic sends some default event data from your mobile app to New Relic, such as data about interactions, sessions, crashes, and request errors. You can also create your own custom attributes and events for more detailed querying and analysis. Create custom attributes and events You can create custom session-level attributes for default mobile monitoring events using the mobile agent SDKs. For example, to record a username attribute for some part of your iOS or Android app, you would use the setAttribute API (Android | iOS). These attributes are session-related information and are shared by multiple mobile event types. You can also create entirely new custom event types and assign them their own custom attributes, using the recordCustomEvent API (Android | iOS). To help with crash analysis, you can use the SDK to create MobileBreadcrumb and MobileHandledException events. These events are available for querying and also displayed in the crash event trail UI. For more on creating custom attributes and custom events, see: Android SDK API guide iOS SDK API guide NRQL query examples MobileRequestError examples MobileRequest examples Limits and restricted characters Mobile event and attribute query examples Here are some examples of using NRQL to query your mobile app events and attributes: Custom event example: Track purchases To track purchases in your app, use recordCustomEvent to create an event type (such as \"UserAction\") and associate attributes such as \"name\" (with value \"Purchase\"), price, quantity, and SKU. Tip For performance reasons, you should limit the total number of event types to maybe one or two. The recordCustomEvent parameter eventType is meant to be used for high-level categories. For example, you might create an event typeGestures, and then create many different custom event names under the Gesture event type. Create an event on iOS: BOOL purchaseRecorded = [NewRelic recordCustomEvent:@\"UserAction\" attributes:@{@\"name\": @\"Purchase\", @\"sku\": @\"12345LPD\", @\"quantity\": @1, @\"unitPrice\": @99.99, @\"total\": @99.99}]; Copy Create an event on Android: Map<String, Object> userActionAttributes = new HashMap<String, Object>(); userActionAttributes.put(\"name\", \"Purchase\"); userActionAttributes.put(\"sku\", \"12345LPD\"); userActionAttributes.put(\"quantity\", 1); userActionAttributes.put(\"unitPrice\", 99.99); userActionAttributes.put(\"total\", 99.99); boolean userActionRecorded = NewRelic.recordCustomEvent(\"UserAction\", userActionAttributes); Copy New Relic reports a custom event of type UserAction and name Purchase, which allows you to query all purchases made in your app in the last day: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Replace deprecated recordEvent method: As of Android agent version 5.12.0 and iOS agent version 5.12.0, use the recordCustomEvent method to create these custom events. If you have replaced the deprecated recordEvent method for your custom events, be sure to also replace its corresponding NRQL query with the new format. Look for queries used with recordEvent method, such as this: SELECT * from Mobile where category = 'Custom' and name = 'Purchase' since 1 day ago Copy Replace them with the query format used with recordCustomEvent: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Attribute example: Track a specific user You can create a custom attribute to track a custom user identifier across the session, and then query for all that user's interactions. To add an attribute for the userId, call the setUserId method: Set the userId on iOS: BOOL userIdWasSet = [NewRelic setUserId:@\"jsmith\"]; Copy Set the userId on Android: boolean userIdWasSet = NewRelic.setUserId(\"jsmith\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that username in the last day: SELECT * from Mobile WHERE userId = 'jsmith' since 1 day ago Copy Attribute example: Track a specific store id You can create a custom attribute to track a store id across the session, and then query for all that store's interactions. To add an attribute for the storeId, call the setAttribute method: Set the storeId on iOS: BOOL attributeSet = [NewRelic setAttribute:@\"storeId\" value:@\"NY0531\"]; Copy Set the storeId on Android: boolean attributeSet = NewRelic.setAttribute(\"storeId\", \"NY0531\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that storeId in the last day: SELECT * from Mobile WHERE storeId = 'NY0531' since 1 day ago Copy Custom attribute example: Track a specific action You can use custom attributes to track the number of times that a specific action occurs in your application. For example, you can track the number of times a button was clicked or the number of times a level was completed in a game. To track completing a game level, call incrementAttribute with no value specified. This creates an attribute with a default value of 1: Create a counter on iOS: BOOL levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Create a counter on Android: boolean levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Each subsequent call to incrementAttribute adds 1 to the attribute level: Increment a counter on iOS: levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Increment a counter on Android: levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Important Be sure to reset the value to 0 when starting over. To reset the level back to 1 or 0, call setAttribute: Reset a counter on iOS: levelReset = [NewRelic setAttribute:@\"level\" value:@1]; Copy Reset a counter on Android: levelReset = NewRelic.setAttribute(\"level\", 1); Copy When querying, use this level attribute to filter your data. For example, if you have a username and level attribute, use the max() function to find the highest level the user had reached: SELECT max(level) from Mobile where username = 'jsmith' Copy Size limits and restricted characters Limits for custom attributes added to default mobile events: Attributes: 128 maximum String attributes: 4 KB maximum length (empty string values are not accepted) Limits for custom events: Attributes: 254 maximum per event (number includes default session attributes) String attributes: 4 KB maximum length (empty string values are not accepted) Naming syntax and rules: See Rules for custom data. Set the time to send data By default, New Relic transmits event data in any of these situations: A session has been ongoing for 600 seconds. The app session ends by backgrounding. The app crashes. If the app crashes, New Relic gathers the attributes and events for that session and sends them to Insights. (On iOS, this happens the next time the app is launched). You can then use Insights to query and analyze the event and attribute data. To set the maximum time (in seconds) that the agent will store events in memory, use the following SDK calls: iOS method: + (void) setMaxEventBufferTime:(unsigned int)seconds; Copy Android method: public static void setMaxEventBufferTime(int maxBufferTimeInSec); Copy Privacy considerations If you want to collect personal data via custom attributes, please consult with your privacy or legal teams. Be sure to follow your organization's obligations for notices and consent regulations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 231.46744,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report <em>mobile</em> <em>monitoring</em> custom events and attributes",
        "sections": "Report <em>mobile</em> <em>monitoring</em> custom events and attributes",
        "tags": "<em>Insights</em>",
        "body": " information and are shared by multiple <em>mobile</em> event types. You can also create entirely <em>new</em> custom event types and assign them their own custom attributes, using the recordCustomEvent <em>API</em> (Android | <em>iOS</em>). To help with crash analysis, you can use the <em>SDK</em> to create <em>Mobile</em>Breadcrumb and <em>Mobile</em>"
      },
      "id": "609fa5cf28ccbc508d9832d3"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/remove-attribute": [
    {
      "sections": [
        "Adding a prefix header to an iOS project"
      ],
      "title": "Adding a prefix header to an iOS project",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "11df0352a96527157fdd932f7a5bacf0beb8a0ae",
      "image": "https://docs.newrelic.com/static/89991d3f20208fe696e48b3143745df9/8c557/screen-ios-sdk-api-prefix-header.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/adding-prefix-header-ios-project/",
      "published_at": "2021-10-24T16:49:48Z",
      "updated_at": "2021-07-09T08:43:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Installing New Relic's iOS SDK API requires you to modify your project's prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File > New > File... From iOS template options, select Other > PCH file. Name the file < target_name>-Prefix.pch, and then select Create. From your targetâ€™s Build settings, select All, and then add the following to the Prefix Header field: $(SRCROOT)/<target_name>-Prefix.pch Copy Here is an example of using XcodeÂ to add a Prefix Header file to your iOS project for the iOS SDK API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 255.09282,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Adding a prefix header to an <em>iOS</em> project",
        "sections": "Adding a prefix header to an <em>iOS</em> project",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Installing <em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> <em>SDK</em> <em>API</em> requires you to modify your project&#x27;s prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File &gt; <em>New</em> &gt; File... From <em>iOS</em> template options, select Other &gt; PCH file. Name the file &lt; target_name&gt;-Prefix.pch"
      },
      "id": "6044195fe7b9d2f201579a09"
    },
    {
      "sections": [
        "Introduction to iOS monitoring",
        "Compatibility and requirements",
        "Install the agent",
        "Extend your instrumentation",
        "Troubleshoot your installation"
      ],
      "title": "Introduction to iOS monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "243234aeaa02a13856775f6f154cab24a1e5db26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios/",
      "published_at": "2021-10-24T16:51:42Z",
      "updated_at": "2021-07-08T01:46:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring for iOS gives you a comprehensive view of your app's performance. It works for iOS apps written using Objective-C, Swift, or both languages. For a general overview of mobile monitoring functionality, see Introduction to mobile monitoring. Compatibility and requirements Before you install the iOS agent, review the compatibility and requirements. Install the agent As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. There are two ways you can install the iOS agent: We recommend you install and configure the iOS agent using the CocoaPods installation method. You can also manually install and configure the iOS agent by adding the New Relic framework to your app. Extend your instrumentation After you install the agent, you can extend the agent's default instrumentation with various types of custom data: To access: In the mobile UI: In New Relic One dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. You can also query the custom events that you created in New Relic One dashboards and NRQL. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. iOS SDK API Use the iOS SDK API to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. Troubleshoot your installation If the agent isn't reporting data, try these troubleshooting suggestions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 232.07884,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "sections": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for <em>iOS</em> gives you a comprehensive view of your app&#x27;s performance. It works for <em>iOS</em> apps written using Objective-C, Swift, or both languages. For a general overview of <em>mobile</em> <em>monitoring</em> functionality, see Introduction to <em>mobile</em> <em>monitoring</em>. Compatibility and requirements"
      },
      "id": "6043a48fe7b9d2ad8d5799db"
    },
    {
      "sections": [
        "Report mobile monitoring custom events and attributes",
        "Create custom attributes and events",
        "Mobile event and attribute query examples",
        "Custom event example: Track purchases",
        "Tip",
        "Attribute example: Track a specific user",
        "Attribute example: Track a specific store id",
        "Custom attribute example: Track a specific action",
        "Important",
        "Size limits and restricted characters",
        "Set the time to send data",
        "Privacy considerations"
      ],
      "title": "Report mobile monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "65970eacbedb3360fd1c7394affc8cbc42f2ab0c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/report-mobile-monitoring-custom-events-attributes/",
      "published_at": "2021-10-24T14:59:18Z",
      "updated_at": "2021-10-23T21:59:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring in New Relic sends some default event data from your mobile app to New Relic, such as data about interactions, sessions, crashes, and request errors. You can also create your own custom attributes and events for more detailed querying and analysis. Create custom attributes and events You can create custom session-level attributes for default mobile monitoring events using the mobile agent SDKs. For example, to record a username attribute for some part of your iOS or Android app, you would use the setAttribute API (Android | iOS). These attributes are session-related information and are shared by multiple mobile event types. You can also create entirely new custom event types and assign them their own custom attributes, using the recordCustomEvent API (Android | iOS). To help with crash analysis, you can use the SDK to create MobileBreadcrumb and MobileHandledException events. These events are available for querying and also displayed in the crash event trail UI. For more on creating custom attributes and custom events, see: Android SDK API guide iOS SDK API guide NRQL query examples MobileRequestError examples MobileRequest examples Limits and restricted characters Mobile event and attribute query examples Here are some examples of using NRQL to query your mobile app events and attributes: Custom event example: Track purchases To track purchases in your app, use recordCustomEvent to create an event type (such as \"UserAction\") and associate attributes such as \"name\" (with value \"Purchase\"), price, quantity, and SKU. Tip For performance reasons, you should limit the total number of event types to maybe one or two. The recordCustomEvent parameter eventType is meant to be used for high-level categories. For example, you might create an event typeGestures, and then create many different custom event names under the Gesture event type. Create an event on iOS: BOOL purchaseRecorded = [NewRelic recordCustomEvent:@\"UserAction\" attributes:@{@\"name\": @\"Purchase\", @\"sku\": @\"12345LPD\", @\"quantity\": @1, @\"unitPrice\": @99.99, @\"total\": @99.99}]; Copy Create an event on Android: Map<String, Object> userActionAttributes = new HashMap<String, Object>(); userActionAttributes.put(\"name\", \"Purchase\"); userActionAttributes.put(\"sku\", \"12345LPD\"); userActionAttributes.put(\"quantity\", 1); userActionAttributes.put(\"unitPrice\", 99.99); userActionAttributes.put(\"total\", 99.99); boolean userActionRecorded = NewRelic.recordCustomEvent(\"UserAction\", userActionAttributes); Copy New Relic reports a custom event of type UserAction and name Purchase, which allows you to query all purchases made in your app in the last day: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Replace deprecated recordEvent method: As of Android agent version 5.12.0 and iOS agent version 5.12.0, use the recordCustomEvent method to create these custom events. If you have replaced the deprecated recordEvent method for your custom events, be sure to also replace its corresponding NRQL query with the new format. Look for queries used with recordEvent method, such as this: SELECT * from Mobile where category = 'Custom' and name = 'Purchase' since 1 day ago Copy Replace them with the query format used with recordCustomEvent: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Attribute example: Track a specific user You can create a custom attribute to track a custom user identifier across the session, and then query for all that user's interactions. To add an attribute for the userId, call the setUserId method: Set the userId on iOS: BOOL userIdWasSet = [NewRelic setUserId:@\"jsmith\"]; Copy Set the userId on Android: boolean userIdWasSet = NewRelic.setUserId(\"jsmith\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that username in the last day: SELECT * from Mobile WHERE userId = 'jsmith' since 1 day ago Copy Attribute example: Track a specific store id You can create a custom attribute to track a store id across the session, and then query for all that store's interactions. To add an attribute for the storeId, call the setAttribute method: Set the storeId on iOS: BOOL attributeSet = [NewRelic setAttribute:@\"storeId\" value:@\"NY0531\"]; Copy Set the storeId on Android: boolean attributeSet = NewRelic.setAttribute(\"storeId\", \"NY0531\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that storeId in the last day: SELECT * from Mobile WHERE storeId = 'NY0531' since 1 day ago Copy Custom attribute example: Track a specific action You can use custom attributes to track the number of times that a specific action occurs in your application. For example, you can track the number of times a button was clicked or the number of times a level was completed in a game. To track completing a game level, call incrementAttribute with no value specified. This creates an attribute with a default value of 1: Create a counter on iOS: BOOL levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Create a counter on Android: boolean levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Each subsequent call to incrementAttribute adds 1 to the attribute level: Increment a counter on iOS: levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Increment a counter on Android: levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Important Be sure to reset the value to 0 when starting over. To reset the level back to 1 or 0, call setAttribute: Reset a counter on iOS: levelReset = [NewRelic setAttribute:@\"level\" value:@1]; Copy Reset a counter on Android: levelReset = NewRelic.setAttribute(\"level\", 1); Copy When querying, use this level attribute to filter your data. For example, if you have a username and level attribute, use the max() function to find the highest level the user had reached: SELECT max(level) from Mobile where username = 'jsmith' Copy Size limits and restricted characters Limits for custom attributes added to default mobile events: Attributes: 128 maximum String attributes: 4 KB maximum length (empty string values are not accepted) Limits for custom events: Attributes: 254 maximum per event (number includes default session attributes) String attributes: 4 KB maximum length (empty string values are not accepted) Naming syntax and rules: See Rules for custom data. Set the time to send data By default, New Relic transmits event data in any of these situations: A session has been ongoing for 600 seconds. The app session ends by backgrounding. The app crashes. If the app crashes, New Relic gathers the attributes and events for that session and sends them to Insights. (On iOS, this happens the next time the app is launched). You can then use Insights to query and analyze the event and attribute data. To set the maximum time (in seconds) that the agent will store events in memory, use the following SDK calls: iOS method: + (void) setMaxEventBufferTime:(unsigned int)seconds; Copy Android method: public static void setMaxEventBufferTime(int maxBufferTimeInSec); Copy Privacy considerations If you want to collect personal data via custom attributes, please consult with your privacy or legal teams. Be sure to follow your organization's obligations for notices and consent regulations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 231.46744,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report <em>mobile</em> <em>monitoring</em> custom events and attributes",
        "sections": "Report <em>mobile</em> <em>monitoring</em> custom events and attributes",
        "tags": "<em>Insights</em>",
        "body": " information and are shared by multiple <em>mobile</em> event types. You can also create entirely <em>new</em> custom event types and assign them their own custom attributes, using the recordCustomEvent <em>API</em> (Android | <em>iOS</em>). To help with crash analysis, you can use the <em>SDK</em> to create <em>Mobile</em>Breadcrumb and <em>Mobile</em>"
      },
      "id": "609fa5cf28ccbc508d9832d3"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/set-attribute": [
    {
      "sections": [
        "Adding a prefix header to an iOS project"
      ],
      "title": "Adding a prefix header to an iOS project",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "11df0352a96527157fdd932f7a5bacf0beb8a0ae",
      "image": "https://docs.newrelic.com/static/89991d3f20208fe696e48b3143745df9/8c557/screen-ios-sdk-api-prefix-header.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/adding-prefix-header-ios-project/",
      "published_at": "2021-10-24T16:49:48Z",
      "updated_at": "2021-07-09T08:43:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Installing New Relic's iOS SDK API requires you to modify your project's prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File > New > File... From iOS template options, select Other > PCH file. Name the file < target_name>-Prefix.pch, and then select Create. From your targetâ€™s Build settings, select All, and then add the following to the Prefix Header field: $(SRCROOT)/<target_name>-Prefix.pch Copy Here is an example of using XcodeÂ to add a Prefix Header file to your iOS project for the iOS SDK API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 255.09282,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Adding a prefix header to an <em>iOS</em> project",
        "sections": "Adding a prefix header to an <em>iOS</em> project",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Installing <em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> <em>SDK</em> <em>API</em> requires you to modify your project&#x27;s prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File &gt; <em>New</em> &gt; File... From <em>iOS</em> template options, select Other &gt; PCH file. Name the file &lt; target_name&gt;-Prefix.pch"
      },
      "id": "6044195fe7b9d2f201579a09"
    },
    {
      "sections": [
        "Introduction to iOS monitoring",
        "Compatibility and requirements",
        "Install the agent",
        "Extend your instrumentation",
        "Troubleshoot your installation"
      ],
      "title": "Introduction to iOS monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "243234aeaa02a13856775f6f154cab24a1e5db26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios/",
      "published_at": "2021-10-24T16:51:42Z",
      "updated_at": "2021-07-08T01:46:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring for iOS gives you a comprehensive view of your app's performance. It works for iOS apps written using Objective-C, Swift, or both languages. For a general overview of mobile monitoring functionality, see Introduction to mobile monitoring. Compatibility and requirements Before you install the iOS agent, review the compatibility and requirements. Install the agent As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. There are two ways you can install the iOS agent: We recommend you install and configure the iOS agent using the CocoaPods installation method. You can also manually install and configure the iOS agent by adding the New Relic framework to your app. Extend your instrumentation After you install the agent, you can extend the agent's default instrumentation with various types of custom data: To access: In the mobile UI: In New Relic One dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. You can also query the custom events that you created in New Relic One dashboards and NRQL. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. iOS SDK API Use the iOS SDK API to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. Troubleshoot your installation If the agent isn't reporting data, try these troubleshooting suggestions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 232.07884,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "sections": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for <em>iOS</em> gives you a comprehensive view of your app&#x27;s performance. It works for <em>iOS</em> apps written using Objective-C, Swift, or both languages. For a general overview of <em>mobile</em> <em>monitoring</em> functionality, see Introduction to <em>mobile</em> <em>monitoring</em>. Compatibility and requirements"
      },
      "id": "6043a48fe7b9d2ad8d5799db"
    },
    {
      "sections": [
        "Report mobile monitoring custom events and attributes",
        "Create custom attributes and events",
        "Mobile event and attribute query examples",
        "Custom event example: Track purchases",
        "Tip",
        "Attribute example: Track a specific user",
        "Attribute example: Track a specific store id",
        "Custom attribute example: Track a specific action",
        "Important",
        "Size limits and restricted characters",
        "Set the time to send data",
        "Privacy considerations"
      ],
      "title": "Report mobile monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "65970eacbedb3360fd1c7394affc8cbc42f2ab0c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/report-mobile-monitoring-custom-events-attributes/",
      "published_at": "2021-10-24T14:59:18Z",
      "updated_at": "2021-10-23T21:59:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring in New Relic sends some default event data from your mobile app to New Relic, such as data about interactions, sessions, crashes, and request errors. You can also create your own custom attributes and events for more detailed querying and analysis. Create custom attributes and events You can create custom session-level attributes for default mobile monitoring events using the mobile agent SDKs. For example, to record a username attribute for some part of your iOS or Android app, you would use the setAttribute API (Android | iOS). These attributes are session-related information and are shared by multiple mobile event types. You can also create entirely new custom event types and assign them their own custom attributes, using the recordCustomEvent API (Android | iOS). To help with crash analysis, you can use the SDK to create MobileBreadcrumb and MobileHandledException events. These events are available for querying and also displayed in the crash event trail UI. For more on creating custom attributes and custom events, see: Android SDK API guide iOS SDK API guide NRQL query examples MobileRequestError examples MobileRequest examples Limits and restricted characters Mobile event and attribute query examples Here are some examples of using NRQL to query your mobile app events and attributes: Custom event example: Track purchases To track purchases in your app, use recordCustomEvent to create an event type (such as \"UserAction\") and associate attributes such as \"name\" (with value \"Purchase\"), price, quantity, and SKU. Tip For performance reasons, you should limit the total number of event types to maybe one or two. The recordCustomEvent parameter eventType is meant to be used for high-level categories. For example, you might create an event typeGestures, and then create many different custom event names under the Gesture event type. Create an event on iOS: BOOL purchaseRecorded = [NewRelic recordCustomEvent:@\"UserAction\" attributes:@{@\"name\": @\"Purchase\", @\"sku\": @\"12345LPD\", @\"quantity\": @1, @\"unitPrice\": @99.99, @\"total\": @99.99}]; Copy Create an event on Android: Map<String, Object> userActionAttributes = new HashMap<String, Object>(); userActionAttributes.put(\"name\", \"Purchase\"); userActionAttributes.put(\"sku\", \"12345LPD\"); userActionAttributes.put(\"quantity\", 1); userActionAttributes.put(\"unitPrice\", 99.99); userActionAttributes.put(\"total\", 99.99); boolean userActionRecorded = NewRelic.recordCustomEvent(\"UserAction\", userActionAttributes); Copy New Relic reports a custom event of type UserAction and name Purchase, which allows you to query all purchases made in your app in the last day: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Replace deprecated recordEvent method: As of Android agent version 5.12.0 and iOS agent version 5.12.0, use the recordCustomEvent method to create these custom events. If you have replaced the deprecated recordEvent method for your custom events, be sure to also replace its corresponding NRQL query with the new format. Look for queries used with recordEvent method, such as this: SELECT * from Mobile where category = 'Custom' and name = 'Purchase' since 1 day ago Copy Replace them with the query format used with recordCustomEvent: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Attribute example: Track a specific user You can create a custom attribute to track a custom user identifier across the session, and then query for all that user's interactions. To add an attribute for the userId, call the setUserId method: Set the userId on iOS: BOOL userIdWasSet = [NewRelic setUserId:@\"jsmith\"]; Copy Set the userId on Android: boolean userIdWasSet = NewRelic.setUserId(\"jsmith\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that username in the last day: SELECT * from Mobile WHERE userId = 'jsmith' since 1 day ago Copy Attribute example: Track a specific store id You can create a custom attribute to track a store id across the session, and then query for all that store's interactions. To add an attribute for the storeId, call the setAttribute method: Set the storeId on iOS: BOOL attributeSet = [NewRelic setAttribute:@\"storeId\" value:@\"NY0531\"]; Copy Set the storeId on Android: boolean attributeSet = NewRelic.setAttribute(\"storeId\", \"NY0531\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that storeId in the last day: SELECT * from Mobile WHERE storeId = 'NY0531' since 1 day ago Copy Custom attribute example: Track a specific action You can use custom attributes to track the number of times that a specific action occurs in your application. For example, you can track the number of times a button was clicked or the number of times a level was completed in a game. To track completing a game level, call incrementAttribute with no value specified. This creates an attribute with a default value of 1: Create a counter on iOS: BOOL levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Create a counter on Android: boolean levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Each subsequent call to incrementAttribute adds 1 to the attribute level: Increment a counter on iOS: levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Increment a counter on Android: levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Important Be sure to reset the value to 0 when starting over. To reset the level back to 1 or 0, call setAttribute: Reset a counter on iOS: levelReset = [NewRelic setAttribute:@\"level\" value:@1]; Copy Reset a counter on Android: levelReset = NewRelic.setAttribute(\"level\", 1); Copy When querying, use this level attribute to filter your data. For example, if you have a username and level attribute, use the max() function to find the highest level the user had reached: SELECT max(level) from Mobile where username = 'jsmith' Copy Size limits and restricted characters Limits for custom attributes added to default mobile events: Attributes: 128 maximum String attributes: 4 KB maximum length (empty string values are not accepted) Limits for custom events: Attributes: 254 maximum per event (number includes default session attributes) String attributes: 4 KB maximum length (empty string values are not accepted) Naming syntax and rules: See Rules for custom data. Set the time to send data By default, New Relic transmits event data in any of these situations: A session has been ongoing for 600 seconds. The app session ends by backgrounding. The app crashes. If the app crashes, New Relic gathers the attributes and events for that session and sends them to Insights. (On iOS, this happens the next time the app is launched). You can then use Insights to query and analyze the event and attribute data. To set the maximum time (in seconds) that the agent will store events in memory, use the following SDK calls: iOS method: + (void) setMaxEventBufferTime:(unsigned int)seconds; Copy Android method: public static void setMaxEventBufferTime(int maxBufferTimeInSec); Copy Privacy considerations If you want to collect personal data via custom attributes, please consult with your privacy or legal teams. Be sure to follow your organization's obligations for notices and consent regulations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 231.46725,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report <em>mobile</em> <em>monitoring</em> custom events and attributes",
        "sections": "Report <em>mobile</em> <em>monitoring</em> custom events and attributes",
        "tags": "<em>Insights</em>",
        "body": " information and are shared by multiple <em>mobile</em> event types. You can also create entirely <em>new</em> custom event types and assign them their own custom attributes, using the recordCustomEvent <em>API</em> (Android | <em>iOS</em>). To help with crash analysis, you can use the <em>SDK</em> to create <em>Mobile</em>Breadcrumb and <em>Mobile</em>"
      },
      "id": "609fa5cf28ccbc508d9832d3"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/set-max-event-buffer-time": [
    {
      "sections": [
        "Adding a prefix header to an iOS project"
      ],
      "title": "Adding a prefix header to an iOS project",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "11df0352a96527157fdd932f7a5bacf0beb8a0ae",
      "image": "https://docs.newrelic.com/static/89991d3f20208fe696e48b3143745df9/8c557/screen-ios-sdk-api-prefix-header.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/adding-prefix-header-ios-project/",
      "published_at": "2021-10-24T16:49:48Z",
      "updated_at": "2021-07-09T08:43:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Installing New Relic's iOS SDK API requires you to modify your project's prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File > New > File... From iOS template options, select Other > PCH file. Name the file < target_name>-Prefix.pch, and then select Create. From your targetâ€™s Build settings, select All, and then add the following to the Prefix Header field: $(SRCROOT)/<target_name>-Prefix.pch Copy Here is an example of using XcodeÂ to add a Prefix Header file to your iOS project for the iOS SDK API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 255.09282,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Adding a prefix header to an <em>iOS</em> project",
        "sections": "Adding a prefix header to an <em>iOS</em> project",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Installing <em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> <em>SDK</em> <em>API</em> requires you to modify your project&#x27;s prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File &gt; <em>New</em> &gt; File... From <em>iOS</em> template options, select Other &gt; PCH file. Name the file &lt; target_name&gt;-Prefix.pch"
      },
      "id": "6044195fe7b9d2f201579a09"
    },
    {
      "sections": [
        "Introduction to iOS monitoring",
        "Compatibility and requirements",
        "Install the agent",
        "Extend your instrumentation",
        "Troubleshoot your installation"
      ],
      "title": "Introduction to iOS monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "243234aeaa02a13856775f6f154cab24a1e5db26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios/",
      "published_at": "2021-10-24T16:51:42Z",
      "updated_at": "2021-07-08T01:46:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring for iOS gives you a comprehensive view of your app's performance. It works for iOS apps written using Objective-C, Swift, or both languages. For a general overview of mobile monitoring functionality, see Introduction to mobile monitoring. Compatibility and requirements Before you install the iOS agent, review the compatibility and requirements. Install the agent As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. There are two ways you can install the iOS agent: We recommend you install and configure the iOS agent using the CocoaPods installation method. You can also manually install and configure the iOS agent by adding the New Relic framework to your app. Extend your instrumentation After you install the agent, you can extend the agent's default instrumentation with various types of custom data: To access: In the mobile UI: In New Relic One dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. You can also query the custom events that you created in New Relic One dashboards and NRQL. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. iOS SDK API Use the iOS SDK API to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. Troubleshoot your installation If the agent isn't reporting data, try these troubleshooting suggestions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 232.07884,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "sections": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for <em>iOS</em> gives you a comprehensive view of your app&#x27;s performance. It works for <em>iOS</em> apps written using Objective-C, Swift, or both languages. For a general overview of <em>mobile</em> <em>monitoring</em> functionality, see Introduction to <em>mobile</em> <em>monitoring</em>. Compatibility and requirements"
      },
      "id": "6043a48fe7b9d2ad8d5799db"
    },
    {
      "sections": [
        "Report mobile monitoring custom events and attributes",
        "Create custom attributes and events",
        "Mobile event and attribute query examples",
        "Custom event example: Track purchases",
        "Tip",
        "Attribute example: Track a specific user",
        "Attribute example: Track a specific store id",
        "Custom attribute example: Track a specific action",
        "Important",
        "Size limits and restricted characters",
        "Set the time to send data",
        "Privacy considerations"
      ],
      "title": "Report mobile monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "65970eacbedb3360fd1c7394affc8cbc42f2ab0c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/report-mobile-monitoring-custom-events-attributes/",
      "published_at": "2021-10-24T14:59:18Z",
      "updated_at": "2021-10-23T21:59:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring in New Relic sends some default event data from your mobile app to New Relic, such as data about interactions, sessions, crashes, and request errors. You can also create your own custom attributes and events for more detailed querying and analysis. Create custom attributes and events You can create custom session-level attributes for default mobile monitoring events using the mobile agent SDKs. For example, to record a username attribute for some part of your iOS or Android app, you would use the setAttribute API (Android | iOS). These attributes are session-related information and are shared by multiple mobile event types. You can also create entirely new custom event types and assign them their own custom attributes, using the recordCustomEvent API (Android | iOS). To help with crash analysis, you can use the SDK to create MobileBreadcrumb and MobileHandledException events. These events are available for querying and also displayed in the crash event trail UI. For more on creating custom attributes and custom events, see: Android SDK API guide iOS SDK API guide NRQL query examples MobileRequestError examples MobileRequest examples Limits and restricted characters Mobile event and attribute query examples Here are some examples of using NRQL to query your mobile app events and attributes: Custom event example: Track purchases To track purchases in your app, use recordCustomEvent to create an event type (such as \"UserAction\") and associate attributes such as \"name\" (with value \"Purchase\"), price, quantity, and SKU. Tip For performance reasons, you should limit the total number of event types to maybe one or two. The recordCustomEvent parameter eventType is meant to be used for high-level categories. For example, you might create an event typeGestures, and then create many different custom event names under the Gesture event type. Create an event on iOS: BOOL purchaseRecorded = [NewRelic recordCustomEvent:@\"UserAction\" attributes:@{@\"name\": @\"Purchase\", @\"sku\": @\"12345LPD\", @\"quantity\": @1, @\"unitPrice\": @99.99, @\"total\": @99.99}]; Copy Create an event on Android: Map<String, Object> userActionAttributes = new HashMap<String, Object>(); userActionAttributes.put(\"name\", \"Purchase\"); userActionAttributes.put(\"sku\", \"12345LPD\"); userActionAttributes.put(\"quantity\", 1); userActionAttributes.put(\"unitPrice\", 99.99); userActionAttributes.put(\"total\", 99.99); boolean userActionRecorded = NewRelic.recordCustomEvent(\"UserAction\", userActionAttributes); Copy New Relic reports a custom event of type UserAction and name Purchase, which allows you to query all purchases made in your app in the last day: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Replace deprecated recordEvent method: As of Android agent version 5.12.0 and iOS agent version 5.12.0, use the recordCustomEvent method to create these custom events. If you have replaced the deprecated recordEvent method for your custom events, be sure to also replace its corresponding NRQL query with the new format. Look for queries used with recordEvent method, such as this: SELECT * from Mobile where category = 'Custom' and name = 'Purchase' since 1 day ago Copy Replace them with the query format used with recordCustomEvent: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Attribute example: Track a specific user You can create a custom attribute to track a custom user identifier across the session, and then query for all that user's interactions. To add an attribute for the userId, call the setUserId method: Set the userId on iOS: BOOL userIdWasSet = [NewRelic setUserId:@\"jsmith\"]; Copy Set the userId on Android: boolean userIdWasSet = NewRelic.setUserId(\"jsmith\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that username in the last day: SELECT * from Mobile WHERE userId = 'jsmith' since 1 day ago Copy Attribute example: Track a specific store id You can create a custom attribute to track a store id across the session, and then query for all that store's interactions. To add an attribute for the storeId, call the setAttribute method: Set the storeId on iOS: BOOL attributeSet = [NewRelic setAttribute:@\"storeId\" value:@\"NY0531\"]; Copy Set the storeId on Android: boolean attributeSet = NewRelic.setAttribute(\"storeId\", \"NY0531\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that storeId in the last day: SELECT * from Mobile WHERE storeId = 'NY0531' since 1 day ago Copy Custom attribute example: Track a specific action You can use custom attributes to track the number of times that a specific action occurs in your application. For example, you can track the number of times a button was clicked or the number of times a level was completed in a game. To track completing a game level, call incrementAttribute with no value specified. This creates an attribute with a default value of 1: Create a counter on iOS: BOOL levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Create a counter on Android: boolean levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Each subsequent call to incrementAttribute adds 1 to the attribute level: Increment a counter on iOS: levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Increment a counter on Android: levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Important Be sure to reset the value to 0 when starting over. To reset the level back to 1 or 0, call setAttribute: Reset a counter on iOS: levelReset = [NewRelic setAttribute:@\"level\" value:@1]; Copy Reset a counter on Android: levelReset = NewRelic.setAttribute(\"level\", 1); Copy When querying, use this level attribute to filter your data. For example, if you have a username and level attribute, use the max() function to find the highest level the user had reached: SELECT max(level) from Mobile where username = 'jsmith' Copy Size limits and restricted characters Limits for custom attributes added to default mobile events: Attributes: 128 maximum String attributes: 4 KB maximum length (empty string values are not accepted) Limits for custom events: Attributes: 254 maximum per event (number includes default session attributes) String attributes: 4 KB maximum length (empty string values are not accepted) Naming syntax and rules: See Rules for custom data. Set the time to send data By default, New Relic transmits event data in any of these situations: A session has been ongoing for 600 seconds. The app session ends by backgrounding. The app crashes. If the app crashes, New Relic gathers the attributes and events for that session and sends them to Insights. (On iOS, this happens the next time the app is launched). You can then use Insights to query and analyze the event and attribute data. To set the maximum time (in seconds) that the agent will store events in memory, use the following SDK calls: iOS method: + (void) setMaxEventBufferTime:(unsigned int)seconds; Copy Android method: public static void setMaxEventBufferTime(int maxBufferTimeInSec); Copy Privacy considerations If you want to collect personal data via custom attributes, please consult with your privacy or legal teams. Be sure to follow your organization's obligations for notices and consent regulations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 231.46725,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report <em>mobile</em> <em>monitoring</em> custom events and attributes",
        "sections": "Report <em>mobile</em> <em>monitoring</em> custom events and attributes",
        "tags": "<em>Insights</em>",
        "body": " information and are shared by multiple <em>mobile</em> event types. You can also create entirely <em>new</em> custom event types and assign them their own custom attributes, using the recordCustomEvent <em>API</em> (Android | <em>iOS</em>). To help with crash analysis, you can use the <em>SDK</em> to create <em>Mobile</em>Breadcrumb and <em>Mobile</em>"
      },
      "id": "609fa5cf28ccbc508d9832d3"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/set-max-event-pool-size": [
    {
      "sections": [
        "Adding a prefix header to an iOS project"
      ],
      "title": "Adding a prefix header to an iOS project",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "11df0352a96527157fdd932f7a5bacf0beb8a0ae",
      "image": "https://docs.newrelic.com/static/89991d3f20208fe696e48b3143745df9/8c557/screen-ios-sdk-api-prefix-header.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/adding-prefix-header-ios-project/",
      "published_at": "2021-10-24T16:49:48Z",
      "updated_at": "2021-07-09T08:43:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Installing New Relic's iOS SDK API requires you to modify your project's prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File > New > File... From iOS template options, select Other > PCH file. Name the file < target_name>-Prefix.pch, and then select Create. From your targetâ€™s Build settings, select All, and then add the following to the Prefix Header field: $(SRCROOT)/<target_name>-Prefix.pch Copy Here is an example of using XcodeÂ to add a Prefix Header file to your iOS project for the iOS SDK API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 255.09282,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Adding a prefix header to an <em>iOS</em> project",
        "sections": "Adding a prefix header to an <em>iOS</em> project",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Installing <em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> <em>SDK</em> <em>API</em> requires you to modify your project&#x27;s prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File &gt; <em>New</em> &gt; File... From <em>iOS</em> template options, select Other &gt; PCH file. Name the file &lt; target_name&gt;-Prefix.pch"
      },
      "id": "6044195fe7b9d2f201579a09"
    },
    {
      "sections": [
        "Introduction to iOS monitoring",
        "Compatibility and requirements",
        "Install the agent",
        "Extend your instrumentation",
        "Troubleshoot your installation"
      ],
      "title": "Introduction to iOS monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "243234aeaa02a13856775f6f154cab24a1e5db26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios/",
      "published_at": "2021-10-24T16:51:42Z",
      "updated_at": "2021-07-08T01:46:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring for iOS gives you a comprehensive view of your app's performance. It works for iOS apps written using Objective-C, Swift, or both languages. For a general overview of mobile monitoring functionality, see Introduction to mobile monitoring. Compatibility and requirements Before you install the iOS agent, review the compatibility and requirements. Install the agent As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. There are two ways you can install the iOS agent: We recommend you install and configure the iOS agent using the CocoaPods installation method. You can also manually install and configure the iOS agent by adding the New Relic framework to your app. Extend your instrumentation After you install the agent, you can extend the agent's default instrumentation with various types of custom data: To access: In the mobile UI: In New Relic One dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. You can also query the custom events that you created in New Relic One dashboards and NRQL. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. iOS SDK API Use the iOS SDK API to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. Troubleshoot your installation If the agent isn't reporting data, try these troubleshooting suggestions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 232.07884,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "sections": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for <em>iOS</em> gives you a comprehensive view of your app&#x27;s performance. It works for <em>iOS</em> apps written using Objective-C, Swift, or both languages. For a general overview of <em>mobile</em> <em>monitoring</em> functionality, see Introduction to <em>mobile</em> <em>monitoring</em>. Compatibility and requirements"
      },
      "id": "6043a48fe7b9d2ad8d5799db"
    },
    {
      "sections": [
        "Report mobile monitoring custom events and attributes",
        "Create custom attributes and events",
        "Mobile event and attribute query examples",
        "Custom event example: Track purchases",
        "Tip",
        "Attribute example: Track a specific user",
        "Attribute example: Track a specific store id",
        "Custom attribute example: Track a specific action",
        "Important",
        "Size limits and restricted characters",
        "Set the time to send data",
        "Privacy considerations"
      ],
      "title": "Report mobile monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "65970eacbedb3360fd1c7394affc8cbc42f2ab0c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/report-mobile-monitoring-custom-events-attributes/",
      "published_at": "2021-10-24T14:59:18Z",
      "updated_at": "2021-10-23T21:59:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring in New Relic sends some default event data from your mobile app to New Relic, such as data about interactions, sessions, crashes, and request errors. You can also create your own custom attributes and events for more detailed querying and analysis. Create custom attributes and events You can create custom session-level attributes for default mobile monitoring events using the mobile agent SDKs. For example, to record a username attribute for some part of your iOS or Android app, you would use the setAttribute API (Android | iOS). These attributes are session-related information and are shared by multiple mobile event types. You can also create entirely new custom event types and assign them their own custom attributes, using the recordCustomEvent API (Android | iOS). To help with crash analysis, you can use the SDK to create MobileBreadcrumb and MobileHandledException events. These events are available for querying and also displayed in the crash event trail UI. For more on creating custom attributes and custom events, see: Android SDK API guide iOS SDK API guide NRQL query examples MobileRequestError examples MobileRequest examples Limits and restricted characters Mobile event and attribute query examples Here are some examples of using NRQL to query your mobile app events and attributes: Custom event example: Track purchases To track purchases in your app, use recordCustomEvent to create an event type (such as \"UserAction\") and associate attributes such as \"name\" (with value \"Purchase\"), price, quantity, and SKU. Tip For performance reasons, you should limit the total number of event types to maybe one or two. The recordCustomEvent parameter eventType is meant to be used for high-level categories. For example, you might create an event typeGestures, and then create many different custom event names under the Gesture event type. Create an event on iOS: BOOL purchaseRecorded = [NewRelic recordCustomEvent:@\"UserAction\" attributes:@{@\"name\": @\"Purchase\", @\"sku\": @\"12345LPD\", @\"quantity\": @1, @\"unitPrice\": @99.99, @\"total\": @99.99}]; Copy Create an event on Android: Map<String, Object> userActionAttributes = new HashMap<String, Object>(); userActionAttributes.put(\"name\", \"Purchase\"); userActionAttributes.put(\"sku\", \"12345LPD\"); userActionAttributes.put(\"quantity\", 1); userActionAttributes.put(\"unitPrice\", 99.99); userActionAttributes.put(\"total\", 99.99); boolean userActionRecorded = NewRelic.recordCustomEvent(\"UserAction\", userActionAttributes); Copy New Relic reports a custom event of type UserAction and name Purchase, which allows you to query all purchases made in your app in the last day: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Replace deprecated recordEvent method: As of Android agent version 5.12.0 and iOS agent version 5.12.0, use the recordCustomEvent method to create these custom events. If you have replaced the deprecated recordEvent method for your custom events, be sure to also replace its corresponding NRQL query with the new format. Look for queries used with recordEvent method, such as this: SELECT * from Mobile where category = 'Custom' and name = 'Purchase' since 1 day ago Copy Replace them with the query format used with recordCustomEvent: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Attribute example: Track a specific user You can create a custom attribute to track a custom user identifier across the session, and then query for all that user's interactions. To add an attribute for the userId, call the setUserId method: Set the userId on iOS: BOOL userIdWasSet = [NewRelic setUserId:@\"jsmith\"]; Copy Set the userId on Android: boolean userIdWasSet = NewRelic.setUserId(\"jsmith\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that username in the last day: SELECT * from Mobile WHERE userId = 'jsmith' since 1 day ago Copy Attribute example: Track a specific store id You can create a custom attribute to track a store id across the session, and then query for all that store's interactions. To add an attribute for the storeId, call the setAttribute method: Set the storeId on iOS: BOOL attributeSet = [NewRelic setAttribute:@\"storeId\" value:@\"NY0531\"]; Copy Set the storeId on Android: boolean attributeSet = NewRelic.setAttribute(\"storeId\", \"NY0531\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that storeId in the last day: SELECT * from Mobile WHERE storeId = 'NY0531' since 1 day ago Copy Custom attribute example: Track a specific action You can use custom attributes to track the number of times that a specific action occurs in your application. For example, you can track the number of times a button was clicked or the number of times a level was completed in a game. To track completing a game level, call incrementAttribute with no value specified. This creates an attribute with a default value of 1: Create a counter on iOS: BOOL levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Create a counter on Android: boolean levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Each subsequent call to incrementAttribute adds 1 to the attribute level: Increment a counter on iOS: levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Increment a counter on Android: levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Important Be sure to reset the value to 0 when starting over. To reset the level back to 1 or 0, call setAttribute: Reset a counter on iOS: levelReset = [NewRelic setAttribute:@\"level\" value:@1]; Copy Reset a counter on Android: levelReset = NewRelic.setAttribute(\"level\", 1); Copy When querying, use this level attribute to filter your data. For example, if you have a username and level attribute, use the max() function to find the highest level the user had reached: SELECT max(level) from Mobile where username = 'jsmith' Copy Size limits and restricted characters Limits for custom attributes added to default mobile events: Attributes: 128 maximum String attributes: 4 KB maximum length (empty string values are not accepted) Limits for custom events: Attributes: 254 maximum per event (number includes default session attributes) String attributes: 4 KB maximum length (empty string values are not accepted) Naming syntax and rules: See Rules for custom data. Set the time to send data By default, New Relic transmits event data in any of these situations: A session has been ongoing for 600 seconds. The app session ends by backgrounding. The app crashes. If the app crashes, New Relic gathers the attributes and events for that session and sends them to Insights. (On iOS, this happens the next time the app is launched). You can then use Insights to query and analyze the event and attribute data. To set the maximum time (in seconds) that the agent will store events in memory, use the following SDK calls: iOS method: + (void) setMaxEventBufferTime:(unsigned int)seconds; Copy Android method: public static void setMaxEventBufferTime(int maxBufferTimeInSec); Copy Privacy considerations If you want to collect personal data via custom attributes, please consult with your privacy or legal teams. Be sure to follow your organization's obligations for notices and consent regulations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 231.46707,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report <em>mobile</em> <em>monitoring</em> custom events and attributes",
        "sections": "Report <em>mobile</em> <em>monitoring</em> custom events and attributes",
        "tags": "<em>Insights</em>",
        "body": " information and are shared by multiple <em>mobile</em> event types. You can also create entirely <em>new</em> custom event types and assign them their own custom attributes, using the recordCustomEvent <em>API</em> (Android | <em>iOS</em>). To help with crash analysis, you can use the <em>SDK</em> to create <em>Mobile</em>Breadcrumb and <em>Mobile</em>"
      },
      "id": "609fa5cf28ccbc508d9832d3"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/ios-sdk-api/set-user-id": [
    {
      "sections": [
        "Adding a prefix header to an iOS project"
      ],
      "title": "Adding a prefix header to an iOS project",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "11df0352a96527157fdd932f7a5bacf0beb8a0ae",
      "image": "https://docs.newrelic.com/static/89991d3f20208fe696e48b3143745df9/8c557/screen-ios-sdk-api-prefix-header.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/adding-prefix-header-ios-project/",
      "published_at": "2021-10-24T16:49:48Z",
      "updated_at": "2021-07-09T08:43:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Installing New Relic's iOS SDK API requires you to modify your project's prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File > New > File... From iOS template options, select Other > PCH file. Name the file < target_name>-Prefix.pch, and then select Create. From your targetâ€™s Build settings, select All, and then add the following to the Prefix Header field: $(SRCROOT)/<target_name>-Prefix.pch Copy Here is an example of using XcodeÂ to add a Prefix Header file to your iOS project for the iOS SDK API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 255.09282,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Adding a prefix header to an <em>iOS</em> project",
        "sections": "Adding a prefix header to an <em>iOS</em> project",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Installing <em>New</em> <em>Relic</em>&#x27;s <em>iOS</em> <em>SDK</em> <em>API</em> requires you to modify your project&#x27;s prefix header. If your project does not have one, follow these steps to add it. From your Xcode menu, select File &gt; <em>New</em> &gt; File... From <em>iOS</em> template options, select Other &gt; PCH file. Name the file &lt; target_name&gt;-Prefix.pch"
      },
      "id": "6044195fe7b9d2f201579a09"
    },
    {
      "sections": [
        "Introduction to iOS monitoring",
        "Compatibility and requirements",
        "Install the agent",
        "Extend your instrumentation",
        "Troubleshoot your installation"
      ],
      "title": "Introduction to iOS monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "243234aeaa02a13856775f6f154cab24a1e5db26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios/",
      "published_at": "2021-10-24T16:51:42Z",
      "updated_at": "2021-07-08T01:46:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring for iOS gives you a comprehensive view of your app's performance. It works for iOS apps written using Objective-C, Swift, or both languages. For a general overview of mobile monitoring functionality, see Introduction to mobile monitoring. Compatibility and requirements Before you install the iOS agent, review the compatibility and requirements. Install the agent As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. There are two ways you can install the iOS agent: We recommend you install and configure the iOS agent using the CocoaPods installation method. You can also manually install and configure the iOS agent by adding the New Relic framework to your app. Extend your instrumentation After you install the agent, you can extend the agent's default instrumentation with various types of custom data: To access: In the mobile UI: In New Relic One dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. You can also query the custom events that you created in New Relic One dashboards and NRQL. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. iOS SDK API Use the iOS SDK API to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. Troubleshoot your installation If the agent isn't reporting data, try these troubleshooting suggestions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 232.07884,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "sections": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for <em>iOS</em> gives you a comprehensive view of your app&#x27;s performance. It works for <em>iOS</em> apps written using Objective-C, Swift, or both languages. For a general overview of <em>mobile</em> <em>monitoring</em> functionality, see Introduction to <em>mobile</em> <em>monitoring</em>. Compatibility and requirements"
      },
      "id": "6043a48fe7b9d2ad8d5799db"
    },
    {
      "sections": [
        "Report mobile monitoring custom events and attributes",
        "Create custom attributes and events",
        "Mobile event and attribute query examples",
        "Custom event example: Track purchases",
        "Tip",
        "Attribute example: Track a specific user",
        "Attribute example: Track a specific store id",
        "Custom attribute example: Track a specific action",
        "Important",
        "Size limits and restricted characters",
        "Set the time to send data",
        "Privacy considerations"
      ],
      "title": "Report mobile monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "65970eacbedb3360fd1c7394affc8cbc42f2ab0c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/report-mobile-monitoring-custom-events-attributes/",
      "published_at": "2021-10-24T14:59:18Z",
      "updated_at": "2021-10-23T21:59:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring in New Relic sends some default event data from your mobile app to New Relic, such as data about interactions, sessions, crashes, and request errors. You can also create your own custom attributes and events for more detailed querying and analysis. Create custom attributes and events You can create custom session-level attributes for default mobile monitoring events using the mobile agent SDKs. For example, to record a username attribute for some part of your iOS or Android app, you would use the setAttribute API (Android | iOS). These attributes are session-related information and are shared by multiple mobile event types. You can also create entirely new custom event types and assign them their own custom attributes, using the recordCustomEvent API (Android | iOS). To help with crash analysis, you can use the SDK to create MobileBreadcrumb and MobileHandledException events. These events are available for querying and also displayed in the crash event trail UI. For more on creating custom attributes and custom events, see: Android SDK API guide iOS SDK API guide NRQL query examples MobileRequestError examples MobileRequest examples Limits and restricted characters Mobile event and attribute query examples Here are some examples of using NRQL to query your mobile app events and attributes: Custom event example: Track purchases To track purchases in your app, use recordCustomEvent to create an event type (such as \"UserAction\") and associate attributes such as \"name\" (with value \"Purchase\"), price, quantity, and SKU. Tip For performance reasons, you should limit the total number of event types to maybe one or two. The recordCustomEvent parameter eventType is meant to be used for high-level categories. For example, you might create an event typeGestures, and then create many different custom event names under the Gesture event type. Create an event on iOS: BOOL purchaseRecorded = [NewRelic recordCustomEvent:@\"UserAction\" attributes:@{@\"name\": @\"Purchase\", @\"sku\": @\"12345LPD\", @\"quantity\": @1, @\"unitPrice\": @99.99, @\"total\": @99.99}]; Copy Create an event on Android: Map<String, Object> userActionAttributes = new HashMap<String, Object>(); userActionAttributes.put(\"name\", \"Purchase\"); userActionAttributes.put(\"sku\", \"12345LPD\"); userActionAttributes.put(\"quantity\", 1); userActionAttributes.put(\"unitPrice\", 99.99); userActionAttributes.put(\"total\", 99.99); boolean userActionRecorded = NewRelic.recordCustomEvent(\"UserAction\", userActionAttributes); Copy New Relic reports a custom event of type UserAction and name Purchase, which allows you to query all purchases made in your app in the last day: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Replace deprecated recordEvent method: As of Android agent version 5.12.0 and iOS agent version 5.12.0, use the recordCustomEvent method to create these custom events. If you have replaced the deprecated recordEvent method for your custom events, be sure to also replace its corresponding NRQL query with the new format. Look for queries used with recordEvent method, such as this: SELECT * from Mobile where category = 'Custom' and name = 'Purchase' since 1 day ago Copy Replace them with the query format used with recordCustomEvent: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Attribute example: Track a specific user You can create a custom attribute to track a custom user identifier across the session, and then query for all that user's interactions. To add an attribute for the userId, call the setUserId method: Set the userId on iOS: BOOL userIdWasSet = [NewRelic setUserId:@\"jsmith\"]; Copy Set the userId on Android: boolean userIdWasSet = NewRelic.setUserId(\"jsmith\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that username in the last day: SELECT * from Mobile WHERE userId = 'jsmith' since 1 day ago Copy Attribute example: Track a specific store id You can create a custom attribute to track a store id across the session, and then query for all that store's interactions. To add an attribute for the storeId, call the setAttribute method: Set the storeId on iOS: BOOL attributeSet = [NewRelic setAttribute:@\"storeId\" value:@\"NY0531\"]; Copy Set the storeId on Android: boolean attributeSet = NewRelic.setAttribute(\"storeId\", \"NY0531\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that storeId in the last day: SELECT * from Mobile WHERE storeId = 'NY0531' since 1 day ago Copy Custom attribute example: Track a specific action You can use custom attributes to track the number of times that a specific action occurs in your application. For example, you can track the number of times a button was clicked or the number of times a level was completed in a game. To track completing a game level, call incrementAttribute with no value specified. This creates an attribute with a default value of 1: Create a counter on iOS: BOOL levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Create a counter on Android: boolean levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Each subsequent call to incrementAttribute adds 1 to the attribute level: Increment a counter on iOS: levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Increment a counter on Android: levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Important Be sure to reset the value to 0 when starting over. To reset the level back to 1 or 0, call setAttribute: Reset a counter on iOS: levelReset = [NewRelic setAttribute:@\"level\" value:@1]; Copy Reset a counter on Android: levelReset = NewRelic.setAttribute(\"level\", 1); Copy When querying, use this level attribute to filter your data. For example, if you have a username and level attribute, use the max() function to find the highest level the user had reached: SELECT max(level) from Mobile where username = 'jsmith' Copy Size limits and restricted characters Limits for custom attributes added to default mobile events: Attributes: 128 maximum String attributes: 4 KB maximum length (empty string values are not accepted) Limits for custom events: Attributes: 254 maximum per event (number includes default session attributes) String attributes: 4 KB maximum length (empty string values are not accepted) Naming syntax and rules: See Rules for custom data. Set the time to send data By default, New Relic transmits event data in any of these situations: A session has been ongoing for 600 seconds. The app session ends by backgrounding. The app crashes. If the app crashes, New Relic gathers the attributes and events for that session and sends them to Insights. (On iOS, this happens the next time the app is launched). You can then use Insights to query and analyze the event and attribute data. To set the maximum time (in seconds) that the agent will store events in memory, use the following SDK calls: iOS method: + (void) setMaxEventBufferTime:(unsigned int)seconds; Copy Android method: public static void setMaxEventBufferTime(int maxBufferTimeInSec); Copy Privacy considerations If you want to collect personal data via custom attributes, please consult with your privacy or legal teams. Be sure to follow your organization's obligations for notices and consent regulations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 231.46707,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report <em>mobile</em> <em>monitoring</em> custom events and attributes",
        "sections": "Report <em>mobile</em> <em>monitoring</em> custom events and attributes",
        "tags": "<em>Insights</em>",
        "body": " information and are shared by multiple <em>mobile</em> event types. You can also create entirely <em>new</em> custom event types and assign them their own custom attributes, using the recordCustomEvent <em>API</em> (Android | <em>iOS</em>). To help with crash analysis, you can use the <em>SDK</em> to create <em>Mobile</em>Breadcrumb and <em>Mobile</em>"
      },
      "id": "609fa5cf28ccbc508d9832d3"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/troubleshoot/no-data-appears-ios": [
    {
      "sections": [
        "CocoaPods installation",
        "Install your iOS application",
        "Configure using Objective-C",
        "Important",
        "Configure using Swift",
        "Change the logging level (optional)"
      ],
      "title": "CocoaPods installation",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Installation"
      ],
      "external_id": "9a062745f628f66e34f865a47d58713f12e59ac9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/installation/cocoapods-installation/",
      "published_at": "2021-10-24T16:53:24Z",
      "updated_at": "2021-10-01T20:15:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "These procedures apply to iOS apps using Cocoapods. For other types, see iOS installation and configuration. Install your iOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. To install and configure your iOS application: Go to one.newrelic.com. If applicable: From the Mobile Apps list, select Add a new app. From the Get Started page, select iOS as the platform for mobile monitoring. Type a name for your mobile app, then select Continue. If your installation does not automatically include the prefix header, follow the steps to add the prefix header to your project. Continue with the steps to configure New Relic for mobile monitoring. Configure using Objective-C These procedures to configure your iOS app with CocoaPods and Objective-C also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy In your APP_NAME-Prefix.pch project file (generally found in the Supporting Files folder), include the New Relic header inside the #ifdef __OBJC__ #endif block: #import <NewRelic/NewRelic.h> Copy In your AppDelegate.m file, add this call as the first line of application:didFinishLaunchingWithOptions, replacing APP_TOKEN with your application token: [NewRelic startWithApplicationToken:@\"APP_TOKEN\"]; Copy Important The agent must be on the first line of didFinishLaunchingWithOptions and run on the main thread to ensure proper instrumentation. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Add a build script to your target's Build Phases. Ensure the new build script is the very last build script. Then paste the following, replacing APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"APP_TOKEN\" Copy Clean and build your app, then run it in the simulator or other device. Configure using Swift These procedures to configure your iOS app with CocoaPods and Swift also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy Create a bridging header: Select File > New > File > Objective-C File. Name the file Placeholder.m, then select Next. Select Create, and confirm Xcode's prompt to generate the bridging header. In your APP_NAME-Bridging-Header.h, add the New Relic header: #import \"NewRelic/NewRelic.h\" Copy In your AppDelegate.swift file, add this call as the first line of application:didFinishLaunchingWithOptions, replacing APP_TOKEN with your application token: NewRelic.start(withApplicationToken:\"APP_TOKEN\") Copy Important To ensure proper instrumentation, you must call the agent on the first line of didFinishLaunchingWithOptions(), and run the agent on the main thread. Starting the call later, on a background thread, or asynchronously can cause unexpected or unstable behavior. Add a build script to your target's Build Phases. Ensure the new build script is the very last build script. Then paste the following, replacing APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/sh \"${SCRIPT}\" \"APP_TOKEN\" Copy Clean and build your app, then run it in the simulator or other device. Change the logging level (optional) Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add this method call before calling NewRelic.start(withApplicationToken): [NRLogger setLogLevels:NRLogLevelALL]; Copy For Swift apps: NRLogger.setLogLevels(NRLogLevelALL.rawValue) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.38872,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "CocoaPods <em>installation</em>",
        "sections": "<em>Install</em> your <em>iOS</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " <em>mobile</em> app you <em>monitor</em> in <em>New</em> <em>Relic</em>. To install and configure your <em>iOS</em> application: Go to one.newrelic.com. If applicable: From the <em>Mobile</em> Apps list, select Add a <em>new</em> app. From the Get Started page, select <em>iOS</em> as the platform for <em>mobile</em> <em>monitoring</em>. Type a name for your <em>mobile</em> app, then select Continue"
      },
      "id": "603ea15d64441fef3d4e8867"
    },
    {
      "sections": [
        "Upload dSYM files",
        "Automatic script",
        "Identify missing dSYMs",
        "Upload dSYM files through the mobile monitoring UI",
        "Manually upload dSYM files",
        "Via Python script (agent versions 6.0.0 or higher)",
        "Via command line",
        "Troubleshooting",
        "Auto-upload failure",
        "Missing dSYMs"
      ],
      "title": "Upload dSYM files",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "3655f49cf0e1ae693de0f8ea45bf4e5e6437e399",
      "image": "https://docs.newrelic.com/static/5c859575f391fbb1eaa18243a8c97000/8c557/Screen-Shot-2014-09-23-at-11.30.35-AM_0.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/upload-dsyms-bitcode-apps/",
      "published_at": "2021-10-24T16:52:30Z",
      "updated_at": "2021-09-27T15:06:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your app's dSYM files are stored in Xcode's dSYM archive path folder. This is the folder where the iOS agent gets the dSYM files that are used to symbolicate your crash reports. New Relic provides a post-build script as part of the iOS agent's install process and the tvOS agent's install process. This script automatically uploads your app's dSYM files. Automatic script The script automatically uploads dSYM files only for release builds. Non-release builds must upload their files either manually or through the mobile monitoring UI. Bitcode-enabled apps have their dSYM files generated by Apple. You must download the dSYM files for Bitcode-enabled apps from Apple and upload them to New Relic. If you see unreadable machine code in the Crashes page, your dSYM files may not be uploaded correctly. In some cases, you may need to manually upload dSYM files. The automatic script uses Python 2. As of October 2019 with macOS 10.15 (Catalina), Python won't be installed by default. If you're using the automatic script (recommended), you may need to manually install Python 2. If you're using Homebrew, see Python on Homebrew. Identify missing dSYMs When a Bitcode-enabled app is uploaded to Apple for App Store review or ad-hoc distribution, dSYMs need to be manually downloaded from Apple and uploaded to New Relic to allow the mobile crash reports to be properly symbolicated. These dSYMs can be downloaded through the archives organizer in Xcode within several minutes of uploading the app. In this situation follow the procedures to find the archive and download dSYMs. If an app is missing a dSYM file, you'll see three indicators in the mobile monitoring UI: Banner notification: A banner warning appears on the Crash report page. The warning reads: We were unable to locate your dsym. Copy Upload prompt: From the Crash type summary page you will be automatically prompted to upload a dSYM file if it is missing. Machine code: The crash stack trace on the Crash report page displays machine code and not a human-readable error message. Upload dSYM files through the mobile monitoring UI You can easily upload your dSYM files directly from the New Relic One UI. The maximum file size is 600 MB. To upload your dSYM files: Go to one.newrelic.com and click Mobile. Then select your app from the list. View Crash analysis. Select a specific crash from the Crash types list. Click Upload dSYM. You can either drag and drop your dSYMs directly, or select the file form your computer. Manually upload dSYM files In some circumstances, New Relic's automatic upload of dSYM files may fail. If a dSYM upload is attempted and fails, it creates a build error with a detailed message. For example, if there's a network failure and the dSYM upload isn't completed, Xcode will report an error. For additional information about how New Relic handles dSYM uploads, see New Relic's Online Technical Community. If the automatic upload fails, you can manually upload your dSYM file. If you have multiple dSYM files, they can be within a single zip with a maximum file size of 600 MB. The YOUR_NEW_RELIC_APPLICATION_TOKEN value in the commands below is the same key used for +[NewRelic startWithApplicationToken:] (in Objective-C) or NewRelic.start(withApplicationToken:) (in Swift). To manually upload your dSYM files: Via Python script (agent versions 6.0.0 or higher) In iOS agent versions 6.0.0 or higher, the agent includes a Python script that automatically processes and uploads symbols. You can call this script from the command line: NewRelicAgent.framework/Resources/generateMap.py \"DSYM_ARCHIVE_PATH\" \"YOUR_NEW_RELIC_APPLICATION_TOKEN\" Copy Via command line To manually upload individual dSYM files from the command line: Zip up your dSYM file or files using the following command. Replace ~ /ZIPPED_DSYM_PATH with your new dSYM archive path and file name (for example, Users/my-name/desktop). Also replace ~ /dSYM_PATH with your existing dSYM file path. /usr/bin/zip --recurse-paths --quiet \"~/ZIPPED_DSYM_PATH\" \"~/dSYM_PATH\" Copy Upload the dSYM zip file using the following command: For US accounts: curl -F dsym=@\"~/DSYM_ZIP_PATH\" -H \"X-APP-LICENSE-KEY: YOUR_NEW_RELIC_APPLICATION_TOKEN\" https://mobile-symbol-upload.newrelic.com/symbol Copy For EU accounts: curl -F dsym=@\"~/DSYM_ZIP_PATH\" -H \"X-APP-LICENSE-KEY: YOUR_NEW_RELIC_APPLICATION_TOKEN\" https://mobile-symbol-upload.eu01.nr-data.net/symbol Copy Troubleshooting Auto-upload failure If a dSYM auto-upload failed, the Report Navigator may have a fully formed cURL command. You can use this cURL command to reattempt an upload. Depending on the error, you may also need to follow some of the dSYM manual upload steps. Here is an example of a successful dSYM upload in the Report Navigator: Example: A successful dSYM upload in the Report Navigator. Missing dSYMs If dSYM files are missing, you may need to check Xcode build settings to ensure the file is being generated. Frameworks which are built locally have separate build settings and may need to be updated as well. Build settings: Debug Information Format : Dwarf with dSYM File Deployment Postprocessing: Yes Strip Linked Product: Yes Strip Debug Symbols During Copy : Yes Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.71124,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Upload dSYM files through the <em>mobile</em> <em>monitoring</em> UI",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Your app&#x27;s dSYM files are stored in Xcode&#x27;s dSYM archive path folder. This is the folder where the <em>iOS</em> agent gets the dSYM files that are used to symbolicate your crash reports. <em>New</em> <em>Relic</em> provides a post-build script as part of the <em>iOS</em> agent&#x27;s install process and the tv<em>OS</em> agent&#x27;s install process"
      },
      "id": "60441960e7b9d24f705799ca"
    },
    {
      "sections": [
        "Introduction to iOS monitoring",
        "Compatibility and requirements",
        "Install the agent",
        "Extend your instrumentation",
        "Troubleshoot your installation"
      ],
      "title": "Introduction to iOS monitoring",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Get started"
      ],
      "external_id": "243234aeaa02a13856775f6f154cab24a1e5db26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/get-started/introduction-new-relic-mobile-ios/",
      "published_at": "2021-10-24T16:51:42Z",
      "updated_at": "2021-07-08T01:46:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring for iOS gives you a comprehensive view of your app's performance. It works for iOS apps written using Objective-C, Swift, or both languages. For a general overview of mobile monitoring functionality, see Introduction to mobile monitoring. Compatibility and requirements Before you install the iOS agent, review the compatibility and requirements. Install the agent As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app that you monitor. There are two ways you can install the iOS agent: We recommend you install and configure the iOS agent using the CocoaPods installation method. You can also manually install and configure the iOS agent by adding the New Relic framework to your app. Extend your instrumentation After you install the agent, you can extend the agent's default instrumentation with various types of custom data: To access: In the mobile UI: In New Relic One dashboards: Custom data Create and record custom events, interaction traces, and attributes to add details to your existing data and traces. You can also query the custom events that you created in New Relic One dashboards and NRQL. Network requests Enable the MobileRequest event feature so you can perform a full network analysis. To further investigate network request error rates and response times, query MobileRequest and MobileRequestError events. Crash analysis Review detailed information using groups and filters to analyze trends that lead to crashes. To view more information about crashes, create NRQL queries to review Insights charts related to crash data. iOS SDK API Use the iOS SDK API to instrument parts of your code that are not instrumented by default. Then, view those custom events and attributes in New Relic Insights. Handled exceptions Report exceptions so you can identify factors creating a poor mobile app experience. To further improve performance, review MobileHandledException event records in New Relic Insights. Breadcrumbs Boost the level of detail in crash event trails by adding breadcrumbs. Then, query MobileBreadcrumbs events to see all breadcrumbs or just breadcrumbs related to crashes. Troubleshoot your installation If the agent isn't reporting data, try these troubleshooting suggestions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.224815,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "sections": "<em>Introduction</em> to <em>iOS</em> <em>monitoring</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>mobile</em> <em>monitoring</em> for <em>iOS</em> gives you a comprehensive view of your app&#x27;s performance. It works for <em>iOS</em> apps written using Objective-C, Swift, or both languages. For a general overview of <em>mobile</em> <em>monitoring</em> functionality, see Introduction to <em>mobile</em> <em>monitoring</em>. Compatibility and requirements"
      },
      "id": "6043a48fe7b9d2ad8d5799db"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/tvos/cocoapods-tvos-installation-configuration": [
    {
      "sections": [
        "Upload dSYM files",
        "Automatic script",
        "Identify missing dSYMs",
        "Upload dSYM files through the mobile monitoring UI",
        "Manually upload dSYM files",
        "Via Python script (agent versions 6.0.0 or higher)",
        "Via command line",
        "Troubleshooting",
        "Auto-upload failure",
        "Missing dSYMs"
      ],
      "title": "Upload dSYM files",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "3655f49cf0e1ae693de0f8ea45bf4e5e6437e399",
      "image": "https://docs.newrelic.com/static/5c859575f391fbb1eaa18243a8c97000/8c557/Screen-Shot-2014-09-23-at-11.30.35-AM_0.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/upload-dsyms-bitcode-apps/",
      "published_at": "2021-10-24T16:52:30Z",
      "updated_at": "2021-09-27T15:06:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your app's dSYM files are stored in Xcode's dSYM archive path folder. This is the folder where the iOS agent gets the dSYM files that are used to symbolicate your crash reports. New Relic provides a post-build script as part of the iOS agent's install process and the tvOS agent's install process. This script automatically uploads your app's dSYM files. Automatic script The script automatically uploads dSYM files only for release builds. Non-release builds must upload their files either manually or through the mobile monitoring UI. Bitcode-enabled apps have their dSYM files generated by Apple. You must download the dSYM files for Bitcode-enabled apps from Apple and upload them to New Relic. If you see unreadable machine code in the Crashes page, your dSYM files may not be uploaded correctly. In some cases, you may need to manually upload dSYM files. The automatic script uses Python 2. As of October 2019 with macOS 10.15 (Catalina), Python won't be installed by default. If you're using the automatic script (recommended), you may need to manually install Python 2. If you're using Homebrew, see Python on Homebrew. Identify missing dSYMs When a Bitcode-enabled app is uploaded to Apple for App Store review or ad-hoc distribution, dSYMs need to be manually downloaded from Apple and uploaded to New Relic to allow the mobile crash reports to be properly symbolicated. These dSYMs can be downloaded through the archives organizer in Xcode within several minutes of uploading the app. In this situation follow the procedures to find the archive and download dSYMs. If an app is missing a dSYM file, you'll see three indicators in the mobile monitoring UI: Banner notification: A banner warning appears on the Crash report page. The warning reads: We were unable to locate your dsym. Copy Upload prompt: From the Crash type summary page you will be automatically prompted to upload a dSYM file if it is missing. Machine code: The crash stack trace on the Crash report page displays machine code and not a human-readable error message. Upload dSYM files through the mobile monitoring UI You can easily upload your dSYM files directly from the New Relic One UI. The maximum file size is 600 MB. To upload your dSYM files: Go to one.newrelic.com and click Mobile. Then select your app from the list. View Crash analysis. Select a specific crash from the Crash types list. Click Upload dSYM. You can either drag and drop your dSYMs directly, or select the file form your computer. Manually upload dSYM files In some circumstances, New Relic's automatic upload of dSYM files may fail. If a dSYM upload is attempted and fails, it creates a build error with a detailed message. For example, if there's a network failure and the dSYM upload isn't completed, Xcode will report an error. For additional information about how New Relic handles dSYM uploads, see New Relic's Online Technical Community. If the automatic upload fails, you can manually upload your dSYM file. If you have multiple dSYM files, they can be within a single zip with a maximum file size of 600 MB. The YOUR_NEW_RELIC_APPLICATION_TOKEN value in the commands below is the same key used for +[NewRelic startWithApplicationToken:] (in Objective-C) or NewRelic.start(withApplicationToken:) (in Swift). To manually upload your dSYM files: Via Python script (agent versions 6.0.0 or higher) In iOS agent versions 6.0.0 or higher, the agent includes a Python script that automatically processes and uploads symbols. You can call this script from the command line: NewRelicAgent.framework/Resources/generateMap.py \"DSYM_ARCHIVE_PATH\" \"YOUR_NEW_RELIC_APPLICATION_TOKEN\" Copy Via command line To manually upload individual dSYM files from the command line: Zip up your dSYM file or files using the following command. Replace ~ /ZIPPED_DSYM_PATH with your new dSYM archive path and file name (for example, Users/my-name/desktop). Also replace ~ /dSYM_PATH with your existing dSYM file path. /usr/bin/zip --recurse-paths --quiet \"~/ZIPPED_DSYM_PATH\" \"~/dSYM_PATH\" Copy Upload the dSYM zip file using the following command: For US accounts: curl -F dsym=@\"~/DSYM_ZIP_PATH\" -H \"X-APP-LICENSE-KEY: YOUR_NEW_RELIC_APPLICATION_TOKEN\" https://mobile-symbol-upload.newrelic.com/symbol Copy For EU accounts: curl -F dsym=@\"~/DSYM_ZIP_PATH\" -H \"X-APP-LICENSE-KEY: YOUR_NEW_RELIC_APPLICATION_TOKEN\" https://mobile-symbol-upload.eu01.nr-data.net/symbol Copy Troubleshooting Auto-upload failure If a dSYM auto-upload failed, the Report Navigator may have a fully formed cURL command. You can use this cURL command to reattempt an upload. Depending on the error, you may also need to follow some of the dSYM manual upload steps. Here is an example of a successful dSYM upload in the Report Navigator: Example: A successful dSYM upload in the Report Navigator. Missing dSYMs If dSYM files are missing, you may need to check Xcode build settings to ensure the file is being generated. Frameworks which are built locally have separate build settings and may need to be updated as well. Build settings: Debug Information Format : Dwarf with dSYM File Deployment Postprocessing: Yes Strip Linked Product: Yes Strip Debug Symbols During Copy : Yes Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 290.64044,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Upload dSYM files through the <em>mobile</em> <em>monitoring</em> UI",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Your app&#x27;s dSYM files are stored in Xcode&#x27;s dSYM archive path folder. This is the folder where the <em>iOS</em> agent gets the dSYM files that are used to symbolicate your crash reports. <em>New</em> <em>Relic</em> provides a post-build script as part of the <em>iOS</em> agent&#x27;s install process and the <em>tvOS</em> agent&#x27;s install process"
      },
      "id": "60441960e7b9d24f705799ca"
    },
    {
      "sections": [
        "New Relic for tvOS compatibility and requirements",
        "tvOS requirements"
      ],
      "title": "New Relic for tvOS compatibility and requirements",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "tvOS"
      ],
      "external_id": "ceb80d833a4f472ce844f6aafecd0f50625b3911",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/tvos/new-relic-tvos-compatibility-requirements/",
      "published_at": "2021-10-24T18:03:08Z",
      "updated_at": "2021-07-09T13:30:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Before you install and configure the tvOS agent, make sure your tvOS app meets these requirements. tvOS requirements Make sure your tvOS app meets these requirements: Mobile monitoring tvOS requirements Operating system tvOS 9 or higher API/SDK NSURLConnection, AFNetworking, and ASIHttpRequest networking APIs Languages Objective-C Swift: Works with both network traces and crash reporting, but no interaction traces by default. To enable this, see Enabling interaction tracing in Swift. Devices Any tvOS compatible device (Apple TV 4th generation or higher) File sizes The tvOS agent adds about 270K to your tvOS release app. Architectures ARM 64-bit",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 289.18695,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> for <em>tvOS</em> compatibility and requirements",
        "sections": "<em>New</em> <em>Relic</em> for <em>tvOS</em> compatibility and requirements",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Before you install and configure the <em>tvOS</em> agent, make sure your <em>tvOS</em> app meets these requirements. <em>tvOS</em> requirements Make sure your <em>tvOS</em> app meets these requirements: <em>Mobile</em> <em>monitoring</em> <em>tvOS</em> requirements Operating system <em>tvOS</em> 9 or higher API&#x2F;SDK NSURLConnection, AFNetworking, and ASIHttpRequest"
      },
      "id": "60441ac6196a67e457960f6d"
    },
    {
      "sections": [
        "Upgrade the tvOS SDK",
        "Contents",
        "Replacing your tvOS framework"
      ],
      "title": "Upgrade the tvOS SDK",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "tvOS"
      ],
      "external_id": "f5d6d3d356952d185b96aa409605b79e3ace8ec9",
      "image": "https://docs.newrelic.com/static/a3b6801675529d8f4eba123cf08e8f1f/c1b63/Mobile_tvOS_replace-framework_1.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/tvos/upgrading-new-relic-mobiles-tvos-sdk/",
      "published_at": "2021-10-24T18:03:40Z",
      "updated_at": "2021-07-09T08:17:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You must be the account Admin to install, configure, and upgrade the tvOS agent. For information about the latest version, refer to the release notes. Contents Replacing your tvOS framework Admins: You must replace the earlier version of your tvOS agent framework before upgrading to a newer version of the tvOS SDK. Here is an example of the workflow to remove your existing tvOS agent framework so you can replace it with a newer version. From the Project Navigator (CMD 1) in Xcode, search for NewRelicAgentTVOS.framework. Right-click or control-click NewRelicAgentTVOS.framework, and select Show in Finder. Drag NewRelicAgentTVOS.framework to the trash. Verify that the Xcode project highlights the reference to NewRelicAgentTVOS.framework in red. Right-click or control-click NewRelicAgentTVOS.framework, and select Delete to remove the obsolete reference from the project. Follow standard installation procedures for tvOS app monitoring.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 288.5628,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Upgrade the <em>tvOS</em> SDK",
        "sections": "Upgrade the <em>tvOS</em> SDK",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " in Finder. Drag <em>NewRelicAgentTVOS</em>.framework to the trash. Verify that the Xcode project highlights the reference to <em>NewRelicAgentTVOS</em>.framework in red. Right-click or control-click <em>NewRelicAgentTVOS</em>.framework, and select Delete to remove the obsolete reference from the project. Follow standard installation procedures for <em>tvOS</em> app <em>monitoring</em>."
      },
      "id": "604416cc64441f805c378ecf"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/tvos/new-relic-tvos-compatibility-requirements": [
    {
      "sections": [
        "Upload dSYM files",
        "Automatic script",
        "Identify missing dSYMs",
        "Upload dSYM files through the mobile monitoring UI",
        "Manually upload dSYM files",
        "Via Python script (agent versions 6.0.0 or higher)",
        "Via command line",
        "Troubleshooting",
        "Auto-upload failure",
        "Missing dSYMs"
      ],
      "title": "Upload dSYM files",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "3655f49cf0e1ae693de0f8ea45bf4e5e6437e399",
      "image": "https://docs.newrelic.com/static/5c859575f391fbb1eaa18243a8c97000/8c557/Screen-Shot-2014-09-23-at-11.30.35-AM_0.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/upload-dsyms-bitcode-apps/",
      "published_at": "2021-10-24T16:52:30Z",
      "updated_at": "2021-09-27T15:06:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your app's dSYM files are stored in Xcode's dSYM archive path folder. This is the folder where the iOS agent gets the dSYM files that are used to symbolicate your crash reports. New Relic provides a post-build script as part of the iOS agent's install process and the tvOS agent's install process. This script automatically uploads your app's dSYM files. Automatic script The script automatically uploads dSYM files only for release builds. Non-release builds must upload their files either manually or through the mobile monitoring UI. Bitcode-enabled apps have their dSYM files generated by Apple. You must download the dSYM files for Bitcode-enabled apps from Apple and upload them to New Relic. If you see unreadable machine code in the Crashes page, your dSYM files may not be uploaded correctly. In some cases, you may need to manually upload dSYM files. The automatic script uses Python 2. As of October 2019 with macOS 10.15 (Catalina), Python won't be installed by default. If you're using the automatic script (recommended), you may need to manually install Python 2. If you're using Homebrew, see Python on Homebrew. Identify missing dSYMs When a Bitcode-enabled app is uploaded to Apple for App Store review or ad-hoc distribution, dSYMs need to be manually downloaded from Apple and uploaded to New Relic to allow the mobile crash reports to be properly symbolicated. These dSYMs can be downloaded through the archives organizer in Xcode within several minutes of uploading the app. In this situation follow the procedures to find the archive and download dSYMs. If an app is missing a dSYM file, you'll see three indicators in the mobile monitoring UI: Banner notification: A banner warning appears on the Crash report page. The warning reads: We were unable to locate your dsym. Copy Upload prompt: From the Crash type summary page you will be automatically prompted to upload a dSYM file if it is missing. Machine code: The crash stack trace on the Crash report page displays machine code and not a human-readable error message. Upload dSYM files through the mobile monitoring UI You can easily upload your dSYM files directly from the New Relic One UI. The maximum file size is 600 MB. To upload your dSYM files: Go to one.newrelic.com and click Mobile. Then select your app from the list. View Crash analysis. Select a specific crash from the Crash types list. Click Upload dSYM. You can either drag and drop your dSYMs directly, or select the file form your computer. Manually upload dSYM files In some circumstances, New Relic's automatic upload of dSYM files may fail. If a dSYM upload is attempted and fails, it creates a build error with a detailed message. For example, if there's a network failure and the dSYM upload isn't completed, Xcode will report an error. For additional information about how New Relic handles dSYM uploads, see New Relic's Online Technical Community. If the automatic upload fails, you can manually upload your dSYM file. If you have multiple dSYM files, they can be within a single zip with a maximum file size of 600 MB. The YOUR_NEW_RELIC_APPLICATION_TOKEN value in the commands below is the same key used for +[NewRelic startWithApplicationToken:] (in Objective-C) or NewRelic.start(withApplicationToken:) (in Swift). To manually upload your dSYM files: Via Python script (agent versions 6.0.0 or higher) In iOS agent versions 6.0.0 or higher, the agent includes a Python script that automatically processes and uploads symbols. You can call this script from the command line: NewRelicAgent.framework/Resources/generateMap.py \"DSYM_ARCHIVE_PATH\" \"YOUR_NEW_RELIC_APPLICATION_TOKEN\" Copy Via command line To manually upload individual dSYM files from the command line: Zip up your dSYM file or files using the following command. Replace ~ /ZIPPED_DSYM_PATH with your new dSYM archive path and file name (for example, Users/my-name/desktop). Also replace ~ /dSYM_PATH with your existing dSYM file path. /usr/bin/zip --recurse-paths --quiet \"~/ZIPPED_DSYM_PATH\" \"~/dSYM_PATH\" Copy Upload the dSYM zip file using the following command: For US accounts: curl -F dsym=@\"~/DSYM_ZIP_PATH\" -H \"X-APP-LICENSE-KEY: YOUR_NEW_RELIC_APPLICATION_TOKEN\" https://mobile-symbol-upload.newrelic.com/symbol Copy For EU accounts: curl -F dsym=@\"~/DSYM_ZIP_PATH\" -H \"X-APP-LICENSE-KEY: YOUR_NEW_RELIC_APPLICATION_TOKEN\" https://mobile-symbol-upload.eu01.nr-data.net/symbol Copy Troubleshooting Auto-upload failure If a dSYM auto-upload failed, the Report Navigator may have a fully formed cURL command. You can use this cURL command to reattempt an upload. Depending on the error, you may also need to follow some of the dSYM manual upload steps. Here is an example of a successful dSYM upload in the Report Navigator: Example: A successful dSYM upload in the Report Navigator. Missing dSYMs If dSYM files are missing, you may need to check Xcode build settings to ensure the file is being generated. Frameworks which are built locally have separate build settings and may need to be updated as well. Build settings: Debug Information Format : Dwarf with dSYM File Deployment Postprocessing: Yes Strip Linked Product: Yes Strip Debug Symbols During Copy : Yes Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 290.64044,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Upload dSYM files through the <em>mobile</em> <em>monitoring</em> UI",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Your app&#x27;s dSYM files are stored in Xcode&#x27;s dSYM archive path folder. This is the folder where the <em>iOS</em> agent gets the dSYM files that are used to symbolicate your crash reports. <em>New</em> <em>Relic</em> provides a post-build script as part of the <em>iOS</em> agent&#x27;s install process and the <em>tvOS</em> agent&#x27;s install process"
      },
      "id": "60441960e7b9d24f705799ca"
    },
    {
      "sections": [
        "Upgrade the tvOS SDK",
        "Contents",
        "Replacing your tvOS framework"
      ],
      "title": "Upgrade the tvOS SDK",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "tvOS"
      ],
      "external_id": "f5d6d3d356952d185b96aa409605b79e3ace8ec9",
      "image": "https://docs.newrelic.com/static/a3b6801675529d8f4eba123cf08e8f1f/c1b63/Mobile_tvOS_replace-framework_1.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/tvos/upgrading-new-relic-mobiles-tvos-sdk/",
      "published_at": "2021-10-24T18:03:40Z",
      "updated_at": "2021-07-09T08:17:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You must be the account Admin to install, configure, and upgrade the tvOS agent. For information about the latest version, refer to the release notes. Contents Replacing your tvOS framework Admins: You must replace the earlier version of your tvOS agent framework before upgrading to a newer version of the tvOS SDK. Here is an example of the workflow to remove your existing tvOS agent framework so you can replace it with a newer version. From the Project Navigator (CMD 1) in Xcode, search for NewRelicAgentTVOS.framework. Right-click or control-click NewRelicAgentTVOS.framework, and select Show in Finder. Drag NewRelicAgentTVOS.framework to the trash. Verify that the Xcode project highlights the reference to NewRelicAgentTVOS.framework in red. Right-click or control-click NewRelicAgentTVOS.framework, and select Delete to remove the obsolete reference from the project. Follow standard installation procedures for tvOS app monitoring.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 288.5628,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Upgrade the <em>tvOS</em> SDK",
        "sections": "Upgrade the <em>tvOS</em> SDK",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " in Finder. Drag <em>NewRelicAgentTVOS</em>.framework to the trash. Verify that the Xcode project highlights the reference to <em>NewRelicAgentTVOS</em>.framework in red. Right-click or control-click <em>NewRelicAgentTVOS</em>.framework, and select Delete to remove the obsolete reference from the project. Follow standard installation procedures for <em>tvOS</em> app <em>monitoring</em>."
      },
      "id": "604416cc64441f805c378ecf"
    },
    {
      "sections": [
        "CocoaPods for tvOS installation and configuration",
        "Install your tvOS application",
        "Configure using Objective-C",
        "Configure using Swift",
        "Change the logging level (optional)"
      ],
      "title": "CocoaPods for tvOS installation and configuration",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "tvOS"
      ],
      "external_id": "dd8c9ed16a980b08c67150dada56e129900202bd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/tvos/cocoapods-tvos-installation-configuration/",
      "published_at": "2021-10-24T18:03:08Z",
      "updated_at": "2021-07-21T20:49:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "These procedures apply only to tvOS apps using Cocoapods. For all other types of tvOS apps, see tvOS installation and configuration. Install your tvOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. To install and configure your iOS application: Go to one.newrelic.com. If applicable: Select Add more data, select XCFramework. From the drawer, select the New Relic account you would like to add your tvOS application to, and select Continue. Type a name for your mobile app, and select Continue. Continue with the steps to configure mobile monitoring. Configure using Objective-C These procedures to configure your tvOS app with CocoaPods and Objective-C also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy In your [app_name]-Prefix.pch project file (generally found in the Supporting Files folder), include the New Relic header inside the #ifdef __OBJC__ #endif block: #import <NewRelic/NewRelic.h> Copy In your AppDelegate.m file, add this call as the first line of application:didFinishLaunchingWithOptions: [NewRelicAgent startWithApplicationToken:@\"<appToken>\"]; Copy Add a build script to your target's Build Phases and paste the following, replacing \"PUT_NEW_RELIC_APP_TOKEN_HERE\" with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/bash \"${SCRIPT}\" \"PUT_NEW_RELIC_APP_TOKEN_HERE\" Copy Clean and build your app, then run it in the simulator or other device. Within a few minutes you will begin to see data for your app: Go to one.newrelic.com > Mobile > (select an app). Configure using Swift These procedures to configure your tvOS app with CocoaPods and Swift are also available on the Get Started page in the mobile monitoring UI: In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy Create a bridging header: Select File > New > File > Objective-C File. Name the file Placeholder.m, then select Next. Select Create, and confirm Xcode's prompt to generate the bridging header. In your [ app_name]-Bridging-Header.h, add the New Relic header: #import \"NewRelic/NewRelic.h\" Copy In your AppDelegate.swift file, add this call as the first line of application:didFinishLaunchingWithOptions: NewRelic.startWithApplicationToken(\"<appToken>\"); Copy Add a build script to your target's Build Phases and paste the following, replacing NEW_RELIC_APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/bash \"${SCRIPT}\" NEW_RELIC_APP_TOKEN Copy Clean and build your app, then run it in the simulator or other device. Change the logging level (optional) Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add this method call before calling startWithApplicationToken: [NRLogger setLogLevels:NRLogLevelALL]; Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 287.46014,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "CocoaPods for <em>tvOS</em> <em>installation</em> and configuration",
        "sections": "CocoaPods for <em>tvOS</em> <em>installation</em> and configuration",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " for authenticating each <em>mobile</em> app you <em>monitor</em> in <em>New</em> <em>Relic</em>. To install and configure your <em>iOS</em> application: Go to one.newrelic.com. If applicable: Select Add more data, select XCFramework. From the drawer, select the <em>New</em> <em>Relic</em> account you would like to add your <em>tvOS</em> application to, and select"
      },
      "id": "60441ac6196a6710e4960f57"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/tvos/tvos-installation-configuration": [
    {
      "sections": [
        "Upload dSYM files",
        "Automatic script",
        "Identify missing dSYMs",
        "Upload dSYM files through the mobile monitoring UI",
        "Manually upload dSYM files",
        "Via Python script (agent versions 6.0.0 or higher)",
        "Via command line",
        "Troubleshooting",
        "Auto-upload failure",
        "Missing dSYMs"
      ],
      "title": "Upload dSYM files",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "3655f49cf0e1ae693de0f8ea45bf4e5e6437e399",
      "image": "https://docs.newrelic.com/static/5c859575f391fbb1eaa18243a8c97000/8c557/Screen-Shot-2014-09-23-at-11.30.35-AM_0.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/upload-dsyms-bitcode-apps/",
      "published_at": "2021-10-24T16:52:30Z",
      "updated_at": "2021-09-27T15:06:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your app's dSYM files are stored in Xcode's dSYM archive path folder. This is the folder where the iOS agent gets the dSYM files that are used to symbolicate your crash reports. New Relic provides a post-build script as part of the iOS agent's install process and the tvOS agent's install process. This script automatically uploads your app's dSYM files. Automatic script The script automatically uploads dSYM files only for release builds. Non-release builds must upload their files either manually or through the mobile monitoring UI. Bitcode-enabled apps have their dSYM files generated by Apple. You must download the dSYM files for Bitcode-enabled apps from Apple and upload them to New Relic. If you see unreadable machine code in the Crashes page, your dSYM files may not be uploaded correctly. In some cases, you may need to manually upload dSYM files. The automatic script uses Python 2. As of October 2019 with macOS 10.15 (Catalina), Python won't be installed by default. If you're using the automatic script (recommended), you may need to manually install Python 2. If you're using Homebrew, see Python on Homebrew. Identify missing dSYMs When a Bitcode-enabled app is uploaded to Apple for App Store review or ad-hoc distribution, dSYMs need to be manually downloaded from Apple and uploaded to New Relic to allow the mobile crash reports to be properly symbolicated. These dSYMs can be downloaded through the archives organizer in Xcode within several minutes of uploading the app. In this situation follow the procedures to find the archive and download dSYMs. If an app is missing a dSYM file, you'll see three indicators in the mobile monitoring UI: Banner notification: A banner warning appears on the Crash report page. The warning reads: We were unable to locate your dsym. Copy Upload prompt: From the Crash type summary page you will be automatically prompted to upload a dSYM file if it is missing. Machine code: The crash stack trace on the Crash report page displays machine code and not a human-readable error message. Upload dSYM files through the mobile monitoring UI You can easily upload your dSYM files directly from the New Relic One UI. The maximum file size is 600 MB. To upload your dSYM files: Go to one.newrelic.com and click Mobile. Then select your app from the list. View Crash analysis. Select a specific crash from the Crash types list. Click Upload dSYM. You can either drag and drop your dSYMs directly, or select the file form your computer. Manually upload dSYM files In some circumstances, New Relic's automatic upload of dSYM files may fail. If a dSYM upload is attempted and fails, it creates a build error with a detailed message. For example, if there's a network failure and the dSYM upload isn't completed, Xcode will report an error. For additional information about how New Relic handles dSYM uploads, see New Relic's Online Technical Community. If the automatic upload fails, you can manually upload your dSYM file. If you have multiple dSYM files, they can be within a single zip with a maximum file size of 600 MB. The YOUR_NEW_RELIC_APPLICATION_TOKEN value in the commands below is the same key used for +[NewRelic startWithApplicationToken:] (in Objective-C) or NewRelic.start(withApplicationToken:) (in Swift). To manually upload your dSYM files: Via Python script (agent versions 6.0.0 or higher) In iOS agent versions 6.0.0 or higher, the agent includes a Python script that automatically processes and uploads symbols. You can call this script from the command line: NewRelicAgent.framework/Resources/generateMap.py \"DSYM_ARCHIVE_PATH\" \"YOUR_NEW_RELIC_APPLICATION_TOKEN\" Copy Via command line To manually upload individual dSYM files from the command line: Zip up your dSYM file or files using the following command. Replace ~ /ZIPPED_DSYM_PATH with your new dSYM archive path and file name (for example, Users/my-name/desktop). Also replace ~ /dSYM_PATH with your existing dSYM file path. /usr/bin/zip --recurse-paths --quiet \"~/ZIPPED_DSYM_PATH\" \"~/dSYM_PATH\" Copy Upload the dSYM zip file using the following command: For US accounts: curl -F dsym=@\"~/DSYM_ZIP_PATH\" -H \"X-APP-LICENSE-KEY: YOUR_NEW_RELIC_APPLICATION_TOKEN\" https://mobile-symbol-upload.newrelic.com/symbol Copy For EU accounts: curl -F dsym=@\"~/DSYM_ZIP_PATH\" -H \"X-APP-LICENSE-KEY: YOUR_NEW_RELIC_APPLICATION_TOKEN\" https://mobile-symbol-upload.eu01.nr-data.net/symbol Copy Troubleshooting Auto-upload failure If a dSYM auto-upload failed, the Report Navigator may have a fully formed cURL command. You can use this cURL command to reattempt an upload. Depending on the error, you may also need to follow some of the dSYM manual upload steps. Here is an example of a successful dSYM upload in the Report Navigator: Example: A successful dSYM upload in the Report Navigator. Missing dSYMs If dSYM files are missing, you may need to check Xcode build settings to ensure the file is being generated. Frameworks which are built locally have separate build settings and may need to be updated as well. Build settings: Debug Information Format : Dwarf with dSYM File Deployment Postprocessing: Yes Strip Linked Product: Yes Strip Debug Symbols During Copy : Yes Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 290.6404,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Upload dSYM files through the <em>mobile</em> <em>monitoring</em> UI",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Your app&#x27;s dSYM files are stored in Xcode&#x27;s dSYM archive path folder. This is the folder where the <em>iOS</em> agent gets the dSYM files that are used to symbolicate your crash reports. <em>New</em> <em>Relic</em> provides a post-build script as part of the <em>iOS</em> agent&#x27;s install process and the <em>tvOS</em> agent&#x27;s install process"
      },
      "id": "60441960e7b9d24f705799ca"
    },
    {
      "sections": [
        "New Relic for tvOS compatibility and requirements",
        "tvOS requirements"
      ],
      "title": "New Relic for tvOS compatibility and requirements",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "tvOS"
      ],
      "external_id": "ceb80d833a4f472ce844f6aafecd0f50625b3911",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/tvos/new-relic-tvos-compatibility-requirements/",
      "published_at": "2021-10-24T18:03:08Z",
      "updated_at": "2021-07-09T13:30:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Before you install and configure the tvOS agent, make sure your tvOS app meets these requirements. tvOS requirements Make sure your tvOS app meets these requirements: Mobile monitoring tvOS requirements Operating system tvOS 9 or higher API/SDK NSURLConnection, AFNetworking, and ASIHttpRequest networking APIs Languages Objective-C Swift: Works with both network traces and crash reporting, but no interaction traces by default. To enable this, see Enabling interaction tracing in Swift. Devices Any tvOS compatible device (Apple TV 4th generation or higher) File sizes The tvOS agent adds about 270K to your tvOS release app. Architectures ARM 64-bit",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 289.18695,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> for <em>tvOS</em> compatibility and requirements",
        "sections": "<em>New</em> <em>Relic</em> for <em>tvOS</em> compatibility and requirements",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Before you install and configure the <em>tvOS</em> agent, make sure your <em>tvOS</em> app meets these requirements. <em>tvOS</em> requirements Make sure your <em>tvOS</em> app meets these requirements: <em>Mobile</em> <em>monitoring</em> <em>tvOS</em> requirements Operating system <em>tvOS</em> 9 or higher API&#x2F;SDK NSURLConnection, AFNetworking, and ASIHttpRequest"
      },
      "id": "60441ac6196a67e457960f6d"
    },
    {
      "sections": [
        "Upgrade the tvOS SDK",
        "Contents",
        "Replacing your tvOS framework"
      ],
      "title": "Upgrade the tvOS SDK",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "tvOS"
      ],
      "external_id": "f5d6d3d356952d185b96aa409605b79e3ace8ec9",
      "image": "https://docs.newrelic.com/static/a3b6801675529d8f4eba123cf08e8f1f/c1b63/Mobile_tvOS_replace-framework_1.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/tvos/upgrading-new-relic-mobiles-tvos-sdk/",
      "published_at": "2021-10-24T18:03:40Z",
      "updated_at": "2021-07-09T08:17:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You must be the account Admin to install, configure, and upgrade the tvOS agent. For information about the latest version, refer to the release notes. Contents Replacing your tvOS framework Admins: You must replace the earlier version of your tvOS agent framework before upgrading to a newer version of the tvOS SDK. Here is an example of the workflow to remove your existing tvOS agent framework so you can replace it with a newer version. From the Project Navigator (CMD 1) in Xcode, search for NewRelicAgentTVOS.framework. Right-click or control-click NewRelicAgentTVOS.framework, and select Show in Finder. Drag NewRelicAgentTVOS.framework to the trash. Verify that the Xcode project highlights the reference to NewRelicAgentTVOS.framework in red. Right-click or control-click NewRelicAgentTVOS.framework, and select Delete to remove the obsolete reference from the project. Follow standard installation procedures for tvOS app monitoring.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 288.5628,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Upgrade the <em>tvOS</em> SDK",
        "sections": "Upgrade the <em>tvOS</em> SDK",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " in Finder. Drag <em>NewRelicAgentTVOS</em>.framework to the trash. Verify that the Xcode project highlights the reference to <em>NewRelicAgentTVOS</em>.framework in red. Right-click or control-click <em>NewRelicAgentTVOS</em>.framework, and select Delete to remove the obsolete reference from the project. Follow standard installation procedures for <em>tvOS</em> app <em>monitoring</em>."
      },
      "id": "604416cc64441f805c378ecf"
    }
  ],
  "/docs/mobile-monitoring/new-relic-mobile-ios/tvos/upgrading-new-relic-mobiles-tvos-sdk": [
    {
      "sections": [
        "Upload dSYM files",
        "Automatic script",
        "Identify missing dSYMs",
        "Upload dSYM files through the mobile monitoring UI",
        "Manually upload dSYM files",
        "Via Python script (agent versions 6.0.0 or higher)",
        "Via command line",
        "Troubleshooting",
        "Auto-upload failure",
        "Missing dSYMs"
      ],
      "title": "Upload dSYM files",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "3655f49cf0e1ae693de0f8ea45bf4e5e6437e399",
      "image": "https://docs.newrelic.com/static/5c859575f391fbb1eaa18243a8c97000/8c557/Screen-Shot-2014-09-23-at-11.30.35-AM_0.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/upload-dsyms-bitcode-apps/",
      "published_at": "2021-10-24T16:52:30Z",
      "updated_at": "2021-09-27T15:06:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your app's dSYM files are stored in Xcode's dSYM archive path folder. This is the folder where the iOS agent gets the dSYM files that are used to symbolicate your crash reports. New Relic provides a post-build script as part of the iOS agent's install process and the tvOS agent's install process. This script automatically uploads your app's dSYM files. Automatic script The script automatically uploads dSYM files only for release builds. Non-release builds must upload their files either manually or through the mobile monitoring UI. Bitcode-enabled apps have their dSYM files generated by Apple. You must download the dSYM files for Bitcode-enabled apps from Apple and upload them to New Relic. If you see unreadable machine code in the Crashes page, your dSYM files may not be uploaded correctly. In some cases, you may need to manually upload dSYM files. The automatic script uses Python 2. As of October 2019 with macOS 10.15 (Catalina), Python won't be installed by default. If you're using the automatic script (recommended), you may need to manually install Python 2. If you're using Homebrew, see Python on Homebrew. Identify missing dSYMs When a Bitcode-enabled app is uploaded to Apple for App Store review or ad-hoc distribution, dSYMs need to be manually downloaded from Apple and uploaded to New Relic to allow the mobile crash reports to be properly symbolicated. These dSYMs can be downloaded through the archives organizer in Xcode within several minutes of uploading the app. In this situation follow the procedures to find the archive and download dSYMs. If an app is missing a dSYM file, you'll see three indicators in the mobile monitoring UI: Banner notification: A banner warning appears on the Crash report page. The warning reads: We were unable to locate your dsym. Copy Upload prompt: From the Crash type summary page you will be automatically prompted to upload a dSYM file if it is missing. Machine code: The crash stack trace on the Crash report page displays machine code and not a human-readable error message. Upload dSYM files through the mobile monitoring UI You can easily upload your dSYM files directly from the New Relic One UI. The maximum file size is 600 MB. To upload your dSYM files: Go to one.newrelic.com and click Mobile. Then select your app from the list. View Crash analysis. Select a specific crash from the Crash types list. Click Upload dSYM. You can either drag and drop your dSYMs directly, or select the file form your computer. Manually upload dSYM files In some circumstances, New Relic's automatic upload of dSYM files may fail. If a dSYM upload is attempted and fails, it creates a build error with a detailed message. For example, if there's a network failure and the dSYM upload isn't completed, Xcode will report an error. For additional information about how New Relic handles dSYM uploads, see New Relic's Online Technical Community. If the automatic upload fails, you can manually upload your dSYM file. If you have multiple dSYM files, they can be within a single zip with a maximum file size of 600 MB. The YOUR_NEW_RELIC_APPLICATION_TOKEN value in the commands below is the same key used for +[NewRelic startWithApplicationToken:] (in Objective-C) or NewRelic.start(withApplicationToken:) (in Swift). To manually upload your dSYM files: Via Python script (agent versions 6.0.0 or higher) In iOS agent versions 6.0.0 or higher, the agent includes a Python script that automatically processes and uploads symbols. You can call this script from the command line: NewRelicAgent.framework/Resources/generateMap.py \"DSYM_ARCHIVE_PATH\" \"YOUR_NEW_RELIC_APPLICATION_TOKEN\" Copy Via command line To manually upload individual dSYM files from the command line: Zip up your dSYM file or files using the following command. Replace ~ /ZIPPED_DSYM_PATH with your new dSYM archive path and file name (for example, Users/my-name/desktop). Also replace ~ /dSYM_PATH with your existing dSYM file path. /usr/bin/zip --recurse-paths --quiet \"~/ZIPPED_DSYM_PATH\" \"~/dSYM_PATH\" Copy Upload the dSYM zip file using the following command: For US accounts: curl -F dsym=@\"~/DSYM_ZIP_PATH\" -H \"X-APP-LICENSE-KEY: YOUR_NEW_RELIC_APPLICATION_TOKEN\" https://mobile-symbol-upload.newrelic.com/symbol Copy For EU accounts: curl -F dsym=@\"~/DSYM_ZIP_PATH\" -H \"X-APP-LICENSE-KEY: YOUR_NEW_RELIC_APPLICATION_TOKEN\" https://mobile-symbol-upload.eu01.nr-data.net/symbol Copy Troubleshooting Auto-upload failure If a dSYM auto-upload failed, the Report Navigator may have a fully formed cURL command. You can use this cURL command to reattempt an upload. Depending on the error, you may also need to follow some of the dSYM manual upload steps. Here is an example of a successful dSYM upload in the Report Navigator: Example: A successful dSYM upload in the Report Navigator. Missing dSYMs If dSYM files are missing, you may need to check Xcode build settings to ensure the file is being generated. Frameworks which are built locally have separate build settings and may need to be updated as well. Build settings: Debug Information Format : Dwarf with dSYM File Deployment Postprocessing: Yes Strip Linked Product: Yes Strip Debug Symbols During Copy : Yes Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 290.64053,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Upload dSYM files through the <em>mobile</em> <em>monitoring</em> UI",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Your app&#x27;s dSYM files are stored in Xcode&#x27;s dSYM archive path folder. This is the folder where the <em>iOS</em> agent gets the dSYM files that are used to symbolicate your crash reports. <em>New</em> <em>Relic</em> provides a post-build script as part of the <em>iOS</em> agent&#x27;s install process and the <em>tvOS</em> agent&#x27;s install process"
      },
      "id": "60441960e7b9d24f705799ca"
    },
    {
      "sections": [
        "New Relic for tvOS compatibility and requirements",
        "tvOS requirements"
      ],
      "title": "New Relic for tvOS compatibility and requirements",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "tvOS"
      ],
      "external_id": "ceb80d833a4f472ce844f6aafecd0f50625b3911",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/tvos/new-relic-tvos-compatibility-requirements/",
      "published_at": "2021-10-24T18:03:08Z",
      "updated_at": "2021-07-09T13:30:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Before you install and configure the tvOS agent, make sure your tvOS app meets these requirements. tvOS requirements Make sure your tvOS app meets these requirements: Mobile monitoring tvOS requirements Operating system tvOS 9 or higher API/SDK NSURLConnection, AFNetworking, and ASIHttpRequest networking APIs Languages Objective-C Swift: Works with both network traces and crash reporting, but no interaction traces by default. To enable this, see Enabling interaction tracing in Swift. Devices Any tvOS compatible device (Apple TV 4th generation or higher) File sizes The tvOS agent adds about 270K to your tvOS release app. Architectures ARM 64-bit",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 289.18774,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> for <em>tvOS</em> compatibility and requirements",
        "sections": "<em>New</em> <em>Relic</em> for <em>tvOS</em> compatibility and requirements",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": "Before you install and configure the <em>tvOS</em> agent, make sure your <em>tvOS</em> app meets these requirements. <em>tvOS</em> requirements Make sure your <em>tvOS</em> app meets these requirements: <em>Mobile</em> <em>monitoring</em> <em>tvOS</em> requirements Operating system <em>tvOS</em> 9 or higher API&#x2F;SDK NSURLConnection, AFNetworking, and ASIHttpRequest"
      },
      "id": "60441ac6196a67e457960f6d"
    },
    {
      "sections": [
        "CocoaPods for tvOS installation and configuration",
        "Install your tvOS application",
        "Configure using Objective-C",
        "Configure using Swift",
        "Change the logging level (optional)"
      ],
      "title": "CocoaPods for tvOS installation and configuration",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "tvOS"
      ],
      "external_id": "dd8c9ed16a980b08c67150dada56e129900202bd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/tvos/cocoapods-tvos-installation-configuration/",
      "published_at": "2021-10-24T18:03:08Z",
      "updated_at": "2021-07-21T20:49:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "These procedures apply only to tvOS apps using Cocoapods. For all other types of tvOS apps, see tvOS installation and configuration. Install your tvOS application As part of the installation process, New Relic automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile app you monitor in New Relic. To install and configure your iOS application: Go to one.newrelic.com. If applicable: Select Add more data, select XCFramework. From the drawer, select the New Relic account you would like to add your tvOS application to, and select Continue. Type a name for your mobile app, and select Continue. Continue with the steps to configure mobile monitoring. Configure using Objective-C These procedures to configure your tvOS app with CocoaPods and Objective-C also appear on the Get Started page in New Relic. In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy In your [app_name]-Prefix.pch project file (generally found in the Supporting Files folder), include the New Relic header inside the #ifdef __OBJC__ #endif block: #import <NewRelic/NewRelic.h> Copy In your AppDelegate.m file, add this call as the first line of application:didFinishLaunchingWithOptions: [NewRelicAgent startWithApplicationToken:@\"<appToken>\"]; Copy Add a build script to your target's Build Phases and paste the following, replacing \"PUT_NEW_RELIC_APP_TOKEN_HERE\" with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/bash \"${SCRIPT}\" \"PUT_NEW_RELIC_APP_TOKEN_HERE\" Copy Clean and build your app, then run it in the simulator or other device. Within a few minutes you will begin to see data for your app: Go to one.newrelic.com > Mobile > (select an app). Configure using Swift These procedures to configure your tvOS app with CocoaPods and Swift are also available on the Get Started page in the mobile monitoring UI: In the Podfile for your project, add the following line: pod 'NewRelicAgent' Copy Close your project in Xcode, and update it by running this command from the Terminal in your project directory: pod install Copy Open your project in Xcode by running this command from the Terminal in your project directory: open App.xcworkspace Copy Create a bridging header: Select File > New > File > Objective-C File. Name the file Placeholder.m, then select Next. Select Create, and confirm Xcode's prompt to generate the bridging header. In your [ app_name]-Bridging-Header.h, add the New Relic header: #import \"NewRelic/NewRelic.h\" Copy In your AppDelegate.swift file, add this call as the first line of application:didFinishLaunchingWithOptions: NewRelic.startWithApplicationToken(\"<appToken>\"); Copy Add a build script to your target's Build Phases and paste the following, replacing NEW_RELIC_APP_TOKEN with your application token: SCRIPT=`/usr/bin/find \"${SRCROOT}\" -name newrelic_postbuild.sh | head -n 1` /bin/bash \"${SCRIPT}\" NEW_RELIC_APP_TOKEN Copy Clean and build your app, then run it in the simulator or other device. Change the logging level (optional) Six log levels are available for mobile apps monitoring: none error warning info verbose ALL To increase your logging level in the app, add this method call before calling startWithApplicationToken: [NRLogger setLogLevels:NRLogLevelALL]; Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 287.46088,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "CocoaPods for <em>tvOS</em> <em>installation</em> and configuration",
        "sections": "CocoaPods for <em>tvOS</em> <em>installation</em> and configuration",
        "tags": "<em>New</em> <em>Relic</em> <em>Mobile</em> <em>iOS</em>",
        "body": " for authenticating each <em>mobile</em> app you <em>monitor</em> in <em>New</em> <em>Relic</em>. To install and configure your <em>iOS</em> application: Go to one.newrelic.com. If applicable: Select Add more data, select XCFramework. From the drawer, select the <em>New</em> <em>Relic</em> account you would like to add your <em>tvOS</em> application to, and select"
      },
      "id": "60441ac6196a6710e4960f57"
    }
  ],
  "/docs/more-integrations/grafana-integrations/get-started/grafana-support-prometheus-promql": [
    {
      "sections": [
        "Introduction to New Relic integrations",
        "Choose what's right for you",
        "Create your own solutions"
      ],
      "title": "Introduction to New Relic integrations",
      "type": "docs",
      "tags": [
        "Instrument everything",
        "Get started"
      ],
      "external_id": "9a44613b8a5ec0a9c9570b22c7d2f3ea726f2671",
      "image": "",
      "url": "https://docs.newrelic.com/docs/using-new-relic/welcome-new-relic/get-started/introduction-new-relic-integrations/",
      "published_at": "2021-10-24T11:54:18Z",
      "updated_at": "2021-10-24T00:59:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We provide hundreds of solutions to get your data into New Relic so you can analyze the data in one place. They give you a steady flow of useful data to fix problems quickly, maintain complex systems, improve your code, and accelerate your digital transformation. You can bring in data from hundreds of applications, frameworks, services, operating systems, and other technologies. Our integrations gather the data, and the agents send it to New Relic. The solution you need may require you to install both an integration and an agent. In some cases, you can just install our agents that contain integrations, such as our APM agents. Whatever data you need to bring in, chances are that we have options for your environment. If you prefer to make your own solutions, we also offer tools to get you started. Choose what's right for you We offer a wide range of solutions so you can easily collect data across your environment. You may only need one of our solutions to get the data you need, or you can choose a variety of options to capture a broader range of data types. Go to New Relic Integrations to find solutions that fit your environment. Here is a sample of what youâ€™ll find there: Application performance monitoring (APM): C, Go, Java, Node, .NET, PHP, Python, and Ruby Mobile apps: Android and iOS Browser monitoring: Google Chrome, Mozilla Firefox, Microsoft Internet Explorer, and Apple Safari Host monitoring: Linux and Microsoft Windows Cloud platform monitoring: Amazon Web Services (AWS), Microsoft Azure, and Google Cloud Platform (GCP) Core infrastructure services: Kubernetes, NGINX, MySQL, and more Open source telemetry integrations: Prometheus, Micrometer, OpenTelemetry, and more Create your own solutions If you are looking for custom options, we have tools to help you create your own: Use New Relic Flex to create lightweight monitoring solutions using infrastructure monitoring. Use New Relic Telemetry SDKs to build custom solutions for sending metrics, traces, and more. Build your own New Relic One applications that you can share with your colleagues, or edit open source applications in our catalog.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.74133,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic <em>integrations</em>",
        "sections": "Introduction to New Relic <em>integrations</em>",
        "tags": "<em>Get</em> <em>started</em>",
        "body": " <em>integrations</em>, such as our APM agents. Whatever data you need to bring in, chances are that we have options for your environment. If you prefer to make your own solutions, we also offer tools to <em>get</em> you <em>started</em>. Choose what&#x27;s right for you We offer a wide range of solutions so you can easily collect"
      },
      "id": "603e817f28ccbc4857eba798"
    },
    {
      "sections": [
        "Go agent compatibility and requirements",
        "Golang versions",
        "Operating environments",
        "Integrations",
        "Database and instance-level performance",
        "Connect the agent to other features"
      ],
      "title": "Go agent compatibility and requirements",
      "type": "docs",
      "tags": [
        "Agents",
        "Go agent",
        "Get started"
      ],
      "external_id": "d384ff94e5b894d45013f066f3ff4484dd8c42b3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/go-agent/get-started/go-agent-compatibility-requirements/",
      "published_at": "2021-10-24T13:59:38Z",
      "updated_at": "2021-10-23T20:23:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you don't have one already, create a New Relic account. It's free, forever. Before you install New Relic for Go, ensure your system meets these requirements. Golang versions New Relic supports Golang 1.7 or higher. Operating environments The agent supports Linux, macOS, and Windows. You can also use the Go agent in a Google App Engine (GAE) flexible environment. Integrations The following integration packages extend the base newrelic package to support other frameworks and libraries. If frameworks and databases don't have an integration package, you can still instrument them using the newrelic package primitives. For more information about instrumenting your database using these primitives, see the Go agent's datastore segments documentation on GitHub. The following integration packages must be imported along with the newrelic package, as shown in the nrgin example on GitHub. Project Integration package Purpose aws/aws-sdk-go v3/integrations/nrawssdk-v1 Instrument outbound calls made using Go AWS SDK aws/aws-sdk-go-v2 v3/integrations/nrawssdk-v2 Instrument outbound calls made using Go AWS SDK v2 labstack/echo v3/integrations/nrecho-v3 Instrument inbound requests through version 3 of the Echo framework labstack/echo v3/integrations/nrecho-v4 Instrument inbound requests through version 4 of the Echo framework gin-gonic/gin v3/integrations/nrgin Instrument inbound requests through the Gin framework gorilla/mux v3/integrations/nrgorilla Instrument inbound requests through the Gorilla framework julienschmidt/httprouter v3/integrations/nrhttprouter Instrument inbound requests through the HttpRouter framework aws/aws-lambda-go v3/integrations/nrlambda Instrument AWS Lambda applications sirupsen/logrus v3/integrations/nrlogrus Send agent log messages to Logrus mgutz/logxi v3/integrations/nrlogxi Send agent log messages to Logxi uber-go/zap v3/integrations/nrzap Send agent log messages to Zap pkg/errors v3/integrations/nrpkgerrors Wrap pkg/errors errors to improve stack traces and error class information openzipkin/b3-propagation v3/integrations/nrb3 Add B3 headers to outgoing requests database/sql Use a supported database driver or builtin instrumentation Instrument database calls with SQL jmoiron/sqlx Use a supported database driver or builtin instrumentation Instrument database calls with SQLx go-sql-driver/mysql v3/integrations/nrmysql Instrument database calls to MySQL lib/pq v3/integrations/nrpq Instrument database calls to Postgres using the database/sql library and pq jackc/pgx v3/integrations/nrpgx Instrument database calls to Postgres using the database/sql library and jackc/pgx snowflakedb/gosnowflake v3/integrations/nrsnowflake Instrument database calls to Snowflake go-redis/redis v3/integrations/nrredis-v7 Instrument calls to Redis Version 7 go-redis/redis v3/integrations/nrredis-v8 Instrument calls to Redis Version 8 mattn/go-sqlite3 v3/integrations/nrsqlite3 Instrument database calls to SQLite mongodb/mongo-go-driver v3/integrations/nrmongo Instrument MongoDB calls google.golang.org/grpc v3/integrations/nrgrpc Instrument gRPC servers and clients micro/go-micro v3/integrations/nrmicro Instrument servers, clients, publishers, and subscribers through the Micro framework nats-io/nats.go v3/integrations/nrnats Instrument publishers and subscribers using the NATS client nats-io/stan.go v3/integrations/nrstan Instrument publishers and subscribers using the NATS streaming client graphql-go/graphql v3/integrations/nrgraphqlgo Instrument inbound requests using graphql-go/graphql graph-gophers/graphql-go v3/integrations/nrgraphgophers Instrument inbound requests using graph-gophers/graphql-go Database and instance-level performance New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your agent version. The New Relic Go agent version 1.4 or higher supports instance details for all database drivers. Connect the agent to other features The Go agent integrates with other features to give you observability across your entire stack: Product Integration Infrastructure monitoring When you install the infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in infrastructure monitoring. New Relic dashboards The Go agent sends default events and attributes to New Relic for NRQL queries. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from synthetic monitors to the underlying APM transaction. Browser monitoring The Go agent has an API for returning the browser agent's JavaScript. After using this API method on each request, you can view browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 137.64752,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Integrations</em>",
        "tags": "<em>Get</em> <em>started</em>",
        "body": " use the Go agent in a Google App Engine (GAE) flexible environment. <em>Integrations</em> The following integration packages extend the base newrelic package to support other frameworks and libraries. If frameworks and databases don&#x27;t have an integration package, you can still instrument them using"
      },
      "id": "61746f5964441f72305fbb4c"
    },
    {
      "sections": [
        "Introduction to the Kubernetes integration",
        "Get started: Install the Kubernetes integration",
        "Tip",
        "Why it matters",
        "Navigate all your Kubernetes events",
        "Bring your cluster logs to New Relic",
        "Check the source code"
      ],
      "title": "Introduction to the Kubernetes integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "Kubernetes integration",
        "Get started"
      ],
      "external_id": "81c1ba10f4c79655db595bd6423a7b03720af947",
      "image": "",
      "url": "https://docs.newrelic.com/docs/kubernetes-pixie/kubernetes-integration/get-started/introduction-kubernetes-integration/",
      "published_at": "2021-10-24T16:15:04Z",
      "updated_at": "2021-10-24T02:56:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Kubernetes integration gives you full observability into the health and performance of your environment, no matter whether you run Kubernetes on-premises or in the cloud. With our cluster explorer, you can cut through layers of complexity to see how your cluster is performing, from the heights of the control plane down to applications running on a single pod. one.newrelic.com > Kubernetes cluster explorer: The cluster explorer is our powerful, fully visual answer to the challenges associated with running Kubernetes at a large scale. You can see the power of the Kubernetes integration in the cluster explorer, where the full picture of a cluster is made available on a single screen: nodes and pods are visualized according to their health and performance, with pending and alerting nodes in the innermost circles. Predefined alert conditions help you troubleshoot issues right from the start. Clicking each node reveals its status and how each app is performing. Get started: Install the Kubernetes integration We have an automated installer to help you with many types of installations: servers, virtual machines, and unprivileged environments. It can also help you with installations in managed services or platforms, but you'll need to review a few preliminary notes before getting started. Our automated installer will generate either a helm command or a set of plain manifests for you to install. Our automated installer: Allows users to select the cluster name and namespace for the installation. Allows users to selectively enable or disable bundling of Kube-state-metrics, a dependency of the Kubernetes integration. Allows users to seamlessly install our other products related to Kubernetes such as: Kubernetes events monitoring In-cluster prometheus services monitoring Service instrumentation without code changes using Pixie Automatically fills the required properties with the license keys the integration needs to work. Read the install docs Start the installer Tip If your New Relic account is in the EU region, access the automated installer from one.eu.newrelic.com. Why it matters Governing the complexity of Kubernetes can be challenging; there's so much going on at any given moment, with containers being created and deleted in a matter of minutes, applications crashing, and resources being consumed unexpectedly. Our integration helps you navigate Kubernetes abstractions across on-premises, cloud, and hybrid deployments. In New Relic, you can build your own charts and query all your Kubernetes data, which our integration collects by instrumenting the container orchestration layer. This gives you additional insight into nodes, namespaces, deployments, replica sets, pods, and containers. one.newrelic.com > Dashboards: Using the query builder you can turn any query on Kubernetes data to clear visuals. With the Kubernetes integration you can also: Link your APM data to Kubernetes to measure the performance of your web and mobile applications, with metrics such as request rate, throughput, error rate, and availability. Monitor services running on Kubernetes, such as Apache, NGINX, Cassandra, and many more (see our tutorial for monitoring Redis on Kubernetes). Create new alert policies and alert conditions based on your Kubernetes data, or extend the predefined alert conditions. These features are in addition to the data New Relic already reports for containerized processes running on instrumented hosts. Navigate all your Kubernetes events The Kubernetes events integration, which is installed separately, watches for events happening in your Kubernetes clusters and sends those events to New Relic. Events data is then visualized in the cluster explorer. To set it up, check the Kubernetes events box in step 3 of our install wizard, or follow the instructions. one.newrelic.com > Kubernetes cluster explorer > Events: Browse and filter all your Kubernetes events, and dig into application logs and infrastructure data. Bring your cluster logs to New Relic Our Kubernetes plugin for log monitoring can collect all your cluster's logs and send them to our platform, so that you can set up new alerts and charts. To set it up, check the Log data box in step 3 of our install wizard, or follow the instructions. Check the source code This integration is open source software. That means you can browse its source code and send improvements, or you can create your own fork and build it. For more information, see the README.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.34955,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to the Kubernetes <em>integration</em>",
        "sections": "<em>Get</em> <em>started</em>: Install the Kubernetes <em>integration</em>",
        "tags": "<em>Get</em> <em>started</em>",
        "body": " from the <em>start</em>. Clicking each node reveals its status and how each app is performing. <em>Get</em> <em>started</em>: Install the Kubernetes integration We have an automated installer to help you with many types of installations: servers, virtual machines, and unprivileged environments. It can also help you"
      },
      "id": "6174cb5c28ccbcde75c6c73f"
    }
  ],
  "/docs/more-integrations/grafana-integrations/set-configure/configure-new-relic-prometheus-data-source-grafana": [
    {
      "sections": [
        "Grafana support with Prometheus and PromQL",
        "Use existing Grafana dashboards with New Relic",
        "Compatibility and requirements",
        "Support for PromQL",
        "Get data flowing in Grafana",
        "Whatâ€™s next?"
      ],
      "title": "Grafana support with Prometheus and PromQL",
      "type": "docs",
      "tags": [
        "Integrations",
        "Grafana integrations",
        "Get started"
      ],
      "external_id": "52addf26732e0146545ae8dee6540d3bd7cab2ff",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/grafana-integrations/get-started/grafana-support-prometheus-promql/",
      "published_at": "2021-10-24T18:04:16Z",
      "updated_at": "2021-04-22T13:30:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In Grafana, you can configure New Relic as a Prometheus data source. Not only that, within Grafana you can query metrics stored in New Relic using the PromQL query language. Use existing Grafana dashboards with New Relic When you integrate Prometheus metrics with New Relic via Remote Write or the OpenMetrics Integration (2.0+) and configure New Relic as a Prometheus data source in Grafana, you can use existing Grafana dashboards and seamlessly tap into the additional monitoring, reliability, and scale we provide. Compatibility and requirements Before you begin, make sure youâ€™ve finished integrating Prometheus metrics and are running a recent enough version of Grafana. You should have either the Remote Write or the OpenMetrics Integration ( v2.0+) set up before you can configure New Relic Prometheus data sources in Grafana. You can only configure New Relic Prometheus data sources using this method in Grafana versions 6.7.0 or newer. You will need to configure custom headers in the UI, and this isnâ€™t possible with earlier versions. For details, see Configure New Relic as a Prometheus data source for Grafana. Support for PromQL Our Prometheus API emulates Prometheus' query APIs. We support the Prometheus query language (PromQL) through our PromQL-style query mode. We do our best to automatically translate PromQL syntax queries into the closest NRQL approximation. For more information on how this works and differences you may observe between Prometheus and New Relic, see Supported PromQL features. Get data flowing in Grafana To make your New Relic data available in Grafana, you can configure a new or existing Prometheus data source in just a couple of simple steps: In the Grafana UI, add and configure a new data source. Save the new data source and start viewing your data. Whatâ€™s next? Ready to configure a Grafana data source? Read the how-to documentation for setting up the Prometheus remote write integration or the Prometheus OpenMetrics Integration. Read the how-to documentation for configuring Prometheus data sources in Grafana.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 102.75706,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Grafana</em> support with Prometheus <em>and</em> PromQL",
        "sections": "<em>Grafana</em> support with Prometheus <em>and</em> PromQL",
        "tags": "<em>Grafana</em> <em>integrations</em>",
        "body": " integrating Prometheus metrics and are running a recent enough version of <em>Grafana</em>. You should have either the Remote Write or the OpenMetrics Integration ( v2.0+) <em>set</em> <em>up</em> before you can <em>configure</em> New Relic Prometheus data sources in <em>Grafana</em>. You can only <em>configure</em> New Relic Prometheus data sources using"
      },
      "id": "603e94de64441f9a804e8843"
    },
    {
      "sections": [
        "Cloud services integrations",
        "AWS integrations",
        "GCP integrations",
        "Azure integrations"
      ],
      "title": "Cloud services integrations",
      "type": "docs",
      "tags": [
        "Instrument everything",
        "Instrument core services and applications"
      ],
      "external_id": "509277aa4f9f8ad66cf5f82a94104531df64c296",
      "image": "https://docs.newrelic.com/static/78ac85c1fc41f94776fce7235e327f01/69538/img-integration-aws%25402x.png",
      "url": "https://docs.newrelic.com/docs/using-new-relic/welcome-new-relic/get-started/cloud-services-integrations/",
      "published_at": "2021-10-24T11:49:17Z",
      "updated_at": "2021-10-24T00:48:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic you can easily instrument your services in AWS, Google Cloud Platform, and Azure. AWS integrations Introduction to AWS integrations List of AWS integrations GCP integrations Introduction to GCP integrations List of GCP integrations Azure integrations Introduction to Azure integrations List of Azure integrations",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 50.74465,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Cloud services <em>integrations</em>",
        "sections": "Cloud services <em>integrations</em>",
        "tags": "Instrument core services <em>and</em> applications",
        "body": "With New Relic you can easily instrument your services in AWS, Google Cloud Platform, and Azure. AWS <em>integrations</em> Introduction to AWS <em>integrations</em> List of AWS <em>integrations</em> GCP <em>integrations</em> Introduction to GCP <em>integrations</em> List of GCP <em>integrations</em> Azure <em>integrations</em> Introduction to Azure <em>integrations</em> List of Azure <em>integrations</em>"
      },
      "id": "603e829ae7b9d20bb12a080c"
    },
    {
      "sections": [
        "DagsHub MLOps integration",
        "What is MLOps?",
        "The DagsHub integration",
        "Integrate DagsHub with New Relic",
        "View and explore your DagsHub models in New Relic dashboards"
      ],
      "title": "DagsHub MLOps integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "MLOps integrations",
        "DagsHub integrations"
      ],
      "external_id": "7a93ba8b53a1d905a60dcdfc242ffa4ab9e03ae2",
      "image": "https://docs.newrelic.com/static/d78db1e800d8c753d87ad615803b3411/c1b63/dagshub1.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/mlops-integrations/dagshub-mlops-integration/",
      "published_at": "2021-10-24T23:55:00Z",
      "updated_at": "2021-10-23T17:33:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "What is MLOps? MLOps stands for machine-learning operations. As more companies invest in artificial intelligence and machine learning, there's a gap in understanding between the data science teams developing machine-learning models and the DevOps teams operating the applications that power those models. MLOps provides a tool for monitoring and observing the performance and effectiveness of machine-learning models in a production environment. This increases the possibilities for collaboration between data science and DevOps teams, feeding into a continuous process of development, testing, and operational monitoring. The DagsHub integration DagsHub is a platform for data scientists and machine learning engineers to version and sync their data, models, experiments, and code. It allows you and your team to easily share, review and reuse your work, providing a GitHub-like experience for machine learning. DagsHub is built on popular open-source tools and formats, making it easy to integrate with the tools you already use like New Relic. New Relic now offers an integration with DagsHub to monitor and analyze your machine learning training metrics in real-time. Integrate DagsHub with New Relic Integrating DagsHub and New Relic enables you to analyze and monitor machine learning training metrics in real-time. You can visualize your metrics in a New Relic dashboard, create custom metrics, and set alerts to notify you of events and incidents happening during your training runs. In order to receive data from DagsHub into New Relic, you need your account number and a special key which you can obtain as follows: Log into your New Relic account: Go to one.newrelic.com, and click Explorer. On the upper hand right corner, on the main navigation menu, click on +Add more data. Click on DagsHub: Type DagsHub in the search bar, or scroll down to the MLOps Integration section, and click the DagsHub icon. Select the account ID you want DagsHub to integrate with. Create an access token: Once you've selected an account ID, under real-time insert metrics, click Create an API key . This will be your new telemetry API key. Keep the New Relic page open for future steps. Log into the DagsHub portal and select the repository you're working on. Click Settings, and select the integrations button from the left hand menu. Click on the New Relic tile. Copy and paste the token in DagsHub. Go back to the New Relic integration dashboard and copy the token you created by clicking on the copy icon next to the insert key. On the DagsHubâ€™s portal, paste the insert key under New Relic Insight insert key, and finish by clicking Next. The token will be verified, and a confirmation screen will appear. View and explore your DagsHub models in New Relic dashboards Once you configure the New Relic integration in DagsHub, all the training metrics logged to DagsHub in real time are sent to New Relic. Go to the DagsHub integration dashboard: Once youâ€™ve tested your tokens and confirmed the integration is set up correctly, return to the New Relic integration dashboard and click on See your data. You will be redirected to an automatically generated New Relic dashboard powered by DagsHub. Analyze the DagsHub dashboard: The DagsHub dashboard contains one chart, Loss metric by repository, which displays the loss of your models, grouped by their respective repository. It works for any models that you have trained. Display customized metrics: You can easily customize training metrics coming from DagsHub. For more information on using NRQL and creating queries to track your data, refer to NRQL syntax, clauses, and functions. Set up alerts notifications: Once you've created some dashboards, you can get alerted on your data. To create NRQL alerts conditions from a chart, click the ... chart menu, then click Create alert condition. Once you've named and customized your condition, you can add it to an existing policy, or create a new one. Get notified: Once you've created an alerts condition, you can choose how you want to be notified. See our docs on how to set up notification channels. Youâ€™ve now successfully integrated New Relic with DagsHub. Newly created alerts are correlated with your New Relic alerts, and you'll see data about newly reported predictions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 49.52346,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "DagsHub MLOps <em>integration</em>",
        "sections": "DagsHub MLOps <em>integration</em>",
        "tags": "<em>Integrations</em>",
        "body": " the integration is <em>set</em> <em>up</em> correctly, return to the New Relic integration dashboard and click on See your data. You will be redirected to an automatically generated New Relic dashboard powered by DagsHub. Analyze the DagsHub dashboard: The DagsHub dashboard contains one chart, Loss metric by repository, which"
      },
      "id": "6175f254196a67a8242f0923"
    }
  ],
  "/docs/more-integrations/open-source-telemetry-integrations/dropwizard/dropwizard-reporter": [
    {
      "sections": [
        "Introduction to OpenTelemetry with New Relic",
        "Benefits of OpenTelemetry",
        "Should I use OpenTelemetry instrumentation or New Relic agents?",
        "OpenTelemetry: A work in progress",
        "New Relic's APM agents",
        "How OpenTelemetry works with New Relic",
        "Important",
        "Traces",
        "Metrics",
        "Logs",
        "Next steps"
      ],
      "title": "Introduction to OpenTelemetry with New Relic",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "67818451ffb7594e3c27526f4082bd1bc007bc51",
      "image": "",
      "url": "https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/introduction-opentelemetry-new-relic/",
      "published_at": "2021-10-24T16:37:27Z",
      "updated_at": "2021-10-24T00:59:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Are you already familiar with OpenTelemetry and want to begin the setup? Check out our quick start: Quick start If you don't have one already, create a New Relic account. It's free, forever. If you're just getting acquainted with OpenTelemetry, this is what we'll explore here: Benefits of OpenTelemetry Should I use OpenTelemetry or New Relic agents? How OpenTelemetry works with New Relic Benefits of OpenTelemetry OpenTelemetry provides a secure, vendor-neutral specification for service instrumentation so that you can export data to distinct backends of your choice, such as New Relic. OpenTelemetry offers a single set of APIs and libraries that standardize how you collect and transfer telemetry data for your services. The following components make up the OpenTelemetry project: Specifications for the core pillars of observability to drive consistency across all projects. New Relic supports all of these signals: traces, metrics, and logs (see details below) APIs that contain interfaces and implementations based on the specifications SDKs (reference implementations of the APIs) created specifically for languages like Java, Python, Go, Erlang, and more Collectors that offer a vendor-agnostic implementation for processing and exporting Exporters that enable you to send data to a backend of your choice The components of OpenTelemetry work together to create some distinct advantages for capturing telemetry data: Feature Description Ubiquitous instrumentation A single, open standard of instrumentation provides better coverage and flexibility as engineers from all over the world contribute to the instrumentation. Future proof As the instrumentation gets built into libraries and frameworks, and as more vendors move to support this open standard, you can be confident that you wonâ€™t need to change your instrumentation. Support for newer technologies When new technologies emerge, contributors can build integrations into OpenTelemetry or add instrumentation directly to source code, ensuring end users can easily monitor these new technologies. Simplified choice You donâ€™t need to decide which instrumentation option to use (a proprietary option or one of the other open standards). Cross-platform compatibility OpenTelemetry supports a variety of languages and backends. It represents a vendor-neutral path for capturing and transmitting telemetry to backends without altering existing instrumentation. Streamlined observability It is easier for vendors to support and test against a single standard as they donâ€™t need to develop their own agents or collectors. High dimensionality OpenTelemetry uses dimensional metrics, so you can filter and facet on more aspects of the data, such as AWS regions, Kubernetes clusters, or service versions. Dimensional metrics also lead to less time between occurrence and reporting. Efficiency OpenTelemetryâ€™s fire-and-forget trace-centric approach to instrumentation often has lower overhead than New Relic agents, especially for asynchronous workloads. It will also result in better handling of trace data for asynchronous requests. Should I use OpenTelemetry instrumentation or New Relic agents? As you consider OpenTelemetry, you may also be looking at New Relic APM agents that also capture telemetry data. As you'd expect, there is a lot of overlap between features available from OpenTelemetry agents and SDKs versus those available from New Relic APM agents. This is especially true if you're interested in distributed tracing telemetry data. The choice you make depends on what you need. We recommend that you explore both New Relic and OpenTelemetry instrumentation or discuss this with us in our CNCF Slack channel to decide what works best for you. OpenTelemetry: A work in progress OpenTelemetry is still an emerging standard, so your choices may be affected by what's available. You can check on the current state of the specification at the OpenTelemetry site. The current state of language-specific OpenTelemetry APIs and SDKs varies: some languages are still pre-alpha and may be missing instructions on how to instrument your service. Most languages have some implementation of traces that is sufficient to start exporting data to New Relic. Check out this table in GitHub that provides an overview of the state of OpenTelemetry specification compliance for each language. For languages that New Relic does not currently provide an agent or SDK, OpenTelemetry may offer you a good alternative. Also, in cases where you want explicit control over sampling of your telemetry data, OpenTelemetry provides a lot of flexibility. As OpenTelemetry matures, New Relic will continue to support new OpenTelemetry data models and to provide a curated UI experience for our customers. New Relic's APM agents In general, New Relic's APM agents will collect more telemetry data for your services, and they offer a wide range of configuration options and an extensive set of auto-instrumentation capabilities. New Relic's APM agents offer detailed transaction trace visibility for individual services. They also offer predefined sampling to balance the performance impact of your instrumentation against the need to capture enough data to gain helpful insights. How OpenTelemetry works with New Relic New Relic supports the native OpenTelemetry Protocol (OTLP) for exporting telemetry data. This allows you to use the vendor neutral components developed by the OpenTelemetry community to export your data to New Relic. The following tables show the supported features for each telemetry signal. If you have questions about these or have an unsupported use case, please contact us in our CNCF Slack channel, and watch this page for future updates. Important New Relic's exporters for OpenTelemetry are now deprecated in favor of exporting data to New Relic using OTLP. Traces New Relic offers support for the OTLP ingest of trace signals. The maturity of the upstream specification is stable. OpenTelemetry traces and spans are compatible with New Relic traces and spans. OpenTelemetry spans optionally include attributes (name-value pairs) and resource attributes which map directly to dimensions that can be used to facet or filter span data at query time. OpenTelemetry span metadata (for example, name, kind, and trace_id) also map directly to dimensions on NewRelic spans. At this time, New Relic does not support span links or array attributes. For details, see the Traces section of our best practices guide. Feature Supported Span events âœ… Span linking âŒ Array of primitives (homogeneous) âŒ Metrics New Relic offers support for the OTLP ingest of metric signals. Note that the maturity of the upstream specification is experimental. We intend to follow potentially breaking upstream changes. Here are the OpenTelemetry data types we support and their associated mappings. For details, see the Metrics section of our best practices guide. Metric Type Supported Delta sums âœ… Cumulative sums âœ… Gauges âœ… Delta histograms âœ… Summary âœ… Cumulative histograms âŒ Exemplars âŒ Array of primitives (homogeneous) âŒ Logs New Relic offers support for the OTLP ingest of log signals. Note that the maturity of the upstream specification is experimental. We intend to follow potentially breaking upstream changes. OpenTelemetry logs are compatible with New Relic logs. OpenTelemetry logs optionally include attributes (name-value pairs) and resource attributes which map directly to dimensions that can be used to facet or filter log data at query time. OpenTelemetry log metadata (for example, name, severity_text, and trace_id) also map directly to dimensions on New Relic logs. NewRelic currently supports all OpenTelemetry log message types except for arrays. For more details, see the Logs section of our best practices guide. Feature Supported Description LogRecord body âœ… Supported types: string, boolean, int, double, bytes LogRecord attributes âœ… Supported types: string, boolean, int, double, bytes LogRecord fields âœ… Examples: name, severity_text, trace_id Array messages âŒ Array attributes âŒ Next steps Follow the OpenTelemetry quick start to help you get started. You'll also want to review the best practices guide for getting the most out of the data you export to New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 270.2814,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>OpenTelemetry</em> with New Relic",
        "sections": "Introduction to <em>OpenTelemetry</em> with New Relic",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": " wonâ€™t need to change your instrumentation. Support for newer technologies When new technologies emerge, contributors can build <em>integrations</em> into <em>OpenTelemetry</em> or add instrumentation directly to <em>source</em> code, ensuring end users can easily monitor these new technologies. Simplified choice You donâ€™t need"
      },
      "id": "6174afe1e7b9d2748213b3a6"
    },
    {
      "sections": [
        "Introduction to New Relic's open source telemetry integrations",
        "Types of integrations",
        "How they work"
      ],
      "title": "Introduction to New Relic's open source telemetry integrations",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "Get started"
      ],
      "external_id": "239889ec292525fcfd6b417d243943ea7b3e0529",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/open-source-telemetry-integrations/get-started/introduction-new-relics-open-source-telemetry-integrations/",
      "published_at": "2021-10-24T16:24:47Z",
      "updated_at": "2021-07-27T16:01:31Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic provides open source integrations that report telemetry data from telemetry tools to your New Relic account. Types of integrations We have open source integrations that report data from OpenCensus, OpenTelemetry, DropWizard, Prometheus, and more. With these solutions, you can aggregate all your telemetry data in one place: the New Relic platform. See our list of open source telemetry integrations (to browse all New Relic solutions, see our integrations page). How they work These integrations were built using our Telemetry SDKs, which are open-source language-specific libraries for reporting metrics, trace data, and other telemetry data to New Relic. If our pre-built integrations don't meet your needs, you can use the Telemetry SDKs to build your own telemetry tools. Under the hood, data reported by these solutions are ingested via our data ingest APIs. For example, metrics reported by the DropWizard exporter are ingested via the Metric API, so to understand how to query and chart that type of data, you could read Query metric data.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 202.88057,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic&#x27;s <em>open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "sections": "Introduction to New Relic&#x27;s <em>open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": "New Relic provides <em>open</em> <em>source</em> <em>integrations</em> that report <em>telemetry</em> data from <em>telemetry</em> tools to your New Relic account. Types of <em>integrations</em> We have <em>open</em> <em>source</em> <em>integrations</em> that report data from <em>Open</em>Census, <em>OpenTelemetry</em>, <em>DropWizard</em>, Prometheus, and more. With these solutions, you can aggregate"
      },
      "id": "603e95ab28ccbc036aeba789"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/intro-custom-data/",
      "sections": [
        "Introduction to custom data",
        "Options for custom data"
      ],
      "published_at": "2021-10-24T23:24:44Z",
      "title": "Introduction to custom data",
      "updated_at": "2021-10-23T21:59:19Z",
      "type": "docs",
      "external_id": "90d7829dbf9b522ea51f967c628ecbea38917e76",
      "document_type": "page",
      "popularity": 1,
      "body": "To get the most out of New Relic, you may need or want to report custom data to help you get insights about your environment and the unique challenges your organization faces. Options for custom data We have a wide variety of agents and integrations that bring in various types of data. But you may need to bring in data that isn't reported by default. Options for bringing in custom data include: Use our open source telemetry integrations. We have integrations for reporting data from OpenCensus, OpenTelemetry, DropWizard, Prometheus, and more. Configure our agents to send custom data. If you're using one of our APM agents, browser agents, or mobile agents, you can configure them to send custom data. To learn more, see the docs for the tool you're using. Create your own solution for reporting telemetry data with our language-specific Telemetry SDKs. Or use the underlying APIs directly: Metric API, Trace API, Event API, Log API. Report data from your operating system or network. If you're using our infrastructure agent, you might want to use our Flex integration, which lets you use simple config files to report data. Build a New Relic One application. You can build an app that lives on our platform, that can be shared with your team or the public, and that uses your own JavaScript UI functionality. You can analyze New Relic data, or bring in whatever data you want.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 200.02415,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " need to bring in data that isn&#x27;t reported by default. Options for bringing in custom data include: Use our <em>open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>. We have <em>integrations</em> for reporting data from <em>Open</em>Census, <em>OpenTelemetry</em>, <em>DropWizard</em>, Prometheus, and more. Configure our agents to send custom data. If you&#x27;re"
      },
      "id": "609fa5a264441f731bd2a1cf"
    }
  ],
  "/docs/more-integrations/open-source-telemetry-integrations/elixir/elixir-open-source-agent": [
    {
      "sections": [
        "Roku open-source agent",
        "Tip",
        "Get started",
        "For more help"
      ],
      "title": "Roku open-source agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Open-source licensed agents",
        "Open-source licensed agents"
      ],
      "external_id": "f0982a0ff96c8a85683bf3ef27a2e4cde85ff274",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/open-source-telemetry-integrations/roku/roku-open-source-video-agent/",
      "published_at": "2021-10-24T16:38:20Z",
      "updated_at": "2021-04-27T11:09:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Monitor Roku behavior with New Relic using the Roku open-source agent. The agent contains two parts, to capture two separate categories of Roku behavior: App events like app starts and HTTP requests Video playback within the app Tip This agent is released as open source on GitHub. A change log is also available there for the latest updates. Get started For requirements, installation, and configuration information, see the Open Source Roku Agent README on GitHub. Visit New Relicâ€™s Roku repository on GitHub for questions about installation, usage, or other topics. Report issues or bugs as an issue in the GitHub repository. For more help Recommendations for learning more: Browse New Relic's Explorers Hub for community discussions about the open-source Roku agent. Review New Relic's licenses, attributions, data usage limits, and other notices.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 332.3534,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Roku <em>open</em>-<em>source</em> <em>agent</em>",
        "sections": "Roku <em>open</em>-<em>source</em> <em>agent</em>",
        "tags": "<em>Open</em>-<em>source</em> <em>licensed</em> <em>agents</em>",
        "body": "Monitor Roku behavior with New Relic using the Roku <em>open</em>-<em>source</em> <em>agent</em>. The <em>agent</em> contains two parts, to capture two separate categories of Roku behavior: App events like app starts and HTTP requests Video playback within the app Tip This <em>agent</em> is released as <em>open</em> <em>source</em> on GitHub. A change log"
      },
      "id": "6087f0ff64441f618a9d8533"
    },
    {
      "sections": [
        "Troubleshooting: Missing entities in service maps",
        "Problem",
        "Solution",
        "Tip"
      ],
      "title": "Troubleshooting: Missing entities in service maps",
      "type": "docs",
      "tags": [
        "Understand dependencies",
        "Understand system dependencies",
        "Service maps"
      ],
      "external_id": "44f9c026ad8e1c9d6ba02bd1ec2f2deecbc26832",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/service-maps/troubleshooting-missing-entities-service-maps/",
      "published_at": "2021-10-24T12:02:27Z",
      "updated_at": "2021-10-24T01:50:44Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When using service maps, you can't view the full set of entities or the relationships between entities that you expect to see. Solution Make sure that the entities are being monitored with an agent. If you have a mix of agents with some having distributed tracing turned on and some having it turned off, you will not see the relations between those agents. The solution for this scenario is to run all agents either with distributed tracing turned on (preferred) or turn it off for all agents. If this does not remedy the issue, the service you're trying to view may require manual instrumentation. When you view applications and services that we automatically instrument in service maps, you'll usually see complete and detailed data for those nodes in the distributed tracing UI. However, you may notice that some of these services or applications are missing from service maps. Tip Some browser apps are exceptions to this, and may be missing because: Relationships for copy and paste browser agents are not detected. Only the relationships for injected browser agents is shown (the app the agent is injected into). Call relationships (for example, AJAX calling to other apps) are not displayed. If services or apps are missing, you may want to implement custom instrumentation of applications or specific transactions to see more detail in traces. Some examples of when you may need to do this: Transactions not automatically instrumented. To ensure your application is automatically instrumented, read the compatibility and requirements documentation for the agent you're using. If an application isn't automatically instrumented, or if you'd like to add instrumentation of specific activity, see Custom instrumentation. All Go applications. The Go agent, unlike other agents, requires manual instrumentation of your code. For instructions, see Instrument a Go application. A service doesn't use HTTP. If a service doesn't communicate via HTTP, the agent won't send distributed tracing headers. This may be the case for some non-web applications or message queues. To remedy this, use the distributed tracing APIs to instrument either the calling or called application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 36.211746,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "Problem When using service maps, you can&#x27;t view the full set of entities or the relationships between entities that you expect to see. Solution Make sure that the entities are being monitored with an <em>agent</em>. If you have a mix of <em>agents</em> with some having distributed tracing turned on and some having"
      },
      "id": "603eb369196a67b4aaa83d8d"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/intro-custom-data/",
      "sections": [
        "Introduction to custom data",
        "Options for custom data"
      ],
      "published_at": "2021-10-24T23:24:44Z",
      "title": "Introduction to custom data",
      "updated_at": "2021-10-23T21:59:19Z",
      "type": "docs",
      "external_id": "90d7829dbf9b522ea51f967c628ecbea38917e76",
      "document_type": "page",
      "popularity": 1,
      "body": "To get the most out of New Relic, you may need or want to report custom data to help you get insights about your environment and the unique challenges your organization faces. Options for custom data We have a wide variety of agents and integrations that bring in various types of data. But you may need to bring in data that isn't reported by default. Options for bringing in custom data include: Use our open source telemetry integrations. We have integrations for reporting data from OpenCensus, OpenTelemetry, DropWizard, Prometheus, and more. Configure our agents to send custom data. If you're using one of our APM agents, browser agents, or mobile agents, you can configure them to send custom data. To learn more, see the docs for the tool you're using. Create your own solution for reporting telemetry data with our language-specific Telemetry SDKs. Or use the underlying APIs directly: Metric API, Trace API, Event API, Log API. Report data from your operating system or network. If you're using our infrastructure agent, you might want to use our Flex integration, which lets you use simple config files to report data. Build a New Relic One application. You can build an app that lives on our platform, that can be shared with your team or the public, and that uses your own JavaScript UI functionality. You can analyze New Relic data, or bring in whatever data you want.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 34.52204,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " need to bring in data that isn&#x27;t reported by default. Options for bringing in custom data include: Use our <em>open</em> <em>source</em> telemetry integrations. We have integrations for reporting data from <em>Open</em>Census, <em>Open</em>Telemetry, DropWizard, Prometheus, and more. Configure our <em>agents</em> to send custom data. If you&#x27;re"
      },
      "id": "609fa5a264441f731bd2a1cf"
    }
  ],
  "/docs/more-integrations/open-source-telemetry-integrations/get-started/introduction-new-relics-open-source-telemetry-integrations": [
    {
      "sections": [
        "Introduction to OpenTelemetry with New Relic",
        "Benefits of OpenTelemetry",
        "Should I use OpenTelemetry instrumentation or New Relic agents?",
        "OpenTelemetry: A work in progress",
        "New Relic's APM agents",
        "How OpenTelemetry works with New Relic",
        "Important",
        "Traces",
        "Metrics",
        "Logs",
        "Next steps"
      ],
      "title": "Introduction to OpenTelemetry with New Relic",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "67818451ffb7594e3c27526f4082bd1bc007bc51",
      "image": "",
      "url": "https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/introduction-opentelemetry-new-relic/",
      "published_at": "2021-10-24T16:37:27Z",
      "updated_at": "2021-10-24T00:59:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Are you already familiar with OpenTelemetry and want to begin the setup? Check out our quick start: Quick start If you don't have one already, create a New Relic account. It's free, forever. If you're just getting acquainted with OpenTelemetry, this is what we'll explore here: Benefits of OpenTelemetry Should I use OpenTelemetry or New Relic agents? How OpenTelemetry works with New Relic Benefits of OpenTelemetry OpenTelemetry provides a secure, vendor-neutral specification for service instrumentation so that you can export data to distinct backends of your choice, such as New Relic. OpenTelemetry offers a single set of APIs and libraries that standardize how you collect and transfer telemetry data for your services. The following components make up the OpenTelemetry project: Specifications for the core pillars of observability to drive consistency across all projects. New Relic supports all of these signals: traces, metrics, and logs (see details below) APIs that contain interfaces and implementations based on the specifications SDKs (reference implementations of the APIs) created specifically for languages like Java, Python, Go, Erlang, and more Collectors that offer a vendor-agnostic implementation for processing and exporting Exporters that enable you to send data to a backend of your choice The components of OpenTelemetry work together to create some distinct advantages for capturing telemetry data: Feature Description Ubiquitous instrumentation A single, open standard of instrumentation provides better coverage and flexibility as engineers from all over the world contribute to the instrumentation. Future proof As the instrumentation gets built into libraries and frameworks, and as more vendors move to support this open standard, you can be confident that you wonâ€™t need to change your instrumentation. Support for newer technologies When new technologies emerge, contributors can build integrations into OpenTelemetry or add instrumentation directly to source code, ensuring end users can easily monitor these new technologies. Simplified choice You donâ€™t need to decide which instrumentation option to use (a proprietary option or one of the other open standards). Cross-platform compatibility OpenTelemetry supports a variety of languages and backends. It represents a vendor-neutral path for capturing and transmitting telemetry to backends without altering existing instrumentation. Streamlined observability It is easier for vendors to support and test against a single standard as they donâ€™t need to develop their own agents or collectors. High dimensionality OpenTelemetry uses dimensional metrics, so you can filter and facet on more aspects of the data, such as AWS regions, Kubernetes clusters, or service versions. Dimensional metrics also lead to less time between occurrence and reporting. Efficiency OpenTelemetryâ€™s fire-and-forget trace-centric approach to instrumentation often has lower overhead than New Relic agents, especially for asynchronous workloads. It will also result in better handling of trace data for asynchronous requests. Should I use OpenTelemetry instrumentation or New Relic agents? As you consider OpenTelemetry, you may also be looking at New Relic APM agents that also capture telemetry data. As you'd expect, there is a lot of overlap between features available from OpenTelemetry agents and SDKs versus those available from New Relic APM agents. This is especially true if you're interested in distributed tracing telemetry data. The choice you make depends on what you need. We recommend that you explore both New Relic and OpenTelemetry instrumentation or discuss this with us in our CNCF Slack channel to decide what works best for you. OpenTelemetry: A work in progress OpenTelemetry is still an emerging standard, so your choices may be affected by what's available. You can check on the current state of the specification at the OpenTelemetry site. The current state of language-specific OpenTelemetry APIs and SDKs varies: some languages are still pre-alpha and may be missing instructions on how to instrument your service. Most languages have some implementation of traces that is sufficient to start exporting data to New Relic. Check out this table in GitHub that provides an overview of the state of OpenTelemetry specification compliance for each language. For languages that New Relic does not currently provide an agent or SDK, OpenTelemetry may offer you a good alternative. Also, in cases where you want explicit control over sampling of your telemetry data, OpenTelemetry provides a lot of flexibility. As OpenTelemetry matures, New Relic will continue to support new OpenTelemetry data models and to provide a curated UI experience for our customers. New Relic's APM agents In general, New Relic's APM agents will collect more telemetry data for your services, and they offer a wide range of configuration options and an extensive set of auto-instrumentation capabilities. New Relic's APM agents offer detailed transaction trace visibility for individual services. They also offer predefined sampling to balance the performance impact of your instrumentation against the need to capture enough data to gain helpful insights. How OpenTelemetry works with New Relic New Relic supports the native OpenTelemetry Protocol (OTLP) for exporting telemetry data. This allows you to use the vendor neutral components developed by the OpenTelemetry community to export your data to New Relic. The following tables show the supported features for each telemetry signal. If you have questions about these or have an unsupported use case, please contact us in our CNCF Slack channel, and watch this page for future updates. Important New Relic's exporters for OpenTelemetry are now deprecated in favor of exporting data to New Relic using OTLP. Traces New Relic offers support for the OTLP ingest of trace signals. The maturity of the upstream specification is stable. OpenTelemetry traces and spans are compatible with New Relic traces and spans. OpenTelemetry spans optionally include attributes (name-value pairs) and resource attributes which map directly to dimensions that can be used to facet or filter span data at query time. OpenTelemetry span metadata (for example, name, kind, and trace_id) also map directly to dimensions on NewRelic spans. At this time, New Relic does not support span links or array attributes. For details, see the Traces section of our best practices guide. Feature Supported Span events âœ… Span linking âŒ Array of primitives (homogeneous) âŒ Metrics New Relic offers support for the OTLP ingest of metric signals. Note that the maturity of the upstream specification is experimental. We intend to follow potentially breaking upstream changes. Here are the OpenTelemetry data types we support and their associated mappings. For details, see the Metrics section of our best practices guide. Metric Type Supported Delta sums âœ… Cumulative sums âœ… Gauges âœ… Delta histograms âœ… Summary âœ… Cumulative histograms âŒ Exemplars âŒ Array of primitives (homogeneous) âŒ Logs New Relic offers support for the OTLP ingest of log signals. Note that the maturity of the upstream specification is experimental. We intend to follow potentially breaking upstream changes. OpenTelemetry logs are compatible with New Relic logs. OpenTelemetry logs optionally include attributes (name-value pairs) and resource attributes which map directly to dimensions that can be used to facet or filter log data at query time. OpenTelemetry log metadata (for example, name, severity_text, and trace_id) also map directly to dimensions on New Relic logs. NewRelic currently supports all OpenTelemetry log message types except for arrays. For more details, see the Logs section of our best practices guide. Feature Supported Description LogRecord body âœ… Supported types: string, boolean, int, double, bytes LogRecord attributes âœ… Supported types: string, boolean, int, double, bytes LogRecord fields âœ… Examples: name, severity_text, trace_id Array messages âŒ Array attributes âŒ Next steps Follow the OpenTelemetry quick start to help you get started. You'll also want to review the best practices guide for getting the most out of the data you export to New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 287.20203,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>OpenTelemetry</em> with New Relic",
        "sections": "Introduction to <em>OpenTelemetry</em> with New Relic",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": " Description LogRecord body âœ… Supported types: string, boolean, int, double, bytes LogRecord attributes âœ… Supported types: string, boolean, int, double, bytes LogRecord fields âœ… Examples: name, severity_text, trace_id Array messages âŒ Array attributes âŒ Next steps Follow the <em>OpenTelemetry</em> quick <em>start</em> to help you <em>get</em> <em>started</em>. You&#x27;ll also want to review the best practices guide for getting the most out of the data you export to New Relic."
      },
      "id": "6174afe1e7b9d2748213b3a6"
    },
    {
      "sections": [
        "Introduction to New Relic integrations",
        "Choose what's right for you",
        "Create your own solutions"
      ],
      "title": "Introduction to New Relic integrations",
      "type": "docs",
      "tags": [
        "Instrument everything",
        "Get started"
      ],
      "external_id": "9a44613b8a5ec0a9c9570b22c7d2f3ea726f2671",
      "image": "",
      "url": "https://docs.newrelic.com/docs/using-new-relic/welcome-new-relic/get-started/introduction-new-relic-integrations/",
      "published_at": "2021-10-24T11:54:18Z",
      "updated_at": "2021-10-24T00:59:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We provide hundreds of solutions to get your data into New Relic so you can analyze the data in one place. They give you a steady flow of useful data to fix problems quickly, maintain complex systems, improve your code, and accelerate your digital transformation. You can bring in data from hundreds of applications, frameworks, services, operating systems, and other technologies. Our integrations gather the data, and the agents send it to New Relic. The solution you need may require you to install both an integration and an agent. In some cases, you can just install our agents that contain integrations, such as our APM agents. Whatever data you need to bring in, chances are that we have options for your environment. If you prefer to make your own solutions, we also offer tools to get you started. Choose what's right for you We offer a wide range of solutions so you can easily collect data across your environment. You may only need one of our solutions to get the data you need, or you can choose a variety of options to capture a broader range of data types. Go to New Relic Integrations to find solutions that fit your environment. Here is a sample of what youâ€™ll find there: Application performance monitoring (APM): C, Go, Java, Node, .NET, PHP, Python, and Ruby Mobile apps: Android and iOS Browser monitoring: Google Chrome, Mozilla Firefox, Microsoft Internet Explorer, and Apple Safari Host monitoring: Linux and Microsoft Windows Cloud platform monitoring: Amazon Web Services (AWS), Microsoft Azure, and Google Cloud Platform (GCP) Core infrastructure services: Kubernetes, NGINX, MySQL, and more Open source telemetry integrations: Prometheus, Micrometer, OpenTelemetry, and more Create your own solutions If you are looking for custom options, we have tools to help you create your own: Use New Relic Flex to create lightweight monitoring solutions using infrastructure monitoring. Use New Relic Telemetry SDKs to build custom solutions for sending metrics, traces, and more. Build your own New Relic One applications that you can share with your colleagues, or edit open source applications in our catalog.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 177.25757,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic <em>integrations</em>",
        "sections": "Introduction to New Relic <em>integrations</em>",
        "tags": "<em>Get</em> <em>started</em>",
        "body": " (AWS), Microsoft Azure, and Google Cloud Platform (GCP) Core infrastructure services: Kubernetes, NGINX, MySQL, and more <em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>: Prometheus, Micrometer, <em>OpenTelemetry</em>, and more Create your own solutions If you are looking for custom options, we have tools to help you"
      },
      "id": "603e817f28ccbc4857eba798"
    },
    {
      "sections": [
        "Introduction to OpenTelemetry with New Relic",
        "Benefits of OpenTelemetry",
        "Should I use OpenTelemetry instrumentation or New Relic agents?",
        "OpenTelemetry: A work in progress",
        "New Relic's APM agents",
        "How OpenTelemetry works with New Relic",
        "Important",
        "Traces",
        "Metrics",
        "Logs",
        "Next steps"
      ],
      "title": "Introduction to OpenTelemetry with New Relic",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "c87898d2d5835c00930c173eabd1bf93040badea",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/open-source-telemetry-integrations/opentelemetry/introduction-opentelemetry-new-relic/",
      "published_at": "2021-10-18T15:22:31Z",
      "updated_at": "2021-09-27T15:16:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Are you already familiar with OpenTelemetry and want to begin the setup? Check out our quick start: Quick start If you don't have one already, create a New Relic account. It's free, forever. If you're just getting acquainted with OpenTelemetry, this is what we'll explore here: Benefits of OpenTelemetry Should I use OpenTelemetry or New Relic agents? How OpenTelemetry works with New Relic Benefits of OpenTelemetry OpenTelemetry provides a secure, vendor-neutral specification for service instrumentation so that you can export data to distinct backends of your choice, such as New Relic. OpenTelemetry offers a single set of APIs and libraries that standardize how you collect and transfer telemetry data for your services. The following components make up the OpenTelemetry project: Specifications for the core pillars of observability to drive consistency across all projects. New Relic supports all of these signals: traces, metrics, and logs (see details below) APIs that contain interfaces and implementations based on the specifications SDKs (reference implementations of the APIs) created specifically for languages like Java, Python, Go, Erlang, and more Collectors that offer a vendor-agnostic implementation for processing and exporting Exporters that enable you to send data to a backend of your choice The components of OpenTelemetry work together to create some distinct advantages for capturing telemetry data: Feature Description Ubiquitous instrumentation A single, open standard of instrumentation provides better coverage and flexibility as engineers from all over the world contribute to the instrumentation. Future proof As the instrumentation gets built into libraries and frameworks, and as more vendors move to support this open standard, you can be confident that you wonâ€™t need to change your instrumentation. Support for newer technologies When new technologies emerge, contributors can build integrations into OpenTelemetry or add instrumentation directly to source code, ensuring end users can easily monitor these new technologies. Simplified choice You donâ€™t need to decide which instrumentation option to use (a proprietary option or one of the other open standards). Cross-platform compatibility OpenTelemetry supports a variety of languages and backends. It represents a vendor-neutral path for capturing and transmitting telemetry to backends without altering existing instrumentation. Streamlined observability It is easier for vendors to support and test against a single standard as they donâ€™t need to develop their own agents or collectors. High dimensionality OpenTelemetry uses dimensional metrics, so you can filter and facet on more aspects of the data, such as AWS regions, Kubernetes clusters, or service versions. Dimensional metrics also lead to less time between occurrence and reporting. Efficiency OpenTelemetryâ€™s fire-and-forget trace-centric approach to instrumentation often has lower overhead than New Relic agents, especially for asynchronous workloads. It will also result in better handling of trace data for asynchronous requests. Should I use OpenTelemetry instrumentation or New Relic agents? As you consider OpenTelemetry, you may also be looking at New Relic APM agents that also capture telemetry data. As you'd expect, there is a lot of overlap between features available from OpenTelemetry agents and SDKs versus those available from New Relic APM agents. This is especially true if you're interested in distributed tracing telemetry data. The choice you make depends on what you need. We recommend that you explore both New Relic and OpenTelemetry instrumentation or discuss this with us in our CNCF Slack channel to decide what works best for you. OpenTelemetry: A work in progress OpenTelemetry is still an emerging standard, so your choices may be affected by what's available. You can check on the current state of the specification at the OpenTelemetry site. The current state of language-specific OpenTelemetry APIs and SDKs varies: some languages are still pre-alpha and may be missing instructions on how to instrument your service. Most languages have some implementation of traces that is sufficient to start exporting data to New Relic. Check out this table in GitHub that provides an overview of the state of OpenTelemetry specification compliance for each language. For languages that New Relic does not currently provide an agent or SDK, OpenTelemetry may offer you a good alternative. Also, in cases where you want explicit control over sampling of your telemetry data, OpenTelemetry provides a lot of flexibility. As OpenTelemetry matures, New Relic will continue to support new OpenTelemetry data models and to provide a curated UI experience for our Full Stack Observability customers. New Relic's APM agents In general, New Relic's APM agents will collect more telemetry data for your services, and they offer a wide range of configuration options and an extensive set of auto-instrumentation capabilities. New Relic's APM agents offer detailed transaction trace visibility for individual services. They also offer predefined sampling to balance the performance impact of your instrumentation against the need to capture enough data to gain helpful insights. How OpenTelemetry works with New Relic New Relic supports the native OpenTelemetry Protocol (OTLP) for exporting telemetry data. This allows you to use the vendor neutral components developed by the OpenTelemetry community to export your data to New Relic. The following tables show the supported features for each telemetry signal. If you have questions about these or have an unsupported use case, please contact us in our CNCF Slack channel, and watch this page for future updates. Important New Relic's exporters for OpenTelemetry are now deprecated in favor of exporting data to New Relic using OTLP. Traces New Relic offers support for the OTLP ingest of trace signals. The maturity of the upstream specification is stable. OpenTelemetry traces and spans are compatible with New Relic traces and spans. OpenTelemetry spans optionally include attributes (name-value pairs) and resource attributes which map directly to dimensions that can be used to facet or filter span data at query time. OpenTelemetry span metadata (for example, name, kind, and trace_id) also map directly to dimensions on NewRelic spans. At this time, New Relic does not support span links or array attributes. For details, see the Traces section of our best practices guide. Feature Supported Span events âœ… Span linking âŒ Array of primitives (homogeneous) âŒ Metrics New Relic offers support for the OTLP ingest of metric signals. Note that the maturity of the upstream specification is experimental. We intend to follow potentially breaking upstream changes. Here are the OpenTelemetry data types we support and their associated mappings. For details, see the Metrics section of our best practices guide. Metric Type Supported Delta sums âœ… Cumulative sums âœ… Gauges âœ… Delta histograms âœ… Summary âœ… Cumulative histograms âŒ Exemplars âŒ Array of primitives (homogeneous) âŒ Logs New Relic offers support for the OTLP ingest of log signals. Note that the maturity of the upstream specification is experimental. We intend to follow potentially breaking upstream changes. OpenTelemetry logs are compatible with New Relic logs. OpenTelemetry logs optionally include attributes (name-value pairs) and resource attributes which map directly to dimensions that can be used to facet or filter log data at query time. OpenTelemetry log metadata (for example, name, severity_text, and trace_id) also map directly to dimensions on New Relic logs. NewRelic currently supports all OpenTelemetry log message types except for arrays. For more details, see the Logs section of our best practices guide. Feature Supported Description LogRecord body âœ… Supported types: string, boolean, int, double, bytes LogRecord attributes âœ… Supported types: string, boolean, int, double, bytes LogRecord fields âœ… Examples: name, severity_text, trace_id Array messages âŒ Array attributes âŒ Next steps Follow the OpenTelemetry quick start to help you get started. You'll also want to review the best practices guide for getting the most out of the data you export to New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 162.65317,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>OpenTelemetry</em> with New Relic",
        "sections": "Introduction to <em>OpenTelemetry</em> with New Relic",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": " the <em>OpenTelemetry</em> quick <em>start</em> to help you <em>get</em> <em>started</em>. You&#x27;ll also want to review the best practices guide for getting the most out of the data you export to New Relic."
      },
      "id": "603e81ba196a67304da83dab"
    }
  ],
  "/docs/more-integrations/open-source-telemetry-integrations/istio/istio-adapter": [
    {
      "sections": [
        "Introduction to OpenTelemetry with New Relic",
        "Benefits of OpenTelemetry",
        "Should I use OpenTelemetry instrumentation or New Relic agents?",
        "OpenTelemetry: A work in progress",
        "New Relic's APM agents",
        "How OpenTelemetry works with New Relic",
        "Important",
        "Traces",
        "Metrics",
        "Logs",
        "Next steps"
      ],
      "title": "Introduction to OpenTelemetry with New Relic",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "67818451ffb7594e3c27526f4082bd1bc007bc51",
      "image": "",
      "url": "https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/introduction-opentelemetry-new-relic/",
      "published_at": "2021-10-24T16:37:27Z",
      "updated_at": "2021-10-24T00:59:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Are you already familiar with OpenTelemetry and want to begin the setup? Check out our quick start: Quick start If you don't have one already, create a New Relic account. It's free, forever. If you're just getting acquainted with OpenTelemetry, this is what we'll explore here: Benefits of OpenTelemetry Should I use OpenTelemetry or New Relic agents? How OpenTelemetry works with New Relic Benefits of OpenTelemetry OpenTelemetry provides a secure, vendor-neutral specification for service instrumentation so that you can export data to distinct backends of your choice, such as New Relic. OpenTelemetry offers a single set of APIs and libraries that standardize how you collect and transfer telemetry data for your services. The following components make up the OpenTelemetry project: Specifications for the core pillars of observability to drive consistency across all projects. New Relic supports all of these signals: traces, metrics, and logs (see details below) APIs that contain interfaces and implementations based on the specifications SDKs (reference implementations of the APIs) created specifically for languages like Java, Python, Go, Erlang, and more Collectors that offer a vendor-agnostic implementation for processing and exporting Exporters that enable you to send data to a backend of your choice The components of OpenTelemetry work together to create some distinct advantages for capturing telemetry data: Feature Description Ubiquitous instrumentation A single, open standard of instrumentation provides better coverage and flexibility as engineers from all over the world contribute to the instrumentation. Future proof As the instrumentation gets built into libraries and frameworks, and as more vendors move to support this open standard, you can be confident that you wonâ€™t need to change your instrumentation. Support for newer technologies When new technologies emerge, contributors can build integrations into OpenTelemetry or add instrumentation directly to source code, ensuring end users can easily monitor these new technologies. Simplified choice You donâ€™t need to decide which instrumentation option to use (a proprietary option or one of the other open standards). Cross-platform compatibility OpenTelemetry supports a variety of languages and backends. It represents a vendor-neutral path for capturing and transmitting telemetry to backends without altering existing instrumentation. Streamlined observability It is easier for vendors to support and test against a single standard as they donâ€™t need to develop their own agents or collectors. High dimensionality OpenTelemetry uses dimensional metrics, so you can filter and facet on more aspects of the data, such as AWS regions, Kubernetes clusters, or service versions. Dimensional metrics also lead to less time between occurrence and reporting. Efficiency OpenTelemetryâ€™s fire-and-forget trace-centric approach to instrumentation often has lower overhead than New Relic agents, especially for asynchronous workloads. It will also result in better handling of trace data for asynchronous requests. Should I use OpenTelemetry instrumentation or New Relic agents? As you consider OpenTelemetry, you may also be looking at New Relic APM agents that also capture telemetry data. As you'd expect, there is a lot of overlap between features available from OpenTelemetry agents and SDKs versus those available from New Relic APM agents. This is especially true if you're interested in distributed tracing telemetry data. The choice you make depends on what you need. We recommend that you explore both New Relic and OpenTelemetry instrumentation or discuss this with us in our CNCF Slack channel to decide what works best for you. OpenTelemetry: A work in progress OpenTelemetry is still an emerging standard, so your choices may be affected by what's available. You can check on the current state of the specification at the OpenTelemetry site. The current state of language-specific OpenTelemetry APIs and SDKs varies: some languages are still pre-alpha and may be missing instructions on how to instrument your service. Most languages have some implementation of traces that is sufficient to start exporting data to New Relic. Check out this table in GitHub that provides an overview of the state of OpenTelemetry specification compliance for each language. For languages that New Relic does not currently provide an agent or SDK, OpenTelemetry may offer you a good alternative. Also, in cases where you want explicit control over sampling of your telemetry data, OpenTelemetry provides a lot of flexibility. As OpenTelemetry matures, New Relic will continue to support new OpenTelemetry data models and to provide a curated UI experience for our customers. New Relic's APM agents In general, New Relic's APM agents will collect more telemetry data for your services, and they offer a wide range of configuration options and an extensive set of auto-instrumentation capabilities. New Relic's APM agents offer detailed transaction trace visibility for individual services. They also offer predefined sampling to balance the performance impact of your instrumentation against the need to capture enough data to gain helpful insights. How OpenTelemetry works with New Relic New Relic supports the native OpenTelemetry Protocol (OTLP) for exporting telemetry data. This allows you to use the vendor neutral components developed by the OpenTelemetry community to export your data to New Relic. The following tables show the supported features for each telemetry signal. If you have questions about these or have an unsupported use case, please contact us in our CNCF Slack channel, and watch this page for future updates. Important New Relic's exporters for OpenTelemetry are now deprecated in favor of exporting data to New Relic using OTLP. Traces New Relic offers support for the OTLP ingest of trace signals. The maturity of the upstream specification is stable. OpenTelemetry traces and spans are compatible with New Relic traces and spans. OpenTelemetry spans optionally include attributes (name-value pairs) and resource attributes which map directly to dimensions that can be used to facet or filter span data at query time. OpenTelemetry span metadata (for example, name, kind, and trace_id) also map directly to dimensions on NewRelic spans. At this time, New Relic does not support span links or array attributes. For details, see the Traces section of our best practices guide. Feature Supported Span events âœ… Span linking âŒ Array of primitives (homogeneous) âŒ Metrics New Relic offers support for the OTLP ingest of metric signals. Note that the maturity of the upstream specification is experimental. We intend to follow potentially breaking upstream changes. Here are the OpenTelemetry data types we support and their associated mappings. For details, see the Metrics section of our best practices guide. Metric Type Supported Delta sums âœ… Cumulative sums âœ… Gauges âœ… Delta histograms âœ… Summary âœ… Cumulative histograms âŒ Exemplars âŒ Array of primitives (homogeneous) âŒ Logs New Relic offers support for the OTLP ingest of log signals. Note that the maturity of the upstream specification is experimental. We intend to follow potentially breaking upstream changes. OpenTelemetry logs are compatible with New Relic logs. OpenTelemetry logs optionally include attributes (name-value pairs) and resource attributes which map directly to dimensions that can be used to facet or filter log data at query time. OpenTelemetry log metadata (for example, name, severity_text, and trace_id) also map directly to dimensions on New Relic logs. NewRelic currently supports all OpenTelemetry log message types except for arrays. For more details, see the Logs section of our best practices guide. Feature Supported Description LogRecord body âœ… Supported types: string, boolean, int, double, bytes LogRecord attributes âœ… Supported types: string, boolean, int, double, bytes LogRecord fields âœ… Examples: name, severity_text, trace_id Array messages âŒ Array attributes âŒ Next steps Follow the OpenTelemetry quick start to help you get started. You'll also want to review the best practices guide for getting the most out of the data you export to New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 268.8386,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>OpenTelemetry</em> with New Relic",
        "sections": "Introduction to <em>OpenTelemetry</em> with New Relic",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": " wonâ€™t need to change your instrumentation. Support for newer technologies When new technologies emerge, contributors can build <em>integrations</em> into <em>OpenTelemetry</em> or add instrumentation directly to <em>source</em> code, ensuring end users can easily monitor these new technologies. Simplified choice You donâ€™t need"
      },
      "id": "6174afe1e7b9d2748213b3a6"
    },
    {
      "sections": [
        "Telemetry SDKs: Report custom telemetry data",
        "Requirements and compatibility",
        "Tip",
        "Available libraries",
        "Write your own Telemetry SDK or contribute to an existing one",
        "Integrations built with the Telemetry SDKs"
      ],
      "title": "Telemetry SDKs: Report custom telemetry data",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "d883a07b7ede4c3beaba4077c507b95f9a228435",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/ingest-apis/telemetry-sdks-report-custom-telemetry-data/",
      "published_at": "2021-10-24T19:37:31Z",
      "updated_at": "2021-10-23T17:26:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Telemetry SDKs are an open source set of API client libraries that send data to the New Relic platform. Under the hood, these SDKs rely on our core data ingest APIs: the Metric API, Trace API, Log API, and Event API. We offer open-source integrations for telemetry tools like Prometheus, Istio, and OpenCensus that were created using our Telemetry SDKs. If those solutions (or our other integrations) don't meet your needs, you can use the Telemetry SDKs to create your own telemetry data solutions. Requirements and compatibility The Telemetry SDKs use our Metric API, Event API, Log API, and Trace API, which all require a license key, so you'll need a license key for the account you wish to send data to. Tip New Relic has contributed the Telemetry SDK to the open source community under an Apache 2.0 license. Available libraries The Telemetry SDKs are open source software on GitHub. Use the language-specific GitHub links below to get library details, coding examples, and procedures for how to use the SDKs. We currently support the following libraries, with more to be created in the future: Language Library Supported New Relic data types Java Java library on GitHub Metrics Events Logs Traces Node/TypeScript NodeJS library on GitHub Metrics Traces Python Python library on GitHub Metrics Events Logs Traces Go Go library on Github Metrics Traces .NET .NET library on GitHub .NET package in NuGet Metrics Traces C C library on Github Traces Rust Rust library on Github Traces Ruby Ruby library on Github Gem on Rubygems Traces For more on the supported data types, see: An overview of New Relic data types Metrics: see the Metric API Logs: see the Log API Traces: see the Trace API Events: see the Event API Write your own Telemetry SDK or contribute to an existing one If you need a Telemetry SDK in a language that does not currently exist or want to contribute to an existing library, please see the Telemetry SDK specifications. Integrations built with the Telemetry SDKs To see the integrations built using our Telemetry SDKs, see Open source telemetry integrations. For all monitoring solutions, see our integrations page.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 164.8476,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Telemetry</em> SDKs: Report custom <em>telemetry</em> data",
        "sections": "<em>Integrations</em> built with the <em>Telemetry</em> SDKs",
        "body": "Our <em>Telemetry</em> SDKs are an <em>open</em> <em>source</em> set of API client libraries that send data to the New Relic platform. Under the hood, these SDKs rely on our core data ingest APIs: the Metric API, Trace API, Log API, and Event API. We offer <em>open</em>-<em>source</em> <em>integrations</em> for <em>telemetry</em> tools like Prometheus, <em>Istio</em>"
      },
      "id": "603ea196196a670192a83d83"
    },
    {
      "sections": [
        "View your OpenTelemetry data in New Relic",
        "Explorer: Get the big picture along with the details",
        "Find your service (entity)",
        "Narrow down your data with filters",
        "Summary page",
        "Distributed tracing",
        "Find traces and their associated spans",
        "Tip",
        "View spans with errors",
        "View span events",
        "Databases",
        "Errors",
        "Externals",
        "JVMs",
        "Logs",
        "Metrics explorer",
        "Transactions",
        "Data explorer and query builder"
      ],
      "title": "View your OpenTelemetry data in New Relic",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "a5213cb2206f4c161dd97c015a7c6679b08e867b",
      "image": "https://docs.newrelic.com/static/490779aac8c10802682d86f0b785b6a2/a4078/explorer_otel_services.png",
      "url": "https://docs.newrelic.com/docs/integrations/open-source-telemetry-integrations/opentelemetry/view-your-opentelemetry-data-new-relic/",
      "published_at": "2021-10-24T16:39:15Z",
      "updated_at": "2021-09-27T15:53:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you import OpenTelemetry data into New Relic, you can use a variety of tools to analyze it. Take a look at these UI options: Explorer Data explorer and query builder Explorer: Get the big picture along with the details The New Relic Explorer tab is a good place to start gathering information about your services. It offers you a way to filter services and then filter the data to show a variety of views into your data. Find your service (entity) To get started in Explorer, you need to find your service: Go to one.newrelic.com. In the left sidebar, click Services - OpenTelemetry: In the center pane, click the service you want to know more about, or find your service by entering the name in the top filter bar. Narrow down your data with filters Once you have your entity, you can then filter for data from your service. With the filter bar Narrow data to..., you can highlight a specific facet of the telemetry recorded for your service. For example, you may want to see the error rate for a particular version of the service that you've deployed in a canary instance, so you add a filter for service.version='1.2.3'. Filters are preserved when navigating between different views of your data for a service. For example, the filter for service.version='1.2.3' carries over to the Transactions view, so that you would see telemetry on requests to the endpoints (transactions) that are running version 1.2.3 of your service, and not any other versions. Filters are preserved when navigating between the Summary, Transactions, Databases, Externals, Errors, and JVMs views. Filters are also preserved when navigating to the Distributed tracing view, but with limitations. Only filter conditions that use the equals operator (\"=\") are currently supported when navigating to Distributed tracing. If you navigate back from the Distributed tracing page, the filters you selected on the previous view will come back. Once you filter your data, the UI has various views in the left-navigation pane. See our descriptions below for view details. Summary page After you click on a service in the Explorer tab, you see the Summary page listing various golden signals about your entity. Golden signals are key monitoring details such as response time, throughput, and error rate. By using this information, you can quickly decide if you need to dig deeper. For your data to appear in this section, make sure it has the following: UI area Attribute Response time span.kind = server or consumer Throughput span.kind = server or consumer Error rate span.kind = server or consumer otel.status_code = ERROR Service instances pane service.instance.id (usually set via the OTel resource API) Distributed tracing In Distributed tracing, you can locate traces and examine span details. For your trace data to appear in the New Relic UI, it needs to conform to the OpenTelemetry trace semantic conventions. Also, in the Traces section of our best practices guide, you can find some tips about making sure your traces and spans appear in New Relic. The following attributes are typically not added explicitly to spans. Rather, they are usually set when creating a span or performing operations (for example, recording an error) on a span using the OpenTelemetry SDK. Attribute Description name A spanâ€™s name is generally set when starting a span. The name can generally be anything, but the OpenTelemetry specification provides guidance for certain types of spans like Database spans or HTTP spans. span.kind A spanâ€™s kind is generally set when starting a span. New Relic uses span.kind to infer that a span is an entry point to a given service. When span.kind = server or consumer it is considered an entry point. When span.kind = client or producer, it is considered a call to an external service or database system. otel.status_code A spanâ€™s status is set using the span API. The otel.status_code attribute is how it is manifested by New Relic. The UI primarily uses otel.status_code for the purpose of identifying errors. Find traces and their associated spans Here are some ways to target your searches: To find the traces you want, you can run queries like these in the filter bar: service.name = YOUR_SERVICE_NAME trace.id = YOUR_TRACE_ID When you find an interesting trace, click on it to display a waterfall diagram showing the spans of the trace. Click on specific spans within the trace to display span details in the right panel. Tip For more ways to filter traces, see our distributed tracing UI page. View spans with errors After you click on a span in the trace waterfall view, you can see span errors in the right panel under Error details. The error details are populated by spans containing otel.status_code = ERROR and display the content of otel.status_description. To narrow your search for spans with errors, you can enter otel.status_code = ERROR directly in the distributed tracing filter bar. View span events If you send span events as described by the OpenTelemetry specification, you can view them in the New Relic UI. Span events have two general types: Exceptions Non-exceptions (for example, logs) If you have span events, links for these appear in the right pane: Click on a span in the waterfall view. In the right pane, click View span events, or you can expand Error details and click the link at the bottom of the errors. When you're in span events and only want to view exceptions, slide the toggle Only show exceptions. Tip OpenTelemetry exceptions handled by the app/service are displayed independently of span error status and are not necessarily associated with a span error status. Databases The Databases page shows an application's database and cache data. The page shows individual database transactions as a sortable table, and shows operations, throughput, and response time as charts. For your data to appear in this section, make sure it has the following: UI area Attribute Top database calls span.kind = client or producer db.system Facets by span name Top databases (by query time) span.kind = client or producer db.system Facets by db.system Top databases (by throughput) span.kind = client or producer db.system Facets by db.system Errors On the Errors page, you can see total errors as well as charts showing error count and error rate. For your data to appear in this section, make sure it has the following: span.kind = server or consumer otel.status_code = ERROR Facets by span name Externals Externals capture calls to out-of-process services such as web services, resources in the cloud, and other network entities. For your data to appear in this section, make sure it has the following: span.kind = client or producer db.system is not present JVMs When you drill into a specific JVM, the UI display charts driven by JVM metric data: JVM metrics follow the general semantic conventions for runtime environment metrics. The Java specific runtime metrics are not well documented. The implementation is effectively the documentation and may be subject to change. For your data to appear in this section, make sure it has the following: Requires a unique service.instance.id attribute for rendering the list of JVMs Service.instance.id is an OpenTelemetry resource attribute Logs The Logs page displays logs from your application. For more information about how to associate log data to your application in New Relic, see our OpenTelemetry and logging documentation. For your data to appear in this section, make sure it has the following: service.name To correlate with trace data, the logs should contain the trace.id and span.id attributes. Metrics explorer For selected OpenTelemetry languages, you can see information about your metrics in this section. Also, if you are using the Prometheus exporter with OpenTelemetry, you can view your metric data here. Transactions Use Transactions to identify slow or error transactions that might be causing a spike in your application's response time. To get a list of transactions: From the Transaction Summary page, select the transactions table. For your data to appear in this section, make sure it has the following: UI area Description Top Transactions span.kind = server or consumer Facets by span name Throughput span.kind = server or consumer Facets by span name Data explorer and query builder Explore your metrics and traces using the data explorer, or write your own queries in query builder using NRQL. For more on how to query your data once it's in New Relic, see Query your data and Introduction to NRQL.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 152.28038,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "View your <em>OpenTelemetry</em> data in New Relic",
        "sections": "View your <em>OpenTelemetry</em> data in New Relic",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": "After you import <em>OpenTelemetry</em> data into New Relic, you can use a variety of tools to analyze it. Take a look at these UI options: Explorer Data explorer and query builder Explorer: Get the big picture along with the details The New Relic Explorer tab is a good place to start gathering information"
      },
      "id": "6044e5dfe7b9d283d3579a04"
    }
  ],
  "/docs/more-integrations/open-source-telemetry-integrations/kamon/kamon-reporter": [
    {
      "sections": [
        "Introduction to OpenTelemetry with New Relic",
        "Benefits of OpenTelemetry",
        "Should I use OpenTelemetry instrumentation or New Relic agents?",
        "OpenTelemetry: A work in progress",
        "New Relic's APM agents",
        "How OpenTelemetry works with New Relic",
        "Important",
        "Traces",
        "Metrics",
        "Logs",
        "Next steps"
      ],
      "title": "Introduction to OpenTelemetry with New Relic",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "67818451ffb7594e3c27526f4082bd1bc007bc51",
      "image": "",
      "url": "https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/introduction-opentelemetry-new-relic/",
      "published_at": "2021-10-24T16:37:27Z",
      "updated_at": "2021-10-24T00:59:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Are you already familiar with OpenTelemetry and want to begin the setup? Check out our quick start: Quick start If you don't have one already, create a New Relic account. It's free, forever. If you're just getting acquainted with OpenTelemetry, this is what we'll explore here: Benefits of OpenTelemetry Should I use OpenTelemetry or New Relic agents? How OpenTelemetry works with New Relic Benefits of OpenTelemetry OpenTelemetry provides a secure, vendor-neutral specification for service instrumentation so that you can export data to distinct backends of your choice, such as New Relic. OpenTelemetry offers a single set of APIs and libraries that standardize how you collect and transfer telemetry data for your services. The following components make up the OpenTelemetry project: Specifications for the core pillars of observability to drive consistency across all projects. New Relic supports all of these signals: traces, metrics, and logs (see details below) APIs that contain interfaces and implementations based on the specifications SDKs (reference implementations of the APIs) created specifically for languages like Java, Python, Go, Erlang, and more Collectors that offer a vendor-agnostic implementation for processing and exporting Exporters that enable you to send data to a backend of your choice The components of OpenTelemetry work together to create some distinct advantages for capturing telemetry data: Feature Description Ubiquitous instrumentation A single, open standard of instrumentation provides better coverage and flexibility as engineers from all over the world contribute to the instrumentation. Future proof As the instrumentation gets built into libraries and frameworks, and as more vendors move to support this open standard, you can be confident that you wonâ€™t need to change your instrumentation. Support for newer technologies When new technologies emerge, contributors can build integrations into OpenTelemetry or add instrumentation directly to source code, ensuring end users can easily monitor these new technologies. Simplified choice You donâ€™t need to decide which instrumentation option to use (a proprietary option or one of the other open standards). Cross-platform compatibility OpenTelemetry supports a variety of languages and backends. It represents a vendor-neutral path for capturing and transmitting telemetry to backends without altering existing instrumentation. Streamlined observability It is easier for vendors to support and test against a single standard as they donâ€™t need to develop their own agents or collectors. High dimensionality OpenTelemetry uses dimensional metrics, so you can filter and facet on more aspects of the data, such as AWS regions, Kubernetes clusters, or service versions. Dimensional metrics also lead to less time between occurrence and reporting. Efficiency OpenTelemetryâ€™s fire-and-forget trace-centric approach to instrumentation often has lower overhead than New Relic agents, especially for asynchronous workloads. It will also result in better handling of trace data for asynchronous requests. Should I use OpenTelemetry instrumentation or New Relic agents? As you consider OpenTelemetry, you may also be looking at New Relic APM agents that also capture telemetry data. As you'd expect, there is a lot of overlap between features available from OpenTelemetry agents and SDKs versus those available from New Relic APM agents. This is especially true if you're interested in distributed tracing telemetry data. The choice you make depends on what you need. We recommend that you explore both New Relic and OpenTelemetry instrumentation or discuss this with us in our CNCF Slack channel to decide what works best for you. OpenTelemetry: A work in progress OpenTelemetry is still an emerging standard, so your choices may be affected by what's available. You can check on the current state of the specification at the OpenTelemetry site. The current state of language-specific OpenTelemetry APIs and SDKs varies: some languages are still pre-alpha and may be missing instructions on how to instrument your service. Most languages have some implementation of traces that is sufficient to start exporting data to New Relic. Check out this table in GitHub that provides an overview of the state of OpenTelemetry specification compliance for each language. For languages that New Relic does not currently provide an agent or SDK, OpenTelemetry may offer you a good alternative. Also, in cases where you want explicit control over sampling of your telemetry data, OpenTelemetry provides a lot of flexibility. As OpenTelemetry matures, New Relic will continue to support new OpenTelemetry data models and to provide a curated UI experience for our customers. New Relic's APM agents In general, New Relic's APM agents will collect more telemetry data for your services, and they offer a wide range of configuration options and an extensive set of auto-instrumentation capabilities. New Relic's APM agents offer detailed transaction trace visibility for individual services. They also offer predefined sampling to balance the performance impact of your instrumentation against the need to capture enough data to gain helpful insights. How OpenTelemetry works with New Relic New Relic supports the native OpenTelemetry Protocol (OTLP) for exporting telemetry data. This allows you to use the vendor neutral components developed by the OpenTelemetry community to export your data to New Relic. The following tables show the supported features for each telemetry signal. If you have questions about these or have an unsupported use case, please contact us in our CNCF Slack channel, and watch this page for future updates. Important New Relic's exporters for OpenTelemetry are now deprecated in favor of exporting data to New Relic using OTLP. Traces New Relic offers support for the OTLP ingest of trace signals. The maturity of the upstream specification is stable. OpenTelemetry traces and spans are compatible with New Relic traces and spans. OpenTelemetry spans optionally include attributes (name-value pairs) and resource attributes which map directly to dimensions that can be used to facet or filter span data at query time. OpenTelemetry span metadata (for example, name, kind, and trace_id) also map directly to dimensions on NewRelic spans. At this time, New Relic does not support span links or array attributes. For details, see the Traces section of our best practices guide. Feature Supported Span events âœ… Span linking âŒ Array of primitives (homogeneous) âŒ Metrics New Relic offers support for the OTLP ingest of metric signals. Note that the maturity of the upstream specification is experimental. We intend to follow potentially breaking upstream changes. Here are the OpenTelemetry data types we support and their associated mappings. For details, see the Metrics section of our best practices guide. Metric Type Supported Delta sums âœ… Cumulative sums âœ… Gauges âœ… Delta histograms âœ… Summary âœ… Cumulative histograms âŒ Exemplars âŒ Array of primitives (homogeneous) âŒ Logs New Relic offers support for the OTLP ingest of log signals. Note that the maturity of the upstream specification is experimental. We intend to follow potentially breaking upstream changes. OpenTelemetry logs are compatible with New Relic logs. OpenTelemetry logs optionally include attributes (name-value pairs) and resource attributes which map directly to dimensions that can be used to facet or filter log data at query time. OpenTelemetry log metadata (for example, name, severity_text, and trace_id) also map directly to dimensions on New Relic logs. NewRelic currently supports all OpenTelemetry log message types except for arrays. For more details, see the Logs section of our best practices guide. Feature Supported Description LogRecord body âœ… Supported types: string, boolean, int, double, bytes LogRecord attributes âœ… Supported types: string, boolean, int, double, bytes LogRecord fields âœ… Examples: name, severity_text, trace_id Array messages âŒ Array attributes âŒ Next steps Follow the OpenTelemetry quick start to help you get started. You'll also want to review the best practices guide for getting the most out of the data you export to New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 270.28094,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>OpenTelemetry</em> with New Relic",
        "sections": "Introduction to <em>OpenTelemetry</em> with New Relic",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": " wonâ€™t need to change your instrumentation. Support for newer technologies When new technologies emerge, contributors can build <em>integrations</em> into <em>OpenTelemetry</em> or add instrumentation directly to <em>source</em> code, ensuring end users can easily monitor these new technologies. Simplified choice You donâ€™t need"
      },
      "id": "6174afe1e7b9d2748213b3a6"
    },
    {
      "sections": [
        "View your OpenTelemetry data in New Relic",
        "Explorer: Get the big picture along with the details",
        "Find your service (entity)",
        "Narrow down your data with filters",
        "Summary page",
        "Distributed tracing",
        "Find traces and their associated spans",
        "Tip",
        "View spans with errors",
        "View span events",
        "Databases",
        "Errors",
        "Externals",
        "JVMs",
        "Logs",
        "Metrics explorer",
        "Transactions",
        "Data explorer and query builder"
      ],
      "title": "View your OpenTelemetry data in New Relic",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "a5213cb2206f4c161dd97c015a7c6679b08e867b",
      "image": "https://docs.newrelic.com/static/490779aac8c10802682d86f0b785b6a2/a4078/explorer_otel_services.png",
      "url": "https://docs.newrelic.com/docs/integrations/open-source-telemetry-integrations/opentelemetry/view-your-opentelemetry-data-new-relic/",
      "published_at": "2021-10-24T16:39:15Z",
      "updated_at": "2021-09-27T15:53:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you import OpenTelemetry data into New Relic, you can use a variety of tools to analyze it. Take a look at these UI options: Explorer Data explorer and query builder Explorer: Get the big picture along with the details The New Relic Explorer tab is a good place to start gathering information about your services. It offers you a way to filter services and then filter the data to show a variety of views into your data. Find your service (entity) To get started in Explorer, you need to find your service: Go to one.newrelic.com. In the left sidebar, click Services - OpenTelemetry: In the center pane, click the service you want to know more about, or find your service by entering the name in the top filter bar. Narrow down your data with filters Once you have your entity, you can then filter for data from your service. With the filter bar Narrow data to..., you can highlight a specific facet of the telemetry recorded for your service. For example, you may want to see the error rate for a particular version of the service that you've deployed in a canary instance, so you add a filter for service.version='1.2.3'. Filters are preserved when navigating between different views of your data for a service. For example, the filter for service.version='1.2.3' carries over to the Transactions view, so that you would see telemetry on requests to the endpoints (transactions) that are running version 1.2.3 of your service, and not any other versions. Filters are preserved when navigating between the Summary, Transactions, Databases, Externals, Errors, and JVMs views. Filters are also preserved when navigating to the Distributed tracing view, but with limitations. Only filter conditions that use the equals operator (\"=\") are currently supported when navigating to Distributed tracing. If you navigate back from the Distributed tracing page, the filters you selected on the previous view will come back. Once you filter your data, the UI has various views in the left-navigation pane. See our descriptions below for view details. Summary page After you click on a service in the Explorer tab, you see the Summary page listing various golden signals about your entity. Golden signals are key monitoring details such as response time, throughput, and error rate. By using this information, you can quickly decide if you need to dig deeper. For your data to appear in this section, make sure it has the following: UI area Attribute Response time span.kind = server or consumer Throughput span.kind = server or consumer Error rate span.kind = server or consumer otel.status_code = ERROR Service instances pane service.instance.id (usually set via the OTel resource API) Distributed tracing In Distributed tracing, you can locate traces and examine span details. For your trace data to appear in the New Relic UI, it needs to conform to the OpenTelemetry trace semantic conventions. Also, in the Traces section of our best practices guide, you can find some tips about making sure your traces and spans appear in New Relic. The following attributes are typically not added explicitly to spans. Rather, they are usually set when creating a span or performing operations (for example, recording an error) on a span using the OpenTelemetry SDK. Attribute Description name A spanâ€™s name is generally set when starting a span. The name can generally be anything, but the OpenTelemetry specification provides guidance for certain types of spans like Database spans or HTTP spans. span.kind A spanâ€™s kind is generally set when starting a span. New Relic uses span.kind to infer that a span is an entry point to a given service. When span.kind = server or consumer it is considered an entry point. When span.kind = client or producer, it is considered a call to an external service or database system. otel.status_code A spanâ€™s status is set using the span API. The otel.status_code attribute is how it is manifested by New Relic. The UI primarily uses otel.status_code for the purpose of identifying errors. Find traces and their associated spans Here are some ways to target your searches: To find the traces you want, you can run queries like these in the filter bar: service.name = YOUR_SERVICE_NAME trace.id = YOUR_TRACE_ID When you find an interesting trace, click on it to display a waterfall diagram showing the spans of the trace. Click on specific spans within the trace to display span details in the right panel. Tip For more ways to filter traces, see our distributed tracing UI page. View spans with errors After you click on a span in the trace waterfall view, you can see span errors in the right panel under Error details. The error details are populated by spans containing otel.status_code = ERROR and display the content of otel.status_description. To narrow your search for spans with errors, you can enter otel.status_code = ERROR directly in the distributed tracing filter bar. View span events If you send span events as described by the OpenTelemetry specification, you can view them in the New Relic UI. Span events have two general types: Exceptions Non-exceptions (for example, logs) If you have span events, links for these appear in the right pane: Click on a span in the waterfall view. In the right pane, click View span events, or you can expand Error details and click the link at the bottom of the errors. When you're in span events and only want to view exceptions, slide the toggle Only show exceptions. Tip OpenTelemetry exceptions handled by the app/service are displayed independently of span error status and are not necessarily associated with a span error status. Databases The Databases page shows an application's database and cache data. The page shows individual database transactions as a sortable table, and shows operations, throughput, and response time as charts. For your data to appear in this section, make sure it has the following: UI area Attribute Top database calls span.kind = client or producer db.system Facets by span name Top databases (by query time) span.kind = client or producer db.system Facets by db.system Top databases (by throughput) span.kind = client or producer db.system Facets by db.system Errors On the Errors page, you can see total errors as well as charts showing error count and error rate. For your data to appear in this section, make sure it has the following: span.kind = server or consumer otel.status_code = ERROR Facets by span name Externals Externals capture calls to out-of-process services such as web services, resources in the cloud, and other network entities. For your data to appear in this section, make sure it has the following: span.kind = client or producer db.system is not present JVMs When you drill into a specific JVM, the UI display charts driven by JVM metric data: JVM metrics follow the general semantic conventions for runtime environment metrics. The Java specific runtime metrics are not well documented. The implementation is effectively the documentation and may be subject to change. For your data to appear in this section, make sure it has the following: Requires a unique service.instance.id attribute for rendering the list of JVMs Service.instance.id is an OpenTelemetry resource attribute Logs The Logs page displays logs from your application. For more information about how to associate log data to your application in New Relic, see our OpenTelemetry and logging documentation. For your data to appear in this section, make sure it has the following: service.name To correlate with trace data, the logs should contain the trace.id and span.id attributes. Metrics explorer For selected OpenTelemetry languages, you can see information about your metrics in this section. Also, if you are using the Prometheus exporter with OpenTelemetry, you can view your metric data here. Transactions Use Transactions to identify slow or error transactions that might be causing a spike in your application's response time. To get a list of transactions: From the Transaction Summary page, select the transactions table. For your data to appear in this section, make sure it has the following: UI area Description Top Transactions span.kind = server or consumer Facets by span name Throughput span.kind = server or consumer Facets by span name Data explorer and query builder Explore your metrics and traces using the data explorer, or write your own queries in query builder using NRQL. For more on how to query your data once it's in New Relic, see Query your data and Introduction to NRQL.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 153.0975,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "View your <em>OpenTelemetry</em> data in New Relic",
        "sections": "View your <em>OpenTelemetry</em> data in New Relic",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": "After you import <em>OpenTelemetry</em> data into New Relic, you can use a variety of tools to analyze it. Take a look at these UI options: Explorer Data explorer and query builder Explorer: Get the big picture along with the details The New Relic Explorer tab is a good place to start gathering information"
      },
      "id": "6044e5dfe7b9d283d3579a04"
    },
    {
      "sections": [
        "Introduction to OpenTelemetry with New Relic",
        "Benefits of OpenTelemetry",
        "Should I use OpenTelemetry instrumentation or New Relic agents?",
        "OpenTelemetry: A work in progress",
        "New Relic's APM agents",
        "How OpenTelemetry works with New Relic",
        "Important",
        "Traces",
        "Metrics",
        "Logs",
        "Next steps"
      ],
      "title": "Introduction to OpenTelemetry with New Relic",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "c87898d2d5835c00930c173eabd1bf93040badea",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/open-source-telemetry-integrations/opentelemetry/introduction-opentelemetry-new-relic/",
      "published_at": "2021-10-18T15:22:31Z",
      "updated_at": "2021-09-27T15:16:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Are you already familiar with OpenTelemetry and want to begin the setup? Check out our quick start: Quick start If you don't have one already, create a New Relic account. It's free, forever. If you're just getting acquainted with OpenTelemetry, this is what we'll explore here: Benefits of OpenTelemetry Should I use OpenTelemetry or New Relic agents? How OpenTelemetry works with New Relic Benefits of OpenTelemetry OpenTelemetry provides a secure, vendor-neutral specification for service instrumentation so that you can export data to distinct backends of your choice, such as New Relic. OpenTelemetry offers a single set of APIs and libraries that standardize how you collect and transfer telemetry data for your services. The following components make up the OpenTelemetry project: Specifications for the core pillars of observability to drive consistency across all projects. New Relic supports all of these signals: traces, metrics, and logs (see details below) APIs that contain interfaces and implementations based on the specifications SDKs (reference implementations of the APIs) created specifically for languages like Java, Python, Go, Erlang, and more Collectors that offer a vendor-agnostic implementation for processing and exporting Exporters that enable you to send data to a backend of your choice The components of OpenTelemetry work together to create some distinct advantages for capturing telemetry data: Feature Description Ubiquitous instrumentation A single, open standard of instrumentation provides better coverage and flexibility as engineers from all over the world contribute to the instrumentation. Future proof As the instrumentation gets built into libraries and frameworks, and as more vendors move to support this open standard, you can be confident that you wonâ€™t need to change your instrumentation. Support for newer technologies When new technologies emerge, contributors can build integrations into OpenTelemetry or add instrumentation directly to source code, ensuring end users can easily monitor these new technologies. Simplified choice You donâ€™t need to decide which instrumentation option to use (a proprietary option or one of the other open standards). Cross-platform compatibility OpenTelemetry supports a variety of languages and backends. It represents a vendor-neutral path for capturing and transmitting telemetry to backends without altering existing instrumentation. Streamlined observability It is easier for vendors to support and test against a single standard as they donâ€™t need to develop their own agents or collectors. High dimensionality OpenTelemetry uses dimensional metrics, so you can filter and facet on more aspects of the data, such as AWS regions, Kubernetes clusters, or service versions. Dimensional metrics also lead to less time between occurrence and reporting. Efficiency OpenTelemetryâ€™s fire-and-forget trace-centric approach to instrumentation often has lower overhead than New Relic agents, especially for asynchronous workloads. It will also result in better handling of trace data for asynchronous requests. Should I use OpenTelemetry instrumentation or New Relic agents? As you consider OpenTelemetry, you may also be looking at New Relic APM agents that also capture telemetry data. As you'd expect, there is a lot of overlap between features available from OpenTelemetry agents and SDKs versus those available from New Relic APM agents. This is especially true if you're interested in distributed tracing telemetry data. The choice you make depends on what you need. We recommend that you explore both New Relic and OpenTelemetry instrumentation or discuss this with us in our CNCF Slack channel to decide what works best for you. OpenTelemetry: A work in progress OpenTelemetry is still an emerging standard, so your choices may be affected by what's available. You can check on the current state of the specification at the OpenTelemetry site. The current state of language-specific OpenTelemetry APIs and SDKs varies: some languages are still pre-alpha and may be missing instructions on how to instrument your service. Most languages have some implementation of traces that is sufficient to start exporting data to New Relic. Check out this table in GitHub that provides an overview of the state of OpenTelemetry specification compliance for each language. For languages that New Relic does not currently provide an agent or SDK, OpenTelemetry may offer you a good alternative. Also, in cases where you want explicit control over sampling of your telemetry data, OpenTelemetry provides a lot of flexibility. As OpenTelemetry matures, New Relic will continue to support new OpenTelemetry data models and to provide a curated UI experience for our Full Stack Observability customers. New Relic's APM agents In general, New Relic's APM agents will collect more telemetry data for your services, and they offer a wide range of configuration options and an extensive set of auto-instrumentation capabilities. New Relic's APM agents offer detailed transaction trace visibility for individual services. They also offer predefined sampling to balance the performance impact of your instrumentation against the need to capture enough data to gain helpful insights. How OpenTelemetry works with New Relic New Relic supports the native OpenTelemetry Protocol (OTLP) for exporting telemetry data. This allows you to use the vendor neutral components developed by the OpenTelemetry community to export your data to New Relic. The following tables show the supported features for each telemetry signal. If you have questions about these or have an unsupported use case, please contact us in our CNCF Slack channel, and watch this page for future updates. Important New Relic's exporters for OpenTelemetry are now deprecated in favor of exporting data to New Relic using OTLP. Traces New Relic offers support for the OTLP ingest of trace signals. The maturity of the upstream specification is stable. OpenTelemetry traces and spans are compatible with New Relic traces and spans. OpenTelemetry spans optionally include attributes (name-value pairs) and resource attributes which map directly to dimensions that can be used to facet or filter span data at query time. OpenTelemetry span metadata (for example, name, kind, and trace_id) also map directly to dimensions on NewRelic spans. At this time, New Relic does not support span links or array attributes. For details, see the Traces section of our best practices guide. Feature Supported Span events âœ… Span linking âŒ Array of primitives (homogeneous) âŒ Metrics New Relic offers support for the OTLP ingest of metric signals. Note that the maturity of the upstream specification is experimental. We intend to follow potentially breaking upstream changes. Here are the OpenTelemetry data types we support and their associated mappings. For details, see the Metrics section of our best practices guide. Metric Type Supported Delta sums âœ… Cumulative sums âœ… Gauges âœ… Delta histograms âœ… Summary âœ… Cumulative histograms âŒ Exemplars âŒ Array of primitives (homogeneous) âŒ Logs New Relic offers support for the OTLP ingest of log signals. Note that the maturity of the upstream specification is experimental. We intend to follow potentially breaking upstream changes. OpenTelemetry logs are compatible with New Relic logs. OpenTelemetry logs optionally include attributes (name-value pairs) and resource attributes which map directly to dimensions that can be used to facet or filter log data at query time. OpenTelemetry log metadata (for example, name, severity_text, and trace_id) also map directly to dimensions on New Relic logs. NewRelic currently supports all OpenTelemetry log message types except for arrays. For more details, see the Logs section of our best practices guide. Feature Supported Description LogRecord body âœ… Supported types: string, boolean, int, double, bytes LogRecord attributes âœ… Supported types: string, boolean, int, double, bytes LogRecord fields âœ… Examples: name, severity_text, trace_id Array messages âŒ Array attributes âŒ Next steps Follow the OpenTelemetry quick start to help you get started. You'll also want to review the best practices guide for getting the most out of the data you export to New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 153.07025,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>OpenTelemetry</em> with New Relic",
        "sections": "Introduction to <em>OpenTelemetry</em> with New Relic",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": " wonâ€™t need to change your instrumentation. Support for newer technologies When new technologies emerge, contributors can build <em>integrations</em> into <em>OpenTelemetry</em> or add instrumentation directly to <em>source</em> code, ensuring end users can easily monitor these new technologies. Simplified choice You donâ€™t need"
      },
      "id": "603e81ba196a67304da83dab"
    }
  ],
  "/docs/more-integrations/open-source-telemetry-integrations/micrometer/micrometer-metrics-registry": [
    {
      "sections": [
        "Introduction to OpenTelemetry with New Relic",
        "Benefits of OpenTelemetry",
        "Should I use OpenTelemetry instrumentation or New Relic agents?",
        "OpenTelemetry: A work in progress",
        "New Relic's APM agents",
        "How OpenTelemetry works with New Relic",
        "Important",
        "Traces",
        "Metrics",
        "Logs",
        "Next steps"
      ],
      "title": "Introduction to OpenTelemetry with New Relic",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "67818451ffb7594e3c27526f4082bd1bc007bc51",
      "image": "",
      "url": "https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/introduction-opentelemetry-new-relic/",
      "published_at": "2021-10-24T16:37:27Z",
      "updated_at": "2021-10-24T00:59:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Are you already familiar with OpenTelemetry and want to begin the setup? Check out our quick start: Quick start If you don't have one already, create a New Relic account. It's free, forever. If you're just getting acquainted with OpenTelemetry, this is what we'll explore here: Benefits of OpenTelemetry Should I use OpenTelemetry or New Relic agents? How OpenTelemetry works with New Relic Benefits of OpenTelemetry OpenTelemetry provides a secure, vendor-neutral specification for service instrumentation so that you can export data to distinct backends of your choice, such as New Relic. OpenTelemetry offers a single set of APIs and libraries that standardize how you collect and transfer telemetry data for your services. The following components make up the OpenTelemetry project: Specifications for the core pillars of observability to drive consistency across all projects. New Relic supports all of these signals: traces, metrics, and logs (see details below) APIs that contain interfaces and implementations based on the specifications SDKs (reference implementations of the APIs) created specifically for languages like Java, Python, Go, Erlang, and more Collectors that offer a vendor-agnostic implementation for processing and exporting Exporters that enable you to send data to a backend of your choice The components of OpenTelemetry work together to create some distinct advantages for capturing telemetry data: Feature Description Ubiquitous instrumentation A single, open standard of instrumentation provides better coverage and flexibility as engineers from all over the world contribute to the instrumentation. Future proof As the instrumentation gets built into libraries and frameworks, and as more vendors move to support this open standard, you can be confident that you wonâ€™t need to change your instrumentation. Support for newer technologies When new technologies emerge, contributors can build integrations into OpenTelemetry or add instrumentation directly to source code, ensuring end users can easily monitor these new technologies. Simplified choice You donâ€™t need to decide which instrumentation option to use (a proprietary option or one of the other open standards). Cross-platform compatibility OpenTelemetry supports a variety of languages and backends. It represents a vendor-neutral path for capturing and transmitting telemetry to backends without altering existing instrumentation. Streamlined observability It is easier for vendors to support and test against a single standard as they donâ€™t need to develop their own agents or collectors. High dimensionality OpenTelemetry uses dimensional metrics, so you can filter and facet on more aspects of the data, such as AWS regions, Kubernetes clusters, or service versions. Dimensional metrics also lead to less time between occurrence and reporting. Efficiency OpenTelemetryâ€™s fire-and-forget trace-centric approach to instrumentation often has lower overhead than New Relic agents, especially for asynchronous workloads. It will also result in better handling of trace data for asynchronous requests. Should I use OpenTelemetry instrumentation or New Relic agents? As you consider OpenTelemetry, you may also be looking at New Relic APM agents that also capture telemetry data. As you'd expect, there is a lot of overlap between features available from OpenTelemetry agents and SDKs versus those available from New Relic APM agents. This is especially true if you're interested in distributed tracing telemetry data. The choice you make depends on what you need. We recommend that you explore both New Relic and OpenTelemetry instrumentation or discuss this with us in our CNCF Slack channel to decide what works best for you. OpenTelemetry: A work in progress OpenTelemetry is still an emerging standard, so your choices may be affected by what's available. You can check on the current state of the specification at the OpenTelemetry site. The current state of language-specific OpenTelemetry APIs and SDKs varies: some languages are still pre-alpha and may be missing instructions on how to instrument your service. Most languages have some implementation of traces that is sufficient to start exporting data to New Relic. Check out this table in GitHub that provides an overview of the state of OpenTelemetry specification compliance for each language. For languages that New Relic does not currently provide an agent or SDK, OpenTelemetry may offer you a good alternative. Also, in cases where you want explicit control over sampling of your telemetry data, OpenTelemetry provides a lot of flexibility. As OpenTelemetry matures, New Relic will continue to support new OpenTelemetry data models and to provide a curated UI experience for our customers. New Relic's APM agents In general, New Relic's APM agents will collect more telemetry data for your services, and they offer a wide range of configuration options and an extensive set of auto-instrumentation capabilities. New Relic's APM agents offer detailed transaction trace visibility for individual services. They also offer predefined sampling to balance the performance impact of your instrumentation against the need to capture enough data to gain helpful insights. How OpenTelemetry works with New Relic New Relic supports the native OpenTelemetry Protocol (OTLP) for exporting telemetry data. This allows you to use the vendor neutral components developed by the OpenTelemetry community to export your data to New Relic. The following tables show the supported features for each telemetry signal. If you have questions about these or have an unsupported use case, please contact us in our CNCF Slack channel, and watch this page for future updates. Important New Relic's exporters for OpenTelemetry are now deprecated in favor of exporting data to New Relic using OTLP. Traces New Relic offers support for the OTLP ingest of trace signals. The maturity of the upstream specification is stable. OpenTelemetry traces and spans are compatible with New Relic traces and spans. OpenTelemetry spans optionally include attributes (name-value pairs) and resource attributes which map directly to dimensions that can be used to facet or filter span data at query time. OpenTelemetry span metadata (for example, name, kind, and trace_id) also map directly to dimensions on NewRelic spans. At this time, New Relic does not support span links or array attributes. For details, see the Traces section of our best practices guide. Feature Supported Span events âœ… Span linking âŒ Array of primitives (homogeneous) âŒ Metrics New Relic offers support for the OTLP ingest of metric signals. Note that the maturity of the upstream specification is experimental. We intend to follow potentially breaking upstream changes. Here are the OpenTelemetry data types we support and their associated mappings. For details, see the Metrics section of our best practices guide. Metric Type Supported Delta sums âœ… Cumulative sums âœ… Gauges âœ… Delta histograms âœ… Summary âœ… Cumulative histograms âŒ Exemplars âŒ Array of primitives (homogeneous) âŒ Logs New Relic offers support for the OTLP ingest of log signals. Note that the maturity of the upstream specification is experimental. We intend to follow potentially breaking upstream changes. OpenTelemetry logs are compatible with New Relic logs. OpenTelemetry logs optionally include attributes (name-value pairs) and resource attributes which map directly to dimensions that can be used to facet or filter log data at query time. OpenTelemetry log metadata (for example, name, severity_text, and trace_id) also map directly to dimensions on New Relic logs. NewRelic currently supports all OpenTelemetry log message types except for arrays. For more details, see the Logs section of our best practices guide. Feature Supported Description LogRecord body âœ… Supported types: string, boolean, int, double, bytes LogRecord attributes âœ… Supported types: string, boolean, int, double, bytes LogRecord fields âœ… Examples: name, severity_text, trace_id Array messages âŒ Array attributes âŒ Next steps Follow the OpenTelemetry quick start to help you get started. You'll also want to review the best practices guide for getting the most out of the data you export to New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 268.83838,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>OpenTelemetry</em> with New Relic",
        "sections": "Introduction to <em>OpenTelemetry</em> with New Relic",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": " wonâ€™t need to change your instrumentation. Support for newer technologies When new technologies emerge, contributors can build <em>integrations</em> into <em>OpenTelemetry</em> or add instrumentation directly to <em>source</em> code, ensuring end users can easily monitor these new technologies. Simplified choice You donâ€™t need"
      },
      "id": "6174afe1e7b9d2748213b3a6"
    },
    {
      "sections": [
        "Introduction to New Relic integrations",
        "Choose what's right for you",
        "Create your own solutions"
      ],
      "title": "Introduction to New Relic integrations",
      "type": "docs",
      "tags": [
        "Instrument everything",
        "Get started"
      ],
      "external_id": "9a44613b8a5ec0a9c9570b22c7d2f3ea726f2671",
      "image": "",
      "url": "https://docs.newrelic.com/docs/using-new-relic/welcome-new-relic/get-started/introduction-new-relic-integrations/",
      "published_at": "2021-10-24T11:54:18Z",
      "updated_at": "2021-10-24T00:59:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We provide hundreds of solutions to get your data into New Relic so you can analyze the data in one place. They give you a steady flow of useful data to fix problems quickly, maintain complex systems, improve your code, and accelerate your digital transformation. You can bring in data from hundreds of applications, frameworks, services, operating systems, and other technologies. Our integrations gather the data, and the agents send it to New Relic. The solution you need may require you to install both an integration and an agent. In some cases, you can just install our agents that contain integrations, such as our APM agents. Whatever data you need to bring in, chances are that we have options for your environment. If you prefer to make your own solutions, we also offer tools to get you started. Choose what's right for you We offer a wide range of solutions so you can easily collect data across your environment. You may only need one of our solutions to get the data you need, or you can choose a variety of options to capture a broader range of data types. Go to New Relic Integrations to find solutions that fit your environment. Here is a sample of what youâ€™ll find there: Application performance monitoring (APM): C, Go, Java, Node, .NET, PHP, Python, and Ruby Mobile apps: Android and iOS Browser monitoring: Google Chrome, Mozilla Firefox, Microsoft Internet Explorer, and Apple Safari Host monitoring: Linux and Microsoft Windows Cloud platform monitoring: Amazon Web Services (AWS), Microsoft Azure, and Google Cloud Platform (GCP) Core infrastructure services: Kubernetes, NGINX, MySQL, and more Open source telemetry integrations: Prometheus, Micrometer, OpenTelemetry, and more Create your own solutions If you are looking for custom options, we have tools to help you create your own: Use New Relic Flex to create lightweight monitoring solutions using infrastructure monitoring. Use New Relic Telemetry SDKs to build custom solutions for sending metrics, traces, and more. Build your own New Relic One applications that you can share with your colleagues, or edit open source applications in our catalog.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 166.7055,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic <em>integrations</em>",
        "sections": "Introduction to New Relic <em>integrations</em>",
        "body": " (AWS), Microsoft Azure, and Google Cloud Platform (GCP) Core infrastructure services: Kubernetes, NGINX, MySQL, and more <em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>: Prometheus, <em>Micrometer</em>, <em>OpenTelemetry</em>, and more Create your own solutions If you are looking for custom options, we have tools to help you"
      },
      "id": "603e817f28ccbc4857eba798"
    },
    {
      "sections": [
        "View your OpenTelemetry data in New Relic",
        "Explorer: Get the big picture along with the details",
        "Find your service (entity)",
        "Narrow down your data with filters",
        "Summary page",
        "Distributed tracing",
        "Find traces and their associated spans",
        "Tip",
        "View spans with errors",
        "View span events",
        "Databases",
        "Errors",
        "Externals",
        "JVMs",
        "Logs",
        "Metrics explorer",
        "Transactions",
        "Data explorer and query builder"
      ],
      "title": "View your OpenTelemetry data in New Relic",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "a5213cb2206f4c161dd97c015a7c6679b08e867b",
      "image": "https://docs.newrelic.com/static/490779aac8c10802682d86f0b785b6a2/a4078/explorer_otel_services.png",
      "url": "https://docs.newrelic.com/docs/integrations/open-source-telemetry-integrations/opentelemetry/view-your-opentelemetry-data-new-relic/",
      "published_at": "2021-10-24T16:39:15Z",
      "updated_at": "2021-09-27T15:53:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you import OpenTelemetry data into New Relic, you can use a variety of tools to analyze it. Take a look at these UI options: Explorer Data explorer and query builder Explorer: Get the big picture along with the details The New Relic Explorer tab is a good place to start gathering information about your services. It offers you a way to filter services and then filter the data to show a variety of views into your data. Find your service (entity) To get started in Explorer, you need to find your service: Go to one.newrelic.com. In the left sidebar, click Services - OpenTelemetry: In the center pane, click the service you want to know more about, or find your service by entering the name in the top filter bar. Narrow down your data with filters Once you have your entity, you can then filter for data from your service. With the filter bar Narrow data to..., you can highlight a specific facet of the telemetry recorded for your service. For example, you may want to see the error rate for a particular version of the service that you've deployed in a canary instance, so you add a filter for service.version='1.2.3'. Filters are preserved when navigating between different views of your data for a service. For example, the filter for service.version='1.2.3' carries over to the Transactions view, so that you would see telemetry on requests to the endpoints (transactions) that are running version 1.2.3 of your service, and not any other versions. Filters are preserved when navigating between the Summary, Transactions, Databases, Externals, Errors, and JVMs views. Filters are also preserved when navigating to the Distributed tracing view, but with limitations. Only filter conditions that use the equals operator (\"=\") are currently supported when navigating to Distributed tracing. If you navigate back from the Distributed tracing page, the filters you selected on the previous view will come back. Once you filter your data, the UI has various views in the left-navigation pane. See our descriptions below for view details. Summary page After you click on a service in the Explorer tab, you see the Summary page listing various golden signals about your entity. Golden signals are key monitoring details such as response time, throughput, and error rate. By using this information, you can quickly decide if you need to dig deeper. For your data to appear in this section, make sure it has the following: UI area Attribute Response time span.kind = server or consumer Throughput span.kind = server or consumer Error rate span.kind = server or consumer otel.status_code = ERROR Service instances pane service.instance.id (usually set via the OTel resource API) Distributed tracing In Distributed tracing, you can locate traces and examine span details. For your trace data to appear in the New Relic UI, it needs to conform to the OpenTelemetry trace semantic conventions. Also, in the Traces section of our best practices guide, you can find some tips about making sure your traces and spans appear in New Relic. The following attributes are typically not added explicitly to spans. Rather, they are usually set when creating a span or performing operations (for example, recording an error) on a span using the OpenTelemetry SDK. Attribute Description name A spanâ€™s name is generally set when starting a span. The name can generally be anything, but the OpenTelemetry specification provides guidance for certain types of spans like Database spans or HTTP spans. span.kind A spanâ€™s kind is generally set when starting a span. New Relic uses span.kind to infer that a span is an entry point to a given service. When span.kind = server or consumer it is considered an entry point. When span.kind = client or producer, it is considered a call to an external service or database system. otel.status_code A spanâ€™s status is set using the span API. The otel.status_code attribute is how it is manifested by New Relic. The UI primarily uses otel.status_code for the purpose of identifying errors. Find traces and their associated spans Here are some ways to target your searches: To find the traces you want, you can run queries like these in the filter bar: service.name = YOUR_SERVICE_NAME trace.id = YOUR_TRACE_ID When you find an interesting trace, click on it to display a waterfall diagram showing the spans of the trace. Click on specific spans within the trace to display span details in the right panel. Tip For more ways to filter traces, see our distributed tracing UI page. View spans with errors After you click on a span in the trace waterfall view, you can see span errors in the right panel under Error details. The error details are populated by spans containing otel.status_code = ERROR and display the content of otel.status_description. To narrow your search for spans with errors, you can enter otel.status_code = ERROR directly in the distributed tracing filter bar. View span events If you send span events as described by the OpenTelemetry specification, you can view them in the New Relic UI. Span events have two general types: Exceptions Non-exceptions (for example, logs) If you have span events, links for these appear in the right pane: Click on a span in the waterfall view. In the right pane, click View span events, or you can expand Error details and click the link at the bottom of the errors. When you're in span events and only want to view exceptions, slide the toggle Only show exceptions. Tip OpenTelemetry exceptions handled by the app/service are displayed independently of span error status and are not necessarily associated with a span error status. Databases The Databases page shows an application's database and cache data. The page shows individual database transactions as a sortable table, and shows operations, throughput, and response time as charts. For your data to appear in this section, make sure it has the following: UI area Attribute Top database calls span.kind = client or producer db.system Facets by span name Top databases (by query time) span.kind = client or producer db.system Facets by db.system Top databases (by throughput) span.kind = client or producer db.system Facets by db.system Errors On the Errors page, you can see total errors as well as charts showing error count and error rate. For your data to appear in this section, make sure it has the following: span.kind = server or consumer otel.status_code = ERROR Facets by span name Externals Externals capture calls to out-of-process services such as web services, resources in the cloud, and other network entities. For your data to appear in this section, make sure it has the following: span.kind = client or producer db.system is not present JVMs When you drill into a specific JVM, the UI display charts driven by JVM metric data: JVM metrics follow the general semantic conventions for runtime environment metrics. The Java specific runtime metrics are not well documented. The implementation is effectively the documentation and may be subject to change. For your data to appear in this section, make sure it has the following: Requires a unique service.instance.id attribute for rendering the list of JVMs Service.instance.id is an OpenTelemetry resource attribute Logs The Logs page displays logs from your application. For more information about how to associate log data to your application in New Relic, see our OpenTelemetry and logging documentation. For your data to appear in this section, make sure it has the following: service.name To correlate with trace data, the logs should contain the trace.id and span.id attributes. Metrics explorer For selected OpenTelemetry languages, you can see information about your metrics in this section. Also, if you are using the Prometheus exporter with OpenTelemetry, you can view your metric data here. Transactions Use Transactions to identify slow or error transactions that might be causing a spike in your application's response time. To get a list of transactions: From the Transaction Summary page, select the transactions table. For your data to appear in this section, make sure it has the following: UI area Description Top Transactions span.kind = server or consumer Facets by span name Throughput span.kind = server or consumer Facets by span name Data explorer and query builder Explore your metrics and traces using the data explorer, or write your own queries in query builder using NRQL. For more on how to query your data once it's in New Relic, see Query your data and Introduction to NRQL.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 152.28036,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "View your <em>OpenTelemetry</em> data in New Relic",
        "sections": "View your <em>OpenTelemetry</em> data in New Relic",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": "After you import <em>OpenTelemetry</em> data into New Relic, you can use a variety of tools to analyze it. Take a look at these UI options: Explorer Data explorer and query builder Explorer: Get the big picture along with the details The New Relic Explorer tab is a good place to start gathering information"
      },
      "id": "6044e5dfe7b9d283d3579a04"
    }
  ],
  "/docs/more-integrations/open-source-telemetry-integrations/opencensus/opencensus-exporter": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/intro-custom-data/",
      "sections": [
        "Introduction to custom data",
        "Options for custom data"
      ],
      "published_at": "2021-10-24T23:24:44Z",
      "title": "Introduction to custom data",
      "updated_at": "2021-10-23T21:59:19Z",
      "type": "docs",
      "external_id": "90d7829dbf9b522ea51f967c628ecbea38917e76",
      "document_type": "page",
      "popularity": 1,
      "body": "To get the most out of New Relic, you may need or want to report custom data to help you get insights about your environment and the unique challenges your organization faces. Options for custom data We have a wide variety of agents and integrations that bring in various types of data. But you may need to bring in data that isn't reported by default. Options for bringing in custom data include: Use our open source telemetry integrations. We have integrations for reporting data from OpenCensus, OpenTelemetry, DropWizard, Prometheus, and more. Configure our agents to send custom data. If you're using one of our APM agents, browser agents, or mobile agents, you can configure them to send custom data. To learn more, see the docs for the tool you're using. Create your own solution for reporting telemetry data with our language-specific Telemetry SDKs. Or use the underlying APIs directly: Metric API, Trace API, Event API, Log API. Report data from your operating system or network. If you're using our infrastructure agent, you might want to use our Flex integration, which lets you use simple config files to report data. Build a New Relic One application. You can build an app that lives on our platform, that can be shared with your team or the public, and that uses your own JavaScript UI functionality. You can analyze New Relic data, or bring in whatever data you want.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 372.84174,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " need to bring in data that isn&#x27;t reported by default. Options for bringing in custom data include: Use our <em>open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>. We have <em>integrations</em> for reporting data from <em>OpenCensus</em>, <em>OpenTelemetry</em>, DropWizard, Prometheus, and more. Configure our agents to send custom data. If you&#x27;re"
      },
      "id": "609fa5a264441f731bd2a1cf"
    },
    {
      "sections": [
        "Telemetry SDKs: Report custom telemetry data",
        "Requirements and compatibility",
        "Tip",
        "Available libraries",
        "Write your own Telemetry SDK or contribute to an existing one",
        "Integrations built with the Telemetry SDKs"
      ],
      "title": "Telemetry SDKs: Report custom telemetry data",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "d883a07b7ede4c3beaba4077c507b95f9a228435",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/ingest-apis/telemetry-sdks-report-custom-telemetry-data/",
      "published_at": "2021-10-24T19:37:31Z",
      "updated_at": "2021-10-23T17:26:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Telemetry SDKs are an open source set of API client libraries that send data to the New Relic platform. Under the hood, these SDKs rely on our core data ingest APIs: the Metric API, Trace API, Log API, and Event API. We offer open-source integrations for telemetry tools like Prometheus, Istio, and OpenCensus that were created using our Telemetry SDKs. If those solutions (or our other integrations) don't meet your needs, you can use the Telemetry SDKs to create your own telemetry data solutions. Requirements and compatibility The Telemetry SDKs use our Metric API, Event API, Log API, and Trace API, which all require a license key, so you'll need a license key for the account you wish to send data to. Tip New Relic has contributed the Telemetry SDK to the open source community under an Apache 2.0 license. Available libraries The Telemetry SDKs are open source software on GitHub. Use the language-specific GitHub links below to get library details, coding examples, and procedures for how to use the SDKs. We currently support the following libraries, with more to be created in the future: Language Library Supported New Relic data types Java Java library on GitHub Metrics Events Logs Traces Node/TypeScript NodeJS library on GitHub Metrics Traces Python Python library on GitHub Metrics Events Logs Traces Go Go library on Github Metrics Traces .NET .NET library on GitHub .NET package in NuGet Metrics Traces C C library on Github Traces Rust Rust library on Github Traces Ruby Ruby library on Github Gem on Rubygems Traces For more on the supported data types, see: An overview of New Relic data types Metrics: see the Metric API Logs: see the Log API Traces: see the Trace API Events: see the Event API Write your own Telemetry SDK or contribute to an existing one If you need a Telemetry SDK in a language that does not currently exist or want to contribute to an existing library, please see the Telemetry SDK specifications. Integrations built with the Telemetry SDKs To see the integrations built using our Telemetry SDKs, see Open source telemetry integrations. For all monitoring solutions, see our integrations page.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 362.85852,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Telemetry</em> SDKs: Report custom <em>telemetry</em> data",
        "sections": "<em>Integrations</em> built with the <em>Telemetry</em> SDKs",
        "body": ", and <em>OpenCensus</em> that were created using our <em>Telemetry</em> SDKs. If those solutions (or our other <em>integrations</em>) don&#x27;t meet your needs, you can use the <em>Telemetry</em> SDKs to create your own <em>telemetry</em> data solutions. Requirements and compatibility The <em>Telemetry</em> SDKs use our Metric API, Event API, Log API"
      },
      "id": "603ea196196a670192a83d83"
    },
    {
      "sections": [
        "Introduction to the Metric API",
        "What is the Metric API?",
        "Requirements",
        "Get started",
        "Find and use your data",
        "Alert on metric data",
        "Data retention",
        "Troubleshooting"
      ],
      "title": "Introduction to the Metric API",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "3d1e1c9bdb5d2cbf172eb055dc83020e39dbd16b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/ingest-apis/metric-api/introduction-metric-api/",
      "published_at": "2021-10-24T20:15:16Z",
      "updated_at": "2021-10-23T17:26:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Metric API can be used to send metric data to New Relic from a variety of sources. This API is how metrics from some of our integrations and exporters get into New Relic. Want to try out our Metric API? Create a New Relic account for free! No credit card required. What is the Metric API? The Metric API is a way to get metric data into New Relic. The API works by sending a POST request to our HTTP endpoint with a JSON payload containing the metric data. The Metric API is how metrics are ingested from some of our integrations, including our open source exporters (like DropWizard, OpenCensus, and Prometheus). The Metric API is also used by our Telemetry SDKs, which are language-specific tools that make it easier to use our data-ingest APIs. The Metric API can be used to: Report metric data to New Relic without a New Relic agent. Integrate metric data from an open source or in-house developed tool, library, or framework. Fully control the metric data you're sending, including the resolution and associated dimensions. Leverage the power of NRQL, New Relic's query language, for querying your metric data. Set up alerts for your metric data. Requirements Ensure outbound connectivity on TCP port 443 is allowed to the CIDR range that matches your region. The preferred configuration method is to use the DNS name metric-api.newrelic.com or metric-api.eu.newrelic.com. You'll need a New Relic license key for the New Relic account you want to send data to. For information on limits and restricted attributes, see Metric API requirements and limits. Get started If we don't have an existing integration that meets your metric-reporting needs, you have two options: Use our Telemetry SDKs, which are language-specific tools that help you send us metrics and other data. Use the Metric API directly. Find and use your data You can find data sent via the Metric API (including from integrations that use this API) in these locations: From one.newrelic.com, select Explorer and look for your service. By querying the Metric data type. For example, you can use NRQL to run: SELECT * FROM Metric Copy For more on querying, see Metric query examples. For information on querying in general, see Query data. Alert on metric data To alert on metrics created with the Metric API, use NRQL alert conditions: Select the NRQL category when defining your condition, then use the FROM Metric ... NRQL query syntax to express it. When you create these alert conditions, Alerts automatically uses the finest granularity data available (the raw metric data points) to evaluate alerts. Data retention All raw metric data points will be retained for 30 days. All additional aggregated data derived from the raw metric data points (for example, one-minute rollups) will be retained for 13 months. Any change to the retention period beyond such periods may result in a charge to you. Troubleshooting See Troubleshoot an NrIntegrationError event.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 312.05542,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ", <em>OpenCensus</em>, and Prometheus). The Metric API is also used by our <em>Telemetry</em> SDKs, which are language-specific tools that make it easier to use our data-ingest APIs. The Metric API can be used to: Report metric data to New Relic without a New Relic agent. Integrate metric data from an <em>open</em> <em>source</em>"
      },
      "id": "6107858fe7b9d2f9dcfc108e"
    }
  ],
  "/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/introduction-opentelemetry-new-relic": [
    {
      "sections": [
        "Best practices for OpenTelemetry with New Relic",
        "Resources",
        "Batching",
        "Caution",
        "Compression",
        "Traces",
        "Required fields",
        "Sampling",
        "OpenTelemetry built-in samplers",
        "OpenTelemetry tail-based samplers",
        "New Relic tail-based sampling with Infinite Tracing",
        "Important",
        "Metrics",
        "Sum metrics",
        "Delta sums",
        "Cumulative sums",
        "Sum configuration examples",
        "Gauge metrics",
        "Histogram metrics",
        "Summary metrics",
        "Start time",
        "Array values for attributes",
        "Exemplars",
        "How to query metrics",
        "Query cumulative sums stored as gauges",
        "Example: Raw gauge value for cumulative sums",
        "Example: Rate of change with cumulative sums as gauges",
        "Query gauge metrics",
        "Query histogram metrics",
        "Example: Normal distribution",
        "Example: Heat map",
        "Logs",
        "Send logs to New Relic",
        "Application log correlation",
        "View OpenTelemetry logs",
        "The time field"
      ],
      "title": "Best practices for OpenTelemetry with New Relic",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "2b624c5862a5a48d088268eccb310510f372b125",
      "image": "https://docs.newrelic.com/static/764474b6404e7a5c65e55d2eb985e93c/c1b63/sum-derivative-function.png",
      "url": "https://docs.newrelic.com/docs/integrations/open-source-telemetry-integrations/opentelemetry/opentelemetry-concepts/",
      "published_at": "2021-10-24T15:53:24Z",
      "updated_at": "2021-09-27T14:48:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are some best practices based on how OpenTelemetry works with New Relic: Resources Batching Compression Traces Metrics Logs Resources A resource in OpenTelemetry represents information about an entity generating telemetry data. All telemetry data sent to New Relic is expected to be associated with a resource so that it can be linked with the appropriate entity in New Relic. The OpenTelemetry Resource SDK specification defines the functionality implemented by all language SDKs for defining a resource. The following suites of attributes are defined by the OpenTelemetry resource semantic conventions. These attributes are usually set by creating a resource using the OpenTelemetry SDK. service.* attributes service.name attribute is required to associate your resource with an entity in the UI service.instance.id is required for certain panes to light up telemetry.sdk.language=java is required to see data in the JVM section Batching Caution Avoid getting rate limited! You should batch requests sent to the OTLP endpoint as described in this section. By default, the OpenTelemetry SDKs and Collector send one (1) data point per request. Using these defaults, it is likely your account will be rate limited. All OpenTelemetry SDKs and Collectors provide a BatchProcessor, which batches data points in memory. This batching allows requests to be sent with more than one (1) data point. Component Batch Processor Collector Batch Processor Go SDK BatchSpanProcessor JS SDK BatchSpanProcessor Python SDK BatchExportSpanProcessor Compression New Relic supports gzip compression for OTLP payloads exported over gRPC. To maximize the amount of data you can send per request, we recommend enabling compression in all OTLP exporters. If there are other compression formats you'd like to see us support, please let us know in the CNCF Slack channel. Traces Familiarize yourself with these trace topics to ensure your traces and spans appear in New Relic. Required fields The startTimeUnixNano and endTimeUnixNano fields on spans are required according to the OpenTelemetry protocol for trace data. When startTimeUnixNano is not present, the span is dropped and a NrIntegrationError is created. When endTimeUnixNano is not present, the duration of your span is large and negative. The timeUnixNano field on span events is required. When timeUnixNano is not present, the span event is dropped and a NrIntegrationError is created. The traceId and spanId fields on spans are required according to the OpenTelemetry protocol for trace data. When traceId or spanId are not present, the span is dropped and a NrIntegrationError is created. Sampling Trace data is the most mature OpenTelemetry data type. Because of this, New Relic's OpenTelemetry user experience is largely based on trace data and is therefore influenced by your sampling strategy. You can configure sampling in a number of places: Service: Use the OpenTelemetry SDK for your language. Collector: If you're running your own instance of the OpenTelemetry collector, you can configure it to do more sophisticated forms of sampling, such as tail-based sampling (see below). Check out this documentation about how to configure different types of sampling: OpenTelemetry built-in samplers Built-in samplers implemented by the OpenTelemetry SDK for each language. OpenTelemetry tail-based samplers The OpenTelemetry collector has a tail-based sampling processor. We have an example demonstrating the use of the tail-based sampling processor. New Relic tail-based sampling with Infinite Tracing Infinite Tracing is New Relic's tail-based sampling option. You can use this in conjunction with your OpenTelemetry instrumented services. In setting up Infinite Tracing, you need to override the default span endpoint and send telemetry data to the New Relic trace observer: Important Currently, Infinite Tracing does not support OTLP ingest. You must run your own instance of the OpenTelemetry Collector and configure it to use the New Relic exporter. Follow the steps in Set up the trace observer to get the value for YOUR_TRACE_OBSERVER_URL. Use the value of YOUR_TRACE_OBSERVER_URL to configure your integration. Since you want New Relic to analyze all your traces, make sure to verify that your OpenTelemetry integrations use the AlwaysOn sampler. Metrics OpenTelemetry metrics are largely compatible with New Relic dimensional metrics. We support OpenTelemetry metrics v0.10. All of the supported metric types include an independent set of associated attributes (name-value pairs) which map directly to dimensions you can use to facet or filter metric data at query time. OpenTelemetry metrics are accompanied by a set of resource attributes that identify the originating entity that produced them and map to dimensions for faceting and filtering. The OpenTelemetry data model for metrics defines a number of different metric types: sum, gauge, histogram, and summary. Sum metrics OpenTelemetry sums are a scalar metric that is the sum of all data points over a given time window. Sums have a notion of temporality indicating whether reported values incorporate previous measurements (cumulative temporality) or not (delta temporality). In addition, sums can either be monotonic (only go up or only go down) or non-monotonic (go up and down). Delta sums In New Relic, delta metrics are handled differently depending on whether they are monotonic or non-monotonic: Monotonic delta sums are mapped to the count metric type. Non-monotonic delta sums are mapped to the gauge metric type. Cumulative sums Monotonic and non-monotonic cumulative sums are mapped to the New Relic gauge metric type. Sum configuration examples To understand how to configure aggregation temporality, see these examples using the Java and Go OpenTelemetry SDKs. Gauge metrics OpenTelemetry gauge metric data points represent a sampled value at a given time. These values are converted to the New Relic gauge metric type. OpenTelemetry gauges do not have an aggregation temporality, but the sampled values can be aggregated at query time. Histogram metrics OpenTelemetry histograms compactly represent a population of recorded values along with a total count and sum. Optionally, histograms may include a series of buckets with explicit bounds and a count value for that bucketâ€™s population. OpenTelemetry histograms are converted to New Relicâ€™s distribution metric type, which is backed by a scaled exponential base 2 histogram (see NrSketch for a more thorough explanation). Counts from OpenTelemetry histogram buckets are assigned to New Relicâ€™s distribution metric buckets using linear interpolation. Also, OpenTelemetry has negative and positive infinity bound buckets which we represent in New Relic as zero-width buckets. We do this because we do not have a representation for negative and positive infinity. For example, an OpenTelemetry bucket with bounds [-âˆž, 10) will be represented by a [10,10) zero width New Relic bucket. You may see exaggerated bucket counts at the endpoints of your distribution due to this translation. Summary metrics OpenTelemetry summary metric data points are used to represent quantile summaries (for example, P99 latency). These map directly to the New Relic summary metric type. Summary metric data points include count, sum, and quantile values, with 0.0 as min and 1.0 as max. OpenTelemetry provides summary metrics for compatibility with other formats. Start time The startTimeUnixNano field is optional according to the OpenTelemetry specification. When this field is provided, it is used for the timestamp on the resulting NewRelic metric, and the duration is calculated as timeUnixNano - startTimeUnixNano. The duration field is used to calculate the queryable endTimeStamp attribute on the New Relic metric, but it serves no other semantic purpose. If startTimeUnixNano is not provided, then timeUnixNano is used for the timestamp field on the resulting NewRelic metric, and the duration field is set to zero. Array values for attributes OpenTelemetry metrics and other signals may include attributes that consist of a homogenous array of primitive types. These attributes are not supported by New Relic. Exemplars OpenTelemetry defines exemplar values that allow other signals, like traces, to be connected to a metric event and provide context. Exemplars are not supported by New Relic. How to query metrics Consider these tips for building metric NRQL queries in New Relic. Query cumulative sums stored as gauges Since cumulative sums are converted to gauges, here are some ways to query your data: Example: Raw gauge value for cumulative sums To view the raw gauge value for cumulative sums, you can use the latest() NRQL function: SELECT latest(totalApiBytesSent) FROM Metric Copy Example: Rate of change with cumulative sums as gauges To see the rate of change over a given time interval for a cumulative sum stored as a gauge, you can use the derivative() NRQL function: SELECT derivative(totalApiBytesSent, 1 minute) FROM Metric Copy New Relic does not currently support either reporting on resets and gaps or accounting for them with cumulative counters. Query gauge metrics When New Relic converts cumulative sums to gauges, you can query them using either the latest() or derivative() NRQL functions. The function you choose depends on whether you want to see the raw value or compute the rate of change. Query histogram metrics New Relic histograms translated from OpenTelemetry metrics have the same query semantics as other New Relic histograms. Namely, the histogram() NRQL function can be used to represent the histogram with a configurable number of buckets and bucket width. Note that you may see larger bucket counts at the endpoint buckets. This is because we are adding negative and positive infinity bound OpenTelemetry buckets into a zero width New Relic bucket. Example: Normal distribution FROM Metric SELECT histogram(test.histogram, buckets: 100, width: 1000) WHERE distributionType = 'Normal Distribution' SINCE 1 day ago Copy Example: Heat map The FACET keyword is also available to create heat map charts. FROM Metric SELECT histogram(test.histogram, buckets: 100, width: 1000) FACET distributionType SINCE 1 day ago Copy Important The TIMESERIES keyword is not supported for New Relic histograms. Logs Logs generated from your applications and environment are an important piece of telemetry. They may represent application logs, machine generated events, or system logs. OpenTelemetry has defined a log data model for representing log data. You can send logs using OpenTelemetry tooling, correlate them with applications, and view them in New Relic. Send logs to New Relic The OpenTelemetry Collector and OpenTelemetry Collector Contrib repositories contain a number of components for consuming log data. The general pattern is to configure the collector to: Receive logs from any of the log receivers. Some of the receiver options include Filelog Receiver, Fluent Forward Receiver, and Syslog Receiver. Process logs, potentially annotating them with resource information. Some of the processor options include Resource Detection Processor and Resource Processor. Export logs to New Relic via the OTLP exporter. Application log correlation Application logs are more useful if they're correlated with other telemetry data produced by the application. The OpenTelemetry semantic convention for services specifies service.name as a required field. All application metric, trace, and log data sent to New Relic with the same service.name are associated with the same entity. The specifics of how logs get annotated with the service.name resource attribute depends on the application's environment: Applications may produce structured JSON logs, which you can configure to include service.name as another field. You can deploy applications alongside a dedicated Collector Agent instance, which you can configure with a Resource Processor to annotate logs with the service.name attribute. Optionally, additional application trace context (sometimes called execution context) can be propagated to log messages. The setup and availability of this depends on the language and logging framework used by the application. The general strategy is to set up the application to write structured JSON logs and to configure it to extract trace context into specified trace context fields on available log messages. The Logs in Context with Log4j2 example in GitHub demonstrates an end-to-end working example for a simple Java application using Log4j2. View OpenTelemetry logs Here are two ways you can view logs: Look in the New Relic Logs UI. If your logs are correlated with an application, view them in the context of the application. The time field The timeUnixNano field is optional according to the OpenTelemetry specification for log data. When timeUnixNano is not present New Relic will use the time that the data was received for the New Relic log timestamp.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 225.10983,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Best practices for <em>OpenTelemetry</em> with New Relic",
        "sections": "Best practices for <em>OpenTelemetry</em> with New Relic",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": " to analyze all your traces, make sure to verify that your <em>OpenTelemetry</em> <em>integrations</em> use the AlwaysOn sampler. Metrics <em>OpenTelemetry</em> metrics are largely compatible with New Relic dimensional metrics. We support <em>OpenTelemetry</em> metrics v0.10. All of the supported metric types include an independent set"
      },
      "id": "60f6b9b964441f5da847ac01"
    },
    {
      "sections": [
        "OpenTelemetry quick start",
        "Step 1. Prerequisites",
        "Step 2. Instrument your service with OpenTelemetry",
        "Step 3. Export your telemetry data to New Relic",
        "Review New Relic settings for exports",
        "Important",
        "Complete the export configuration steps",
        "Export data to an OpenTelemetry Collector (optional)",
        "Step 4. View your data in the New Relic UI",
        "What's next?"
      ],
      "title": "OpenTelemetry quick start",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "1b846417a2958b61b047c838db49aea06f09a2a8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/open-source-telemetry-integrations/opentelemetry/opentelemetry-quick-start/",
      "published_at": "2021-10-24T16:38:21Z",
      "updated_at": "2021-09-27T14:43:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "OpenTelemetry is a flexible toolkit that you can implement in a variety of ways. We recommend a basic four-step approach for setting up OpenTelemetry with New Relic. Here's an overview of the process, followed by details for each step. Prerequisites Instrument your service with OpenTelemetry Export your telemetry data to New Relic View your data in the New Relic UI Step 1. Prerequisites First things first: If we donâ€™t already know you, sign up for a free New Relic account. Copy your account license key. Step 2. Instrument your service with OpenTelemetry To get started, you instrument your service with OpenTelemetry. OpenTelemetry has language-specific products and SDKs to help you. Many languages offer out-the-box instrumentation for common libraries and frameworks. Each language also provides an API for further instrumenting your service manually. Go to the repository for your language and follow the instructions to instrument your service. When you're done, return here to complete Step 3. Export your telemetry data to New Relic. C++ Erlang Go Java Javascript/Node.js .NET PHP Python Ruby Rust Swift ...See a complete list of languages in GitHub Step 3. Export your telemetry data to New Relic The OpenTelemetry Protocol, or OTLP for short, is a general purpose telemetry data delivery protocol designed for the OpenTelemetry project. This protocol describes how to encode and transmit telemetry data, which makes it a natural choice for data transport. Each language SDK provides an OTLP exporter you can configure to export data over OTLP. In this step, we focus on how to configure an OTLP exporter in your service to export data directly to New Relic. If you prefer to export your data first to an OpenTelemetry collector, we have separate instructions. Here's an example of sending data from your service directly to New Relic. To complete this third step, first familiarize yourself with some required New Relic settings, and then complete the steps in the OTLP exporter documentation for your language. Review New Relic settings for exports Before you go to the external OTLP exporter documentation, consult the table below so you're ready to do the following: Configure the OTLP exporter to add a header ( api-key ) whose value is your account license key. Based on your region, configure the endpoint where the exporter sends data to New Relic. Region gRPC HTTP/1.1 Endpoint API Header Name API Header Value TLS encryption required US âœ… âŒ https://otlp.nr-data.net:4317 api-key License Key âœ… EU âœ… âŒ https://otlp.eu01.nr-data.net:4317 api-key License Key âœ… If you have FedRamp compliance constraints, see FedRAMP-compliant endpoints. Important In Node.js, the opentelemetry-collector-grpc library requires additional options to enable TLS. Complete the export configuration steps Click on the link below for your language and complete the configuration steps. When you're done, return here to complete Step 4. View your data in the New Relic UI. C++ Erlang Go Java Javascript/Node.js .NET PHP Python Ruby Rust Swift ...Find additional OTLP language support in GitHub Export data to an OpenTelemetry Collector (optional) The OpenTelemetry Collector is a configurable and extensible software component to receive, process, and export telemetry data. When you set up a collector, it can operate as a gateway or as an agent: Gateway: The collector receives data from a variety of sources and applies standard processing before exporting to some backend. Agent: The collector is deployed on each host in an environment and can collect telemetry data about the host and processes running on it. When you use a collector, you start by following the same routine as above for setting up OTLP in your service. In this case, instead of exporting data directly to New Relic, you export through a collector that you set up. In the collector, you configure the OTLP exporter to export data to New Relic. When your data goes through a collector, the transport looks like this: Here's a Docker example of how to set up and run an OpenTelemetry collector with the collector YAML: Save the following as otel-config.yaml: receivers: otlp: protocols: grpc: http: processors: batch: exporters: otlp: endpoint: ${OTEL_EXPORTER_OTLP_ENDPOINT} headers: api-key: ${NEW_RELIC_LICENSE_KEY} service: pipelines: traces: receivers: [otlp] processors: [batch] exporters: [otlp] metrics: receivers: [otlp] processors: [batch] exporters: [otlp] logs: receivers: [otlp] processors: [batch] exporters: [otlp] Copy Run the OpenTelemetry collector, making sure you replace OTLP_ENDPOINT_HERE with the appropriate endpoint and replace YOUR_KEY_HERE with your Account License Key: export OTEL_EXPORTER_OTLP_ENDPOINT=OTLP_ENDPOINT_HERE export NEW_RELIC_LICENSE_KEY=YOUR_KEY_HERE docker run --rm \\ -e OTEL_EXPORTER_OTLP_ENDPOINT \\ -e NEW_RELIC_LICENSE_KEY \\ -p 4317:4317 \\ -v \"${PWD}/otel-config.yaml\":/otel-config.yaml \\ --config otel-config.yaml \\ --name otelcol \\ otel/opentelemetry-collector Copy Step 4. View your data in the New Relic UI Once youâ€™ve instrumented your service and configured it to export its data to New Relic, watch the New Relic One user interface for your traces, metrics, and logs! The UI for OpenTelemetry has some similarities to the APM agent UI, so if you are familiar with that, you can go right to the UI. If you need help understanding your OpenTelemetry UI options or how to make sure your data appears in the UI, see View your OpenTelemetry data in New Relic. What's next? After you do your initial setup, check out our best-practices guide for tips about various configurations to improve your use of OpenTelemetry and New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 224.50713,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>OpenTelemetry</em> quick start",
        "sections": "<em>OpenTelemetry</em> quick start",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": "<em>OpenTelemetry</em> is a flexible toolkit that you can implement in a variety of ways. We recommend a basic four-step approach for setting up <em>OpenTelemetry</em> with New Relic. Here&#x27;s an overview of the process, followed by details for each step. Prerequisites Instrument your service with <em>OpenTelemetry</em> Export"
      },
      "id": "6044e5dfe7b9d2aadc5799d4"
    },
    {
      "sections": [
        "View your OpenTelemetry data in New Relic",
        "Explorer: Get the big picture along with the details",
        "Find your service (entity)",
        "Narrow down your data with filters",
        "Summary page",
        "Distributed tracing",
        "Find traces and their associated spans",
        "Tip",
        "View spans with errors",
        "View span events",
        "Databases",
        "Errors",
        "Externals",
        "JVMs",
        "Logs",
        "Metrics explorer",
        "Transactions",
        "Data explorer and query builder"
      ],
      "title": "View your OpenTelemetry data in New Relic",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "a5213cb2206f4c161dd97c015a7c6679b08e867b",
      "image": "https://docs.newrelic.com/static/490779aac8c10802682d86f0b785b6a2/a4078/explorer_otel_services.png",
      "url": "https://docs.newrelic.com/docs/integrations/open-source-telemetry-integrations/opentelemetry/view-your-opentelemetry-data-new-relic/",
      "published_at": "2021-10-24T16:39:15Z",
      "updated_at": "2021-09-27T15:53:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you import OpenTelemetry data into New Relic, you can use a variety of tools to analyze it. Take a look at these UI options: Explorer Data explorer and query builder Explorer: Get the big picture along with the details The New Relic Explorer tab is a good place to start gathering information about your services. It offers you a way to filter services and then filter the data to show a variety of views into your data. Find your service (entity) To get started in Explorer, you need to find your service: Go to one.newrelic.com. In the left sidebar, click Services - OpenTelemetry: In the center pane, click the service you want to know more about, or find your service by entering the name in the top filter bar. Narrow down your data with filters Once you have your entity, you can then filter for data from your service. With the filter bar Narrow data to..., you can highlight a specific facet of the telemetry recorded for your service. For example, you may want to see the error rate for a particular version of the service that you've deployed in a canary instance, so you add a filter for service.version='1.2.3'. Filters are preserved when navigating between different views of your data for a service. For example, the filter for service.version='1.2.3' carries over to the Transactions view, so that you would see telemetry on requests to the endpoints (transactions) that are running version 1.2.3 of your service, and not any other versions. Filters are preserved when navigating between the Summary, Transactions, Databases, Externals, Errors, and JVMs views. Filters are also preserved when navigating to the Distributed tracing view, but with limitations. Only filter conditions that use the equals operator (\"=\") are currently supported when navigating to Distributed tracing. If you navigate back from the Distributed tracing page, the filters you selected on the previous view will come back. Once you filter your data, the UI has various views in the left-navigation pane. See our descriptions below for view details. Summary page After you click on a service in the Explorer tab, you see the Summary page listing various golden signals about your entity. Golden signals are key monitoring details such as response time, throughput, and error rate. By using this information, you can quickly decide if you need to dig deeper. For your data to appear in this section, make sure it has the following: UI area Attribute Response time span.kind = server or consumer Throughput span.kind = server or consumer Error rate span.kind = server or consumer otel.status_code = ERROR Service instances pane service.instance.id (usually set via the OTel resource API) Distributed tracing In Distributed tracing, you can locate traces and examine span details. For your trace data to appear in the New Relic UI, it needs to conform to the OpenTelemetry trace semantic conventions. Also, in the Traces section of our best practices guide, you can find some tips about making sure your traces and spans appear in New Relic. The following attributes are typically not added explicitly to spans. Rather, they are usually set when creating a span or performing operations (for example, recording an error) on a span using the OpenTelemetry SDK. Attribute Description name A spanâ€™s name is generally set when starting a span. The name can generally be anything, but the OpenTelemetry specification provides guidance for certain types of spans like Database spans or HTTP spans. span.kind A spanâ€™s kind is generally set when starting a span. New Relic uses span.kind to infer that a span is an entry point to a given service. When span.kind = server or consumer it is considered an entry point. When span.kind = client or producer, it is considered a call to an external service or database system. otel.status_code A spanâ€™s status is set using the span API. The otel.status_code attribute is how it is manifested by New Relic. The UI primarily uses otel.status_code for the purpose of identifying errors. Find traces and their associated spans Here are some ways to target your searches: To find the traces you want, you can run queries like these in the filter bar: service.name = YOUR_SERVICE_NAME trace.id = YOUR_TRACE_ID When you find an interesting trace, click on it to display a waterfall diagram showing the spans of the trace. Click on specific spans within the trace to display span details in the right panel. Tip For more ways to filter traces, see our distributed tracing UI page. View spans with errors After you click on a span in the trace waterfall view, you can see span errors in the right panel under Error details. The error details are populated by spans containing otel.status_code = ERROR and display the content of otel.status_description. To narrow your search for spans with errors, you can enter otel.status_code = ERROR directly in the distributed tracing filter bar. View span events If you send span events as described by the OpenTelemetry specification, you can view them in the New Relic UI. Span events have two general types: Exceptions Non-exceptions (for example, logs) If you have span events, links for these appear in the right pane: Click on a span in the waterfall view. In the right pane, click View span events, or you can expand Error details and click the link at the bottom of the errors. When you're in span events and only want to view exceptions, slide the toggle Only show exceptions. Tip OpenTelemetry exceptions handled by the app/service are displayed independently of span error status and are not necessarily associated with a span error status. Databases The Databases page shows an application's database and cache data. The page shows individual database transactions as a sortable table, and shows operations, throughput, and response time as charts. For your data to appear in this section, make sure it has the following: UI area Attribute Top database calls span.kind = client or producer db.system Facets by span name Top databases (by query time) span.kind = client or producer db.system Facets by db.system Top databases (by throughput) span.kind = client or producer db.system Facets by db.system Errors On the Errors page, you can see total errors as well as charts showing error count and error rate. For your data to appear in this section, make sure it has the following: span.kind = server or consumer otel.status_code = ERROR Facets by span name Externals Externals capture calls to out-of-process services such as web services, resources in the cloud, and other network entities. For your data to appear in this section, make sure it has the following: span.kind = client or producer db.system is not present JVMs When you drill into a specific JVM, the UI display charts driven by JVM metric data: JVM metrics follow the general semantic conventions for runtime environment metrics. The Java specific runtime metrics are not well documented. The implementation is effectively the documentation and may be subject to change. For your data to appear in this section, make sure it has the following: Requires a unique service.instance.id attribute for rendering the list of JVMs Service.instance.id is an OpenTelemetry resource attribute Logs The Logs page displays logs from your application. For more information about how to associate log data to your application in New Relic, see our OpenTelemetry and logging documentation. For your data to appear in this section, make sure it has the following: service.name To correlate with trace data, the logs should contain the trace.id and span.id attributes. Metrics explorer For selected OpenTelemetry languages, you can see information about your metrics in this section. Also, if you are using the Prometheus exporter with OpenTelemetry, you can view your metric data here. Transactions Use Transactions to identify slow or error transactions that might be causing a spike in your application's response time. To get a list of transactions: From the Transaction Summary page, select the transactions table. For your data to appear in this section, make sure it has the following: UI area Description Top Transactions span.kind = server or consumer Facets by span name Throughput span.kind = server or consumer Facets by span name Data explorer and query builder Explore your metrics and traces using the data explorer, or write your own queries in query builder using NRQL. For more on how to query your data once it's in New Relic, see Query your data and Introduction to NRQL.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 222.95732,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "View your <em>OpenTelemetry</em> data in New Relic",
        "sections": "View your <em>OpenTelemetry</em> data in New Relic",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": "After you import <em>OpenTelemetry</em> data into New Relic, you can use a variety of tools to analyze it. Take a look at these UI options: Explorer Data explorer and query builder Explorer: Get the big picture along with the details The New Relic Explorer tab is a good place to start gathering information"
      },
      "id": "6044e5dfe7b9d283d3579a04"
    }
  ],
  "/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/opentelemetry-concepts": [
    {
      "sections": [
        "Introduction to OpenTelemetry with New Relic",
        "Benefits of OpenTelemetry",
        "Should I use OpenTelemetry instrumentation or New Relic agents?",
        "OpenTelemetry: A work in progress",
        "New Relic's APM agents",
        "How OpenTelemetry works with New Relic",
        "Important",
        "Traces",
        "Metrics",
        "Logs",
        "Next steps"
      ],
      "title": "Introduction to OpenTelemetry with New Relic",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "67818451ffb7594e3c27526f4082bd1bc007bc51",
      "image": "",
      "url": "https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/introduction-opentelemetry-new-relic/",
      "published_at": "2021-10-24T16:37:27Z",
      "updated_at": "2021-10-24T00:59:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Are you already familiar with OpenTelemetry and want to begin the setup? Check out our quick start: Quick start If you don't have one already, create a New Relic account. It's free, forever. If you're just getting acquainted with OpenTelemetry, this is what we'll explore here: Benefits of OpenTelemetry Should I use OpenTelemetry or New Relic agents? How OpenTelemetry works with New Relic Benefits of OpenTelemetry OpenTelemetry provides a secure, vendor-neutral specification for service instrumentation so that you can export data to distinct backends of your choice, such as New Relic. OpenTelemetry offers a single set of APIs and libraries that standardize how you collect and transfer telemetry data for your services. The following components make up the OpenTelemetry project: Specifications for the core pillars of observability to drive consistency across all projects. New Relic supports all of these signals: traces, metrics, and logs (see details below) APIs that contain interfaces and implementations based on the specifications SDKs (reference implementations of the APIs) created specifically for languages like Java, Python, Go, Erlang, and more Collectors that offer a vendor-agnostic implementation for processing and exporting Exporters that enable you to send data to a backend of your choice The components of OpenTelemetry work together to create some distinct advantages for capturing telemetry data: Feature Description Ubiquitous instrumentation A single, open standard of instrumentation provides better coverage and flexibility as engineers from all over the world contribute to the instrumentation. Future proof As the instrumentation gets built into libraries and frameworks, and as more vendors move to support this open standard, you can be confident that you wonâ€™t need to change your instrumentation. Support for newer technologies When new technologies emerge, contributors can build integrations into OpenTelemetry or add instrumentation directly to source code, ensuring end users can easily monitor these new technologies. Simplified choice You donâ€™t need to decide which instrumentation option to use (a proprietary option or one of the other open standards). Cross-platform compatibility OpenTelemetry supports a variety of languages and backends. It represents a vendor-neutral path for capturing and transmitting telemetry to backends without altering existing instrumentation. Streamlined observability It is easier for vendors to support and test against a single standard as they donâ€™t need to develop their own agents or collectors. High dimensionality OpenTelemetry uses dimensional metrics, so you can filter and facet on more aspects of the data, such as AWS regions, Kubernetes clusters, or service versions. Dimensional metrics also lead to less time between occurrence and reporting. Efficiency OpenTelemetryâ€™s fire-and-forget trace-centric approach to instrumentation often has lower overhead than New Relic agents, especially for asynchronous workloads. It will also result in better handling of trace data for asynchronous requests. Should I use OpenTelemetry instrumentation or New Relic agents? As you consider OpenTelemetry, you may also be looking at New Relic APM agents that also capture telemetry data. As you'd expect, there is a lot of overlap between features available from OpenTelemetry agents and SDKs versus those available from New Relic APM agents. This is especially true if you're interested in distributed tracing telemetry data. The choice you make depends on what you need. We recommend that you explore both New Relic and OpenTelemetry instrumentation or discuss this with us in our CNCF Slack channel to decide what works best for you. OpenTelemetry: A work in progress OpenTelemetry is still an emerging standard, so your choices may be affected by what's available. You can check on the current state of the specification at the OpenTelemetry site. The current state of language-specific OpenTelemetry APIs and SDKs varies: some languages are still pre-alpha and may be missing instructions on how to instrument your service. Most languages have some implementation of traces that is sufficient to start exporting data to New Relic. Check out this table in GitHub that provides an overview of the state of OpenTelemetry specification compliance for each language. For languages that New Relic does not currently provide an agent or SDK, OpenTelemetry may offer you a good alternative. Also, in cases where you want explicit control over sampling of your telemetry data, OpenTelemetry provides a lot of flexibility. As OpenTelemetry matures, New Relic will continue to support new OpenTelemetry data models and to provide a curated UI experience for our customers. New Relic's APM agents In general, New Relic's APM agents will collect more telemetry data for your services, and they offer a wide range of configuration options and an extensive set of auto-instrumentation capabilities. New Relic's APM agents offer detailed transaction trace visibility for individual services. They also offer predefined sampling to balance the performance impact of your instrumentation against the need to capture enough data to gain helpful insights. How OpenTelemetry works with New Relic New Relic supports the native OpenTelemetry Protocol (OTLP) for exporting telemetry data. This allows you to use the vendor neutral components developed by the OpenTelemetry community to export your data to New Relic. The following tables show the supported features for each telemetry signal. If you have questions about these or have an unsupported use case, please contact us in our CNCF Slack channel, and watch this page for future updates. Important New Relic's exporters for OpenTelemetry are now deprecated in favor of exporting data to New Relic using OTLP. Traces New Relic offers support for the OTLP ingest of trace signals. The maturity of the upstream specification is stable. OpenTelemetry traces and spans are compatible with New Relic traces and spans. OpenTelemetry spans optionally include attributes (name-value pairs) and resource attributes which map directly to dimensions that can be used to facet or filter span data at query time. OpenTelemetry span metadata (for example, name, kind, and trace_id) also map directly to dimensions on NewRelic spans. At this time, New Relic does not support span links or array attributes. For details, see the Traces section of our best practices guide. Feature Supported Span events âœ… Span linking âŒ Array of primitives (homogeneous) âŒ Metrics New Relic offers support for the OTLP ingest of metric signals. Note that the maturity of the upstream specification is experimental. We intend to follow potentially breaking upstream changes. Here are the OpenTelemetry data types we support and their associated mappings. For details, see the Metrics section of our best practices guide. Metric Type Supported Delta sums âœ… Cumulative sums âœ… Gauges âœ… Delta histograms âœ… Summary âœ… Cumulative histograms âŒ Exemplars âŒ Array of primitives (homogeneous) âŒ Logs New Relic offers support for the OTLP ingest of log signals. Note that the maturity of the upstream specification is experimental. We intend to follow potentially breaking upstream changes. OpenTelemetry logs are compatible with New Relic logs. OpenTelemetry logs optionally include attributes (name-value pairs) and resource attributes which map directly to dimensions that can be used to facet or filter log data at query time. OpenTelemetry log metadata (for example, name, severity_text, and trace_id) also map directly to dimensions on New Relic logs. NewRelic currently supports all OpenTelemetry log message types except for arrays. For more details, see the Logs section of our best practices guide. Feature Supported Description LogRecord body âœ… Supported types: string, boolean, int, double, bytes LogRecord attributes âœ… Supported types: string, boolean, int, double, bytes LogRecord fields âœ… Examples: name, severity_text, trace_id Array messages âŒ Array attributes âŒ Next steps Follow the OpenTelemetry quick start to help you get started. You'll also want to review the best practices guide for getting the most out of the data you export to New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 398.04144,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>OpenTelemetry</em> with New Relic",
        "sections": "Introduction to <em>OpenTelemetry</em> with New Relic",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": " wonâ€™t need to change your instrumentation. Support for newer technologies When new technologies emerge, contributors can build <em>integrations</em> into <em>OpenTelemetry</em> or add instrumentation directly to <em>source</em> code, ensuring end users can easily monitor these new technologies. Simplified choice You donâ€™t need"
      },
      "id": "6174afe1e7b9d2748213b3a6"
    },
    {
      "sections": [
        "Introduction to OpenTelemetry with New Relic",
        "Benefits of OpenTelemetry",
        "Should I use OpenTelemetry instrumentation or New Relic agents?",
        "OpenTelemetry: A work in progress",
        "New Relic's APM agents",
        "How OpenTelemetry works with New Relic",
        "Important",
        "Traces",
        "Metrics",
        "Logs",
        "Next steps"
      ],
      "title": "Introduction to OpenTelemetry with New Relic",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "c87898d2d5835c00930c173eabd1bf93040badea",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/open-source-telemetry-integrations/opentelemetry/introduction-opentelemetry-new-relic/",
      "published_at": "2021-10-18T15:22:31Z",
      "updated_at": "2021-09-27T15:16:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Are you already familiar with OpenTelemetry and want to begin the setup? Check out our quick start: Quick start If you don't have one already, create a New Relic account. It's free, forever. If you're just getting acquainted with OpenTelemetry, this is what we'll explore here: Benefits of OpenTelemetry Should I use OpenTelemetry or New Relic agents? How OpenTelemetry works with New Relic Benefits of OpenTelemetry OpenTelemetry provides a secure, vendor-neutral specification for service instrumentation so that you can export data to distinct backends of your choice, such as New Relic. OpenTelemetry offers a single set of APIs and libraries that standardize how you collect and transfer telemetry data for your services. The following components make up the OpenTelemetry project: Specifications for the core pillars of observability to drive consistency across all projects. New Relic supports all of these signals: traces, metrics, and logs (see details below) APIs that contain interfaces and implementations based on the specifications SDKs (reference implementations of the APIs) created specifically for languages like Java, Python, Go, Erlang, and more Collectors that offer a vendor-agnostic implementation for processing and exporting Exporters that enable you to send data to a backend of your choice The components of OpenTelemetry work together to create some distinct advantages for capturing telemetry data: Feature Description Ubiquitous instrumentation A single, open standard of instrumentation provides better coverage and flexibility as engineers from all over the world contribute to the instrumentation. Future proof As the instrumentation gets built into libraries and frameworks, and as more vendors move to support this open standard, you can be confident that you wonâ€™t need to change your instrumentation. Support for newer technologies When new technologies emerge, contributors can build integrations into OpenTelemetry or add instrumentation directly to source code, ensuring end users can easily monitor these new technologies. Simplified choice You donâ€™t need to decide which instrumentation option to use (a proprietary option or one of the other open standards). Cross-platform compatibility OpenTelemetry supports a variety of languages and backends. It represents a vendor-neutral path for capturing and transmitting telemetry to backends without altering existing instrumentation. Streamlined observability It is easier for vendors to support and test against a single standard as they donâ€™t need to develop their own agents or collectors. High dimensionality OpenTelemetry uses dimensional metrics, so you can filter and facet on more aspects of the data, such as AWS regions, Kubernetes clusters, or service versions. Dimensional metrics also lead to less time between occurrence and reporting. Efficiency OpenTelemetryâ€™s fire-and-forget trace-centric approach to instrumentation often has lower overhead than New Relic agents, especially for asynchronous workloads. It will also result in better handling of trace data for asynchronous requests. Should I use OpenTelemetry instrumentation or New Relic agents? As you consider OpenTelemetry, you may also be looking at New Relic APM agents that also capture telemetry data. As you'd expect, there is a lot of overlap between features available from OpenTelemetry agents and SDKs versus those available from New Relic APM agents. This is especially true if you're interested in distributed tracing telemetry data. The choice you make depends on what you need. We recommend that you explore both New Relic and OpenTelemetry instrumentation or discuss this with us in our CNCF Slack channel to decide what works best for you. OpenTelemetry: A work in progress OpenTelemetry is still an emerging standard, so your choices may be affected by what's available. You can check on the current state of the specification at the OpenTelemetry site. The current state of language-specific OpenTelemetry APIs and SDKs varies: some languages are still pre-alpha and may be missing instructions on how to instrument your service. Most languages have some implementation of traces that is sufficient to start exporting data to New Relic. Check out this table in GitHub that provides an overview of the state of OpenTelemetry specification compliance for each language. For languages that New Relic does not currently provide an agent or SDK, OpenTelemetry may offer you a good alternative. Also, in cases where you want explicit control over sampling of your telemetry data, OpenTelemetry provides a lot of flexibility. As OpenTelemetry matures, New Relic will continue to support new OpenTelemetry data models and to provide a curated UI experience for our Full Stack Observability customers. New Relic's APM agents In general, New Relic's APM agents will collect more telemetry data for your services, and they offer a wide range of configuration options and an extensive set of auto-instrumentation capabilities. New Relic's APM agents offer detailed transaction trace visibility for individual services. They also offer predefined sampling to balance the performance impact of your instrumentation against the need to capture enough data to gain helpful insights. How OpenTelemetry works with New Relic New Relic supports the native OpenTelemetry Protocol (OTLP) for exporting telemetry data. This allows you to use the vendor neutral components developed by the OpenTelemetry community to export your data to New Relic. The following tables show the supported features for each telemetry signal. If you have questions about these or have an unsupported use case, please contact us in our CNCF Slack channel, and watch this page for future updates. Important New Relic's exporters for OpenTelemetry are now deprecated in favor of exporting data to New Relic using OTLP. Traces New Relic offers support for the OTLP ingest of trace signals. The maturity of the upstream specification is stable. OpenTelemetry traces and spans are compatible with New Relic traces and spans. OpenTelemetry spans optionally include attributes (name-value pairs) and resource attributes which map directly to dimensions that can be used to facet or filter span data at query time. OpenTelemetry span metadata (for example, name, kind, and trace_id) also map directly to dimensions on NewRelic spans. At this time, New Relic does not support span links or array attributes. For details, see the Traces section of our best practices guide. Feature Supported Span events âœ… Span linking âŒ Array of primitives (homogeneous) âŒ Metrics New Relic offers support for the OTLP ingest of metric signals. Note that the maturity of the upstream specification is experimental. We intend to follow potentially breaking upstream changes. Here are the OpenTelemetry data types we support and their associated mappings. For details, see the Metrics section of our best practices guide. Metric Type Supported Delta sums âœ… Cumulative sums âœ… Gauges âœ… Delta histograms âœ… Summary âœ… Cumulative histograms âŒ Exemplars âŒ Array of primitives (homogeneous) âŒ Logs New Relic offers support for the OTLP ingest of log signals. Note that the maturity of the upstream specification is experimental. We intend to follow potentially breaking upstream changes. OpenTelemetry logs are compatible with New Relic logs. OpenTelemetry logs optionally include attributes (name-value pairs) and resource attributes which map directly to dimensions that can be used to facet or filter log data at query time. OpenTelemetry log metadata (for example, name, severity_text, and trace_id) also map directly to dimensions on New Relic logs. NewRelic currently supports all OpenTelemetry log message types except for arrays. For more details, see the Logs section of our best practices guide. Feature Supported Description LogRecord body âœ… Supported types: string, boolean, int, double, bytes LogRecord attributes âœ… Supported types: string, boolean, int, double, bytes LogRecord fields âœ… Examples: name, severity_text, trace_id Array messages âŒ Array attributes âŒ Next steps Follow the OpenTelemetry quick start to help you get started. You'll also want to review the best practices guide for getting the most out of the data you export to New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 225.42596,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>OpenTelemetry</em> with New Relic",
        "sections": "Introduction to <em>OpenTelemetry</em> with New Relic",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": " wonâ€™t need to change your instrumentation. Support for newer technologies When new technologies emerge, contributors can build <em>integrations</em> into <em>OpenTelemetry</em> or add instrumentation directly to <em>source</em> code, ensuring end users can easily monitor these new technologies. Simplified choice You donâ€™t need"
      },
      "id": "603e81ba196a67304da83dab"
    },
    {
      "sections": [
        "OpenTelemetry quick start",
        "Step 1. Prerequisites",
        "Step 2. Instrument your service with OpenTelemetry",
        "Step 3. Export your telemetry data to New Relic",
        "Review New Relic settings for exports",
        "Important",
        "Complete the export configuration steps",
        "Export data to an OpenTelemetry Collector (optional)",
        "Step 4. View your data in the New Relic UI",
        "What's next?"
      ],
      "title": "OpenTelemetry quick start",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "1b846417a2958b61b047c838db49aea06f09a2a8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/open-source-telemetry-integrations/opentelemetry/opentelemetry-quick-start/",
      "published_at": "2021-10-24T16:38:21Z",
      "updated_at": "2021-09-27T14:43:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "OpenTelemetry is a flexible toolkit that you can implement in a variety of ways. We recommend a basic four-step approach for setting up OpenTelemetry with New Relic. Here's an overview of the process, followed by details for each step. Prerequisites Instrument your service with OpenTelemetry Export your telemetry data to New Relic View your data in the New Relic UI Step 1. Prerequisites First things first: If we donâ€™t already know you, sign up for a free New Relic account. Copy your account license key. Step 2. Instrument your service with OpenTelemetry To get started, you instrument your service with OpenTelemetry. OpenTelemetry has language-specific products and SDKs to help you. Many languages offer out-the-box instrumentation for common libraries and frameworks. Each language also provides an API for further instrumenting your service manually. Go to the repository for your language and follow the instructions to instrument your service. When you're done, return here to complete Step 3. Export your telemetry data to New Relic. C++ Erlang Go Java Javascript/Node.js .NET PHP Python Ruby Rust Swift ...See a complete list of languages in GitHub Step 3. Export your telemetry data to New Relic The OpenTelemetry Protocol, or OTLP for short, is a general purpose telemetry data delivery protocol designed for the OpenTelemetry project. This protocol describes how to encode and transmit telemetry data, which makes it a natural choice for data transport. Each language SDK provides an OTLP exporter you can configure to export data over OTLP. In this step, we focus on how to configure an OTLP exporter in your service to export data directly to New Relic. If you prefer to export your data first to an OpenTelemetry collector, we have separate instructions. Here's an example of sending data from your service directly to New Relic. To complete this third step, first familiarize yourself with some required New Relic settings, and then complete the steps in the OTLP exporter documentation for your language. Review New Relic settings for exports Before you go to the external OTLP exporter documentation, consult the table below so you're ready to do the following: Configure the OTLP exporter to add a header ( api-key ) whose value is your account license key. Based on your region, configure the endpoint where the exporter sends data to New Relic. Region gRPC HTTP/1.1 Endpoint API Header Name API Header Value TLS encryption required US âœ… âŒ https://otlp.nr-data.net:4317 api-key License Key âœ… EU âœ… âŒ https://otlp.eu01.nr-data.net:4317 api-key License Key âœ… If you have FedRamp compliance constraints, see FedRAMP-compliant endpoints. Important In Node.js, the opentelemetry-collector-grpc library requires additional options to enable TLS. Complete the export configuration steps Click on the link below for your language and complete the configuration steps. When you're done, return here to complete Step 4. View your data in the New Relic UI. C++ Erlang Go Java Javascript/Node.js .NET PHP Python Ruby Rust Swift ...Find additional OTLP language support in GitHub Export data to an OpenTelemetry Collector (optional) The OpenTelemetry Collector is a configurable and extensible software component to receive, process, and export telemetry data. When you set up a collector, it can operate as a gateway or as an agent: Gateway: The collector receives data from a variety of sources and applies standard processing before exporting to some backend. Agent: The collector is deployed on each host in an environment and can collect telemetry data about the host and processes running on it. When you use a collector, you start by following the same routine as above for setting up OTLP in your service. In this case, instead of exporting data directly to New Relic, you export through a collector that you set up. In the collector, you configure the OTLP exporter to export data to New Relic. When your data goes through a collector, the transport looks like this: Here's a Docker example of how to set up and run an OpenTelemetry collector with the collector YAML: Save the following as otel-config.yaml: receivers: otlp: protocols: grpc: http: processors: batch: exporters: otlp: endpoint: ${OTEL_EXPORTER_OTLP_ENDPOINT} headers: api-key: ${NEW_RELIC_LICENSE_KEY} service: pipelines: traces: receivers: [otlp] processors: [batch] exporters: [otlp] metrics: receivers: [otlp] processors: [batch] exporters: [otlp] logs: receivers: [otlp] processors: [batch] exporters: [otlp] Copy Run the OpenTelemetry collector, making sure you replace OTLP_ENDPOINT_HERE with the appropriate endpoint and replace YOUR_KEY_HERE with your Account License Key: export OTEL_EXPORTER_OTLP_ENDPOINT=OTLP_ENDPOINT_HERE export NEW_RELIC_LICENSE_KEY=YOUR_KEY_HERE docker run --rm \\ -e OTEL_EXPORTER_OTLP_ENDPOINT \\ -e NEW_RELIC_LICENSE_KEY \\ -p 4317:4317 \\ -v \"${PWD}/otel-config.yaml\":/otel-config.yaml \\ --config otel-config.yaml \\ --name otelcol \\ otel/opentelemetry-collector Copy Step 4. View your data in the New Relic UI Once youâ€™ve instrumented your service and configured it to export its data to New Relic, watch the New Relic One user interface for your traces, metrics, and logs! The UI for OpenTelemetry has some similarities to the APM agent UI, so if you are familiar with that, you can go right to the UI. If you need help understanding your OpenTelemetry UI options or how to make sure your data appears in the UI, see View your OpenTelemetry data in New Relic. What's next? After you do your initial setup, check out our best-practices guide for tips about various configurations to improve your use of OpenTelemetry and New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 224.50713,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>OpenTelemetry</em> quick start",
        "sections": "<em>OpenTelemetry</em> quick start",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": "<em>OpenTelemetry</em> is a flexible toolkit that you can implement in a variety of ways. We recommend a basic four-step approach for setting up <em>OpenTelemetry</em> with New Relic. Here&#x27;s an overview of the process, followed by details for each step. Prerequisites Instrument your service with <em>OpenTelemetry</em> Export"
      },
      "id": "6044e5dfe7b9d2aadc5799d4"
    }
  ],
  "/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/opentelemetry-legacy-new-relic-exporters": [
    {
      "sections": [
        "Introduction to OpenTelemetry with New Relic",
        "Benefits of OpenTelemetry",
        "Should I use OpenTelemetry instrumentation or New Relic agents?",
        "OpenTelemetry: A work in progress",
        "New Relic's APM agents",
        "How OpenTelemetry works with New Relic",
        "Important",
        "Traces",
        "Metrics",
        "Logs",
        "Next steps"
      ],
      "title": "Introduction to OpenTelemetry with New Relic",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "67818451ffb7594e3c27526f4082bd1bc007bc51",
      "image": "",
      "url": "https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/introduction-opentelemetry-new-relic/",
      "published_at": "2021-10-24T16:37:27Z",
      "updated_at": "2021-10-24T00:59:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Are you already familiar with OpenTelemetry and want to begin the setup? Check out our quick start: Quick start If you don't have one already, create a New Relic account. It's free, forever. If you're just getting acquainted with OpenTelemetry, this is what we'll explore here: Benefits of OpenTelemetry Should I use OpenTelemetry or New Relic agents? How OpenTelemetry works with New Relic Benefits of OpenTelemetry OpenTelemetry provides a secure, vendor-neutral specification for service instrumentation so that you can export data to distinct backends of your choice, such as New Relic. OpenTelemetry offers a single set of APIs and libraries that standardize how you collect and transfer telemetry data for your services. The following components make up the OpenTelemetry project: Specifications for the core pillars of observability to drive consistency across all projects. New Relic supports all of these signals: traces, metrics, and logs (see details below) APIs that contain interfaces and implementations based on the specifications SDKs (reference implementations of the APIs) created specifically for languages like Java, Python, Go, Erlang, and more Collectors that offer a vendor-agnostic implementation for processing and exporting Exporters that enable you to send data to a backend of your choice The components of OpenTelemetry work together to create some distinct advantages for capturing telemetry data: Feature Description Ubiquitous instrumentation A single, open standard of instrumentation provides better coverage and flexibility as engineers from all over the world contribute to the instrumentation. Future proof As the instrumentation gets built into libraries and frameworks, and as more vendors move to support this open standard, you can be confident that you wonâ€™t need to change your instrumentation. Support for newer technologies When new technologies emerge, contributors can build integrations into OpenTelemetry or add instrumentation directly to source code, ensuring end users can easily monitor these new technologies. Simplified choice You donâ€™t need to decide which instrumentation option to use (a proprietary option or one of the other open standards). Cross-platform compatibility OpenTelemetry supports a variety of languages and backends. It represents a vendor-neutral path for capturing and transmitting telemetry to backends without altering existing instrumentation. Streamlined observability It is easier for vendors to support and test against a single standard as they donâ€™t need to develop their own agents or collectors. High dimensionality OpenTelemetry uses dimensional metrics, so you can filter and facet on more aspects of the data, such as AWS regions, Kubernetes clusters, or service versions. Dimensional metrics also lead to less time between occurrence and reporting. Efficiency OpenTelemetryâ€™s fire-and-forget trace-centric approach to instrumentation often has lower overhead than New Relic agents, especially for asynchronous workloads. It will also result in better handling of trace data for asynchronous requests. Should I use OpenTelemetry instrumentation or New Relic agents? As you consider OpenTelemetry, you may also be looking at New Relic APM agents that also capture telemetry data. As you'd expect, there is a lot of overlap between features available from OpenTelemetry agents and SDKs versus those available from New Relic APM agents. This is especially true if you're interested in distributed tracing telemetry data. The choice you make depends on what you need. We recommend that you explore both New Relic and OpenTelemetry instrumentation or discuss this with us in our CNCF Slack channel to decide what works best for you. OpenTelemetry: A work in progress OpenTelemetry is still an emerging standard, so your choices may be affected by what's available. You can check on the current state of the specification at the OpenTelemetry site. The current state of language-specific OpenTelemetry APIs and SDKs varies: some languages are still pre-alpha and may be missing instructions on how to instrument your service. Most languages have some implementation of traces that is sufficient to start exporting data to New Relic. Check out this table in GitHub that provides an overview of the state of OpenTelemetry specification compliance for each language. For languages that New Relic does not currently provide an agent or SDK, OpenTelemetry may offer you a good alternative. Also, in cases where you want explicit control over sampling of your telemetry data, OpenTelemetry provides a lot of flexibility. As OpenTelemetry matures, New Relic will continue to support new OpenTelemetry data models and to provide a curated UI experience for our customers. New Relic's APM agents In general, New Relic's APM agents will collect more telemetry data for your services, and they offer a wide range of configuration options and an extensive set of auto-instrumentation capabilities. New Relic's APM agents offer detailed transaction trace visibility for individual services. They also offer predefined sampling to balance the performance impact of your instrumentation against the need to capture enough data to gain helpful insights. How OpenTelemetry works with New Relic New Relic supports the native OpenTelemetry Protocol (OTLP) for exporting telemetry data. This allows you to use the vendor neutral components developed by the OpenTelemetry community to export your data to New Relic. The following tables show the supported features for each telemetry signal. If you have questions about these or have an unsupported use case, please contact us in our CNCF Slack channel, and watch this page for future updates. Important New Relic's exporters for OpenTelemetry are now deprecated in favor of exporting data to New Relic using OTLP. Traces New Relic offers support for the OTLP ingest of trace signals. The maturity of the upstream specification is stable. OpenTelemetry traces and spans are compatible with New Relic traces and spans. OpenTelemetry spans optionally include attributes (name-value pairs) and resource attributes which map directly to dimensions that can be used to facet or filter span data at query time. OpenTelemetry span metadata (for example, name, kind, and trace_id) also map directly to dimensions on NewRelic spans. At this time, New Relic does not support span links or array attributes. For details, see the Traces section of our best practices guide. Feature Supported Span events âœ… Span linking âŒ Array of primitives (homogeneous) âŒ Metrics New Relic offers support for the OTLP ingest of metric signals. Note that the maturity of the upstream specification is experimental. We intend to follow potentially breaking upstream changes. Here are the OpenTelemetry data types we support and their associated mappings. For details, see the Metrics section of our best practices guide. Metric Type Supported Delta sums âœ… Cumulative sums âœ… Gauges âœ… Delta histograms âœ… Summary âœ… Cumulative histograms âŒ Exemplars âŒ Array of primitives (homogeneous) âŒ Logs New Relic offers support for the OTLP ingest of log signals. Note that the maturity of the upstream specification is experimental. We intend to follow potentially breaking upstream changes. OpenTelemetry logs are compatible with New Relic logs. OpenTelemetry logs optionally include attributes (name-value pairs) and resource attributes which map directly to dimensions that can be used to facet or filter log data at query time. OpenTelemetry log metadata (for example, name, severity_text, and trace_id) also map directly to dimensions on New Relic logs. NewRelic currently supports all OpenTelemetry log message types except for arrays. For more details, see the Logs section of our best practices guide. Feature Supported Description LogRecord body âœ… Supported types: string, boolean, int, double, bytes LogRecord attributes âœ… Supported types: string, boolean, int, double, bytes LogRecord fields âœ… Examples: name, severity_text, trace_id Array messages âŒ Array attributes âŒ Next steps Follow the OpenTelemetry quick start to help you get started. You'll also want to review the best practices guide for getting the most out of the data you export to New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 398.04114,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>OpenTelemetry</em> with New Relic",
        "sections": "Introduction to <em>OpenTelemetry</em> with New Relic",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": " wonâ€™t need to change your instrumentation. Support for newer technologies When new technologies emerge, contributors can build <em>integrations</em> into <em>OpenTelemetry</em> or add instrumentation directly to <em>source</em> code, ensuring end users can easily monitor these new technologies. Simplified choice You donâ€™t need"
      },
      "id": "6174afe1e7b9d2748213b3a6"
    },
    {
      "sections": [
        "Introduction to OpenTelemetry with New Relic",
        "Benefits of OpenTelemetry",
        "Should I use OpenTelemetry instrumentation or New Relic agents?",
        "OpenTelemetry: A work in progress",
        "New Relic's APM agents",
        "How OpenTelemetry works with New Relic",
        "Important",
        "Traces",
        "Metrics",
        "Logs",
        "Next steps"
      ],
      "title": "Introduction to OpenTelemetry with New Relic",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "c87898d2d5835c00930c173eabd1bf93040badea",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/open-source-telemetry-integrations/opentelemetry/introduction-opentelemetry-new-relic/",
      "published_at": "2021-10-18T15:22:31Z",
      "updated_at": "2021-09-27T15:16:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Are you already familiar with OpenTelemetry and want to begin the setup? Check out our quick start: Quick start If you don't have one already, create a New Relic account. It's free, forever. If you're just getting acquainted with OpenTelemetry, this is what we'll explore here: Benefits of OpenTelemetry Should I use OpenTelemetry or New Relic agents? How OpenTelemetry works with New Relic Benefits of OpenTelemetry OpenTelemetry provides a secure, vendor-neutral specification for service instrumentation so that you can export data to distinct backends of your choice, such as New Relic. OpenTelemetry offers a single set of APIs and libraries that standardize how you collect and transfer telemetry data for your services. The following components make up the OpenTelemetry project: Specifications for the core pillars of observability to drive consistency across all projects. New Relic supports all of these signals: traces, metrics, and logs (see details below) APIs that contain interfaces and implementations based on the specifications SDKs (reference implementations of the APIs) created specifically for languages like Java, Python, Go, Erlang, and more Collectors that offer a vendor-agnostic implementation for processing and exporting Exporters that enable you to send data to a backend of your choice The components of OpenTelemetry work together to create some distinct advantages for capturing telemetry data: Feature Description Ubiquitous instrumentation A single, open standard of instrumentation provides better coverage and flexibility as engineers from all over the world contribute to the instrumentation. Future proof As the instrumentation gets built into libraries and frameworks, and as more vendors move to support this open standard, you can be confident that you wonâ€™t need to change your instrumentation. Support for newer technologies When new technologies emerge, contributors can build integrations into OpenTelemetry or add instrumentation directly to source code, ensuring end users can easily monitor these new technologies. Simplified choice You donâ€™t need to decide which instrumentation option to use (a proprietary option or one of the other open standards). Cross-platform compatibility OpenTelemetry supports a variety of languages and backends. It represents a vendor-neutral path for capturing and transmitting telemetry to backends without altering existing instrumentation. Streamlined observability It is easier for vendors to support and test against a single standard as they donâ€™t need to develop their own agents or collectors. High dimensionality OpenTelemetry uses dimensional metrics, so you can filter and facet on more aspects of the data, such as AWS regions, Kubernetes clusters, or service versions. Dimensional metrics also lead to less time between occurrence and reporting. Efficiency OpenTelemetryâ€™s fire-and-forget trace-centric approach to instrumentation often has lower overhead than New Relic agents, especially for asynchronous workloads. It will also result in better handling of trace data for asynchronous requests. Should I use OpenTelemetry instrumentation or New Relic agents? As you consider OpenTelemetry, you may also be looking at New Relic APM agents that also capture telemetry data. As you'd expect, there is a lot of overlap between features available from OpenTelemetry agents and SDKs versus those available from New Relic APM agents. This is especially true if you're interested in distributed tracing telemetry data. The choice you make depends on what you need. We recommend that you explore both New Relic and OpenTelemetry instrumentation or discuss this with us in our CNCF Slack channel to decide what works best for you. OpenTelemetry: A work in progress OpenTelemetry is still an emerging standard, so your choices may be affected by what's available. You can check on the current state of the specification at the OpenTelemetry site. The current state of language-specific OpenTelemetry APIs and SDKs varies: some languages are still pre-alpha and may be missing instructions on how to instrument your service. Most languages have some implementation of traces that is sufficient to start exporting data to New Relic. Check out this table in GitHub that provides an overview of the state of OpenTelemetry specification compliance for each language. For languages that New Relic does not currently provide an agent or SDK, OpenTelemetry may offer you a good alternative. Also, in cases where you want explicit control over sampling of your telemetry data, OpenTelemetry provides a lot of flexibility. As OpenTelemetry matures, New Relic will continue to support new OpenTelemetry data models and to provide a curated UI experience for our Full Stack Observability customers. New Relic's APM agents In general, New Relic's APM agents will collect more telemetry data for your services, and they offer a wide range of configuration options and an extensive set of auto-instrumentation capabilities. New Relic's APM agents offer detailed transaction trace visibility for individual services. They also offer predefined sampling to balance the performance impact of your instrumentation against the need to capture enough data to gain helpful insights. How OpenTelemetry works with New Relic New Relic supports the native OpenTelemetry Protocol (OTLP) for exporting telemetry data. This allows you to use the vendor neutral components developed by the OpenTelemetry community to export your data to New Relic. The following tables show the supported features for each telemetry signal. If you have questions about these or have an unsupported use case, please contact us in our CNCF Slack channel, and watch this page for future updates. Important New Relic's exporters for OpenTelemetry are now deprecated in favor of exporting data to New Relic using OTLP. Traces New Relic offers support for the OTLP ingest of trace signals. The maturity of the upstream specification is stable. OpenTelemetry traces and spans are compatible with New Relic traces and spans. OpenTelemetry spans optionally include attributes (name-value pairs) and resource attributes which map directly to dimensions that can be used to facet or filter span data at query time. OpenTelemetry span metadata (for example, name, kind, and trace_id) also map directly to dimensions on NewRelic spans. At this time, New Relic does not support span links or array attributes. For details, see the Traces section of our best practices guide. Feature Supported Span events âœ… Span linking âŒ Array of primitives (homogeneous) âŒ Metrics New Relic offers support for the OTLP ingest of metric signals. Note that the maturity of the upstream specification is experimental. We intend to follow potentially breaking upstream changes. Here are the OpenTelemetry data types we support and their associated mappings. For details, see the Metrics section of our best practices guide. Metric Type Supported Delta sums âœ… Cumulative sums âœ… Gauges âœ… Delta histograms âœ… Summary âœ… Cumulative histograms âŒ Exemplars âŒ Array of primitives (homogeneous) âŒ Logs New Relic offers support for the OTLP ingest of log signals. Note that the maturity of the upstream specification is experimental. We intend to follow potentially breaking upstream changes. OpenTelemetry logs are compatible with New Relic logs. OpenTelemetry logs optionally include attributes (name-value pairs) and resource attributes which map directly to dimensions that can be used to facet or filter log data at query time. OpenTelemetry log metadata (for example, name, severity_text, and trace_id) also map directly to dimensions on New Relic logs. NewRelic currently supports all OpenTelemetry log message types except for arrays. For more details, see the Logs section of our best practices guide. Feature Supported Description LogRecord body âœ… Supported types: string, boolean, int, double, bytes LogRecord attributes âœ… Supported types: string, boolean, int, double, bytes LogRecord fields âœ… Examples: name, severity_text, trace_id Array messages âŒ Array attributes âŒ Next steps Follow the OpenTelemetry quick start to help you get started. You'll also want to review the best practices guide for getting the most out of the data you export to New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 225.42595,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>OpenTelemetry</em> with New Relic",
        "sections": "Introduction to <em>OpenTelemetry</em> with New Relic",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": " wonâ€™t need to change your instrumentation. Support for newer technologies When new technologies emerge, contributors can build <em>integrations</em> into <em>OpenTelemetry</em> or add instrumentation directly to <em>source</em> code, ensuring end users can easily monitor these new technologies. Simplified choice You donâ€™t need"
      },
      "id": "603e81ba196a67304da83dab"
    },
    {
      "sections": [
        "Best practices for OpenTelemetry with New Relic",
        "Resources",
        "Batching",
        "Caution",
        "Compression",
        "Traces",
        "Required fields",
        "Sampling",
        "OpenTelemetry built-in samplers",
        "OpenTelemetry tail-based samplers",
        "New Relic tail-based sampling with Infinite Tracing",
        "Important",
        "Metrics",
        "Sum metrics",
        "Delta sums",
        "Cumulative sums",
        "Sum configuration examples",
        "Gauge metrics",
        "Histogram metrics",
        "Summary metrics",
        "Start time",
        "Array values for attributes",
        "Exemplars",
        "How to query metrics",
        "Query cumulative sums stored as gauges",
        "Example: Raw gauge value for cumulative sums",
        "Example: Rate of change with cumulative sums as gauges",
        "Query gauge metrics",
        "Query histogram metrics",
        "Example: Normal distribution",
        "Example: Heat map",
        "Logs",
        "Send logs to New Relic",
        "Application log correlation",
        "View OpenTelemetry logs",
        "The time field"
      ],
      "title": "Best practices for OpenTelemetry with New Relic",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "2b624c5862a5a48d088268eccb310510f372b125",
      "image": "https://docs.newrelic.com/static/764474b6404e7a5c65e55d2eb985e93c/c1b63/sum-derivative-function.png",
      "url": "https://docs.newrelic.com/docs/integrations/open-source-telemetry-integrations/opentelemetry/opentelemetry-concepts/",
      "published_at": "2021-10-24T15:53:24Z",
      "updated_at": "2021-09-27T14:48:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are some best practices based on how OpenTelemetry works with New Relic: Resources Batching Compression Traces Metrics Logs Resources A resource in OpenTelemetry represents information about an entity generating telemetry data. All telemetry data sent to New Relic is expected to be associated with a resource so that it can be linked with the appropriate entity in New Relic. The OpenTelemetry Resource SDK specification defines the functionality implemented by all language SDKs for defining a resource. The following suites of attributes are defined by the OpenTelemetry resource semantic conventions. These attributes are usually set by creating a resource using the OpenTelemetry SDK. service.* attributes service.name attribute is required to associate your resource with an entity in the UI service.instance.id is required for certain panes to light up telemetry.sdk.language=java is required to see data in the JVM section Batching Caution Avoid getting rate limited! You should batch requests sent to the OTLP endpoint as described in this section. By default, the OpenTelemetry SDKs and Collector send one (1) data point per request. Using these defaults, it is likely your account will be rate limited. All OpenTelemetry SDKs and Collectors provide a BatchProcessor, which batches data points in memory. This batching allows requests to be sent with more than one (1) data point. Component Batch Processor Collector Batch Processor Go SDK BatchSpanProcessor JS SDK BatchSpanProcessor Python SDK BatchExportSpanProcessor Compression New Relic supports gzip compression for OTLP payloads exported over gRPC. To maximize the amount of data you can send per request, we recommend enabling compression in all OTLP exporters. If there are other compression formats you'd like to see us support, please let us know in the CNCF Slack channel. Traces Familiarize yourself with these trace topics to ensure your traces and spans appear in New Relic. Required fields The startTimeUnixNano and endTimeUnixNano fields on spans are required according to the OpenTelemetry protocol for trace data. When startTimeUnixNano is not present, the span is dropped and a NrIntegrationError is created. When endTimeUnixNano is not present, the duration of your span is large and negative. The timeUnixNano field on span events is required. When timeUnixNano is not present, the span event is dropped and a NrIntegrationError is created. The traceId and spanId fields on spans are required according to the OpenTelemetry protocol for trace data. When traceId or spanId are not present, the span is dropped and a NrIntegrationError is created. Sampling Trace data is the most mature OpenTelemetry data type. Because of this, New Relic's OpenTelemetry user experience is largely based on trace data and is therefore influenced by your sampling strategy. You can configure sampling in a number of places: Service: Use the OpenTelemetry SDK for your language. Collector: If you're running your own instance of the OpenTelemetry collector, you can configure it to do more sophisticated forms of sampling, such as tail-based sampling (see below). Check out this documentation about how to configure different types of sampling: OpenTelemetry built-in samplers Built-in samplers implemented by the OpenTelemetry SDK for each language. OpenTelemetry tail-based samplers The OpenTelemetry collector has a tail-based sampling processor. We have an example demonstrating the use of the tail-based sampling processor. New Relic tail-based sampling with Infinite Tracing Infinite Tracing is New Relic's tail-based sampling option. You can use this in conjunction with your OpenTelemetry instrumented services. In setting up Infinite Tracing, you need to override the default span endpoint and send telemetry data to the New Relic trace observer: Important Currently, Infinite Tracing does not support OTLP ingest. You must run your own instance of the OpenTelemetry Collector and configure it to use the New Relic exporter. Follow the steps in Set up the trace observer to get the value for YOUR_TRACE_OBSERVER_URL. Use the value of YOUR_TRACE_OBSERVER_URL to configure your integration. Since you want New Relic to analyze all your traces, make sure to verify that your OpenTelemetry integrations use the AlwaysOn sampler. Metrics OpenTelemetry metrics are largely compatible with New Relic dimensional metrics. We support OpenTelemetry metrics v0.10. All of the supported metric types include an independent set of associated attributes (name-value pairs) which map directly to dimensions you can use to facet or filter metric data at query time. OpenTelemetry metrics are accompanied by a set of resource attributes that identify the originating entity that produced them and map to dimensions for faceting and filtering. The OpenTelemetry data model for metrics defines a number of different metric types: sum, gauge, histogram, and summary. Sum metrics OpenTelemetry sums are a scalar metric that is the sum of all data points over a given time window. Sums have a notion of temporality indicating whether reported values incorporate previous measurements (cumulative temporality) or not (delta temporality). In addition, sums can either be monotonic (only go up or only go down) or non-monotonic (go up and down). Delta sums In New Relic, delta metrics are handled differently depending on whether they are monotonic or non-monotonic: Monotonic delta sums are mapped to the count metric type. Non-monotonic delta sums are mapped to the gauge metric type. Cumulative sums Monotonic and non-monotonic cumulative sums are mapped to the New Relic gauge metric type. Sum configuration examples To understand how to configure aggregation temporality, see these examples using the Java and Go OpenTelemetry SDKs. Gauge metrics OpenTelemetry gauge metric data points represent a sampled value at a given time. These values are converted to the New Relic gauge metric type. OpenTelemetry gauges do not have an aggregation temporality, but the sampled values can be aggregated at query time. Histogram metrics OpenTelemetry histograms compactly represent a population of recorded values along with a total count and sum. Optionally, histograms may include a series of buckets with explicit bounds and a count value for that bucketâ€™s population. OpenTelemetry histograms are converted to New Relicâ€™s distribution metric type, which is backed by a scaled exponential base 2 histogram (see NrSketch for a more thorough explanation). Counts from OpenTelemetry histogram buckets are assigned to New Relicâ€™s distribution metric buckets using linear interpolation. Also, OpenTelemetry has negative and positive infinity bound buckets which we represent in New Relic as zero-width buckets. We do this because we do not have a representation for negative and positive infinity. For example, an OpenTelemetry bucket with bounds [-âˆž, 10) will be represented by a [10,10) zero width New Relic bucket. You may see exaggerated bucket counts at the endpoints of your distribution due to this translation. Summary metrics OpenTelemetry summary metric data points are used to represent quantile summaries (for example, P99 latency). These map directly to the New Relic summary metric type. Summary metric data points include count, sum, and quantile values, with 0.0 as min and 1.0 as max. OpenTelemetry provides summary metrics for compatibility with other formats. Start time The startTimeUnixNano field is optional according to the OpenTelemetry specification. When this field is provided, it is used for the timestamp on the resulting NewRelic metric, and the duration is calculated as timeUnixNano - startTimeUnixNano. The duration field is used to calculate the queryable endTimeStamp attribute on the New Relic metric, but it serves no other semantic purpose. If startTimeUnixNano is not provided, then timeUnixNano is used for the timestamp field on the resulting NewRelic metric, and the duration field is set to zero. Array values for attributes OpenTelemetry metrics and other signals may include attributes that consist of a homogenous array of primitive types. These attributes are not supported by New Relic. Exemplars OpenTelemetry defines exemplar values that allow other signals, like traces, to be connected to a metric event and provide context. Exemplars are not supported by New Relic. How to query metrics Consider these tips for building metric NRQL queries in New Relic. Query cumulative sums stored as gauges Since cumulative sums are converted to gauges, here are some ways to query your data: Example: Raw gauge value for cumulative sums To view the raw gauge value for cumulative sums, you can use the latest() NRQL function: SELECT latest(totalApiBytesSent) FROM Metric Copy Example: Rate of change with cumulative sums as gauges To see the rate of change over a given time interval for a cumulative sum stored as a gauge, you can use the derivative() NRQL function: SELECT derivative(totalApiBytesSent, 1 minute) FROM Metric Copy New Relic does not currently support either reporting on resets and gaps or accounting for them with cumulative counters. Query gauge metrics When New Relic converts cumulative sums to gauges, you can query them using either the latest() or derivative() NRQL functions. The function you choose depends on whether you want to see the raw value or compute the rate of change. Query histogram metrics New Relic histograms translated from OpenTelemetry metrics have the same query semantics as other New Relic histograms. Namely, the histogram() NRQL function can be used to represent the histogram with a configurable number of buckets and bucket width. Note that you may see larger bucket counts at the endpoint buckets. This is because we are adding negative and positive infinity bound OpenTelemetry buckets into a zero width New Relic bucket. Example: Normal distribution FROM Metric SELECT histogram(test.histogram, buckets: 100, width: 1000) WHERE distributionType = 'Normal Distribution' SINCE 1 day ago Copy Example: Heat map The FACET keyword is also available to create heat map charts. FROM Metric SELECT histogram(test.histogram, buckets: 100, width: 1000) FACET distributionType SINCE 1 day ago Copy Important The TIMESERIES keyword is not supported for New Relic histograms. Logs Logs generated from your applications and environment are an important piece of telemetry. They may represent application logs, machine generated events, or system logs. OpenTelemetry has defined a log data model for representing log data. You can send logs using OpenTelemetry tooling, correlate them with applications, and view them in New Relic. Send logs to New Relic The OpenTelemetry Collector and OpenTelemetry Collector Contrib repositories contain a number of components for consuming log data. The general pattern is to configure the collector to: Receive logs from any of the log receivers. Some of the receiver options include Filelog Receiver, Fluent Forward Receiver, and Syslog Receiver. Process logs, potentially annotating them with resource information. Some of the processor options include Resource Detection Processor and Resource Processor. Export logs to New Relic via the OTLP exporter. Application log correlation Application logs are more useful if they're correlated with other telemetry data produced by the application. The OpenTelemetry semantic convention for services specifies service.name as a required field. All application metric, trace, and log data sent to New Relic with the same service.name are associated with the same entity. The specifics of how logs get annotated with the service.name resource attribute depends on the application's environment: Applications may produce structured JSON logs, which you can configure to include service.name as another field. You can deploy applications alongside a dedicated Collector Agent instance, which you can configure with a Resource Processor to annotate logs with the service.name attribute. Optionally, additional application trace context (sometimes called execution context) can be propagated to log messages. The setup and availability of this depends on the language and logging framework used by the application. The general strategy is to set up the application to write structured JSON logs and to configure it to extract trace context into specified trace context fields on available log messages. The Logs in Context with Log4j2 example in GitHub demonstrates an end-to-end working example for a simple Java application using Log4j2. View OpenTelemetry logs Here are two ways you can view logs: Look in the New Relic Logs UI. If your logs are correlated with an application, view them in the context of the application. The time field The timeUnixNano field is optional according to the OpenTelemetry specification for log data. When timeUnixNano is not present New Relic will use the time that the data was received for the New Relic log timestamp.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 225.10983,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Best practices for <em>OpenTelemetry</em> with New Relic",
        "sections": "Best practices for <em>OpenTelemetry</em> with New Relic",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": " to analyze all your traces, make sure to verify that your <em>OpenTelemetry</em> <em>integrations</em> use the AlwaysOn sampler. Metrics <em>OpenTelemetry</em> metrics are largely compatible with New Relic dimensional metrics. We support <em>OpenTelemetry</em> metrics v0.10. All of the supported metric types include an independent set"
      },
      "id": "60f6b9b964441f5da847ac01"
    }
  ],
  "/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/opentelemetry-quick-start": [
    {
      "sections": [
        "Introduction to OpenTelemetry with New Relic",
        "Benefits of OpenTelemetry",
        "Should I use OpenTelemetry instrumentation or New Relic agents?",
        "OpenTelemetry: A work in progress",
        "New Relic's APM agents",
        "How OpenTelemetry works with New Relic",
        "Important",
        "Traces",
        "Metrics",
        "Logs",
        "Next steps"
      ],
      "title": "Introduction to OpenTelemetry with New Relic",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "67818451ffb7594e3c27526f4082bd1bc007bc51",
      "image": "",
      "url": "https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/introduction-opentelemetry-new-relic/",
      "published_at": "2021-10-24T16:37:27Z",
      "updated_at": "2021-10-24T00:59:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Are you already familiar with OpenTelemetry and want to begin the setup? Check out our quick start: Quick start If you don't have one already, create a New Relic account. It's free, forever. If you're just getting acquainted with OpenTelemetry, this is what we'll explore here: Benefits of OpenTelemetry Should I use OpenTelemetry or New Relic agents? How OpenTelemetry works with New Relic Benefits of OpenTelemetry OpenTelemetry provides a secure, vendor-neutral specification for service instrumentation so that you can export data to distinct backends of your choice, such as New Relic. OpenTelemetry offers a single set of APIs and libraries that standardize how you collect and transfer telemetry data for your services. The following components make up the OpenTelemetry project: Specifications for the core pillars of observability to drive consistency across all projects. New Relic supports all of these signals: traces, metrics, and logs (see details below) APIs that contain interfaces and implementations based on the specifications SDKs (reference implementations of the APIs) created specifically for languages like Java, Python, Go, Erlang, and more Collectors that offer a vendor-agnostic implementation for processing and exporting Exporters that enable you to send data to a backend of your choice The components of OpenTelemetry work together to create some distinct advantages for capturing telemetry data: Feature Description Ubiquitous instrumentation A single, open standard of instrumentation provides better coverage and flexibility as engineers from all over the world contribute to the instrumentation. Future proof As the instrumentation gets built into libraries and frameworks, and as more vendors move to support this open standard, you can be confident that you wonâ€™t need to change your instrumentation. Support for newer technologies When new technologies emerge, contributors can build integrations into OpenTelemetry or add instrumentation directly to source code, ensuring end users can easily monitor these new technologies. Simplified choice You donâ€™t need to decide which instrumentation option to use (a proprietary option or one of the other open standards). Cross-platform compatibility OpenTelemetry supports a variety of languages and backends. It represents a vendor-neutral path for capturing and transmitting telemetry to backends without altering existing instrumentation. Streamlined observability It is easier for vendors to support and test against a single standard as they donâ€™t need to develop their own agents or collectors. High dimensionality OpenTelemetry uses dimensional metrics, so you can filter and facet on more aspects of the data, such as AWS regions, Kubernetes clusters, or service versions. Dimensional metrics also lead to less time between occurrence and reporting. Efficiency OpenTelemetryâ€™s fire-and-forget trace-centric approach to instrumentation often has lower overhead than New Relic agents, especially for asynchronous workloads. It will also result in better handling of trace data for asynchronous requests. Should I use OpenTelemetry instrumentation or New Relic agents? As you consider OpenTelemetry, you may also be looking at New Relic APM agents that also capture telemetry data. As you'd expect, there is a lot of overlap between features available from OpenTelemetry agents and SDKs versus those available from New Relic APM agents. This is especially true if you're interested in distributed tracing telemetry data. The choice you make depends on what you need. We recommend that you explore both New Relic and OpenTelemetry instrumentation or discuss this with us in our CNCF Slack channel to decide what works best for you. OpenTelemetry: A work in progress OpenTelemetry is still an emerging standard, so your choices may be affected by what's available. You can check on the current state of the specification at the OpenTelemetry site. The current state of language-specific OpenTelemetry APIs and SDKs varies: some languages are still pre-alpha and may be missing instructions on how to instrument your service. Most languages have some implementation of traces that is sufficient to start exporting data to New Relic. Check out this table in GitHub that provides an overview of the state of OpenTelemetry specification compliance for each language. For languages that New Relic does not currently provide an agent or SDK, OpenTelemetry may offer you a good alternative. Also, in cases where you want explicit control over sampling of your telemetry data, OpenTelemetry provides a lot of flexibility. As OpenTelemetry matures, New Relic will continue to support new OpenTelemetry data models and to provide a curated UI experience for our customers. New Relic's APM agents In general, New Relic's APM agents will collect more telemetry data for your services, and they offer a wide range of configuration options and an extensive set of auto-instrumentation capabilities. New Relic's APM agents offer detailed transaction trace visibility for individual services. They also offer predefined sampling to balance the performance impact of your instrumentation against the need to capture enough data to gain helpful insights. How OpenTelemetry works with New Relic New Relic supports the native OpenTelemetry Protocol (OTLP) for exporting telemetry data. This allows you to use the vendor neutral components developed by the OpenTelemetry community to export your data to New Relic. The following tables show the supported features for each telemetry signal. If you have questions about these or have an unsupported use case, please contact us in our CNCF Slack channel, and watch this page for future updates. Important New Relic's exporters for OpenTelemetry are now deprecated in favor of exporting data to New Relic using OTLP. Traces New Relic offers support for the OTLP ingest of trace signals. The maturity of the upstream specification is stable. OpenTelemetry traces and spans are compatible with New Relic traces and spans. OpenTelemetry spans optionally include attributes (name-value pairs) and resource attributes which map directly to dimensions that can be used to facet or filter span data at query time. OpenTelemetry span metadata (for example, name, kind, and trace_id) also map directly to dimensions on NewRelic spans. At this time, New Relic does not support span links or array attributes. For details, see the Traces section of our best practices guide. Feature Supported Span events âœ… Span linking âŒ Array of primitives (homogeneous) âŒ Metrics New Relic offers support for the OTLP ingest of metric signals. Note that the maturity of the upstream specification is experimental. We intend to follow potentially breaking upstream changes. Here are the OpenTelemetry data types we support and their associated mappings. For details, see the Metrics section of our best practices guide. Metric Type Supported Delta sums âœ… Cumulative sums âœ… Gauges âœ… Delta histograms âœ… Summary âœ… Cumulative histograms âŒ Exemplars âŒ Array of primitives (homogeneous) âŒ Logs New Relic offers support for the OTLP ingest of log signals. Note that the maturity of the upstream specification is experimental. We intend to follow potentially breaking upstream changes. OpenTelemetry logs are compatible with New Relic logs. OpenTelemetry logs optionally include attributes (name-value pairs) and resource attributes which map directly to dimensions that can be used to facet or filter log data at query time. OpenTelemetry log metadata (for example, name, severity_text, and trace_id) also map directly to dimensions on New Relic logs. NewRelic currently supports all OpenTelemetry log message types except for arrays. For more details, see the Logs section of our best practices guide. Feature Supported Description LogRecord body âœ… Supported types: string, boolean, int, double, bytes LogRecord attributes âœ… Supported types: string, boolean, int, double, bytes LogRecord fields âœ… Examples: name, severity_text, trace_id Array messages âŒ Array attributes âŒ Next steps Follow the OpenTelemetry quick start to help you get started. You'll also want to review the best practices guide for getting the most out of the data you export to New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 398.04114,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>OpenTelemetry</em> with New Relic",
        "sections": "Introduction to <em>OpenTelemetry</em> with New Relic",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": " wonâ€™t need to change your instrumentation. Support for newer technologies When new technologies emerge, contributors can build <em>integrations</em> into <em>OpenTelemetry</em> or add instrumentation directly to <em>source</em> code, ensuring end users can easily monitor these new technologies. Simplified choice You donâ€™t need"
      },
      "id": "6174afe1e7b9d2748213b3a6"
    },
    {
      "sections": [
        "Introduction to OpenTelemetry with New Relic",
        "Benefits of OpenTelemetry",
        "Should I use OpenTelemetry instrumentation or New Relic agents?",
        "OpenTelemetry: A work in progress",
        "New Relic's APM agents",
        "How OpenTelemetry works with New Relic",
        "Important",
        "Traces",
        "Metrics",
        "Logs",
        "Next steps"
      ],
      "title": "Introduction to OpenTelemetry with New Relic",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "c87898d2d5835c00930c173eabd1bf93040badea",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/open-source-telemetry-integrations/opentelemetry/introduction-opentelemetry-new-relic/",
      "published_at": "2021-10-18T15:22:31Z",
      "updated_at": "2021-09-27T15:16:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Are you already familiar with OpenTelemetry and want to begin the setup? Check out our quick start: Quick start If you don't have one already, create a New Relic account. It's free, forever. If you're just getting acquainted with OpenTelemetry, this is what we'll explore here: Benefits of OpenTelemetry Should I use OpenTelemetry or New Relic agents? How OpenTelemetry works with New Relic Benefits of OpenTelemetry OpenTelemetry provides a secure, vendor-neutral specification for service instrumentation so that you can export data to distinct backends of your choice, such as New Relic. OpenTelemetry offers a single set of APIs and libraries that standardize how you collect and transfer telemetry data for your services. The following components make up the OpenTelemetry project: Specifications for the core pillars of observability to drive consistency across all projects. New Relic supports all of these signals: traces, metrics, and logs (see details below) APIs that contain interfaces and implementations based on the specifications SDKs (reference implementations of the APIs) created specifically for languages like Java, Python, Go, Erlang, and more Collectors that offer a vendor-agnostic implementation for processing and exporting Exporters that enable you to send data to a backend of your choice The components of OpenTelemetry work together to create some distinct advantages for capturing telemetry data: Feature Description Ubiquitous instrumentation A single, open standard of instrumentation provides better coverage and flexibility as engineers from all over the world contribute to the instrumentation. Future proof As the instrumentation gets built into libraries and frameworks, and as more vendors move to support this open standard, you can be confident that you wonâ€™t need to change your instrumentation. Support for newer technologies When new technologies emerge, contributors can build integrations into OpenTelemetry or add instrumentation directly to source code, ensuring end users can easily monitor these new technologies. Simplified choice You donâ€™t need to decide which instrumentation option to use (a proprietary option or one of the other open standards). Cross-platform compatibility OpenTelemetry supports a variety of languages and backends. It represents a vendor-neutral path for capturing and transmitting telemetry to backends without altering existing instrumentation. Streamlined observability It is easier for vendors to support and test against a single standard as they donâ€™t need to develop their own agents or collectors. High dimensionality OpenTelemetry uses dimensional metrics, so you can filter and facet on more aspects of the data, such as AWS regions, Kubernetes clusters, or service versions. Dimensional metrics also lead to less time between occurrence and reporting. Efficiency OpenTelemetryâ€™s fire-and-forget trace-centric approach to instrumentation often has lower overhead than New Relic agents, especially for asynchronous workloads. It will also result in better handling of trace data for asynchronous requests. Should I use OpenTelemetry instrumentation or New Relic agents? As you consider OpenTelemetry, you may also be looking at New Relic APM agents that also capture telemetry data. As you'd expect, there is a lot of overlap between features available from OpenTelemetry agents and SDKs versus those available from New Relic APM agents. This is especially true if you're interested in distributed tracing telemetry data. The choice you make depends on what you need. We recommend that you explore both New Relic and OpenTelemetry instrumentation or discuss this with us in our CNCF Slack channel to decide what works best for you. OpenTelemetry: A work in progress OpenTelemetry is still an emerging standard, so your choices may be affected by what's available. You can check on the current state of the specification at the OpenTelemetry site. The current state of language-specific OpenTelemetry APIs and SDKs varies: some languages are still pre-alpha and may be missing instructions on how to instrument your service. Most languages have some implementation of traces that is sufficient to start exporting data to New Relic. Check out this table in GitHub that provides an overview of the state of OpenTelemetry specification compliance for each language. For languages that New Relic does not currently provide an agent or SDK, OpenTelemetry may offer you a good alternative. Also, in cases where you want explicit control over sampling of your telemetry data, OpenTelemetry provides a lot of flexibility. As OpenTelemetry matures, New Relic will continue to support new OpenTelemetry data models and to provide a curated UI experience for our Full Stack Observability customers. New Relic's APM agents In general, New Relic's APM agents will collect more telemetry data for your services, and they offer a wide range of configuration options and an extensive set of auto-instrumentation capabilities. New Relic's APM agents offer detailed transaction trace visibility for individual services. They also offer predefined sampling to balance the performance impact of your instrumentation against the need to capture enough data to gain helpful insights. How OpenTelemetry works with New Relic New Relic supports the native OpenTelemetry Protocol (OTLP) for exporting telemetry data. This allows you to use the vendor neutral components developed by the OpenTelemetry community to export your data to New Relic. The following tables show the supported features for each telemetry signal. If you have questions about these or have an unsupported use case, please contact us in our CNCF Slack channel, and watch this page for future updates. Important New Relic's exporters for OpenTelemetry are now deprecated in favor of exporting data to New Relic using OTLP. Traces New Relic offers support for the OTLP ingest of trace signals. The maturity of the upstream specification is stable. OpenTelemetry traces and spans are compatible with New Relic traces and spans. OpenTelemetry spans optionally include attributes (name-value pairs) and resource attributes which map directly to dimensions that can be used to facet or filter span data at query time. OpenTelemetry span metadata (for example, name, kind, and trace_id) also map directly to dimensions on NewRelic spans. At this time, New Relic does not support span links or array attributes. For details, see the Traces section of our best practices guide. Feature Supported Span events âœ… Span linking âŒ Array of primitives (homogeneous) âŒ Metrics New Relic offers support for the OTLP ingest of metric signals. Note that the maturity of the upstream specification is experimental. We intend to follow potentially breaking upstream changes. Here are the OpenTelemetry data types we support and their associated mappings. For details, see the Metrics section of our best practices guide. Metric Type Supported Delta sums âœ… Cumulative sums âœ… Gauges âœ… Delta histograms âœ… Summary âœ… Cumulative histograms âŒ Exemplars âŒ Array of primitives (homogeneous) âŒ Logs New Relic offers support for the OTLP ingest of log signals. Note that the maturity of the upstream specification is experimental. We intend to follow potentially breaking upstream changes. OpenTelemetry logs are compatible with New Relic logs. OpenTelemetry logs optionally include attributes (name-value pairs) and resource attributes which map directly to dimensions that can be used to facet or filter log data at query time. OpenTelemetry log metadata (for example, name, severity_text, and trace_id) also map directly to dimensions on New Relic logs. NewRelic currently supports all OpenTelemetry log message types except for arrays. For more details, see the Logs section of our best practices guide. Feature Supported Description LogRecord body âœ… Supported types: string, boolean, int, double, bytes LogRecord attributes âœ… Supported types: string, boolean, int, double, bytes LogRecord fields âœ… Examples: name, severity_text, trace_id Array messages âŒ Array attributes âŒ Next steps Follow the OpenTelemetry quick start to help you get started. You'll also want to review the best practices guide for getting the most out of the data you export to New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 225.42595,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>OpenTelemetry</em> with New Relic",
        "sections": "Introduction to <em>OpenTelemetry</em> with New Relic",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": " wonâ€™t need to change your instrumentation. Support for newer technologies When new technologies emerge, contributors can build <em>integrations</em> into <em>OpenTelemetry</em> or add instrumentation directly to <em>source</em> code, ensuring end users can easily monitor these new technologies. Simplified choice You donâ€™t need"
      },
      "id": "603e81ba196a67304da83dab"
    },
    {
      "sections": [
        "Best practices for OpenTelemetry with New Relic",
        "Resources",
        "Batching",
        "Caution",
        "Compression",
        "Traces",
        "Required fields",
        "Sampling",
        "OpenTelemetry built-in samplers",
        "OpenTelemetry tail-based samplers",
        "New Relic tail-based sampling with Infinite Tracing",
        "Important",
        "Metrics",
        "Sum metrics",
        "Delta sums",
        "Cumulative sums",
        "Sum configuration examples",
        "Gauge metrics",
        "Histogram metrics",
        "Summary metrics",
        "Start time",
        "Array values for attributes",
        "Exemplars",
        "How to query metrics",
        "Query cumulative sums stored as gauges",
        "Example: Raw gauge value for cumulative sums",
        "Example: Rate of change with cumulative sums as gauges",
        "Query gauge metrics",
        "Query histogram metrics",
        "Example: Normal distribution",
        "Example: Heat map",
        "Logs",
        "Send logs to New Relic",
        "Application log correlation",
        "View OpenTelemetry logs",
        "The time field"
      ],
      "title": "Best practices for OpenTelemetry with New Relic",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "2b624c5862a5a48d088268eccb310510f372b125",
      "image": "https://docs.newrelic.com/static/764474b6404e7a5c65e55d2eb985e93c/c1b63/sum-derivative-function.png",
      "url": "https://docs.newrelic.com/docs/integrations/open-source-telemetry-integrations/opentelemetry/opentelemetry-concepts/",
      "published_at": "2021-10-24T15:53:24Z",
      "updated_at": "2021-09-27T14:48:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are some best practices based on how OpenTelemetry works with New Relic: Resources Batching Compression Traces Metrics Logs Resources A resource in OpenTelemetry represents information about an entity generating telemetry data. All telemetry data sent to New Relic is expected to be associated with a resource so that it can be linked with the appropriate entity in New Relic. The OpenTelemetry Resource SDK specification defines the functionality implemented by all language SDKs for defining a resource. The following suites of attributes are defined by the OpenTelemetry resource semantic conventions. These attributes are usually set by creating a resource using the OpenTelemetry SDK. service.* attributes service.name attribute is required to associate your resource with an entity in the UI service.instance.id is required for certain panes to light up telemetry.sdk.language=java is required to see data in the JVM section Batching Caution Avoid getting rate limited! You should batch requests sent to the OTLP endpoint as described in this section. By default, the OpenTelemetry SDKs and Collector send one (1) data point per request. Using these defaults, it is likely your account will be rate limited. All OpenTelemetry SDKs and Collectors provide a BatchProcessor, which batches data points in memory. This batching allows requests to be sent with more than one (1) data point. Component Batch Processor Collector Batch Processor Go SDK BatchSpanProcessor JS SDK BatchSpanProcessor Python SDK BatchExportSpanProcessor Compression New Relic supports gzip compression for OTLP payloads exported over gRPC. To maximize the amount of data you can send per request, we recommend enabling compression in all OTLP exporters. If there are other compression formats you'd like to see us support, please let us know in the CNCF Slack channel. Traces Familiarize yourself with these trace topics to ensure your traces and spans appear in New Relic. Required fields The startTimeUnixNano and endTimeUnixNano fields on spans are required according to the OpenTelemetry protocol for trace data. When startTimeUnixNano is not present, the span is dropped and a NrIntegrationError is created. When endTimeUnixNano is not present, the duration of your span is large and negative. The timeUnixNano field on span events is required. When timeUnixNano is not present, the span event is dropped and a NrIntegrationError is created. The traceId and spanId fields on spans are required according to the OpenTelemetry protocol for trace data. When traceId or spanId are not present, the span is dropped and a NrIntegrationError is created. Sampling Trace data is the most mature OpenTelemetry data type. Because of this, New Relic's OpenTelemetry user experience is largely based on trace data and is therefore influenced by your sampling strategy. You can configure sampling in a number of places: Service: Use the OpenTelemetry SDK for your language. Collector: If you're running your own instance of the OpenTelemetry collector, you can configure it to do more sophisticated forms of sampling, such as tail-based sampling (see below). Check out this documentation about how to configure different types of sampling: OpenTelemetry built-in samplers Built-in samplers implemented by the OpenTelemetry SDK for each language. OpenTelemetry tail-based samplers The OpenTelemetry collector has a tail-based sampling processor. We have an example demonstrating the use of the tail-based sampling processor. New Relic tail-based sampling with Infinite Tracing Infinite Tracing is New Relic's tail-based sampling option. You can use this in conjunction with your OpenTelemetry instrumented services. In setting up Infinite Tracing, you need to override the default span endpoint and send telemetry data to the New Relic trace observer: Important Currently, Infinite Tracing does not support OTLP ingest. You must run your own instance of the OpenTelemetry Collector and configure it to use the New Relic exporter. Follow the steps in Set up the trace observer to get the value for YOUR_TRACE_OBSERVER_URL. Use the value of YOUR_TRACE_OBSERVER_URL to configure your integration. Since you want New Relic to analyze all your traces, make sure to verify that your OpenTelemetry integrations use the AlwaysOn sampler. Metrics OpenTelemetry metrics are largely compatible with New Relic dimensional metrics. We support OpenTelemetry metrics v0.10. All of the supported metric types include an independent set of associated attributes (name-value pairs) which map directly to dimensions you can use to facet or filter metric data at query time. OpenTelemetry metrics are accompanied by a set of resource attributes that identify the originating entity that produced them and map to dimensions for faceting and filtering. The OpenTelemetry data model for metrics defines a number of different metric types: sum, gauge, histogram, and summary. Sum metrics OpenTelemetry sums are a scalar metric that is the sum of all data points over a given time window. Sums have a notion of temporality indicating whether reported values incorporate previous measurements (cumulative temporality) or not (delta temporality). In addition, sums can either be monotonic (only go up or only go down) or non-monotonic (go up and down). Delta sums In New Relic, delta metrics are handled differently depending on whether they are monotonic or non-monotonic: Monotonic delta sums are mapped to the count metric type. Non-monotonic delta sums are mapped to the gauge metric type. Cumulative sums Monotonic and non-monotonic cumulative sums are mapped to the New Relic gauge metric type. Sum configuration examples To understand how to configure aggregation temporality, see these examples using the Java and Go OpenTelemetry SDKs. Gauge metrics OpenTelemetry gauge metric data points represent a sampled value at a given time. These values are converted to the New Relic gauge metric type. OpenTelemetry gauges do not have an aggregation temporality, but the sampled values can be aggregated at query time. Histogram metrics OpenTelemetry histograms compactly represent a population of recorded values along with a total count and sum. Optionally, histograms may include a series of buckets with explicit bounds and a count value for that bucketâ€™s population. OpenTelemetry histograms are converted to New Relicâ€™s distribution metric type, which is backed by a scaled exponential base 2 histogram (see NrSketch for a more thorough explanation). Counts from OpenTelemetry histogram buckets are assigned to New Relicâ€™s distribution metric buckets using linear interpolation. Also, OpenTelemetry has negative and positive infinity bound buckets which we represent in New Relic as zero-width buckets. We do this because we do not have a representation for negative and positive infinity. For example, an OpenTelemetry bucket with bounds [-âˆž, 10) will be represented by a [10,10) zero width New Relic bucket. You may see exaggerated bucket counts at the endpoints of your distribution due to this translation. Summary metrics OpenTelemetry summary metric data points are used to represent quantile summaries (for example, P99 latency). These map directly to the New Relic summary metric type. Summary metric data points include count, sum, and quantile values, with 0.0 as min and 1.0 as max. OpenTelemetry provides summary metrics for compatibility with other formats. Start time The startTimeUnixNano field is optional according to the OpenTelemetry specification. When this field is provided, it is used for the timestamp on the resulting NewRelic metric, and the duration is calculated as timeUnixNano - startTimeUnixNano. The duration field is used to calculate the queryable endTimeStamp attribute on the New Relic metric, but it serves no other semantic purpose. If startTimeUnixNano is not provided, then timeUnixNano is used for the timestamp field on the resulting NewRelic metric, and the duration field is set to zero. Array values for attributes OpenTelemetry metrics and other signals may include attributes that consist of a homogenous array of primitive types. These attributes are not supported by New Relic. Exemplars OpenTelemetry defines exemplar values that allow other signals, like traces, to be connected to a metric event and provide context. Exemplars are not supported by New Relic. How to query metrics Consider these tips for building metric NRQL queries in New Relic. Query cumulative sums stored as gauges Since cumulative sums are converted to gauges, here are some ways to query your data: Example: Raw gauge value for cumulative sums To view the raw gauge value for cumulative sums, you can use the latest() NRQL function: SELECT latest(totalApiBytesSent) FROM Metric Copy Example: Rate of change with cumulative sums as gauges To see the rate of change over a given time interval for a cumulative sum stored as a gauge, you can use the derivative() NRQL function: SELECT derivative(totalApiBytesSent, 1 minute) FROM Metric Copy New Relic does not currently support either reporting on resets and gaps or accounting for them with cumulative counters. Query gauge metrics When New Relic converts cumulative sums to gauges, you can query them using either the latest() or derivative() NRQL functions. The function you choose depends on whether you want to see the raw value or compute the rate of change. Query histogram metrics New Relic histograms translated from OpenTelemetry metrics have the same query semantics as other New Relic histograms. Namely, the histogram() NRQL function can be used to represent the histogram with a configurable number of buckets and bucket width. Note that you may see larger bucket counts at the endpoint buckets. This is because we are adding negative and positive infinity bound OpenTelemetry buckets into a zero width New Relic bucket. Example: Normal distribution FROM Metric SELECT histogram(test.histogram, buckets: 100, width: 1000) WHERE distributionType = 'Normal Distribution' SINCE 1 day ago Copy Example: Heat map The FACET keyword is also available to create heat map charts. FROM Metric SELECT histogram(test.histogram, buckets: 100, width: 1000) FACET distributionType SINCE 1 day ago Copy Important The TIMESERIES keyword is not supported for New Relic histograms. Logs Logs generated from your applications and environment are an important piece of telemetry. They may represent application logs, machine generated events, or system logs. OpenTelemetry has defined a log data model for representing log data. You can send logs using OpenTelemetry tooling, correlate them with applications, and view them in New Relic. Send logs to New Relic The OpenTelemetry Collector and OpenTelemetry Collector Contrib repositories contain a number of components for consuming log data. The general pattern is to configure the collector to: Receive logs from any of the log receivers. Some of the receiver options include Filelog Receiver, Fluent Forward Receiver, and Syslog Receiver. Process logs, potentially annotating them with resource information. Some of the processor options include Resource Detection Processor and Resource Processor. Export logs to New Relic via the OTLP exporter. Application log correlation Application logs are more useful if they're correlated with other telemetry data produced by the application. The OpenTelemetry semantic convention for services specifies service.name as a required field. All application metric, trace, and log data sent to New Relic with the same service.name are associated with the same entity. The specifics of how logs get annotated with the service.name resource attribute depends on the application's environment: Applications may produce structured JSON logs, which you can configure to include service.name as another field. You can deploy applications alongside a dedicated Collector Agent instance, which you can configure with a Resource Processor to annotate logs with the service.name attribute. Optionally, additional application trace context (sometimes called execution context) can be propagated to log messages. The setup and availability of this depends on the language and logging framework used by the application. The general strategy is to set up the application to write structured JSON logs and to configure it to extract trace context into specified trace context fields on available log messages. The Logs in Context with Log4j2 example in GitHub demonstrates an end-to-end working example for a simple Java application using Log4j2. View OpenTelemetry logs Here are two ways you can view logs: Look in the New Relic Logs UI. If your logs are correlated with an application, view them in the context of the application. The time field The timeUnixNano field is optional according to the OpenTelemetry specification for log data. When timeUnixNano is not present New Relic will use the time that the data was received for the New Relic log timestamp.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 225.10983,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Best practices for <em>OpenTelemetry</em> with New Relic",
        "sections": "Best practices for <em>OpenTelemetry</em> with New Relic",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": " to analyze all your traces, make sure to verify that your <em>OpenTelemetry</em> <em>integrations</em> use the AlwaysOn sampler. Metrics <em>OpenTelemetry</em> metrics are largely compatible with New Relic dimensional metrics. We support <em>OpenTelemetry</em> metrics v0.10. All of the supported metric types include an independent set"
      },
      "id": "60f6b9b964441f5da847ac01"
    }
  ],
  "/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/view-your-opentelemetry-data-new-relic": [
    {
      "sections": [
        "Introduction to OpenTelemetry with New Relic",
        "Benefits of OpenTelemetry",
        "Should I use OpenTelemetry instrumentation or New Relic agents?",
        "OpenTelemetry: A work in progress",
        "New Relic's APM agents",
        "How OpenTelemetry works with New Relic",
        "Important",
        "Traces",
        "Metrics",
        "Logs",
        "Next steps"
      ],
      "title": "Introduction to OpenTelemetry with New Relic",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "67818451ffb7594e3c27526f4082bd1bc007bc51",
      "image": "",
      "url": "https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/introduction-opentelemetry-new-relic/",
      "published_at": "2021-10-24T16:37:27Z",
      "updated_at": "2021-10-24T00:59:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Are you already familiar with OpenTelemetry and want to begin the setup? Check out our quick start: Quick start If you don't have one already, create a New Relic account. It's free, forever. If you're just getting acquainted with OpenTelemetry, this is what we'll explore here: Benefits of OpenTelemetry Should I use OpenTelemetry or New Relic agents? How OpenTelemetry works with New Relic Benefits of OpenTelemetry OpenTelemetry provides a secure, vendor-neutral specification for service instrumentation so that you can export data to distinct backends of your choice, such as New Relic. OpenTelemetry offers a single set of APIs and libraries that standardize how you collect and transfer telemetry data for your services. The following components make up the OpenTelemetry project: Specifications for the core pillars of observability to drive consistency across all projects. New Relic supports all of these signals: traces, metrics, and logs (see details below) APIs that contain interfaces and implementations based on the specifications SDKs (reference implementations of the APIs) created specifically for languages like Java, Python, Go, Erlang, and more Collectors that offer a vendor-agnostic implementation for processing and exporting Exporters that enable you to send data to a backend of your choice The components of OpenTelemetry work together to create some distinct advantages for capturing telemetry data: Feature Description Ubiquitous instrumentation A single, open standard of instrumentation provides better coverage and flexibility as engineers from all over the world contribute to the instrumentation. Future proof As the instrumentation gets built into libraries and frameworks, and as more vendors move to support this open standard, you can be confident that you wonâ€™t need to change your instrumentation. Support for newer technologies When new technologies emerge, contributors can build integrations into OpenTelemetry or add instrumentation directly to source code, ensuring end users can easily monitor these new technologies. Simplified choice You donâ€™t need to decide which instrumentation option to use (a proprietary option or one of the other open standards). Cross-platform compatibility OpenTelemetry supports a variety of languages and backends. It represents a vendor-neutral path for capturing and transmitting telemetry to backends without altering existing instrumentation. Streamlined observability It is easier for vendors to support and test against a single standard as they donâ€™t need to develop their own agents or collectors. High dimensionality OpenTelemetry uses dimensional metrics, so you can filter and facet on more aspects of the data, such as AWS regions, Kubernetes clusters, or service versions. Dimensional metrics also lead to less time between occurrence and reporting. Efficiency OpenTelemetryâ€™s fire-and-forget trace-centric approach to instrumentation often has lower overhead than New Relic agents, especially for asynchronous workloads. It will also result in better handling of trace data for asynchronous requests. Should I use OpenTelemetry instrumentation or New Relic agents? As you consider OpenTelemetry, you may also be looking at New Relic APM agents that also capture telemetry data. As you'd expect, there is a lot of overlap between features available from OpenTelemetry agents and SDKs versus those available from New Relic APM agents. This is especially true if you're interested in distributed tracing telemetry data. The choice you make depends on what you need. We recommend that you explore both New Relic and OpenTelemetry instrumentation or discuss this with us in our CNCF Slack channel to decide what works best for you. OpenTelemetry: A work in progress OpenTelemetry is still an emerging standard, so your choices may be affected by what's available. You can check on the current state of the specification at the OpenTelemetry site. The current state of language-specific OpenTelemetry APIs and SDKs varies: some languages are still pre-alpha and may be missing instructions on how to instrument your service. Most languages have some implementation of traces that is sufficient to start exporting data to New Relic. Check out this table in GitHub that provides an overview of the state of OpenTelemetry specification compliance for each language. For languages that New Relic does not currently provide an agent or SDK, OpenTelemetry may offer you a good alternative. Also, in cases where you want explicit control over sampling of your telemetry data, OpenTelemetry provides a lot of flexibility. As OpenTelemetry matures, New Relic will continue to support new OpenTelemetry data models and to provide a curated UI experience for our customers. New Relic's APM agents In general, New Relic's APM agents will collect more telemetry data for your services, and they offer a wide range of configuration options and an extensive set of auto-instrumentation capabilities. New Relic's APM agents offer detailed transaction trace visibility for individual services. They also offer predefined sampling to balance the performance impact of your instrumentation against the need to capture enough data to gain helpful insights. How OpenTelemetry works with New Relic New Relic supports the native OpenTelemetry Protocol (OTLP) for exporting telemetry data. This allows you to use the vendor neutral components developed by the OpenTelemetry community to export your data to New Relic. The following tables show the supported features for each telemetry signal. If you have questions about these or have an unsupported use case, please contact us in our CNCF Slack channel, and watch this page for future updates. Important New Relic's exporters for OpenTelemetry are now deprecated in favor of exporting data to New Relic using OTLP. Traces New Relic offers support for the OTLP ingest of trace signals. The maturity of the upstream specification is stable. OpenTelemetry traces and spans are compatible with New Relic traces and spans. OpenTelemetry spans optionally include attributes (name-value pairs) and resource attributes which map directly to dimensions that can be used to facet or filter span data at query time. OpenTelemetry span metadata (for example, name, kind, and trace_id) also map directly to dimensions on NewRelic spans. At this time, New Relic does not support span links or array attributes. For details, see the Traces section of our best practices guide. Feature Supported Span events âœ… Span linking âŒ Array of primitives (homogeneous) âŒ Metrics New Relic offers support for the OTLP ingest of metric signals. Note that the maturity of the upstream specification is experimental. We intend to follow potentially breaking upstream changes. Here are the OpenTelemetry data types we support and their associated mappings. For details, see the Metrics section of our best practices guide. Metric Type Supported Delta sums âœ… Cumulative sums âœ… Gauges âœ… Delta histograms âœ… Summary âœ… Cumulative histograms âŒ Exemplars âŒ Array of primitives (homogeneous) âŒ Logs New Relic offers support for the OTLP ingest of log signals. Note that the maturity of the upstream specification is experimental. We intend to follow potentially breaking upstream changes. OpenTelemetry logs are compatible with New Relic logs. OpenTelemetry logs optionally include attributes (name-value pairs) and resource attributes which map directly to dimensions that can be used to facet or filter log data at query time. OpenTelemetry log metadata (for example, name, severity_text, and trace_id) also map directly to dimensions on New Relic logs. NewRelic currently supports all OpenTelemetry log message types except for arrays. For more details, see the Logs section of our best practices guide. Feature Supported Description LogRecord body âœ… Supported types: string, boolean, int, double, bytes LogRecord attributes âœ… Supported types: string, boolean, int, double, bytes LogRecord fields âœ… Examples: name, severity_text, trace_id Array messages âŒ Array attributes âŒ Next steps Follow the OpenTelemetry quick start to help you get started. You'll also want to review the best practices guide for getting the most out of the data you export to New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 398.04083,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>OpenTelemetry</em> with New Relic",
        "sections": "Introduction to <em>OpenTelemetry</em> with New Relic",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": " wonâ€™t need to change your instrumentation. Support for newer technologies When new technologies emerge, contributors can build <em>integrations</em> into <em>OpenTelemetry</em> or add instrumentation directly to <em>source</em> code, ensuring end users can easily monitor these new technologies. Simplified choice You donâ€™t need"
      },
      "id": "6174afe1e7b9d2748213b3a6"
    },
    {
      "sections": [
        "Introduction to OpenTelemetry with New Relic",
        "Benefits of OpenTelemetry",
        "Should I use OpenTelemetry instrumentation or New Relic agents?",
        "OpenTelemetry: A work in progress",
        "New Relic's APM agents",
        "How OpenTelemetry works with New Relic",
        "Important",
        "Traces",
        "Metrics",
        "Logs",
        "Next steps"
      ],
      "title": "Introduction to OpenTelemetry with New Relic",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "c87898d2d5835c00930c173eabd1bf93040badea",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/open-source-telemetry-integrations/opentelemetry/introduction-opentelemetry-new-relic/",
      "published_at": "2021-10-18T15:22:31Z",
      "updated_at": "2021-09-27T15:16:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Are you already familiar with OpenTelemetry and want to begin the setup? Check out our quick start: Quick start If you don't have one already, create a New Relic account. It's free, forever. If you're just getting acquainted with OpenTelemetry, this is what we'll explore here: Benefits of OpenTelemetry Should I use OpenTelemetry or New Relic agents? How OpenTelemetry works with New Relic Benefits of OpenTelemetry OpenTelemetry provides a secure, vendor-neutral specification for service instrumentation so that you can export data to distinct backends of your choice, such as New Relic. OpenTelemetry offers a single set of APIs and libraries that standardize how you collect and transfer telemetry data for your services. The following components make up the OpenTelemetry project: Specifications for the core pillars of observability to drive consistency across all projects. New Relic supports all of these signals: traces, metrics, and logs (see details below) APIs that contain interfaces and implementations based on the specifications SDKs (reference implementations of the APIs) created specifically for languages like Java, Python, Go, Erlang, and more Collectors that offer a vendor-agnostic implementation for processing and exporting Exporters that enable you to send data to a backend of your choice The components of OpenTelemetry work together to create some distinct advantages for capturing telemetry data: Feature Description Ubiquitous instrumentation A single, open standard of instrumentation provides better coverage and flexibility as engineers from all over the world contribute to the instrumentation. Future proof As the instrumentation gets built into libraries and frameworks, and as more vendors move to support this open standard, you can be confident that you wonâ€™t need to change your instrumentation. Support for newer technologies When new technologies emerge, contributors can build integrations into OpenTelemetry or add instrumentation directly to source code, ensuring end users can easily monitor these new technologies. Simplified choice You donâ€™t need to decide which instrumentation option to use (a proprietary option or one of the other open standards). Cross-platform compatibility OpenTelemetry supports a variety of languages and backends. It represents a vendor-neutral path for capturing and transmitting telemetry to backends without altering existing instrumentation. Streamlined observability It is easier for vendors to support and test against a single standard as they donâ€™t need to develop their own agents or collectors. High dimensionality OpenTelemetry uses dimensional metrics, so you can filter and facet on more aspects of the data, such as AWS regions, Kubernetes clusters, or service versions. Dimensional metrics also lead to less time between occurrence and reporting. Efficiency OpenTelemetryâ€™s fire-and-forget trace-centric approach to instrumentation often has lower overhead than New Relic agents, especially for asynchronous workloads. It will also result in better handling of trace data for asynchronous requests. Should I use OpenTelemetry instrumentation or New Relic agents? As you consider OpenTelemetry, you may also be looking at New Relic APM agents that also capture telemetry data. As you'd expect, there is a lot of overlap between features available from OpenTelemetry agents and SDKs versus those available from New Relic APM agents. This is especially true if you're interested in distributed tracing telemetry data. The choice you make depends on what you need. We recommend that you explore both New Relic and OpenTelemetry instrumentation or discuss this with us in our CNCF Slack channel to decide what works best for you. OpenTelemetry: A work in progress OpenTelemetry is still an emerging standard, so your choices may be affected by what's available. You can check on the current state of the specification at the OpenTelemetry site. The current state of language-specific OpenTelemetry APIs and SDKs varies: some languages are still pre-alpha and may be missing instructions on how to instrument your service. Most languages have some implementation of traces that is sufficient to start exporting data to New Relic. Check out this table in GitHub that provides an overview of the state of OpenTelemetry specification compliance for each language. For languages that New Relic does not currently provide an agent or SDK, OpenTelemetry may offer you a good alternative. Also, in cases where you want explicit control over sampling of your telemetry data, OpenTelemetry provides a lot of flexibility. As OpenTelemetry matures, New Relic will continue to support new OpenTelemetry data models and to provide a curated UI experience for our Full Stack Observability customers. New Relic's APM agents In general, New Relic's APM agents will collect more telemetry data for your services, and they offer a wide range of configuration options and an extensive set of auto-instrumentation capabilities. New Relic's APM agents offer detailed transaction trace visibility for individual services. They also offer predefined sampling to balance the performance impact of your instrumentation against the need to capture enough data to gain helpful insights. How OpenTelemetry works with New Relic New Relic supports the native OpenTelemetry Protocol (OTLP) for exporting telemetry data. This allows you to use the vendor neutral components developed by the OpenTelemetry community to export your data to New Relic. The following tables show the supported features for each telemetry signal. If you have questions about these or have an unsupported use case, please contact us in our CNCF Slack channel, and watch this page for future updates. Important New Relic's exporters for OpenTelemetry are now deprecated in favor of exporting data to New Relic using OTLP. Traces New Relic offers support for the OTLP ingest of trace signals. The maturity of the upstream specification is stable. OpenTelemetry traces and spans are compatible with New Relic traces and spans. OpenTelemetry spans optionally include attributes (name-value pairs) and resource attributes which map directly to dimensions that can be used to facet or filter span data at query time. OpenTelemetry span metadata (for example, name, kind, and trace_id) also map directly to dimensions on NewRelic spans. At this time, New Relic does not support span links or array attributes. For details, see the Traces section of our best practices guide. Feature Supported Span events âœ… Span linking âŒ Array of primitives (homogeneous) âŒ Metrics New Relic offers support for the OTLP ingest of metric signals. Note that the maturity of the upstream specification is experimental. We intend to follow potentially breaking upstream changes. Here are the OpenTelemetry data types we support and their associated mappings. For details, see the Metrics section of our best practices guide. Metric Type Supported Delta sums âœ… Cumulative sums âœ… Gauges âœ… Delta histograms âœ… Summary âœ… Cumulative histograms âŒ Exemplars âŒ Array of primitives (homogeneous) âŒ Logs New Relic offers support for the OTLP ingest of log signals. Note that the maturity of the upstream specification is experimental. We intend to follow potentially breaking upstream changes. OpenTelemetry logs are compatible with New Relic logs. OpenTelemetry logs optionally include attributes (name-value pairs) and resource attributes which map directly to dimensions that can be used to facet or filter log data at query time. OpenTelemetry log metadata (for example, name, severity_text, and trace_id) also map directly to dimensions on New Relic logs. NewRelic currently supports all OpenTelemetry log message types except for arrays. For more details, see the Logs section of our best practices guide. Feature Supported Description LogRecord body âœ… Supported types: string, boolean, int, double, bytes LogRecord attributes âœ… Supported types: string, boolean, int, double, bytes LogRecord fields âœ… Examples: name, severity_text, trace_id Array messages âŒ Array attributes âŒ Next steps Follow the OpenTelemetry quick start to help you get started. You'll also want to review the best practices guide for getting the most out of the data you export to New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 225.42593,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>OpenTelemetry</em> with New Relic",
        "sections": "Introduction to <em>OpenTelemetry</em> with New Relic",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": " wonâ€™t need to change your instrumentation. Support for newer technologies When new technologies emerge, contributors can build <em>integrations</em> into <em>OpenTelemetry</em> or add instrumentation directly to <em>source</em> code, ensuring end users can easily monitor these new technologies. Simplified choice You donâ€™t need"
      },
      "id": "603e81ba196a67304da83dab"
    },
    {
      "sections": [
        "Best practices for OpenTelemetry with New Relic",
        "Resources",
        "Batching",
        "Caution",
        "Compression",
        "Traces",
        "Required fields",
        "Sampling",
        "OpenTelemetry built-in samplers",
        "OpenTelemetry tail-based samplers",
        "New Relic tail-based sampling with Infinite Tracing",
        "Important",
        "Metrics",
        "Sum metrics",
        "Delta sums",
        "Cumulative sums",
        "Sum configuration examples",
        "Gauge metrics",
        "Histogram metrics",
        "Summary metrics",
        "Start time",
        "Array values for attributes",
        "Exemplars",
        "How to query metrics",
        "Query cumulative sums stored as gauges",
        "Example: Raw gauge value for cumulative sums",
        "Example: Rate of change with cumulative sums as gauges",
        "Query gauge metrics",
        "Query histogram metrics",
        "Example: Normal distribution",
        "Example: Heat map",
        "Logs",
        "Send logs to New Relic",
        "Application log correlation",
        "View OpenTelemetry logs",
        "The time field"
      ],
      "title": "Best practices for OpenTelemetry with New Relic",
      "type": "docs",
      "tags": [
        "Integrations",
        "Open source telemetry integrations",
        "OpenTelemetry"
      ],
      "external_id": "2b624c5862a5a48d088268eccb310510f372b125",
      "image": "https://docs.newrelic.com/static/764474b6404e7a5c65e55d2eb985e93c/c1b63/sum-derivative-function.png",
      "url": "https://docs.newrelic.com/docs/integrations/open-source-telemetry-integrations/opentelemetry/opentelemetry-concepts/",
      "published_at": "2021-10-24T15:53:24Z",
      "updated_at": "2021-09-27T14:48:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are some best practices based on how OpenTelemetry works with New Relic: Resources Batching Compression Traces Metrics Logs Resources A resource in OpenTelemetry represents information about an entity generating telemetry data. All telemetry data sent to New Relic is expected to be associated with a resource so that it can be linked with the appropriate entity in New Relic. The OpenTelemetry Resource SDK specification defines the functionality implemented by all language SDKs for defining a resource. The following suites of attributes are defined by the OpenTelemetry resource semantic conventions. These attributes are usually set by creating a resource using the OpenTelemetry SDK. service.* attributes service.name attribute is required to associate your resource with an entity in the UI service.instance.id is required for certain panes to light up telemetry.sdk.language=java is required to see data in the JVM section Batching Caution Avoid getting rate limited! You should batch requests sent to the OTLP endpoint as described in this section. By default, the OpenTelemetry SDKs and Collector send one (1) data point per request. Using these defaults, it is likely your account will be rate limited. All OpenTelemetry SDKs and Collectors provide a BatchProcessor, which batches data points in memory. This batching allows requests to be sent with more than one (1) data point. Component Batch Processor Collector Batch Processor Go SDK BatchSpanProcessor JS SDK BatchSpanProcessor Python SDK BatchExportSpanProcessor Compression New Relic supports gzip compression for OTLP payloads exported over gRPC. To maximize the amount of data you can send per request, we recommend enabling compression in all OTLP exporters. If there are other compression formats you'd like to see us support, please let us know in the CNCF Slack channel. Traces Familiarize yourself with these trace topics to ensure your traces and spans appear in New Relic. Required fields The startTimeUnixNano and endTimeUnixNano fields on spans are required according to the OpenTelemetry protocol for trace data. When startTimeUnixNano is not present, the span is dropped and a NrIntegrationError is created. When endTimeUnixNano is not present, the duration of your span is large and negative. The timeUnixNano field on span events is required. When timeUnixNano is not present, the span event is dropped and a NrIntegrationError is created. The traceId and spanId fields on spans are required according to the OpenTelemetry protocol for trace data. When traceId or spanId are not present, the span is dropped and a NrIntegrationError is created. Sampling Trace data is the most mature OpenTelemetry data type. Because of this, New Relic's OpenTelemetry user experience is largely based on trace data and is therefore influenced by your sampling strategy. You can configure sampling in a number of places: Service: Use the OpenTelemetry SDK for your language. Collector: If you're running your own instance of the OpenTelemetry collector, you can configure it to do more sophisticated forms of sampling, such as tail-based sampling (see below). Check out this documentation about how to configure different types of sampling: OpenTelemetry built-in samplers Built-in samplers implemented by the OpenTelemetry SDK for each language. OpenTelemetry tail-based samplers The OpenTelemetry collector has a tail-based sampling processor. We have an example demonstrating the use of the tail-based sampling processor. New Relic tail-based sampling with Infinite Tracing Infinite Tracing is New Relic's tail-based sampling option. You can use this in conjunction with your OpenTelemetry instrumented services. In setting up Infinite Tracing, you need to override the default span endpoint and send telemetry data to the New Relic trace observer: Important Currently, Infinite Tracing does not support OTLP ingest. You must run your own instance of the OpenTelemetry Collector and configure it to use the New Relic exporter. Follow the steps in Set up the trace observer to get the value for YOUR_TRACE_OBSERVER_URL. Use the value of YOUR_TRACE_OBSERVER_URL to configure your integration. Since you want New Relic to analyze all your traces, make sure to verify that your OpenTelemetry integrations use the AlwaysOn sampler. Metrics OpenTelemetry metrics are largely compatible with New Relic dimensional metrics. We support OpenTelemetry metrics v0.10. All of the supported metric types include an independent set of associated attributes (name-value pairs) which map directly to dimensions you can use to facet or filter metric data at query time. OpenTelemetry metrics are accompanied by a set of resource attributes that identify the originating entity that produced them and map to dimensions for faceting and filtering. The OpenTelemetry data model for metrics defines a number of different metric types: sum, gauge, histogram, and summary. Sum metrics OpenTelemetry sums are a scalar metric that is the sum of all data points over a given time window. Sums have a notion of temporality indicating whether reported values incorporate previous measurements (cumulative temporality) or not (delta temporality). In addition, sums can either be monotonic (only go up or only go down) or non-monotonic (go up and down). Delta sums In New Relic, delta metrics are handled differently depending on whether they are monotonic or non-monotonic: Monotonic delta sums are mapped to the count metric type. Non-monotonic delta sums are mapped to the gauge metric type. Cumulative sums Monotonic and non-monotonic cumulative sums are mapped to the New Relic gauge metric type. Sum configuration examples To understand how to configure aggregation temporality, see these examples using the Java and Go OpenTelemetry SDKs. Gauge metrics OpenTelemetry gauge metric data points represent a sampled value at a given time. These values are converted to the New Relic gauge metric type. OpenTelemetry gauges do not have an aggregation temporality, but the sampled values can be aggregated at query time. Histogram metrics OpenTelemetry histograms compactly represent a population of recorded values along with a total count and sum. Optionally, histograms may include a series of buckets with explicit bounds and a count value for that bucketâ€™s population. OpenTelemetry histograms are converted to New Relicâ€™s distribution metric type, which is backed by a scaled exponential base 2 histogram (see NrSketch for a more thorough explanation). Counts from OpenTelemetry histogram buckets are assigned to New Relicâ€™s distribution metric buckets using linear interpolation. Also, OpenTelemetry has negative and positive infinity bound buckets which we represent in New Relic as zero-width buckets. We do this because we do not have a representation for negative and positive infinity. For example, an OpenTelemetry bucket with bounds [-âˆž, 10) will be represented by a [10,10) zero width New Relic bucket. You may see exaggerated bucket counts at the endpoints of your distribution due to this translation. Summary metrics OpenTelemetry summary metric data points are used to represent quantile summaries (for example, P99 latency). These map directly to the New Relic summary metric type. Summary metric data points include count, sum, and quantile values, with 0.0 as min and 1.0 as max. OpenTelemetry provides summary metrics for compatibility with other formats. Start time The startTimeUnixNano field is optional according to the OpenTelemetry specification. When this field is provided, it is used for the timestamp on the resulting NewRelic metric, and the duration is calculated as timeUnixNano - startTimeUnixNano. The duration field is used to calculate the queryable endTimeStamp attribute on the New Relic metric, but it serves no other semantic purpose. If startTimeUnixNano is not provided, then timeUnixNano is used for the timestamp field on the resulting NewRelic metric, and the duration field is set to zero. Array values for attributes OpenTelemetry metrics and other signals may include attributes that consist of a homogenous array of primitive types. These attributes are not supported by New Relic. Exemplars OpenTelemetry defines exemplar values that allow other signals, like traces, to be connected to a metric event and provide context. Exemplars are not supported by New Relic. How to query metrics Consider these tips for building metric NRQL queries in New Relic. Query cumulative sums stored as gauges Since cumulative sums are converted to gauges, here are some ways to query your data: Example: Raw gauge value for cumulative sums To view the raw gauge value for cumulative sums, you can use the latest() NRQL function: SELECT latest(totalApiBytesSent) FROM Metric Copy Example: Rate of change with cumulative sums as gauges To see the rate of change over a given time interval for a cumulative sum stored as a gauge, you can use the derivative() NRQL function: SELECT derivative(totalApiBytesSent, 1 minute) FROM Metric Copy New Relic does not currently support either reporting on resets and gaps or accounting for them with cumulative counters. Query gauge metrics When New Relic converts cumulative sums to gauges, you can query them using either the latest() or derivative() NRQL functions. The function you choose depends on whether you want to see the raw value or compute the rate of change. Query histogram metrics New Relic histograms translated from OpenTelemetry metrics have the same query semantics as other New Relic histograms. Namely, the histogram() NRQL function can be used to represent the histogram with a configurable number of buckets and bucket width. Note that you may see larger bucket counts at the endpoint buckets. This is because we are adding negative and positive infinity bound OpenTelemetry buckets into a zero width New Relic bucket. Example: Normal distribution FROM Metric SELECT histogram(test.histogram, buckets: 100, width: 1000) WHERE distributionType = 'Normal Distribution' SINCE 1 day ago Copy Example: Heat map The FACET keyword is also available to create heat map charts. FROM Metric SELECT histogram(test.histogram, buckets: 100, width: 1000) FACET distributionType SINCE 1 day ago Copy Important The TIMESERIES keyword is not supported for New Relic histograms. Logs Logs generated from your applications and environment are an important piece of telemetry. They may represent application logs, machine generated events, or system logs. OpenTelemetry has defined a log data model for representing log data. You can send logs using OpenTelemetry tooling, correlate them with applications, and view them in New Relic. Send logs to New Relic The OpenTelemetry Collector and OpenTelemetry Collector Contrib repositories contain a number of components for consuming log data. The general pattern is to configure the collector to: Receive logs from any of the log receivers. Some of the receiver options include Filelog Receiver, Fluent Forward Receiver, and Syslog Receiver. Process logs, potentially annotating them with resource information. Some of the processor options include Resource Detection Processor and Resource Processor. Export logs to New Relic via the OTLP exporter. Application log correlation Application logs are more useful if they're correlated with other telemetry data produced by the application. The OpenTelemetry semantic convention for services specifies service.name as a required field. All application metric, trace, and log data sent to New Relic with the same service.name are associated with the same entity. The specifics of how logs get annotated with the service.name resource attribute depends on the application's environment: Applications may produce structured JSON logs, which you can configure to include service.name as another field. You can deploy applications alongside a dedicated Collector Agent instance, which you can configure with a Resource Processor to annotate logs with the service.name attribute. Optionally, additional application trace context (sometimes called execution context) can be propagated to log messages. The setup and availability of this depends on the language and logging framework used by the application. The general strategy is to set up the application to write structured JSON logs and to configure it to extract trace context into specified trace context fields on available log messages. The Logs in Context with Log4j2 example in GitHub demonstrates an end-to-end working example for a simple Java application using Log4j2. View OpenTelemetry logs Here are two ways you can view logs: Look in the New Relic Logs UI. If your logs are correlated with an application, view them in the context of the application. The time field The timeUnixNano field is optional according to the OpenTelemetry specification for log data. When timeUnixNano is not present New Relic will use the time that the data was received for the New Relic log timestamp.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 225.1098,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Best practices for <em>OpenTelemetry</em> with New Relic",
        "sections": "Best practices for <em>OpenTelemetry</em> with New Relic",
        "tags": "<em>Open</em> <em>source</em> <em>telemetry</em> <em>integrations</em>",
        "body": " to analyze all your traces, make sure to verify that your <em>OpenTelemetry</em> <em>integrations</em> use the AlwaysOn sampler. Metrics <em>OpenTelemetry</em> metrics are largely compatible with New Relic dimensional metrics. We support <em>OpenTelemetry</em> metrics v0.10. All of the supported metric types include an independent set"
      },
      "id": "60f6b9b964441f5da847ac01"
    }
  ],
  "/docs/more-integrations/open-source-telemetry-integrations/roku/roku-open-source-video-agent": [
    {
      "sections": [
        "Elixir open-source agent",
        "Tip",
        "Get started",
        "For more help"
      ],
      "title": "Elixir open-source agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Open-source licensed agents",
        "Open-source licensed agents"
      ],
      "external_id": "aa03e1693b6ecdd06fa2940ddb99187247743772",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/open-source-telemetry-integrations/elixir/elixir-open-source-agent/",
      "published_at": "2021-10-24T18:04:55Z",
      "updated_at": "2021-04-27T11:09:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Monitor Elixir behavior with New Relic using the Elixir open-source agent. The agent: Helps you track transactions, distributed traces, and other parts of your applicationâ€™s behavior Provides an overview of underlying BEAM activity Tip This agent is released as open source on GitHub. A change log is also available there for the latest updates. Get started For requirements, installation, and configuration information, see the Open Source Elixir Agent README on GitHub. Visit New Relicâ€™s Elixir repository on GitHub for questions about installation, usage, or other topics. Report issues or bugs as an issue in the GitHub repository. For more help Recommendations for learning more: Browse New Relic's Explorers Hub for community discussions about the open-source Elixir agent. Review New Relic's licenses, attributions, data usage limits, and other notices.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 332.3534,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Elixir <em>open</em>-<em>source</em> <em>agent</em>",
        "sections": "Elixir <em>open</em>-<em>source</em> <em>agent</em>",
        "tags": "<em>Open</em>-<em>source</em> <em>licensed</em> <em>agents</em>",
        "body": "Monitor Elixir behavior with New Relic using the Elixir <em>open</em>-<em>source</em> <em>agent</em>. The <em>agent</em>: Helps you track transactions, distributed traces, and other parts of your applicationâ€™s behavior Provides an overview of underlying BEAM activity Tip This <em>agent</em> is released as <em>open</em> <em>source</em> on GitHub. A change log"
      },
      "id": "6087f0ff28ccbceab351c13f"
    },
    {
      "sections": [
        "Troubleshooting: Missing entities in service maps",
        "Problem",
        "Solution",
        "Tip"
      ],
      "title": "Troubleshooting: Missing entities in service maps",
      "type": "docs",
      "tags": [
        "Understand dependencies",
        "Understand system dependencies",
        "Service maps"
      ],
      "external_id": "44f9c026ad8e1c9d6ba02bd1ec2f2deecbc26832",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/service-maps/troubleshooting-missing-entities-service-maps/",
      "published_at": "2021-10-24T12:02:27Z",
      "updated_at": "2021-10-24T01:50:44Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When using service maps, you can't view the full set of entities or the relationships between entities that you expect to see. Solution Make sure that the entities are being monitored with an agent. If you have a mix of agents with some having distributed tracing turned on and some having it turned off, you will not see the relations between those agents. The solution for this scenario is to run all agents either with distributed tracing turned on (preferred) or turn it off for all agents. If this does not remedy the issue, the service you're trying to view may require manual instrumentation. When you view applications and services that we automatically instrument in service maps, you'll usually see complete and detailed data for those nodes in the distributed tracing UI. However, you may notice that some of these services or applications are missing from service maps. Tip Some browser apps are exceptions to this, and may be missing because: Relationships for copy and paste browser agents are not detected. Only the relationships for injected browser agents is shown (the app the agent is injected into). Call relationships (for example, AJAX calling to other apps) are not displayed. If services or apps are missing, you may want to implement custom instrumentation of applications or specific transactions to see more detail in traces. Some examples of when you may need to do this: Transactions not automatically instrumented. To ensure your application is automatically instrumented, read the compatibility and requirements documentation for the agent you're using. If an application isn't automatically instrumented, or if you'd like to add instrumentation of specific activity, see Custom instrumentation. All Go applications. The Go agent, unlike other agents, requires manual instrumentation of your code. For instructions, see Instrument a Go application. A service doesn't use HTTP. If a service doesn't communicate via HTTP, the agent won't send distributed tracing headers. This may be the case for some non-web applications or message queues. To remedy this, use the distributed tracing APIs to instrument either the calling or called application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 36.2116,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "Problem When using service maps, you can&#x27;t view the full set of entities or the relationships between entities that you expect to see. Solution Make sure that the entities are being monitored with an <em>agent</em>. If you have a mix of <em>agents</em> with some having distributed tracing turned on and some having"
      },
      "id": "603eb369196a67b4aaa83d8d"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/intro-custom-data/",
      "sections": [
        "Introduction to custom data",
        "Options for custom data"
      ],
      "published_at": "2021-10-24T23:24:44Z",
      "title": "Introduction to custom data",
      "updated_at": "2021-10-23T21:59:19Z",
      "type": "docs",
      "external_id": "90d7829dbf9b522ea51f967c628ecbea38917e76",
      "document_type": "page",
      "popularity": 1,
      "body": "To get the most out of New Relic, you may need or want to report custom data to help you get insights about your environment and the unique challenges your organization faces. Options for custom data We have a wide variety of agents and integrations that bring in various types of data. But you may need to bring in data that isn't reported by default. Options for bringing in custom data include: Use our open source telemetry integrations. We have integrations for reporting data from OpenCensus, OpenTelemetry, DropWizard, Prometheus, and more. Configure our agents to send custom data. If you're using one of our APM agents, browser agents, or mobile agents, you can configure them to send custom data. To learn more, see the docs for the tool you're using. Create your own solution for reporting telemetry data with our language-specific Telemetry SDKs. Or use the underlying APIs directly: Metric API, Trace API, Event API, Log API. Report data from your operating system or network. If you're using our infrastructure agent, you might want to use our Flex integration, which lets you use simple config files to report data. Build a New Relic One application. You can build an app that lives on our platform, that can be shared with your team or the public, and that uses your own JavaScript UI functionality. You can analyze New Relic data, or bring in whatever data you want.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 34.521904,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " need to bring in data that isn&#x27;t reported by default. Options for bringing in custom data include: Use our <em>open</em> <em>source</em> telemetry integrations. We have integrations for reporting data from <em>Open</em>Census, <em>Open</em>Telemetry, DropWizard, Prometheus, and more. Configure our <em>agents</em> to send custom data. If you&#x27;re"
      },
      "id": "609fa5a264441f731bd2a1cf"
    }
  ],
  "/docs/network-performance-monitoring/get-started/npm-introduction": [
    {
      "sections": [
        "Advanced configuration for Network Performance Monitoring",
        "SNMP-base YAML sample file",
        "Devices section",
        "Trap section",
        "Discovery section",
        "Global section",
        "SNMPv3 optional configuration",
        "The flow_only attribute",
        "Advanced options for running the ktranslate docker image",
        "Logs sent with Network performance monitoring",
        "Tip",
        "Metrics sent with Network performance monitoring"
      ],
      "title": "Advanced configuration for Network Performance Monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network performance monitoring",
        "Advanced configuration"
      ],
      "external_id": "8262ac964abbda46760776a63b051e05ecfecc4f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/setup-performance-monitoring/advanced-config/",
      "published_at": "2021-10-24T23:40:19Z",
      "updated_at": "2021-10-13T02:04:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you want to explore all the options you can use when configuring the monitoring of your network performance, see the following sections. SNMP-base YAML sample file Here's an example of the various configuration options available in the snmp-base.yaml file used by the ktranslate docker image to poll for SNMP and flow data devices. devices: deviceOne: device_name: router123 device_ip: 10.10.0.201 oid: .1.3.6.1.4.1.2636.1.1.1.2.21.0 snmp_comm: public poll_time_sec: 300 user_tags: owning_team: net_eng environment: production trap: listen: 127.0.0.1:162 community: public version: \"\" transport: \"\" discovery: cidrs: - 10.10.0.0/24 - 10.20.0.0/24 - 192.168.0.21/32 debug: false ports: - 161 - 1161 default_communities: - public default_v3: null add_devices: true threads: 4 use_snmp_v1: false replace_devices: true global: poll_time_sec: 60 timeout_ms: 5000 retries: 0 mibs_enabled: - IF-MIB drop_if_outside_poll: false mib_profile_dir: profiles Copy Devices section Option name Required Description device_name âœ“ Name of the device reporting to New Relic One device_ip âœ“ IP to send SNMP queries to port Port to send SNMP queries to. By default, it's set to port 161 provider Value used during entity synthesis for New Relic One mib_profile SNMP Profile file that was associated with this device during the discovery run based on its sysOID snmp_comm âœ“ SNMPv1/2c community string to use. For SNMPv3, set it to snmp_v3 use_snmp_v1 Indicates whether to use SNMPv1. By default, it's set to false snmp_v3 SNMPv3 authentication configuration poll_time_sec Indicates the polling frequency in seconds. This setting is used to override the global.poll_time_sec attribute. timeout_ms Indicates the polling timeout in milliseconds. By default, it's set to 5000 retries Indicates the number of attempts to retry to get the device information. By default, it's set to 0 last_checked Timestamp when this device was last discovered by the ktranslate docker image oid âœ“ sysOID for the device description Description of the device discovered_mibs List of MIBs from our known SNMP profiles this device can respond to, found during discovery by the ktranslate docker image debug Indicates whether to run SNMP polling in debug mode. By default, it's set to false user_tags Additional key:value pair attributes to give more context to the device. For example, environment: production match_attributes Additional attribute:regex pairs to whitelist metrics. Only matching attributes are sent. For example, if_Description: \"^igb|^eth\" monitor_admin_shut Indicates whether the monitor shuts interfaces also. By default, it's set to false Trap section Option name Required Description listen âœ“ Listening IP port for receiving SNMP traps community SNMP community string for receiving SNMP traps version SNMP version to use. Options are v1, v2c, and v3. (Default: v2c) transport SNMP transport protocol to use. The possible values are TCP and UDP. By default, it's set to UDP v3_config SNMP v3 config to use. Only used if version is v3. Discovery section Option name Required Description cidrs âœ“ Array of target IP ranges in CIDR notation. You can add /32 at the end of the IP to poll for SNMP devices without testing with ICMP echo. Optionally, you can point to a cidrs.yaml file in the snmp-base.yaml file: discovery: cidrs: \"@cidrs.yaml\" Copy The cidrs.yaml file should be similar to the following - 10.10.0.0/24 - 10.20.0.0/24 - 192.168.0.21/32 Copy ports âœ“ Array of target ports to scan during SNMP polling default_communities âœ“ Array of SNMPv1/v2c community strings to scan during SNMP polling. This array is evaluated in order and discovery accepts the first passing community. For SNMPv3, set it to default_v3 default_v3 SNMPv3 configuration to scan during SNMP polling use_snmp_v1 Indicates whether to use SNMPv1 during discovery. By default, it's set to false add_devices âœ“ Indicates whether to add discovered devices to the devices section of the snmp-base.yaml file. By default, it's set to true add_mibs âœ“ Indicates whether to add discovered MIBs to the global.mibs_enabled section of the snmp-base.yaml file. By default, it's set to true replace_devices âœ“ Indicates whether to replace discovered devices if they already exist in the devices section of the snmp-base.yaml file. By default, it's set to true debug Indicates whether to enable debug level logging during discovery. By default, it's set to false threads âœ“ Integer limit of threads to use during discovery. It must be less than the number of cores available to the container Global section Option name Required Description poll_time_sec âœ“ Time in seconds to poll devices. By default, it's set to 60 timeout_ms âœ“ Time in milliseconds queries timeout. By default, it's set to 5000 retries âœ“ Number of attempts to retry failed polls. By default, it's set to 0 mibs_enabled âœ“ Array of all active MIBs the ktranslate docker image will poll. Polling only occurs if the MIB is valid for a given device drop_if_outside_poll Indicates whether to drop all values from this cycle if polling takes longer than the value set in poll_time_sec. By default, it's set to false mib_profile_dir Directory to find curated MIB profiles SNMPv3 optional configuration Here's an example of SNMPv3 configuration section for the snmp-base.yaml file: yaml default_v3: user_name: userNamev3 authentication_protocol: MD5 authentication_passphrase: authPassPrivacy privacy_protocol: AES256 privacy_passphrase: passPrivacy Copy Option name Required Description user_name âœ“ User name for SNMPv3 authentication authentication_protocol âœ“ SNMPv3 authentication protocol. The possible values are NoAuth, MD5, or SHA authentication_passphrase SNMPv3 authentication passphrase privacy_protocol âœ“ SNMPv3 privacy protocol. The possible values are AuthNoPriv, DES, AES, AES192, AES256, AES192C, or AES256C privacy_passphrase SNMPv3 privacy passphrase context_engine_id SNMPv3 context engine ID context_name SNMPv3 context name The flow_only attribute There are several supported configurations available for running ktranslate against devices for both SNMP and network flow data collection. The flow_only attribute on both a ktranslate docker container level and in the devices section of the snmp-base.yaml file allows you to get different results: If you have multiple containers collecting both SNMP and network flow data with the ktranslate docker image, define your devices in the snmp-base.yaml file, following the standards for SNMP data polling. They will be automatically matched to their respective flows based on their device_ip matching the sampling IP for the flow device. For network flow data devices, run the ktranslate docker image with the -flow_only=true option. snmp-base.yaml file - No setting changes needed If you have multiple containers collecting both SNMP and network flow data with the ktranslate docker image, and you have specific devices where you only want network flow or SNMP data collection and no SNMP or network flow data polling respectively, you can set them up in their respective device configuration section in the snmp-base.yaml file. For network flow data devices, run the ktranslate docker image with the -flow_only=true option. snmp-base.yaml file - Change the flow_only to true: flow_only: true Copy Advanced options for running the ktranslate docker image In this table you can find additional options you can use with the ktranslate docker image. Option name Description -max_threads Lets you process higher volumes of flow. We recommend one CPU core available for every 2,000 flows per second (fps) of network flow data sent. -sample_rate=100 Changes the default sample rate value at which flows are passed to New Relic One Events. It also sets the sample rate value for flow types that don't have a default sample rate value. -nf.workers=1 Overrides the number of workers used in processing udp packets. Use one worker for every 4,000 of flows per second (fps) of network flow data sent. -nf.port Overrides the default 9995 listening port for incoming flow packets. -listen Overrides the default 8082 port used by ktranslate to expose health metrics. You must use this option when running multiple ktranslate containers on a single host. -metalisten Overrides the default 8083 port used by ktranslate to expose metadata. You must use this option when running multiple ktranslate containers on a single host. -metrics=jchf Forwards health metrics from ktranslate into New Relic One. -log_level Overrides the default info log level for ktranslate. The available options are debug, info, warn, or error. -tee_logs Forwards logs from ktranslate into New Relic One Logs. HTTPS_PROXY Environment variable that can be used during Docker runtime to setup ktranslate to ship data to New Relic via proxy. Ex: -e HTTPS_PROXY=https://user:password@hostname:port You can also run several ktranslate images to monitor different network flow types simultaneously. See the follwing example: bash Copy $ docker run -d --name ktranslate-sflow --net=host \\ > -e NEW_RELIC_API_KEY=$INSERT_API_KEY \\ > kentik/ktranslate:v2 \\ > -snmp /snmp-base.yaml \\ > -nr_account_id=$NR_ACCOUNT_ID \\ > -metrics=jchf \\ > -log_level=info \\ > -tee_logs=true \\ > -nf.source=sflow \\ > -nf.port=9996 \\ > -max_threads=1 \\ > -listen 0.0.0.0:8084 \\ > -metalisten 0.0.0.0:8085 \\ > nr1.flow $ $ $ docker run -d --name ktranslate-netflow9 --net=host \\ > -e NEW_RELIC_API_KEY=$INSERT_API_KEY \\ > kentik/ktranslate:v2 \\ > -snmp /snmp-base.yaml \\ > -nr_account_id=$NR_ACCOUNT_ID \\ > -metrics=jchf \\ > -log_level=info \\ > -tee_logs=true \\ > -nf.source=netflow9 \\ > -nf.port=2055 \\ > -max_threads=2 \\ > -listen 0.0.0.0:8086 \\ > -metalisten 0.0.0.0:8087 \\ > nr1.flow Logs sent with Network performance monitoring If you want to check the logs locally, run docker logs ktranslate-snmp. The -tee_logs=true option sends logs to New Relic One when polling devices. To see them, do the following: Go to one.newrelic.com > Logs. In Find logs where enter collector.name:\"ktranslate\" and click Query logs. Tip If you want to filter out all the information messages, enter collector.name:\"ktranslate\" message:-*\\[Info\\]*. Metrics sent with Network performance monitoring The -metrics option captures one of the following performance metrics when polling devices: Metric Description baseserver_healthcheck_execution_total Rate of internal health checks. Shows mostly that things are not deadlocked. delivery_metrics_nr Rate of metrics sent to New Relic One. delivery_logs_nr Rate of logs sent to New Relic One. delivery_wins_nr Rate of 200 HTTP codes received from sending metrics and events to New Relic One. device_metrics Rate of SNMP polling of device level metrics. inputq Messages per second (msg/sec) recieved over the last 60 seconds from SNMP or network flow devices. interface_metrics Rate of SNMP polling of interface level metrics. jchfq Gauge rate with number of available pre-allocated buffers. It should be 8,000 aproximately. To see these metrics in New Relic One: Go to one.newrelic.com and click Query your data. Enter the following NRQL query: FROM Metric SELECT latest(kentik.ktranslate.chf.kkc.baseserver_healthcheck_execution_total) AS 'baseserver_healthcheck_execution_total', latest(kentik.ktranslate.chf.kkc.delivery_metrics_nr) AS 'delivery_metrics_nr', latest(kentik.ktranslate.chf.kkc.delivery_logs_nr) AS 'delivery_logs_nr', latest(kentik.ktranslate.chf.kkc.delivery_wins_nr) AS 'delivery_wins_nr', latest(kentik.ktranslate.chf.kkc.device_metrics) AS 'device_metrics', latest(kentik.ktranslate.chf.kkc.inputq) AS 'inputq', latest(kentik.ktranslate.chf.kkc.interface_metrics) AS 'interface_metrics', latest(kentik.ktranslate.chf.kkc.jchfq) AS 'jchfq' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' LIMIT MAX Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 164.84386,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Advanced configuration for <em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "sections": "Advanced configuration for <em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "tags": "<em>Network</em> <em>performance</em> <em>monitoring</em>",
        "body": "If you want to explore all the options you can use when configuring the <em>monitoring</em> of your <em>network</em> <em>performance</em>, see the following sections. SNMP-base YAML sample file Here&#x27;s an example of the various configuration options available in the snmp-base.yaml file used by the ktranslate docker image"
      },
      "id": "6127249be7b9d29922f565b0"
    },
    {
      "sections": [
        "Introduction to New Relic integrations",
        "Choose what's right for you",
        "Create your own solutions"
      ],
      "title": "Introduction to New Relic integrations",
      "type": "docs",
      "tags": [
        "Instrument everything",
        "Get started"
      ],
      "external_id": "9a44613b8a5ec0a9c9570b22c7d2f3ea726f2671",
      "image": "",
      "url": "https://docs.newrelic.com/docs/using-new-relic/welcome-new-relic/get-started/introduction-new-relic-integrations/",
      "published_at": "2021-10-24T11:54:18Z",
      "updated_at": "2021-10-24T00:59:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We provide hundreds of solutions to get your data into New Relic so you can analyze the data in one place. They give you a steady flow of useful data to fix problems quickly, maintain complex systems, improve your code, and accelerate your digital transformation. You can bring in data from hundreds of applications, frameworks, services, operating systems, and other technologies. Our integrations gather the data, and the agents send it to New Relic. The solution you need may require you to install both an integration and an agent. In some cases, you can just install our agents that contain integrations, such as our APM agents. Whatever data you need to bring in, chances are that we have options for your environment. If you prefer to make your own solutions, we also offer tools to get you started. Choose what's right for you We offer a wide range of solutions so you can easily collect data across your environment. You may only need one of our solutions to get the data you need, or you can choose a variety of options to capture a broader range of data types. Go to New Relic Integrations to find solutions that fit your environment. Here is a sample of what youâ€™ll find there: Application performance monitoring (APM): C, Go, Java, Node, .NET, PHP, Python, and Ruby Mobile apps: Android and iOS Browser monitoring: Google Chrome, Mozilla Firefox, Microsoft Internet Explorer, and Apple Safari Host monitoring: Linux and Microsoft Windows Cloud platform monitoring: Amazon Web Services (AWS), Microsoft Azure, and Google Cloud Platform (GCP) Core infrastructure services: Kubernetes, NGINX, MySQL, and more Open source telemetry integrations: Prometheus, Micrometer, OpenTelemetry, and more Create your own solutions If you are looking for custom options, we have tools to help you create your own: Use New Relic Flex to create lightweight monitoring solutions using infrastructure monitoring. Use New Relic Telemetry SDKs to build custom solutions for sending metrics, traces, and more. Build your own New Relic One applications that you can share with your colleagues, or edit open source applications in our catalog.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.74167,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic <em>integrations</em>",
        "sections": "Introduction to New Relic <em>integrations</em>",
        "tags": "<em>Get</em> <em>started</em>",
        "body": " <em>integrations</em>, such as our APM agents. Whatever data you need to bring in, chances are that we have options for your environment. If you prefer to make your own solutions, we also offer tools to <em>get</em> you <em>started</em>. Choose what&#x27;s right for you We offer a wide range of solutions so you can easily collect"
      },
      "id": "603e817f28ccbc4857eba798"
    },
    {
      "sections": [
        "Set up network flow data monitoring",
        "Prerequisites",
        "New Relic One account prerequisites",
        "Linux host prerequisites",
        "Network flow data devices prerequisites",
        "Network security prerequisites",
        "Supported types of network flow data",
        "Important",
        "Scaling network flow collection",
        "Set up network flow data monitoring in New Relic One",
        "Manual setup",
        "Tip"
      ],
      "title": "Set up network flow data monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring",
        "Installation",
        "Setup",
        "NPM"
      ],
      "external_id": "626c9bebce36e550d5793d8ef932e6d654c23e47",
      "image": "https://docs.newrelic.com/static/3d1561743f3311471975006fa41f628a/c1b63/network-flows-guided-install.png",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/setup-performance-monitoring/network-flow-monitoring/",
      "published_at": "2021-10-24T23:40:19Z",
      "updated_at": "2021-10-13T03:31:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Set up your network devices so they send network data to New Relic One. Prerequisites New Relic One account prerequisites A New Relic account. Don't have one? Sign up for free! No credit card required. A New Relic account ID. Read how to find your account ID. A New Relic license key. Read how to generate a new License key. Linux host prerequisites Docker installed in a Linux host. SSH access to the Docker host, with the ability to launch new containers. Network flow data devices prerequisites Configured network devices to send flow data to the host running the ktranslate docker container. Here's how to configure network flow data collection in some devices: NetFlow data Palo Alto - PAN-OS Fortinet Fortigate Cisco - NX-OS Cisco - IOS Cisco - Meraki sFlow data F5 - BIG-IP jFlow data Juniper - Junos Network security prerequisites Direction Source Destination Ports Protocol Outbound Docker host ktranslate image on Docker Hub 443 TCP Outbound Docker host New Relic Event API US Endpoint: https://insights-collector.newrelic.com EU Endpoint: https://insights-collector.eu01.nr-data.net 443 TCP Outbound Docker host New Relic Log API US Endpoint: https://log-api.newrelic.com EU Endpoint: https://log-api.eu.newrelic.com 443 TCP Inbound Source devices for network flow data Docker host 9995 (default) UDP Supported types of network flow data NPM flow monitoring supports the four primary types of network flow data and their derivatives. When running the ktranslate container, you will specify which major type you want to monitor using the -nf.source option. Important The ktranslate container only supports monitoring one type of network flow data type at a time. If you want to monitor several types, each will require a container. IPFIX and NetFlow v9 can be sent to the same container, but we recommend running a separate container as a best practice. Network flow data type -nf.source value IPFIX ipfix NetFlow v5 netflow5 NetFlow v9 netflow9 sFlow sflow AppFlow netflow5 Argus netflow5 cflowd netflow5 J-Flow netflow5 NetStream netflow5 RFlow netflow5 Cisco NSEL netflow9 Scaling network flow collection When planning your strategy for collecting network flows at scale, New Relic recommends 1 CPU per 2000 flows-per-second (120,000 flows-per-minute). Deciding whether to run more small containers to distribute load or fewer large containers to consolidate management is a matter of personal preference. Set up network flow data monitoring in New Relic One Go to one.newrelic.com and click Add more data. Scroll down until you see Network performance monitoring and click Network Flows. Follow the steps in New Relic One. one.newrelic.com > Add more data > Network performance monitoring > Network Flows to set up network flow data monitoring. To get better visibility into your network device performance, set up SNMP data monitoring. Visualize your network performance data in New Relic. Manual setup If you prefer to do the setup manually, proceed with the following steps. In your local machine, from a Linux host with Docker installed, download the ktranslate image from dockerhub by running bash Copy $ docker pull kentik/ktranslate:v2 Copy the snmp-base.yaml file to the local $HOME directory of your Docker user, and discard the container by running bash Copy $ cd . $ id=$(docker create kentik/ktranslate:v2) $ docker cp $id:/etc/ktranslate/snmp-base.yaml . $ docker rm -v $id In the snmp-base.yaml file, add your network flow devices inside the devices key with the following structure: devices: flowDevice: device_name: edge-router device_ip: 10.10.1.254 flow_only: true # Optional user tags user_tags: owning_team: net_eng environment: production Copy Tip If you're already monitoring SNMP data devices that send network flow data, you don't need to add them in your snmp-base.yaml file a second time. Run ktranslate to listen for network flows by running: Tip Add your New Relic license key and your account ID in the $NR_LICENSE_KEY and $NR_ACCOUNT_ID variables respectively. bash Copy $ docker run -d --name ktranslate-sflow --restart unless-stopped --net=host \\ > -v `pwd`/snmp-base.yaml:/snmp-base.yaml \\ > -e NEW_RELIC_API_KEY=$NR_LICENSE_KEY \\ > kentik/ktranslate:v2 \\ > -snmp /snmp-base.yaml \\ > -nr_account_id=$NR_ACCOUNT_ID \\ > -metrics=jchf \\ > -log_level=info \\ > -tee_logs=true \\ > -flow_only=true \\ > -nf.source=sflow \\ > nr1.flow $ ## If your account is located in Europe, you need to add the following option before the nr1.flow line $ ## -nr_region=EU \\ Tip This command assumes collection of sflow data. If you are collecting other flow types, you should change the suffix in the --name flag for the container and update the -nf.source argument as necessary To get better visibility into your network device performance, set up SNMP data monitoring. Visualize your network performance data in New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 139.77235,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Set up <em>network</em> flow data <em>monitoring</em>",
        "sections": "Set up <em>network</em> flow data <em>monitoring</em>",
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": " <em>monitoring</em> &gt; <em>Network</em> Flows to set up <em>network</em> flow data <em>monitoring</em>. To <em>get</em> better visibility into your <em>network</em> device <em>performance</em>, set up SNMP data <em>monitoring</em>. Visualize your <em>network</em> <em>performance</em> data in New Relic. Manual setup If you prefer to do the setup manually, proceed with the following steps. In your"
      },
      "id": "612724e128ccbc4ac9f2612a"
    }
  ],
  "/docs/network-performance-monitoring/monitoring-network-data/visualize-network-data": [
    {
      "sections": [
        "Get started with Network Performance Monitoring",
        "Types of network performance data",
        "Important",
        "High level architecture overview"
      ],
      "title": "Get started with Network Performance Monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring",
        "Get started"
      ],
      "external_id": "96d12e2c5551a6e5eab76238cd2b787e5c188c01",
      "image": "https://docs.newrelic.com/static/eb0db7c88b717f386c4900a04e12a8ed/e5166/overview_navigator.jpg",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/get-started/npm-introduction/",
      "published_at": "2021-10-24T23:38:43Z",
      "updated_at": "2021-10-24T01:46:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When system performance suffers, you need to know if itâ€™s due to your code, your infrastructure, or the underlying network. And you need to know fast, so you can focus your efforts. With Network Performance Monitoring you can correlate and analyze application, infrastructure, digital experience, and network data all in one place, and understand how network performance and overall system performance impact each other. Using Navigator with Network Performance Monitoring. Network Performance Monitoring adds the context of network data to the application and infrastructure data you already collect in New Relic One. By monitoring your network data, you can: Analyze and understand the performance of your entire stack (application and infrastructure) for a holistic understanding of your system performance. Have all the data in a single platform to eliminate blind spots. See at first glance whether a network is implicated in an issue. Sign up for free! No credit card required. Already have an account? Login. Types of network performance data You can monitor the following types of network performance data: SNMP data: Simple Network Management Protocol (SNMP) is an applicationâ€“layer protocol for exchanging management information between network devices. To send SNMP data to New Relic One, see Set up SNMP data monitoring. Network flow data: It captures information about the IP traffic going to and from network interfaces in your on-premises network. To send network flow data to New Relic One, see Set up network flow data monitoring. Important We recommend configuring both SNMP and network flow data for better visibility into your network. This will provide both performance metrics and traffic patterns to troubleshoot and optimize your network. High level architecture overview Our solution is based on the ktranslate docker container developed by our partner, Kentik. This single container image is hosted in your environment to collect and process your data to be exported to the Event, Metric, and Log APIs and displayed in New Relic One. Overview of Network Performance Monitoring architecture.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 276.26126,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get started with <em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "sections": "Get started with <em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": "When system <em>performance</em> suffers, you need to know if itâ€™s due to your code, your infrastructure, or the underlying <em>network</em>. And you need to know fast, so you can focus your efforts. With <em>Network</em> <em>Performance</em> <em>Monitoring</em> you can correlate and analyze application, infrastructure, digital experience"
      },
      "id": "6126f39b28ccbc8c49f26162"
    },
    {
      "sections": [
        "Advanced configuration for Network Performance Monitoring",
        "SNMP-base YAML sample file",
        "Devices section",
        "Trap section",
        "Discovery section",
        "Global section",
        "SNMPv3 optional configuration",
        "The flow_only attribute",
        "Advanced options for running the ktranslate docker image",
        "Logs sent with Network performance monitoring",
        "Tip",
        "Metrics sent with Network performance monitoring"
      ],
      "title": "Advanced configuration for Network Performance Monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network performance monitoring",
        "Advanced configuration"
      ],
      "external_id": "8262ac964abbda46760776a63b051e05ecfecc4f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/setup-performance-monitoring/advanced-config/",
      "published_at": "2021-10-24T23:40:19Z",
      "updated_at": "2021-10-13T02:04:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you want to explore all the options you can use when configuring the monitoring of your network performance, see the following sections. SNMP-base YAML sample file Here's an example of the various configuration options available in the snmp-base.yaml file used by the ktranslate docker image to poll for SNMP and flow data devices. devices: deviceOne: device_name: router123 device_ip: 10.10.0.201 oid: .1.3.6.1.4.1.2636.1.1.1.2.21.0 snmp_comm: public poll_time_sec: 300 user_tags: owning_team: net_eng environment: production trap: listen: 127.0.0.1:162 community: public version: \"\" transport: \"\" discovery: cidrs: - 10.10.0.0/24 - 10.20.0.0/24 - 192.168.0.21/32 debug: false ports: - 161 - 1161 default_communities: - public default_v3: null add_devices: true threads: 4 use_snmp_v1: false replace_devices: true global: poll_time_sec: 60 timeout_ms: 5000 retries: 0 mibs_enabled: - IF-MIB drop_if_outside_poll: false mib_profile_dir: profiles Copy Devices section Option name Required Description device_name âœ“ Name of the device reporting to New Relic One device_ip âœ“ IP to send SNMP queries to port Port to send SNMP queries to. By default, it's set to port 161 provider Value used during entity synthesis for New Relic One mib_profile SNMP Profile file that was associated with this device during the discovery run based on its sysOID snmp_comm âœ“ SNMPv1/2c community string to use. For SNMPv3, set it to snmp_v3 use_snmp_v1 Indicates whether to use SNMPv1. By default, it's set to false snmp_v3 SNMPv3 authentication configuration poll_time_sec Indicates the polling frequency in seconds. This setting is used to override the global.poll_time_sec attribute. timeout_ms Indicates the polling timeout in milliseconds. By default, it's set to 5000 retries Indicates the number of attempts to retry to get the device information. By default, it's set to 0 last_checked Timestamp when this device was last discovered by the ktranslate docker image oid âœ“ sysOID for the device description Description of the device discovered_mibs List of MIBs from our known SNMP profiles this device can respond to, found during discovery by the ktranslate docker image debug Indicates whether to run SNMP polling in debug mode. By default, it's set to false user_tags Additional key:value pair attributes to give more context to the device. For example, environment: production match_attributes Additional attribute:regex pairs to whitelist metrics. Only matching attributes are sent. For example, if_Description: \"^igb|^eth\" monitor_admin_shut Indicates whether the monitor shuts interfaces also. By default, it's set to false Trap section Option name Required Description listen âœ“ Listening IP port for receiving SNMP traps community SNMP community string for receiving SNMP traps version SNMP version to use. Options are v1, v2c, and v3. (Default: v2c) transport SNMP transport protocol to use. The possible values are TCP and UDP. By default, it's set to UDP v3_config SNMP v3 config to use. Only used if version is v3. Discovery section Option name Required Description cidrs âœ“ Array of target IP ranges in CIDR notation. You can add /32 at the end of the IP to poll for SNMP devices without testing with ICMP echo. Optionally, you can point to a cidrs.yaml file in the snmp-base.yaml file: discovery: cidrs: \"@cidrs.yaml\" Copy The cidrs.yaml file should be similar to the following - 10.10.0.0/24 - 10.20.0.0/24 - 192.168.0.21/32 Copy ports âœ“ Array of target ports to scan during SNMP polling default_communities âœ“ Array of SNMPv1/v2c community strings to scan during SNMP polling. This array is evaluated in order and discovery accepts the first passing community. For SNMPv3, set it to default_v3 default_v3 SNMPv3 configuration to scan during SNMP polling use_snmp_v1 Indicates whether to use SNMPv1 during discovery. By default, it's set to false add_devices âœ“ Indicates whether to add discovered devices to the devices section of the snmp-base.yaml file. By default, it's set to true add_mibs âœ“ Indicates whether to add discovered MIBs to the global.mibs_enabled section of the snmp-base.yaml file. By default, it's set to true replace_devices âœ“ Indicates whether to replace discovered devices if they already exist in the devices section of the snmp-base.yaml file. By default, it's set to true debug Indicates whether to enable debug level logging during discovery. By default, it's set to false threads âœ“ Integer limit of threads to use during discovery. It must be less than the number of cores available to the container Global section Option name Required Description poll_time_sec âœ“ Time in seconds to poll devices. By default, it's set to 60 timeout_ms âœ“ Time in milliseconds queries timeout. By default, it's set to 5000 retries âœ“ Number of attempts to retry failed polls. By default, it's set to 0 mibs_enabled âœ“ Array of all active MIBs the ktranslate docker image will poll. Polling only occurs if the MIB is valid for a given device drop_if_outside_poll Indicates whether to drop all values from this cycle if polling takes longer than the value set in poll_time_sec. By default, it's set to false mib_profile_dir Directory to find curated MIB profiles SNMPv3 optional configuration Here's an example of SNMPv3 configuration section for the snmp-base.yaml file: yaml default_v3: user_name: userNamev3 authentication_protocol: MD5 authentication_passphrase: authPassPrivacy privacy_protocol: AES256 privacy_passphrase: passPrivacy Copy Option name Required Description user_name âœ“ User name for SNMPv3 authentication authentication_protocol âœ“ SNMPv3 authentication protocol. The possible values are NoAuth, MD5, or SHA authentication_passphrase SNMPv3 authentication passphrase privacy_protocol âœ“ SNMPv3 privacy protocol. The possible values are AuthNoPriv, DES, AES, AES192, AES256, AES192C, or AES256C privacy_passphrase SNMPv3 privacy passphrase context_engine_id SNMPv3 context engine ID context_name SNMPv3 context name The flow_only attribute There are several supported configurations available for running ktranslate against devices for both SNMP and network flow data collection. The flow_only attribute on both a ktranslate docker container level and in the devices section of the snmp-base.yaml file allows you to get different results: If you have multiple containers collecting both SNMP and network flow data with the ktranslate docker image, define your devices in the snmp-base.yaml file, following the standards for SNMP data polling. They will be automatically matched to their respective flows based on their device_ip matching the sampling IP for the flow device. For network flow data devices, run the ktranslate docker image with the -flow_only=true option. snmp-base.yaml file - No setting changes needed If you have multiple containers collecting both SNMP and network flow data with the ktranslate docker image, and you have specific devices where you only want network flow or SNMP data collection and no SNMP or network flow data polling respectively, you can set them up in their respective device configuration section in the snmp-base.yaml file. For network flow data devices, run the ktranslate docker image with the -flow_only=true option. snmp-base.yaml file - Change the flow_only to true: flow_only: true Copy Advanced options for running the ktranslate docker image In this table you can find additional options you can use with the ktranslate docker image. Option name Description -max_threads Lets you process higher volumes of flow. We recommend one CPU core available for every 2,000 flows per second (fps) of network flow data sent. -sample_rate=100 Changes the default sample rate value at which flows are passed to New Relic One Events. It also sets the sample rate value for flow types that don't have a default sample rate value. -nf.workers=1 Overrides the number of workers used in processing udp packets. Use one worker for every 4,000 of flows per second (fps) of network flow data sent. -nf.port Overrides the default 9995 listening port for incoming flow packets. -listen Overrides the default 8082 port used by ktranslate to expose health metrics. You must use this option when running multiple ktranslate containers on a single host. -metalisten Overrides the default 8083 port used by ktranslate to expose metadata. You must use this option when running multiple ktranslate containers on a single host. -metrics=jchf Forwards health metrics from ktranslate into New Relic One. -log_level Overrides the default info log level for ktranslate. The available options are debug, info, warn, or error. -tee_logs Forwards logs from ktranslate into New Relic One Logs. HTTPS_PROXY Environment variable that can be used during Docker runtime to setup ktranslate to ship data to New Relic via proxy. Ex: -e HTTPS_PROXY=https://user:password@hostname:port You can also run several ktranslate images to monitor different network flow types simultaneously. See the follwing example: bash Copy $ docker run -d --name ktranslate-sflow --net=host \\ > -e NEW_RELIC_API_KEY=$INSERT_API_KEY \\ > kentik/ktranslate:v2 \\ > -snmp /snmp-base.yaml \\ > -nr_account_id=$NR_ACCOUNT_ID \\ > -metrics=jchf \\ > -log_level=info \\ > -tee_logs=true \\ > -nf.source=sflow \\ > -nf.port=9996 \\ > -max_threads=1 \\ > -listen 0.0.0.0:8084 \\ > -metalisten 0.0.0.0:8085 \\ > nr1.flow $ $ $ docker run -d --name ktranslate-netflow9 --net=host \\ > -e NEW_RELIC_API_KEY=$INSERT_API_KEY \\ > kentik/ktranslate:v2 \\ > -snmp /snmp-base.yaml \\ > -nr_account_id=$NR_ACCOUNT_ID \\ > -metrics=jchf \\ > -log_level=info \\ > -tee_logs=true \\ > -nf.source=netflow9 \\ > -nf.port=2055 \\ > -max_threads=2 \\ > -listen 0.0.0.0:8086 \\ > -metalisten 0.0.0.0:8087 \\ > nr1.flow Logs sent with Network performance monitoring If you want to check the logs locally, run docker logs ktranslate-snmp. The -tee_logs=true option sends logs to New Relic One when polling devices. To see them, do the following: Go to one.newrelic.com > Logs. In Find logs where enter collector.name:\"ktranslate\" and click Query logs. Tip If you want to filter out all the information messages, enter collector.name:\"ktranslate\" message:-*\\[Info\\]*. Metrics sent with Network performance monitoring The -metrics option captures one of the following performance metrics when polling devices: Metric Description baseserver_healthcheck_execution_total Rate of internal health checks. Shows mostly that things are not deadlocked. delivery_metrics_nr Rate of metrics sent to New Relic One. delivery_logs_nr Rate of logs sent to New Relic One. delivery_wins_nr Rate of 200 HTTP codes received from sending metrics and events to New Relic One. device_metrics Rate of SNMP polling of device level metrics. inputq Messages per second (msg/sec) recieved over the last 60 seconds from SNMP or network flow devices. interface_metrics Rate of SNMP polling of interface level metrics. jchfq Gauge rate with number of available pre-allocated buffers. It should be 8,000 aproximately. To see these metrics in New Relic One: Go to one.newrelic.com and click Query your data. Enter the following NRQL query: FROM Metric SELECT latest(kentik.ktranslate.chf.kkc.baseserver_healthcheck_execution_total) AS 'baseserver_healthcheck_execution_total', latest(kentik.ktranslate.chf.kkc.delivery_metrics_nr) AS 'delivery_metrics_nr', latest(kentik.ktranslate.chf.kkc.delivery_logs_nr) AS 'delivery_logs_nr', latest(kentik.ktranslate.chf.kkc.delivery_wins_nr) AS 'delivery_wins_nr', latest(kentik.ktranslate.chf.kkc.device_metrics) AS 'device_metrics', latest(kentik.ktranslate.chf.kkc.inputq) AS 'inputq', latest(kentik.ktranslate.chf.kkc.interface_metrics) AS 'interface_metrics', latest(kentik.ktranslate.chf.kkc.jchfq) AS 'jchfq' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' LIMIT MAX Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 185.44702,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Advanced configuration for <em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "sections": "Advanced configuration for <em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "tags": "<em>Network</em> <em>performance</em> <em>monitoring</em>",
        "body": "If you want to explore all the options you can use when configuring the <em>monitoring</em> of your <em>network</em> <em>performance</em>, see the following sections. SNMP-base YAML sample file Here&#x27;s an example of the various configuration options available in the snmp-base.yaml file used by the ktranslate docker image"
      },
      "id": "6127249be7b9d29922f565b0"
    },
    {
      "sections": [
        "Set up network flow data monitoring",
        "Prerequisites",
        "New Relic One account prerequisites",
        "Linux host prerequisites",
        "Network flow data devices prerequisites",
        "Network security prerequisites",
        "Supported types of network flow data",
        "Important",
        "Scaling network flow collection",
        "Set up network flow data monitoring in New Relic One",
        "Manual setup",
        "Tip"
      ],
      "title": "Set up network flow data monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring",
        "Installation",
        "Setup",
        "NPM"
      ],
      "external_id": "626c9bebce36e550d5793d8ef932e6d654c23e47",
      "image": "https://docs.newrelic.com/static/3d1561743f3311471975006fa41f628a/c1b63/network-flows-guided-install.png",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/setup-performance-monitoring/network-flow-monitoring/",
      "published_at": "2021-10-24T23:40:19Z",
      "updated_at": "2021-10-13T03:31:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Set up your network devices so they send network data to New Relic One. Prerequisites New Relic One account prerequisites A New Relic account. Don't have one? Sign up for free! No credit card required. A New Relic account ID. Read how to find your account ID. A New Relic license key. Read how to generate a new License key. Linux host prerequisites Docker installed in a Linux host. SSH access to the Docker host, with the ability to launch new containers. Network flow data devices prerequisites Configured network devices to send flow data to the host running the ktranslate docker container. Here's how to configure network flow data collection in some devices: NetFlow data Palo Alto - PAN-OS Fortinet Fortigate Cisco - NX-OS Cisco - IOS Cisco - Meraki sFlow data F5 - BIG-IP jFlow data Juniper - Junos Network security prerequisites Direction Source Destination Ports Protocol Outbound Docker host ktranslate image on Docker Hub 443 TCP Outbound Docker host New Relic Event API US Endpoint: https://insights-collector.newrelic.com EU Endpoint: https://insights-collector.eu01.nr-data.net 443 TCP Outbound Docker host New Relic Log API US Endpoint: https://log-api.newrelic.com EU Endpoint: https://log-api.eu.newrelic.com 443 TCP Inbound Source devices for network flow data Docker host 9995 (default) UDP Supported types of network flow data NPM flow monitoring supports the four primary types of network flow data and their derivatives. When running the ktranslate container, you will specify which major type you want to monitor using the -nf.source option. Important The ktranslate container only supports monitoring one type of network flow data type at a time. If you want to monitor several types, each will require a container. IPFIX and NetFlow v9 can be sent to the same container, but we recommend running a separate container as a best practice. Network flow data type -nf.source value IPFIX ipfix NetFlow v5 netflow5 NetFlow v9 netflow9 sFlow sflow AppFlow netflow5 Argus netflow5 cflowd netflow5 J-Flow netflow5 NetStream netflow5 RFlow netflow5 Cisco NSEL netflow9 Scaling network flow collection When planning your strategy for collecting network flows at scale, New Relic recommends 1 CPU per 2000 flows-per-second (120,000 flows-per-minute). Deciding whether to run more small containers to distribute load or fewer large containers to consolidate management is a matter of personal preference. Set up network flow data monitoring in New Relic One Go to one.newrelic.com and click Add more data. Scroll down until you see Network performance monitoring and click Network Flows. Follow the steps in New Relic One. one.newrelic.com > Add more data > Network performance monitoring > Network Flows to set up network flow data monitoring. To get better visibility into your network device performance, set up SNMP data monitoring. Visualize your network performance data in New Relic. Manual setup If you prefer to do the setup manually, proceed with the following steps. In your local machine, from a Linux host with Docker installed, download the ktranslate image from dockerhub by running bash Copy $ docker pull kentik/ktranslate:v2 Copy the snmp-base.yaml file to the local $HOME directory of your Docker user, and discard the container by running bash Copy $ cd . $ id=$(docker create kentik/ktranslate:v2) $ docker cp $id:/etc/ktranslate/snmp-base.yaml . $ docker rm -v $id In the snmp-base.yaml file, add your network flow devices inside the devices key with the following structure: devices: flowDevice: device_name: edge-router device_ip: 10.10.1.254 flow_only: true # Optional user tags user_tags: owning_team: net_eng environment: production Copy Tip If you're already monitoring SNMP data devices that send network flow data, you don't need to add them in your snmp-base.yaml file a second time. Run ktranslate to listen for network flows by running: Tip Add your New Relic license key and your account ID in the $NR_LICENSE_KEY and $NR_ACCOUNT_ID variables respectively. bash Copy $ docker run -d --name ktranslate-sflow --restart unless-stopped --net=host \\ > -v `pwd`/snmp-base.yaml:/snmp-base.yaml \\ > -e NEW_RELIC_API_KEY=$NR_LICENSE_KEY \\ > kentik/ktranslate:v2 \\ > -snmp /snmp-base.yaml \\ > -nr_account_id=$NR_ACCOUNT_ID \\ > -metrics=jchf \\ > -log_level=info \\ > -tee_logs=true \\ > -flow_only=true \\ > -nf.source=sflow \\ > nr1.flow $ ## If your account is located in Europe, you need to add the following option before the nr1.flow line $ ## -nr_region=EU \\ Tip This command assumes collection of sflow data. If you are collecting other flow types, you should change the suffix in the --name flag for the container and update the -nf.source argument as necessary To get better visibility into your network device performance, set up SNMP data monitoring. Visualize your network performance data in New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 156.52884,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Set up <em>network</em> flow data <em>monitoring</em>",
        "sections": "Set up <em>network</em> flow data <em>monitoring</em>",
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": " will specify which major type you want to <em>monitor</em> using the -nf.source option. Important The ktranslate container only supports <em>monitoring</em> one type of <em>network</em> flow data type at a time. If you want to <em>monitor</em> several types, each will require a container. IPFIX and NetFlow v9 can be sent to the same container"
      },
      "id": "612724e128ccbc4ac9f2612a"
    }
  ],
  "/docs/network-performance-monitoring/setup-performance-monitoring/advanced-config": [
    {
      "sections": [
        "Get started with Network Performance Monitoring",
        "Types of network performance data",
        "Important",
        "High level architecture overview"
      ],
      "title": "Get started with Network Performance Monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring",
        "Get started"
      ],
      "external_id": "96d12e2c5551a6e5eab76238cd2b787e5c188c01",
      "image": "https://docs.newrelic.com/static/eb0db7c88b717f386c4900a04e12a8ed/e5166/overview_navigator.jpg",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/get-started/npm-introduction/",
      "published_at": "2021-10-24T23:38:43Z",
      "updated_at": "2021-10-24T01:46:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When system performance suffers, you need to know if itâ€™s due to your code, your infrastructure, or the underlying network. And you need to know fast, so you can focus your efforts. With Network Performance Monitoring you can correlate and analyze application, infrastructure, digital experience, and network data all in one place, and understand how network performance and overall system performance impact each other. Using Navigator with Network Performance Monitoring. Network Performance Monitoring adds the context of network data to the application and infrastructure data you already collect in New Relic One. By monitoring your network data, you can: Analyze and understand the performance of your entire stack (application and infrastructure) for a holistic understanding of your system performance. Have all the data in a single platform to eliminate blind spots. See at first glance whether a network is implicated in an issue. Sign up for free! No credit card required. Already have an account? Login. Types of network performance data You can monitor the following types of network performance data: SNMP data: Simple Network Management Protocol (SNMP) is an applicationâ€“layer protocol for exchanging management information between network devices. To send SNMP data to New Relic One, see Set up SNMP data monitoring. Network flow data: It captures information about the IP traffic going to and from network interfaces in your on-premises network. To send network flow data to New Relic One, see Set up network flow data monitoring. Important We recommend configuring both SNMP and network flow data for better visibility into your network. This will provide both performance metrics and traffic patterns to troubleshoot and optimize your network. High level architecture overview Our solution is based on the ktranslate docker container developed by our partner, Kentik. This single container image is hosted in your environment to collect and process your data to be exported to the Event, Metric, and Log APIs and displayed in New Relic One. Overview of Network Performance Monitoring architecture.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 243.06293,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get started with <em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "sections": "Get started with <em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": "When system <em>performance</em> suffers, you need to know if itâ€™s due to your code, your infrastructure, or the underlying <em>network</em>. And you need to know fast, so you can focus your efforts. With <em>Network</em> <em>Performance</em> <em>Monitoring</em> you can correlate and analyze application, infrastructure, digital experience"
      },
      "id": "6126f39b28ccbc8c49f26162"
    },
    {
      "sections": [
        "Set up network flow data monitoring",
        "Prerequisites",
        "New Relic One account prerequisites",
        "Linux host prerequisites",
        "Network flow data devices prerequisites",
        "Network security prerequisites",
        "Supported types of network flow data",
        "Important",
        "Scaling network flow collection",
        "Set up network flow data monitoring in New Relic One",
        "Manual setup",
        "Tip"
      ],
      "title": "Set up network flow data monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring",
        "Installation",
        "Setup",
        "NPM"
      ],
      "external_id": "626c9bebce36e550d5793d8ef932e6d654c23e47",
      "image": "https://docs.newrelic.com/static/3d1561743f3311471975006fa41f628a/c1b63/network-flows-guided-install.png",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/setup-performance-monitoring/network-flow-monitoring/",
      "published_at": "2021-10-24T23:40:19Z",
      "updated_at": "2021-10-13T03:31:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Set up your network devices so they send network data to New Relic One. Prerequisites New Relic One account prerequisites A New Relic account. Don't have one? Sign up for free! No credit card required. A New Relic account ID. Read how to find your account ID. A New Relic license key. Read how to generate a new License key. Linux host prerequisites Docker installed in a Linux host. SSH access to the Docker host, with the ability to launch new containers. Network flow data devices prerequisites Configured network devices to send flow data to the host running the ktranslate docker container. Here's how to configure network flow data collection in some devices: NetFlow data Palo Alto - PAN-OS Fortinet Fortigate Cisco - NX-OS Cisco - IOS Cisco - Meraki sFlow data F5 - BIG-IP jFlow data Juniper - Junos Network security prerequisites Direction Source Destination Ports Protocol Outbound Docker host ktranslate image on Docker Hub 443 TCP Outbound Docker host New Relic Event API US Endpoint: https://insights-collector.newrelic.com EU Endpoint: https://insights-collector.eu01.nr-data.net 443 TCP Outbound Docker host New Relic Log API US Endpoint: https://log-api.newrelic.com EU Endpoint: https://log-api.eu.newrelic.com 443 TCP Inbound Source devices for network flow data Docker host 9995 (default) UDP Supported types of network flow data NPM flow monitoring supports the four primary types of network flow data and their derivatives. When running the ktranslate container, you will specify which major type you want to monitor using the -nf.source option. Important The ktranslate container only supports monitoring one type of network flow data type at a time. If you want to monitor several types, each will require a container. IPFIX and NetFlow v9 can be sent to the same container, but we recommend running a separate container as a best practice. Network flow data type -nf.source value IPFIX ipfix NetFlow v5 netflow5 NetFlow v9 netflow9 sFlow sflow AppFlow netflow5 Argus netflow5 cflowd netflow5 J-Flow netflow5 NetStream netflow5 RFlow netflow5 Cisco NSEL netflow9 Scaling network flow collection When planning your strategy for collecting network flows at scale, New Relic recommends 1 CPU per 2000 flows-per-second (120,000 flows-per-minute). Deciding whether to run more small containers to distribute load or fewer large containers to consolidate management is a matter of personal preference. Set up network flow data monitoring in New Relic One Go to one.newrelic.com and click Add more data. Scroll down until you see Network performance monitoring and click Network Flows. Follow the steps in New Relic One. one.newrelic.com > Add more data > Network performance monitoring > Network Flows to set up network flow data monitoring. To get better visibility into your network device performance, set up SNMP data monitoring. Visualize your network performance data in New Relic. Manual setup If you prefer to do the setup manually, proceed with the following steps. In your local machine, from a Linux host with Docker installed, download the ktranslate image from dockerhub by running bash Copy $ docker pull kentik/ktranslate:v2 Copy the snmp-base.yaml file to the local $HOME directory of your Docker user, and discard the container by running bash Copy $ cd . $ id=$(docker create kentik/ktranslate:v2) $ docker cp $id:/etc/ktranslate/snmp-base.yaml . $ docker rm -v $id In the snmp-base.yaml file, add your network flow devices inside the devices key with the following structure: devices: flowDevice: device_name: edge-router device_ip: 10.10.1.254 flow_only: true # Optional user tags user_tags: owning_team: net_eng environment: production Copy Tip If you're already monitoring SNMP data devices that send network flow data, you don't need to add them in your snmp-base.yaml file a second time. Run ktranslate to listen for network flows by running: Tip Add your New Relic license key and your account ID in the $NR_LICENSE_KEY and $NR_ACCOUNT_ID variables respectively. bash Copy $ docker run -d --name ktranslate-sflow --restart unless-stopped --net=host \\ > -v `pwd`/snmp-base.yaml:/snmp-base.yaml \\ > -e NEW_RELIC_API_KEY=$NR_LICENSE_KEY \\ > kentik/ktranslate:v2 \\ > -snmp /snmp-base.yaml \\ > -nr_account_id=$NR_ACCOUNT_ID \\ > -metrics=jchf \\ > -log_level=info \\ > -tee_logs=true \\ > -flow_only=true \\ > -nf.source=sflow \\ > nr1.flow $ ## If your account is located in Europe, you need to add the following option before the nr1.flow line $ ## -nr_region=EU \\ Tip This command assumes collection of sflow data. If you are collecting other flow types, you should change the suffix in the --name flag for the container and update the -nf.source argument as necessary To get better visibility into your network device performance, set up SNMP data monitoring. Visualize your network performance data in New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.9134,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Set up <em>network</em> flow data <em>monitoring</em>",
        "sections": "Set up <em>network</em> flow data <em>monitoring</em>",
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": " will specify which major type you want to <em>monitor</em> using the -nf.source option. Important The ktranslate container only supports <em>monitoring</em> one type of <em>network</em> flow data type at a time. If you want to <em>monitor</em> several types, each will require a container. IPFIX and NetFlow v9 can be sent to the same container"
      },
      "id": "612724e128ccbc4ac9f2612a"
    },
    {
      "sections": [
        "Visualize your network performance data in New Relic One",
        "Prerequisites",
        "Add the Network dashboards to your account",
        "Tip",
        "Start exploring your network performance data"
      ],
      "title": "Visualize your network performance data in New Relic One",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring",
        "Monitoring"
      ],
      "external_id": "a9e82cf586cd71595b0fd3bdcc831768578417cf",
      "image": "https://docs.newrelic.com/static/f6a643a55e2f9a2b070d85ab9174ba48/c1b63/flow_data_dashboard.png",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/monitoring-network-data/visualize-network-data/",
      "published_at": "2021-10-24T23:39:31Z",
      "updated_at": "2021-09-14T18:18:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you've set up your network data for performance monitoring, you can go to New Relic One to install several custom curated visualizations designed specifically for network performance monitoring. Once you've set up these visualizations, you'll be able to start exploring the network data your devices are reporting to New Relic One. Prerequisites A New Relic account. Don't have one? Sign up for free! No credit card required. Having set up your Network Performance Monitoring devices. Read how to: Set up SNMP data monitoring. Set up network flow data monitoring. Add the custom visualizations app to your account: Go to one.newrelic.com > Apps, and search for Network Agent Visualizations. Click the app, and then click Open visualization. one.newrelic.com > Apps, and search for Network Agent Visualizations. From the Account ID dropdown, select the account you want to add the visualizations to, and click Enable. Add the Network dashboards to your account You can go to New Relic One and import several dashboards to see curated views of your network telemetry, including the GeoMap and Sankey custom visualizations from the prerequisites. Go to one.newrelic.com > Apps, and search for Quickstarts. Click Quickstarts, and in the search bar, search for Network and click one of the dashboards: The Network - Data Ingest and Cardinality dashboard to analyze usage trends. The Network - Routers and Switches dashboard for SNMP data from Router and Switch entities. The Network - Flow Devices dashboard for network flow data. one.newrelic.com > Apps, and search for Network. Click Import, and Select the account you want to add the dashboard to. Edit the dashboard name, if you want to. Click Import dashboard. Tip If you want to read more about custom visualizations in New Relic One, see the introduction to custom visualizations. Start exploring your network performance data Once you've finished setting up these dashboards, you can start seeing your network data by going to: one.newrelic.com > Dashboards: For usage trend analysis, you'll see the following dashboard: Dashboard for analyzing network telemetry usage trends in New Relic One. For SNMP data, you'll see the following dashboard: Dashboard for SNMP data from Router and Switch entities in New Relic One. For Network flow data, you'll see the following dashboard: Dashboard for Network flow data monitoring in New Relic One. one.newrelic.com > Explorer: Entities are listed under the Network category in the left-hand side menu. Open a specific device to see the details and trend of its performance. On the top right-hand side, click Lookout to see anomalies. Lookout view for Network Performance Monitoring in New Relic One.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.40323,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Visualize your <em>network</em> <em>performance</em> data in New Relic One",
        "sections": "Visualize your <em>network</em> <em>performance</em> data in New Relic One",
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": "After you&#x27;ve set up your <em>network</em> data for <em>performance</em> <em>monitoring</em>, you can go to New Relic One to install several custom curated visualizations designed specifically for <em>network</em> <em>performance</em> <em>monitoring</em>. Once you&#x27;ve set up these visualizations, you&#x27;ll be able to start exploring the <em>network</em> data your"
      },
      "id": "6127249b64441f621ea47c42"
    }
  ],
  "/docs/network-performance-monitoring/setup-performance-monitoring/network-flow-monitoring": [
    {
      "sections": [
        "Get started with Network Performance Monitoring",
        "Types of network performance data",
        "Important",
        "High level architecture overview"
      ],
      "title": "Get started with Network Performance Monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring",
        "Get started"
      ],
      "external_id": "96d12e2c5551a6e5eab76238cd2b787e5c188c01",
      "image": "https://docs.newrelic.com/static/eb0db7c88b717f386c4900a04e12a8ed/e5166/overview_navigator.jpg",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/get-started/npm-introduction/",
      "published_at": "2021-10-24T23:38:43Z",
      "updated_at": "2021-10-24T01:46:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When system performance suffers, you need to know if itâ€™s due to your code, your infrastructure, or the underlying network. And you need to know fast, so you can focus your efforts. With Network Performance Monitoring you can correlate and analyze application, infrastructure, digital experience, and network data all in one place, and understand how network performance and overall system performance impact each other. Using Navigator with Network Performance Monitoring. Network Performance Monitoring adds the context of network data to the application and infrastructure data you already collect in New Relic One. By monitoring your network data, you can: Analyze and understand the performance of your entire stack (application and infrastructure) for a holistic understanding of your system performance. Have all the data in a single platform to eliminate blind spots. See at first glance whether a network is implicated in an issue. Sign up for free! No credit card required. Already have an account? Login. Types of network performance data You can monitor the following types of network performance data: SNMP data: Simple Network Management Protocol (SNMP) is an applicationâ€“layer protocol for exchanging management information between network devices. To send SNMP data to New Relic One, see Set up SNMP data monitoring. Network flow data: It captures information about the IP traffic going to and from network interfaces in your on-premises network. To send network flow data to New Relic One, see Set up network flow data monitoring. Important We recommend configuring both SNMP and network flow data for better visibility into your network. This will provide both performance metrics and traffic patterns to troubleshoot and optimize your network. High level architecture overview Our solution is based on the ktranslate docker container developed by our partner, Kentik. This single container image is hosted in your environment to collect and process your data to be exported to the Event, Metric, and Log APIs and displayed in New Relic One. Overview of Network Performance Monitoring architecture.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 244.52786,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get started with <em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "sections": "Get started with <em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": "When system <em>performance</em> suffers, you need to know if itâ€™s due to your code, your infrastructure, or the underlying <em>network</em>. And you need to know fast, so you can focus your efforts. With <em>Network</em> <em>Performance</em> <em>Monitoring</em> you can correlate and analyze application, infrastructure, digital experience"
      },
      "id": "6126f39b28ccbc8c49f26162"
    },
    {
      "sections": [
        "Set up SNMP data monitoring",
        "Prerequisites",
        "New Relic One account prerequisites",
        "Linux host prerequisites",
        "SNMP devices prerequisites",
        "Supported SNMP versions",
        "Tip",
        "Set up SNMP data monitoring in New Relic One",
        "Manual setup"
      ],
      "title": "Set up SNMP data monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network performance monitoring",
        "Installation",
        "Setup"
      ],
      "external_id": "ab50c7659f03d76e429769be42ddec21d4744a0d",
      "image": "https://docs.newrelic.com/static/59f9f8d2d86daf23058506e7cf1c9fcc/c1b63/snmp-guided-install.png",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/setup-performance-monitoring/snmp-performance-monitoring/",
      "published_at": "2021-10-24T23:41:16Z",
      "updated_at": "2021-09-27T15:15:11Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Set up your network devices so they send network data to New Relic One. Prerequisites New Relic One account prerequisites A New Relic account. Don't have one? Sign up for free! No credit card required. A New Relic account ID. Read how to find your account ID. A New Relic license key. Read how to generate a new License key. Linux host prerequisites Docker installed in a Linux host. SSH access to the Docker host, with the ability to launch new containers. SNMP devices prerequisites Configured network devices for SNMP polling from the ktranslate docker container. Some samples of basic SNMP configurations can be found here: Cisco IOS Meraki NX-OS Juniper Junos OS Palo Alto PAN-OS Supported SNMP versions Our NPM container supports all major versions of SNMP (v1, v2c, and v3). Additionally, SNMP v3 has support for the following authentication and privacy settings: Setting Protocol Authentication NoAuth Authentication MD5 Authentication SHA Authentication SHA224 Authentication SHA256 Authentication SHA384 Authentication SHA512 Privacy NoPriv Privacy DES Privacy AES Privacy AES192 Privacy AES256 Privacy AES192C Privacy AES256C Tip We recommend using read-only community strings/authentication with SNMP Set up SNMP data monitoring in New Relic One Go to one.newrelic.com and click Add more data. Scroll down until you see Network performance monitoring and click SNMP. Follow the steps in New Relic One. one.newrelic.com > Add more data > Network performance monitoring > SNMP to set up SNMP data monitoring. To get better visibility into how your network is being used, set up network flow data monitoring. Visualize your network performance data in New Relic. Manual setup If you prefer to do the setup manually, proceed with the following steps. On a Linux host with Docker installed, download the ktranslate image from dockerhub by running bash Copy $ docker pull kentik/ktranslate:v2 Copy the snmp-base.yaml file to the local $HOME directory of your Docker user, and discard the container by running bash Copy $ cd . $ id=$(docker create kentik/ktranslate:v2) $ docker cp $id:/etc/ktranslate/snmp-base.yaml . $ docker rm -v $id Edit the snmp-base.yaml file and define the discovery.cidrs and discovery.default_communities attributes to appropriate values for your network. Tip It's recommended to set discovery.add_mibs: true to automate the addition of all discovered MIBs into the global.mibs_enabled attribute Launch a short-lived container to execute discovery by running bash Copy $ docker run -ti --name ktranslate-discovery --rm --net=host \\ > --user `id -u`:`id -g` \\ > -v `pwd`/snmp-base.yaml:/snmp-base.yaml \\ > kentik/ktranslate:v2 \\ > -snmp /snmp-base.yaml \\ > -log_level info \\ > -snmp_discovery=true After the discovery run finishes, you should see an output similar to the following: bash Copy $ >[Info] KTranslate Adding 3 new snmp devices to the config, 0 replaced from 3 $ # In this example, the discovery run found 3 new SNMP devices. The discovered devices are listed in the snmp-base.yaml file's devices.{} section. By default, only the IF-MIB mib is polled. You can manually add other mibs to the global.mibs_enabled attribute if you did not set discovery.add_mibs: true before running the discovery. Run ktranslate to poll target devices by running: Tip Add your New Relic License key and your account ID in the $NR_LICENSE_KEY and $NR_ACCOUNT_ID variables respectively. bash Copy $ docker run -d --name ktranslate-snmp --restart unless-stopped --net=host \\ > -v `pwd`/snmp-base.yaml:/snmp-base.yaml \\ > -e NEW_RELIC_API_KEY=$NR_LICENSE_KEY \\ > kentik/ktranslate:v2 \\ > -snmp /snmp-base.yaml \\ > -nr_account_id=$NR_ACCOUNT_ID \\ > -log_level=info \\ > -metrics=jchf \\ > -tee_logs=true \\ > ## If your account is located in Europe, you need to add the following option: $ ## -nr_region=EU $ nr1.snmp To get better visibility into how your network is being used, set up network flow data monitoring. Visualize your network performance data in New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 241.89651,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Set up SNMP data <em>monitoring</em>",
        "sections": "Set up SNMP data <em>monitoring</em>",
        "tags": "<em>Network</em> <em>performance</em> <em>monitoring</em>",
        "body": " SNMP data <em>monitoring</em>. To get better visibility into how your <em>network</em> is being used, set up <em>network</em> flow data <em>monitoring</em>. Visualize your <em>network</em> <em>performance</em> data in New Relic. Manual <em>setup</em> If you prefer to do the <em>setup</em> manually, proceed with the following steps. On a Linux host with Docker installed"
      },
      "id": "6127249b28ccbc09a4f26187"
    },
    {
      "sections": [
        "Advanced configuration for Network Performance Monitoring",
        "SNMP-base YAML sample file",
        "Devices section",
        "Trap section",
        "Discovery section",
        "Global section",
        "SNMPv3 optional configuration",
        "The flow_only attribute",
        "Advanced options for running the ktranslate docker image",
        "Logs sent with Network performance monitoring",
        "Tip",
        "Metrics sent with Network performance monitoring"
      ],
      "title": "Advanced configuration for Network Performance Monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network performance monitoring",
        "Advanced configuration"
      ],
      "external_id": "8262ac964abbda46760776a63b051e05ecfecc4f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/setup-performance-monitoring/advanced-config/",
      "published_at": "2021-10-24T23:40:19Z",
      "updated_at": "2021-10-13T02:04:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you want to explore all the options you can use when configuring the monitoring of your network performance, see the following sections. SNMP-base YAML sample file Here's an example of the various configuration options available in the snmp-base.yaml file used by the ktranslate docker image to poll for SNMP and flow data devices. devices: deviceOne: device_name: router123 device_ip: 10.10.0.201 oid: .1.3.6.1.4.1.2636.1.1.1.2.21.0 snmp_comm: public poll_time_sec: 300 user_tags: owning_team: net_eng environment: production trap: listen: 127.0.0.1:162 community: public version: \"\" transport: \"\" discovery: cidrs: - 10.10.0.0/24 - 10.20.0.0/24 - 192.168.0.21/32 debug: false ports: - 161 - 1161 default_communities: - public default_v3: null add_devices: true threads: 4 use_snmp_v1: false replace_devices: true global: poll_time_sec: 60 timeout_ms: 5000 retries: 0 mibs_enabled: - IF-MIB drop_if_outside_poll: false mib_profile_dir: profiles Copy Devices section Option name Required Description device_name âœ“ Name of the device reporting to New Relic One device_ip âœ“ IP to send SNMP queries to port Port to send SNMP queries to. By default, it's set to port 161 provider Value used during entity synthesis for New Relic One mib_profile SNMP Profile file that was associated with this device during the discovery run based on its sysOID snmp_comm âœ“ SNMPv1/2c community string to use. For SNMPv3, set it to snmp_v3 use_snmp_v1 Indicates whether to use SNMPv1. By default, it's set to false snmp_v3 SNMPv3 authentication configuration poll_time_sec Indicates the polling frequency in seconds. This setting is used to override the global.poll_time_sec attribute. timeout_ms Indicates the polling timeout in milliseconds. By default, it's set to 5000 retries Indicates the number of attempts to retry to get the device information. By default, it's set to 0 last_checked Timestamp when this device was last discovered by the ktranslate docker image oid âœ“ sysOID for the device description Description of the device discovered_mibs List of MIBs from our known SNMP profiles this device can respond to, found during discovery by the ktranslate docker image debug Indicates whether to run SNMP polling in debug mode. By default, it's set to false user_tags Additional key:value pair attributes to give more context to the device. For example, environment: production match_attributes Additional attribute:regex pairs to whitelist metrics. Only matching attributes are sent. For example, if_Description: \"^igb|^eth\" monitor_admin_shut Indicates whether the monitor shuts interfaces also. By default, it's set to false Trap section Option name Required Description listen âœ“ Listening IP port for receiving SNMP traps community SNMP community string for receiving SNMP traps version SNMP version to use. Options are v1, v2c, and v3. (Default: v2c) transport SNMP transport protocol to use. The possible values are TCP and UDP. By default, it's set to UDP v3_config SNMP v3 config to use. Only used if version is v3. Discovery section Option name Required Description cidrs âœ“ Array of target IP ranges in CIDR notation. You can add /32 at the end of the IP to poll for SNMP devices without testing with ICMP echo. Optionally, you can point to a cidrs.yaml file in the snmp-base.yaml file: discovery: cidrs: \"@cidrs.yaml\" Copy The cidrs.yaml file should be similar to the following - 10.10.0.0/24 - 10.20.0.0/24 - 192.168.0.21/32 Copy ports âœ“ Array of target ports to scan during SNMP polling default_communities âœ“ Array of SNMPv1/v2c community strings to scan during SNMP polling. This array is evaluated in order and discovery accepts the first passing community. For SNMPv3, set it to default_v3 default_v3 SNMPv3 configuration to scan during SNMP polling use_snmp_v1 Indicates whether to use SNMPv1 during discovery. By default, it's set to false add_devices âœ“ Indicates whether to add discovered devices to the devices section of the snmp-base.yaml file. By default, it's set to true add_mibs âœ“ Indicates whether to add discovered MIBs to the global.mibs_enabled section of the snmp-base.yaml file. By default, it's set to true replace_devices âœ“ Indicates whether to replace discovered devices if they already exist in the devices section of the snmp-base.yaml file. By default, it's set to true debug Indicates whether to enable debug level logging during discovery. By default, it's set to false threads âœ“ Integer limit of threads to use during discovery. It must be less than the number of cores available to the container Global section Option name Required Description poll_time_sec âœ“ Time in seconds to poll devices. By default, it's set to 60 timeout_ms âœ“ Time in milliseconds queries timeout. By default, it's set to 5000 retries âœ“ Number of attempts to retry failed polls. By default, it's set to 0 mibs_enabled âœ“ Array of all active MIBs the ktranslate docker image will poll. Polling only occurs if the MIB is valid for a given device drop_if_outside_poll Indicates whether to drop all values from this cycle if polling takes longer than the value set in poll_time_sec. By default, it's set to false mib_profile_dir Directory to find curated MIB profiles SNMPv3 optional configuration Here's an example of SNMPv3 configuration section for the snmp-base.yaml file: yaml default_v3: user_name: userNamev3 authentication_protocol: MD5 authentication_passphrase: authPassPrivacy privacy_protocol: AES256 privacy_passphrase: passPrivacy Copy Option name Required Description user_name âœ“ User name for SNMPv3 authentication authentication_protocol âœ“ SNMPv3 authentication protocol. The possible values are NoAuth, MD5, or SHA authentication_passphrase SNMPv3 authentication passphrase privacy_protocol âœ“ SNMPv3 privacy protocol. The possible values are AuthNoPriv, DES, AES, AES192, AES256, AES192C, or AES256C privacy_passphrase SNMPv3 privacy passphrase context_engine_id SNMPv3 context engine ID context_name SNMPv3 context name The flow_only attribute There are several supported configurations available for running ktranslate against devices for both SNMP and network flow data collection. The flow_only attribute on both a ktranslate docker container level and in the devices section of the snmp-base.yaml file allows you to get different results: If you have multiple containers collecting both SNMP and network flow data with the ktranslate docker image, define your devices in the snmp-base.yaml file, following the standards for SNMP data polling. They will be automatically matched to their respective flows based on their device_ip matching the sampling IP for the flow device. For network flow data devices, run the ktranslate docker image with the -flow_only=true option. snmp-base.yaml file - No setting changes needed If you have multiple containers collecting both SNMP and network flow data with the ktranslate docker image, and you have specific devices where you only want network flow or SNMP data collection and no SNMP or network flow data polling respectively, you can set them up in their respective device configuration section in the snmp-base.yaml file. For network flow data devices, run the ktranslate docker image with the -flow_only=true option. snmp-base.yaml file - Change the flow_only to true: flow_only: true Copy Advanced options for running the ktranslate docker image In this table you can find additional options you can use with the ktranslate docker image. Option name Description -max_threads Lets you process higher volumes of flow. We recommend one CPU core available for every 2,000 flows per second (fps) of network flow data sent. -sample_rate=100 Changes the default sample rate value at which flows are passed to New Relic One Events. It also sets the sample rate value for flow types that don't have a default sample rate value. -nf.workers=1 Overrides the number of workers used in processing udp packets. Use one worker for every 4,000 of flows per second (fps) of network flow data sent. -nf.port Overrides the default 9995 listening port for incoming flow packets. -listen Overrides the default 8082 port used by ktranslate to expose health metrics. You must use this option when running multiple ktranslate containers on a single host. -metalisten Overrides the default 8083 port used by ktranslate to expose metadata. You must use this option when running multiple ktranslate containers on a single host. -metrics=jchf Forwards health metrics from ktranslate into New Relic One. -log_level Overrides the default info log level for ktranslate. The available options are debug, info, warn, or error. -tee_logs Forwards logs from ktranslate into New Relic One Logs. HTTPS_PROXY Environment variable that can be used during Docker runtime to setup ktranslate to ship data to New Relic via proxy. Ex: -e HTTPS_PROXY=https://user:password@hostname:port You can also run several ktranslate images to monitor different network flow types simultaneously. See the follwing example: bash Copy $ docker run -d --name ktranslate-sflow --net=host \\ > -e NEW_RELIC_API_KEY=$INSERT_API_KEY \\ > kentik/ktranslate:v2 \\ > -snmp /snmp-base.yaml \\ > -nr_account_id=$NR_ACCOUNT_ID \\ > -metrics=jchf \\ > -log_level=info \\ > -tee_logs=true \\ > -nf.source=sflow \\ > -nf.port=9996 \\ > -max_threads=1 \\ > -listen 0.0.0.0:8084 \\ > -metalisten 0.0.0.0:8085 \\ > nr1.flow $ $ $ docker run -d --name ktranslate-netflow9 --net=host \\ > -e NEW_RELIC_API_KEY=$INSERT_API_KEY \\ > kentik/ktranslate:v2 \\ > -snmp /snmp-base.yaml \\ > -nr_account_id=$NR_ACCOUNT_ID \\ > -metrics=jchf \\ > -log_level=info \\ > -tee_logs=true \\ > -nf.source=netflow9 \\ > -nf.port=2055 \\ > -max_threads=2 \\ > -listen 0.0.0.0:8086 \\ > -metalisten 0.0.0.0:8087 \\ > nr1.flow Logs sent with Network performance monitoring If you want to check the logs locally, run docker logs ktranslate-snmp. The -tee_logs=true option sends logs to New Relic One when polling devices. To see them, do the following: Go to one.newrelic.com > Logs. In Find logs where enter collector.name:\"ktranslate\" and click Query logs. Tip If you want to filter out all the information messages, enter collector.name:\"ktranslate\" message:-*\\[Info\\]*. Metrics sent with Network performance monitoring The -metrics option captures one of the following performance metrics when polling devices: Metric Description baseserver_healthcheck_execution_total Rate of internal health checks. Shows mostly that things are not deadlocked. delivery_metrics_nr Rate of metrics sent to New Relic One. delivery_logs_nr Rate of logs sent to New Relic One. delivery_wins_nr Rate of 200 HTTP codes received from sending metrics and events to New Relic One. device_metrics Rate of SNMP polling of device level metrics. inputq Messages per second (msg/sec) recieved over the last 60 seconds from SNMP or network flow devices. interface_metrics Rate of SNMP polling of interface level metrics. jchfq Gauge rate with number of available pre-allocated buffers. It should be 8,000 aproximately. To see these metrics in New Relic One: Go to one.newrelic.com and click Query your data. Enter the following NRQL query: FROM Metric SELECT latest(kentik.ktranslate.chf.kkc.baseserver_healthcheck_execution_total) AS 'baseserver_healthcheck_execution_total', latest(kentik.ktranslate.chf.kkc.delivery_metrics_nr) AS 'delivery_metrics_nr', latest(kentik.ktranslate.chf.kkc.delivery_logs_nr) AS 'delivery_logs_nr', latest(kentik.ktranslate.chf.kkc.delivery_wins_nr) AS 'delivery_wins_nr', latest(kentik.ktranslate.chf.kkc.device_metrics) AS 'device_metrics', latest(kentik.ktranslate.chf.kkc.inputq) AS 'inputq', latest(kentik.ktranslate.chf.kkc.interface_metrics) AS 'interface_metrics', latest(kentik.ktranslate.chf.kkc.jchfq) AS 'jchfq' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' LIMIT MAX Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 176.9237,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Advanced configuration for <em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "sections": "Advanced configuration for <em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "tags": "<em>Network</em> <em>performance</em> <em>monitoring</em>",
        "body": "If you want to explore all the options you can use when configuring the <em>monitoring</em> of your <em>network</em> <em>performance</em>, see the following sections. SNMP-base YAML sample file Here&#x27;s an example of the various configuration options available in the snmp-base.yaml file used by the ktranslate docker image"
      },
      "id": "6127249be7b9d29922f565b0"
    }
  ],
  "/docs/network-performance-monitoring/setup-performance-monitoring/snmp-performance-monitoring": [
    {
      "sections": [
        "Get started with Network Performance Monitoring",
        "Types of network performance data",
        "Important",
        "High level architecture overview"
      ],
      "title": "Get started with Network Performance Monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring",
        "Get started"
      ],
      "external_id": "96d12e2c5551a6e5eab76238cd2b787e5c188c01",
      "image": "https://docs.newrelic.com/static/eb0db7c88b717f386c4900a04e12a8ed/e5166/overview_navigator.jpg",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/get-started/npm-introduction/",
      "published_at": "2021-10-24T23:38:43Z",
      "updated_at": "2021-10-24T01:46:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When system performance suffers, you need to know if itâ€™s due to your code, your infrastructure, or the underlying network. And you need to know fast, so you can focus your efforts. With Network Performance Monitoring you can correlate and analyze application, infrastructure, digital experience, and network data all in one place, and understand how network performance and overall system performance impact each other. Using Navigator with Network Performance Monitoring. Network Performance Monitoring adds the context of network data to the application and infrastructure data you already collect in New Relic One. By monitoring your network data, you can: Analyze and understand the performance of your entire stack (application and infrastructure) for a holistic understanding of your system performance. Have all the data in a single platform to eliminate blind spots. See at first glance whether a network is implicated in an issue. Sign up for free! No credit card required. Already have an account? Login. Types of network performance data You can monitor the following types of network performance data: SNMP data: Simple Network Management Protocol (SNMP) is an applicationâ€“layer protocol for exchanging management information between network devices. To send SNMP data to New Relic One, see Set up SNMP data monitoring. Network flow data: It captures information about the IP traffic going to and from network interfaces in your on-premises network. To send network flow data to New Relic One, see Set up network flow data monitoring. Important We recommend configuring both SNMP and network flow data for better visibility into your network. This will provide both performance metrics and traffic patterns to troubleshoot and optimize your network. High level architecture overview Our solution is based on the ktranslate docker container developed by our partner, Kentik. This single container image is hosted in your environment to collect and process your data to be exported to the Event, Metric, and Log APIs and displayed in New Relic One. Overview of Network Performance Monitoring architecture.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 243.06274,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get started with <em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "sections": "Get started with <em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": "When system <em>performance</em> suffers, you need to know if itâ€™s due to your code, your infrastructure, or the underlying <em>network</em>. And you need to know fast, so you can focus your efforts. With <em>Network</em> <em>Performance</em> <em>Monitoring</em> you can correlate and analyze application, infrastructure, digital experience"
      },
      "id": "6126f39b28ccbc8c49f26162"
    },
    {
      "sections": [
        "Set up network flow data monitoring",
        "Prerequisites",
        "New Relic One account prerequisites",
        "Linux host prerequisites",
        "Network flow data devices prerequisites",
        "Network security prerequisites",
        "Supported types of network flow data",
        "Important",
        "Scaling network flow collection",
        "Set up network flow data monitoring in New Relic One",
        "Manual setup",
        "Tip"
      ],
      "title": "Set up network flow data monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring",
        "Installation",
        "Setup",
        "NPM"
      ],
      "external_id": "626c9bebce36e550d5793d8ef932e6d654c23e47",
      "image": "https://docs.newrelic.com/static/3d1561743f3311471975006fa41f628a/c1b63/network-flows-guided-install.png",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/setup-performance-monitoring/network-flow-monitoring/",
      "published_at": "2021-10-24T23:40:19Z",
      "updated_at": "2021-10-13T03:31:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Set up your network devices so they send network data to New Relic One. Prerequisites New Relic One account prerequisites A New Relic account. Don't have one? Sign up for free! No credit card required. A New Relic account ID. Read how to find your account ID. A New Relic license key. Read how to generate a new License key. Linux host prerequisites Docker installed in a Linux host. SSH access to the Docker host, with the ability to launch new containers. Network flow data devices prerequisites Configured network devices to send flow data to the host running the ktranslate docker container. Here's how to configure network flow data collection in some devices: NetFlow data Palo Alto - PAN-OS Fortinet Fortigate Cisco - NX-OS Cisco - IOS Cisco - Meraki sFlow data F5 - BIG-IP jFlow data Juniper - Junos Network security prerequisites Direction Source Destination Ports Protocol Outbound Docker host ktranslate image on Docker Hub 443 TCP Outbound Docker host New Relic Event API US Endpoint: https://insights-collector.newrelic.com EU Endpoint: https://insights-collector.eu01.nr-data.net 443 TCP Outbound Docker host New Relic Log API US Endpoint: https://log-api.newrelic.com EU Endpoint: https://log-api.eu.newrelic.com 443 TCP Inbound Source devices for network flow data Docker host 9995 (default) UDP Supported types of network flow data NPM flow monitoring supports the four primary types of network flow data and their derivatives. When running the ktranslate container, you will specify which major type you want to monitor using the -nf.source option. Important The ktranslate container only supports monitoring one type of network flow data type at a time. If you want to monitor several types, each will require a container. IPFIX and NetFlow v9 can be sent to the same container, but we recommend running a separate container as a best practice. Network flow data type -nf.source value IPFIX ipfix NetFlow v5 netflow5 NetFlow v9 netflow9 sFlow sflow AppFlow netflow5 Argus netflow5 cflowd netflow5 J-Flow netflow5 NetStream netflow5 RFlow netflow5 Cisco NSEL netflow9 Scaling network flow collection When planning your strategy for collecting network flows at scale, New Relic recommends 1 CPU per 2000 flows-per-second (120,000 flows-per-minute). Deciding whether to run more small containers to distribute load or fewer large containers to consolidate management is a matter of personal preference. Set up network flow data monitoring in New Relic One Go to one.newrelic.com and click Add more data. Scroll down until you see Network performance monitoring and click Network Flows. Follow the steps in New Relic One. one.newrelic.com > Add more data > Network performance monitoring > Network Flows to set up network flow data monitoring. To get better visibility into your network device performance, set up SNMP data monitoring. Visualize your network performance data in New Relic. Manual setup If you prefer to do the setup manually, proceed with the following steps. In your local machine, from a Linux host with Docker installed, download the ktranslate image from dockerhub by running bash Copy $ docker pull kentik/ktranslate:v2 Copy the snmp-base.yaml file to the local $HOME directory of your Docker user, and discard the container by running bash Copy $ cd . $ id=$(docker create kentik/ktranslate:v2) $ docker cp $id:/etc/ktranslate/snmp-base.yaml . $ docker rm -v $id In the snmp-base.yaml file, add your network flow devices inside the devices key with the following structure: devices: flowDevice: device_name: edge-router device_ip: 10.10.1.254 flow_only: true # Optional user tags user_tags: owning_team: net_eng environment: production Copy Tip If you're already monitoring SNMP data devices that send network flow data, you don't need to add them in your snmp-base.yaml file a second time. Run ktranslate to listen for network flows by running: Tip Add your New Relic license key and your account ID in the $NR_LICENSE_KEY and $NR_ACCOUNT_ID variables respectively. bash Copy $ docker run -d --name ktranslate-sflow --restart unless-stopped --net=host \\ > -v `pwd`/snmp-base.yaml:/snmp-base.yaml \\ > -e NEW_RELIC_API_KEY=$NR_LICENSE_KEY \\ > kentik/ktranslate:v2 \\ > -snmp /snmp-base.yaml \\ > -nr_account_id=$NR_ACCOUNT_ID \\ > -metrics=jchf \\ > -log_level=info \\ > -tee_logs=true \\ > -flow_only=true \\ > -nf.source=sflow \\ > nr1.flow $ ## If your account is located in Europe, you need to add the following option before the nr1.flow line $ ## -nr_region=EU \\ Tip This command assumes collection of sflow data. If you are collecting other flow types, you should change the suffix in the --name flag for the container and update the -nf.source argument as necessary To get better visibility into your network device performance, set up SNMP data monitoring. Visualize your network performance data in New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 227.5293,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Set up <em>network</em> flow data <em>monitoring</em>",
        "sections": "Set up <em>network</em> flow data <em>monitoring</em>",
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": " <em>monitoring</em> &gt; <em>Network</em> Flows to set up <em>network</em> flow data <em>monitoring</em>. To get better visibility into your <em>network</em> device <em>performance</em>, set up SNMP data <em>monitoring</em>. Visualize your <em>network</em> <em>performance</em> data in New Relic. Manual <em>setup</em> If you prefer to do the <em>setup</em> manually, proceed with the following steps. In your"
      },
      "id": "612724e128ccbc4ac9f2612a"
    },
    {
      "sections": [
        "Advanced configuration for Network Performance Monitoring",
        "SNMP-base YAML sample file",
        "Devices section",
        "Trap section",
        "Discovery section",
        "Global section",
        "SNMPv3 optional configuration",
        "The flow_only attribute",
        "Advanced options for running the ktranslate docker image",
        "Logs sent with Network performance monitoring",
        "Tip",
        "Metrics sent with Network performance monitoring"
      ],
      "title": "Advanced configuration for Network Performance Monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network performance monitoring",
        "Advanced configuration"
      ],
      "external_id": "8262ac964abbda46760776a63b051e05ecfecc4f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/setup-performance-monitoring/advanced-config/",
      "published_at": "2021-10-24T23:40:19Z",
      "updated_at": "2021-10-13T02:04:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you want to explore all the options you can use when configuring the monitoring of your network performance, see the following sections. SNMP-base YAML sample file Here's an example of the various configuration options available in the snmp-base.yaml file used by the ktranslate docker image to poll for SNMP and flow data devices. devices: deviceOne: device_name: router123 device_ip: 10.10.0.201 oid: .1.3.6.1.4.1.2636.1.1.1.2.21.0 snmp_comm: public poll_time_sec: 300 user_tags: owning_team: net_eng environment: production trap: listen: 127.0.0.1:162 community: public version: \"\" transport: \"\" discovery: cidrs: - 10.10.0.0/24 - 10.20.0.0/24 - 192.168.0.21/32 debug: false ports: - 161 - 1161 default_communities: - public default_v3: null add_devices: true threads: 4 use_snmp_v1: false replace_devices: true global: poll_time_sec: 60 timeout_ms: 5000 retries: 0 mibs_enabled: - IF-MIB drop_if_outside_poll: false mib_profile_dir: profiles Copy Devices section Option name Required Description device_name âœ“ Name of the device reporting to New Relic One device_ip âœ“ IP to send SNMP queries to port Port to send SNMP queries to. By default, it's set to port 161 provider Value used during entity synthesis for New Relic One mib_profile SNMP Profile file that was associated with this device during the discovery run based on its sysOID snmp_comm âœ“ SNMPv1/2c community string to use. For SNMPv3, set it to snmp_v3 use_snmp_v1 Indicates whether to use SNMPv1. By default, it's set to false snmp_v3 SNMPv3 authentication configuration poll_time_sec Indicates the polling frequency in seconds. This setting is used to override the global.poll_time_sec attribute. timeout_ms Indicates the polling timeout in milliseconds. By default, it's set to 5000 retries Indicates the number of attempts to retry to get the device information. By default, it's set to 0 last_checked Timestamp when this device was last discovered by the ktranslate docker image oid âœ“ sysOID for the device description Description of the device discovered_mibs List of MIBs from our known SNMP profiles this device can respond to, found during discovery by the ktranslate docker image debug Indicates whether to run SNMP polling in debug mode. By default, it's set to false user_tags Additional key:value pair attributes to give more context to the device. For example, environment: production match_attributes Additional attribute:regex pairs to whitelist metrics. Only matching attributes are sent. For example, if_Description: \"^igb|^eth\" monitor_admin_shut Indicates whether the monitor shuts interfaces also. By default, it's set to false Trap section Option name Required Description listen âœ“ Listening IP port for receiving SNMP traps community SNMP community string for receiving SNMP traps version SNMP version to use. Options are v1, v2c, and v3. (Default: v2c) transport SNMP transport protocol to use. The possible values are TCP and UDP. By default, it's set to UDP v3_config SNMP v3 config to use. Only used if version is v3. Discovery section Option name Required Description cidrs âœ“ Array of target IP ranges in CIDR notation. You can add /32 at the end of the IP to poll for SNMP devices without testing with ICMP echo. Optionally, you can point to a cidrs.yaml file in the snmp-base.yaml file: discovery: cidrs: \"@cidrs.yaml\" Copy The cidrs.yaml file should be similar to the following - 10.10.0.0/24 - 10.20.0.0/24 - 192.168.0.21/32 Copy ports âœ“ Array of target ports to scan during SNMP polling default_communities âœ“ Array of SNMPv1/v2c community strings to scan during SNMP polling. This array is evaluated in order and discovery accepts the first passing community. For SNMPv3, set it to default_v3 default_v3 SNMPv3 configuration to scan during SNMP polling use_snmp_v1 Indicates whether to use SNMPv1 during discovery. By default, it's set to false add_devices âœ“ Indicates whether to add discovered devices to the devices section of the snmp-base.yaml file. By default, it's set to true add_mibs âœ“ Indicates whether to add discovered MIBs to the global.mibs_enabled section of the snmp-base.yaml file. By default, it's set to true replace_devices âœ“ Indicates whether to replace discovered devices if they already exist in the devices section of the snmp-base.yaml file. By default, it's set to true debug Indicates whether to enable debug level logging during discovery. By default, it's set to false threads âœ“ Integer limit of threads to use during discovery. It must be less than the number of cores available to the container Global section Option name Required Description poll_time_sec âœ“ Time in seconds to poll devices. By default, it's set to 60 timeout_ms âœ“ Time in milliseconds queries timeout. By default, it's set to 5000 retries âœ“ Number of attempts to retry failed polls. By default, it's set to 0 mibs_enabled âœ“ Array of all active MIBs the ktranslate docker image will poll. Polling only occurs if the MIB is valid for a given device drop_if_outside_poll Indicates whether to drop all values from this cycle if polling takes longer than the value set in poll_time_sec. By default, it's set to false mib_profile_dir Directory to find curated MIB profiles SNMPv3 optional configuration Here's an example of SNMPv3 configuration section for the snmp-base.yaml file: yaml default_v3: user_name: userNamev3 authentication_protocol: MD5 authentication_passphrase: authPassPrivacy privacy_protocol: AES256 privacy_passphrase: passPrivacy Copy Option name Required Description user_name âœ“ User name for SNMPv3 authentication authentication_protocol âœ“ SNMPv3 authentication protocol. The possible values are NoAuth, MD5, or SHA authentication_passphrase SNMPv3 authentication passphrase privacy_protocol âœ“ SNMPv3 privacy protocol. The possible values are AuthNoPriv, DES, AES, AES192, AES256, AES192C, or AES256C privacy_passphrase SNMPv3 privacy passphrase context_engine_id SNMPv3 context engine ID context_name SNMPv3 context name The flow_only attribute There are several supported configurations available for running ktranslate against devices for both SNMP and network flow data collection. The flow_only attribute on both a ktranslate docker container level and in the devices section of the snmp-base.yaml file allows you to get different results: If you have multiple containers collecting both SNMP and network flow data with the ktranslate docker image, define your devices in the snmp-base.yaml file, following the standards for SNMP data polling. They will be automatically matched to their respective flows based on their device_ip matching the sampling IP for the flow device. For network flow data devices, run the ktranslate docker image with the -flow_only=true option. snmp-base.yaml file - No setting changes needed If you have multiple containers collecting both SNMP and network flow data with the ktranslate docker image, and you have specific devices where you only want network flow or SNMP data collection and no SNMP or network flow data polling respectively, you can set them up in their respective device configuration section in the snmp-base.yaml file. For network flow data devices, run the ktranslate docker image with the -flow_only=true option. snmp-base.yaml file - Change the flow_only to true: flow_only: true Copy Advanced options for running the ktranslate docker image In this table you can find additional options you can use with the ktranslate docker image. Option name Description -max_threads Lets you process higher volumes of flow. We recommend one CPU core available for every 2,000 flows per second (fps) of network flow data sent. -sample_rate=100 Changes the default sample rate value at which flows are passed to New Relic One Events. It also sets the sample rate value for flow types that don't have a default sample rate value. -nf.workers=1 Overrides the number of workers used in processing udp packets. Use one worker for every 4,000 of flows per second (fps) of network flow data sent. -nf.port Overrides the default 9995 listening port for incoming flow packets. -listen Overrides the default 8082 port used by ktranslate to expose health metrics. You must use this option when running multiple ktranslate containers on a single host. -metalisten Overrides the default 8083 port used by ktranslate to expose metadata. You must use this option when running multiple ktranslate containers on a single host. -metrics=jchf Forwards health metrics from ktranslate into New Relic One. -log_level Overrides the default info log level for ktranslate. The available options are debug, info, warn, or error. -tee_logs Forwards logs from ktranslate into New Relic One Logs. HTTPS_PROXY Environment variable that can be used during Docker runtime to setup ktranslate to ship data to New Relic via proxy. Ex: -e HTTPS_PROXY=https://user:password@hostname:port You can also run several ktranslate images to monitor different network flow types simultaneously. See the follwing example: bash Copy $ docker run -d --name ktranslate-sflow --net=host \\ > -e NEW_RELIC_API_KEY=$INSERT_API_KEY \\ > kentik/ktranslate:v2 \\ > -snmp /snmp-base.yaml \\ > -nr_account_id=$NR_ACCOUNT_ID \\ > -metrics=jchf \\ > -log_level=info \\ > -tee_logs=true \\ > -nf.source=sflow \\ > -nf.port=9996 \\ > -max_threads=1 \\ > -listen 0.0.0.0:8084 \\ > -metalisten 0.0.0.0:8085 \\ > nr1.flow $ $ $ docker run -d --name ktranslate-netflow9 --net=host \\ > -e NEW_RELIC_API_KEY=$INSERT_API_KEY \\ > kentik/ktranslate:v2 \\ > -snmp /snmp-base.yaml \\ > -nr_account_id=$NR_ACCOUNT_ID \\ > -metrics=jchf \\ > -log_level=info \\ > -tee_logs=true \\ > -nf.source=netflow9 \\ > -nf.port=2055 \\ > -max_threads=2 \\ > -listen 0.0.0.0:8086 \\ > -metalisten 0.0.0.0:8087 \\ > nr1.flow Logs sent with Network performance monitoring If you want to check the logs locally, run docker logs ktranslate-snmp. The -tee_logs=true option sends logs to New Relic One when polling devices. To see them, do the following: Go to one.newrelic.com > Logs. In Find logs where enter collector.name:\"ktranslate\" and click Query logs. Tip If you want to filter out all the information messages, enter collector.name:\"ktranslate\" message:-*\\[Info\\]*. Metrics sent with Network performance monitoring The -metrics option captures one of the following performance metrics when polling devices: Metric Description baseserver_healthcheck_execution_total Rate of internal health checks. Shows mostly that things are not deadlocked. delivery_metrics_nr Rate of metrics sent to New Relic One. delivery_logs_nr Rate of logs sent to New Relic One. delivery_wins_nr Rate of 200 HTTP codes received from sending metrics and events to New Relic One. device_metrics Rate of SNMP polling of device level metrics. inputq Messages per second (msg/sec) recieved over the last 60 seconds from SNMP or network flow devices. interface_metrics Rate of SNMP polling of interface level metrics. jchfq Gauge rate with number of available pre-allocated buffers. It should be 8,000 aproximately. To see these metrics in New Relic One: Go to one.newrelic.com and click Query your data. Enter the following NRQL query: FROM Metric SELECT latest(kentik.ktranslate.chf.kkc.baseserver_healthcheck_execution_total) AS 'baseserver_healthcheck_execution_total', latest(kentik.ktranslate.chf.kkc.delivery_metrics_nr) AS 'delivery_metrics_nr', latest(kentik.ktranslate.chf.kkc.delivery_logs_nr) AS 'delivery_logs_nr', latest(kentik.ktranslate.chf.kkc.delivery_wins_nr) AS 'delivery_wins_nr', latest(kentik.ktranslate.chf.kkc.device_metrics) AS 'device_metrics', latest(kentik.ktranslate.chf.kkc.inputq) AS 'inputq', latest(kentik.ktranslate.chf.kkc.interface_metrics) AS 'interface_metrics', latest(kentik.ktranslate.chf.kkc.jchfq) AS 'jchfq' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' LIMIT MAX Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 175.77632,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Advanced configuration for <em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "sections": "Advanced configuration for <em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "tags": "<em>Network</em> <em>performance</em> <em>monitoring</em>",
        "body": "If you want to explore all the options you can use when configuring the <em>monitoring</em> of your <em>network</em> <em>performance</em>, see the following sections. SNMP-base YAML sample file Here&#x27;s an example of the various configuration options available in the snmp-base.yaml file used by the ktranslate docker image"
      },
      "id": "6127249be7b9d29922f565b0"
    }
  ],
  "/docs/network-performance-monitoring/troubleshooting/snmp-troubleshooting-no-devices": [
    {
      "sections": [
        "Get started with Network Performance Monitoring",
        "Types of network performance data",
        "Important",
        "High level architecture overview"
      ],
      "title": "Get started with Network Performance Monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring",
        "Get started"
      ],
      "external_id": "96d12e2c5551a6e5eab76238cd2b787e5c188c01",
      "image": "https://docs.newrelic.com/static/eb0db7c88b717f386c4900a04e12a8ed/e5166/overview_navigator.jpg",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/get-started/npm-introduction/",
      "published_at": "2021-10-24T23:38:43Z",
      "updated_at": "2021-10-24T01:46:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When system performance suffers, you need to know if itâ€™s due to your code, your infrastructure, or the underlying network. And you need to know fast, so you can focus your efforts. With Network Performance Monitoring you can correlate and analyze application, infrastructure, digital experience, and network data all in one place, and understand how network performance and overall system performance impact each other. Using Navigator with Network Performance Monitoring. Network Performance Monitoring adds the context of network data to the application and infrastructure data you already collect in New Relic One. By monitoring your network data, you can: Analyze and understand the performance of your entire stack (application and infrastructure) for a holistic understanding of your system performance. Have all the data in a single platform to eliminate blind spots. See at first glance whether a network is implicated in an issue. Sign up for free! No credit card required. Already have an account? Login. Types of network performance data You can monitor the following types of network performance data: SNMP data: Simple Network Management Protocol (SNMP) is an applicationâ€“layer protocol for exchanging management information between network devices. To send SNMP data to New Relic One, see Set up SNMP data monitoring. Network flow data: It captures information about the IP traffic going to and from network interfaces in your on-premises network. To send network flow data to New Relic One, see Set up network flow data monitoring. Important We recommend configuring both SNMP and network flow data for better visibility into your network. This will provide both performance metrics and traffic patterns to troubleshoot and optimize your network. High level architecture overview Our solution is based on the ktranslate docker container developed by our partner, Kentik. This single container image is hosted in your environment to collect and process your data to be exported to the Event, Metric, and Log APIs and displayed in New Relic One. Overview of Network Performance Monitoring architecture.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 243.06274,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get started with <em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "sections": "Get started with <em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": " Relic One, see Set up <em>network</em> flow data <em>monitoring</em>. Important We recommend configuring both SNMP and <em>network</em> flow data for better visibility into your <em>network</em>. This will provide both <em>performance</em> metrics and traffic patterns to <em>troubleshoot</em> and optimize your <em>network</em>. High level architecture overview Our"
      },
      "id": "6126f39b28ccbc8c49f26162"
    },
    {
      "sections": [
        "Advanced configuration for Network Performance Monitoring",
        "SNMP-base YAML sample file",
        "Devices section",
        "Trap section",
        "Discovery section",
        "Global section",
        "SNMPv3 optional configuration",
        "The flow_only attribute",
        "Advanced options for running the ktranslate docker image",
        "Logs sent with Network performance monitoring",
        "Tip",
        "Metrics sent with Network performance monitoring"
      ],
      "title": "Advanced configuration for Network Performance Monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network performance monitoring",
        "Advanced configuration"
      ],
      "external_id": "8262ac964abbda46760776a63b051e05ecfecc4f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/setup-performance-monitoring/advanced-config/",
      "published_at": "2021-10-24T23:40:19Z",
      "updated_at": "2021-10-13T02:04:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you want to explore all the options you can use when configuring the monitoring of your network performance, see the following sections. SNMP-base YAML sample file Here's an example of the various configuration options available in the snmp-base.yaml file used by the ktranslate docker image to poll for SNMP and flow data devices. devices: deviceOne: device_name: router123 device_ip: 10.10.0.201 oid: .1.3.6.1.4.1.2636.1.1.1.2.21.0 snmp_comm: public poll_time_sec: 300 user_tags: owning_team: net_eng environment: production trap: listen: 127.0.0.1:162 community: public version: \"\" transport: \"\" discovery: cidrs: - 10.10.0.0/24 - 10.20.0.0/24 - 192.168.0.21/32 debug: false ports: - 161 - 1161 default_communities: - public default_v3: null add_devices: true threads: 4 use_snmp_v1: false replace_devices: true global: poll_time_sec: 60 timeout_ms: 5000 retries: 0 mibs_enabled: - IF-MIB drop_if_outside_poll: false mib_profile_dir: profiles Copy Devices section Option name Required Description device_name âœ“ Name of the device reporting to New Relic One device_ip âœ“ IP to send SNMP queries to port Port to send SNMP queries to. By default, it's set to port 161 provider Value used during entity synthesis for New Relic One mib_profile SNMP Profile file that was associated with this device during the discovery run based on its sysOID snmp_comm âœ“ SNMPv1/2c community string to use. For SNMPv3, set it to snmp_v3 use_snmp_v1 Indicates whether to use SNMPv1. By default, it's set to false snmp_v3 SNMPv3 authentication configuration poll_time_sec Indicates the polling frequency in seconds. This setting is used to override the global.poll_time_sec attribute. timeout_ms Indicates the polling timeout in milliseconds. By default, it's set to 5000 retries Indicates the number of attempts to retry to get the device information. By default, it's set to 0 last_checked Timestamp when this device was last discovered by the ktranslate docker image oid âœ“ sysOID for the device description Description of the device discovered_mibs List of MIBs from our known SNMP profiles this device can respond to, found during discovery by the ktranslate docker image debug Indicates whether to run SNMP polling in debug mode. By default, it's set to false user_tags Additional key:value pair attributes to give more context to the device. For example, environment: production match_attributes Additional attribute:regex pairs to whitelist metrics. Only matching attributes are sent. For example, if_Description: \"^igb|^eth\" monitor_admin_shut Indicates whether the monitor shuts interfaces also. By default, it's set to false Trap section Option name Required Description listen âœ“ Listening IP port for receiving SNMP traps community SNMP community string for receiving SNMP traps version SNMP version to use. Options are v1, v2c, and v3. (Default: v2c) transport SNMP transport protocol to use. The possible values are TCP and UDP. By default, it's set to UDP v3_config SNMP v3 config to use. Only used if version is v3. Discovery section Option name Required Description cidrs âœ“ Array of target IP ranges in CIDR notation. You can add /32 at the end of the IP to poll for SNMP devices without testing with ICMP echo. Optionally, you can point to a cidrs.yaml file in the snmp-base.yaml file: discovery: cidrs: \"@cidrs.yaml\" Copy The cidrs.yaml file should be similar to the following - 10.10.0.0/24 - 10.20.0.0/24 - 192.168.0.21/32 Copy ports âœ“ Array of target ports to scan during SNMP polling default_communities âœ“ Array of SNMPv1/v2c community strings to scan during SNMP polling. This array is evaluated in order and discovery accepts the first passing community. For SNMPv3, set it to default_v3 default_v3 SNMPv3 configuration to scan during SNMP polling use_snmp_v1 Indicates whether to use SNMPv1 during discovery. By default, it's set to false add_devices âœ“ Indicates whether to add discovered devices to the devices section of the snmp-base.yaml file. By default, it's set to true add_mibs âœ“ Indicates whether to add discovered MIBs to the global.mibs_enabled section of the snmp-base.yaml file. By default, it's set to true replace_devices âœ“ Indicates whether to replace discovered devices if they already exist in the devices section of the snmp-base.yaml file. By default, it's set to true debug Indicates whether to enable debug level logging during discovery. By default, it's set to false threads âœ“ Integer limit of threads to use during discovery. It must be less than the number of cores available to the container Global section Option name Required Description poll_time_sec âœ“ Time in seconds to poll devices. By default, it's set to 60 timeout_ms âœ“ Time in milliseconds queries timeout. By default, it's set to 5000 retries âœ“ Number of attempts to retry failed polls. By default, it's set to 0 mibs_enabled âœ“ Array of all active MIBs the ktranslate docker image will poll. Polling only occurs if the MIB is valid for a given device drop_if_outside_poll Indicates whether to drop all values from this cycle if polling takes longer than the value set in poll_time_sec. By default, it's set to false mib_profile_dir Directory to find curated MIB profiles SNMPv3 optional configuration Here's an example of SNMPv3 configuration section for the snmp-base.yaml file: yaml default_v3: user_name: userNamev3 authentication_protocol: MD5 authentication_passphrase: authPassPrivacy privacy_protocol: AES256 privacy_passphrase: passPrivacy Copy Option name Required Description user_name âœ“ User name for SNMPv3 authentication authentication_protocol âœ“ SNMPv3 authentication protocol. The possible values are NoAuth, MD5, or SHA authentication_passphrase SNMPv3 authentication passphrase privacy_protocol âœ“ SNMPv3 privacy protocol. The possible values are AuthNoPriv, DES, AES, AES192, AES256, AES192C, or AES256C privacy_passphrase SNMPv3 privacy passphrase context_engine_id SNMPv3 context engine ID context_name SNMPv3 context name The flow_only attribute There are several supported configurations available for running ktranslate against devices for both SNMP and network flow data collection. The flow_only attribute on both a ktranslate docker container level and in the devices section of the snmp-base.yaml file allows you to get different results: If you have multiple containers collecting both SNMP and network flow data with the ktranslate docker image, define your devices in the snmp-base.yaml file, following the standards for SNMP data polling. They will be automatically matched to their respective flows based on their device_ip matching the sampling IP for the flow device. For network flow data devices, run the ktranslate docker image with the -flow_only=true option. snmp-base.yaml file - No setting changes needed If you have multiple containers collecting both SNMP and network flow data with the ktranslate docker image, and you have specific devices where you only want network flow or SNMP data collection and no SNMP or network flow data polling respectively, you can set them up in their respective device configuration section in the snmp-base.yaml file. For network flow data devices, run the ktranslate docker image with the -flow_only=true option. snmp-base.yaml file - Change the flow_only to true: flow_only: true Copy Advanced options for running the ktranslate docker image In this table you can find additional options you can use with the ktranslate docker image. Option name Description -max_threads Lets you process higher volumes of flow. We recommend one CPU core available for every 2,000 flows per second (fps) of network flow data sent. -sample_rate=100 Changes the default sample rate value at which flows are passed to New Relic One Events. It also sets the sample rate value for flow types that don't have a default sample rate value. -nf.workers=1 Overrides the number of workers used in processing udp packets. Use one worker for every 4,000 of flows per second (fps) of network flow data sent. -nf.port Overrides the default 9995 listening port for incoming flow packets. -listen Overrides the default 8082 port used by ktranslate to expose health metrics. You must use this option when running multiple ktranslate containers on a single host. -metalisten Overrides the default 8083 port used by ktranslate to expose metadata. You must use this option when running multiple ktranslate containers on a single host. -metrics=jchf Forwards health metrics from ktranslate into New Relic One. -log_level Overrides the default info log level for ktranslate. The available options are debug, info, warn, or error. -tee_logs Forwards logs from ktranslate into New Relic One Logs. HTTPS_PROXY Environment variable that can be used during Docker runtime to setup ktranslate to ship data to New Relic via proxy. Ex: -e HTTPS_PROXY=https://user:password@hostname:port You can also run several ktranslate images to monitor different network flow types simultaneously. See the follwing example: bash Copy $ docker run -d --name ktranslate-sflow --net=host \\ > -e NEW_RELIC_API_KEY=$INSERT_API_KEY \\ > kentik/ktranslate:v2 \\ > -snmp /snmp-base.yaml \\ > -nr_account_id=$NR_ACCOUNT_ID \\ > -metrics=jchf \\ > -log_level=info \\ > -tee_logs=true \\ > -nf.source=sflow \\ > -nf.port=9996 \\ > -max_threads=1 \\ > -listen 0.0.0.0:8084 \\ > -metalisten 0.0.0.0:8085 \\ > nr1.flow $ $ $ docker run -d --name ktranslate-netflow9 --net=host \\ > -e NEW_RELIC_API_KEY=$INSERT_API_KEY \\ > kentik/ktranslate:v2 \\ > -snmp /snmp-base.yaml \\ > -nr_account_id=$NR_ACCOUNT_ID \\ > -metrics=jchf \\ > -log_level=info \\ > -tee_logs=true \\ > -nf.source=netflow9 \\ > -nf.port=2055 \\ > -max_threads=2 \\ > -listen 0.0.0.0:8086 \\ > -metalisten 0.0.0.0:8087 \\ > nr1.flow Logs sent with Network performance monitoring If you want to check the logs locally, run docker logs ktranslate-snmp. The -tee_logs=true option sends logs to New Relic One when polling devices. To see them, do the following: Go to one.newrelic.com > Logs. In Find logs where enter collector.name:\"ktranslate\" and click Query logs. Tip If you want to filter out all the information messages, enter collector.name:\"ktranslate\" message:-*\\[Info\\]*. Metrics sent with Network performance monitoring The -metrics option captures one of the following performance metrics when polling devices: Metric Description baseserver_healthcheck_execution_total Rate of internal health checks. Shows mostly that things are not deadlocked. delivery_metrics_nr Rate of metrics sent to New Relic One. delivery_logs_nr Rate of logs sent to New Relic One. delivery_wins_nr Rate of 200 HTTP codes received from sending metrics and events to New Relic One. device_metrics Rate of SNMP polling of device level metrics. inputq Messages per second (msg/sec) recieved over the last 60 seconds from SNMP or network flow devices. interface_metrics Rate of SNMP polling of interface level metrics. jchfq Gauge rate with number of available pre-allocated buffers. It should be 8,000 aproximately. To see these metrics in New Relic One: Go to one.newrelic.com and click Query your data. Enter the following NRQL query: FROM Metric SELECT latest(kentik.ktranslate.chf.kkc.baseserver_healthcheck_execution_total) AS 'baseserver_healthcheck_execution_total', latest(kentik.ktranslate.chf.kkc.delivery_metrics_nr) AS 'delivery_metrics_nr', latest(kentik.ktranslate.chf.kkc.delivery_logs_nr) AS 'delivery_logs_nr', latest(kentik.ktranslate.chf.kkc.delivery_wins_nr) AS 'delivery_wins_nr', latest(kentik.ktranslate.chf.kkc.device_metrics) AS 'device_metrics', latest(kentik.ktranslate.chf.kkc.inputq) AS 'inputq', latest(kentik.ktranslate.chf.kkc.interface_metrics) AS 'interface_metrics', latest(kentik.ktranslate.chf.kkc.jchfq) AS 'jchfq' WHERE provider = 'kentik-agent' AND instrumentation.name = 'heartbeat' LIMIT MAX Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 163.85623,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Advanced configuration for <em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "sections": "Advanced configuration for <em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "tags": "<em>Network</em> <em>performance</em> <em>monitoring</em>",
        "body": "If you want to explore all the options you can use when configuring the <em>monitoring</em> of your <em>network</em> <em>performance</em>, see the following sections. SNMP-base YAML sample file Here&#x27;s an example of the various configuration options available in the snmp-base.yaml file used by the ktranslate docker image"
      },
      "id": "6127249be7b9d29922f565b0"
    },
    {
      "sections": [
        "Set up network flow data monitoring",
        "Prerequisites",
        "New Relic One account prerequisites",
        "Linux host prerequisites",
        "Network flow data devices prerequisites",
        "Network security prerequisites",
        "Supported types of network flow data",
        "Important",
        "Scaling network flow collection",
        "Set up network flow data monitoring in New Relic One",
        "Manual setup",
        "Tip"
      ],
      "title": "Set up network flow data monitoring",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network Performance Monitoring",
        "Installation",
        "Setup",
        "NPM"
      ],
      "external_id": "626c9bebce36e550d5793d8ef932e6d654c23e47",
      "image": "https://docs.newrelic.com/static/3d1561743f3311471975006fa41f628a/c1b63/network-flows-guided-install.png",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/setup-performance-monitoring/network-flow-monitoring/",
      "published_at": "2021-10-24T23:40:19Z",
      "updated_at": "2021-10-13T03:31:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Set up your network devices so they send network data to New Relic One. Prerequisites New Relic One account prerequisites A New Relic account. Don't have one? Sign up for free! No credit card required. A New Relic account ID. Read how to find your account ID. A New Relic license key. Read how to generate a new License key. Linux host prerequisites Docker installed in a Linux host. SSH access to the Docker host, with the ability to launch new containers. Network flow data devices prerequisites Configured network devices to send flow data to the host running the ktranslate docker container. Here's how to configure network flow data collection in some devices: NetFlow data Palo Alto - PAN-OS Fortinet Fortigate Cisco - NX-OS Cisco - IOS Cisco - Meraki sFlow data F5 - BIG-IP jFlow data Juniper - Junos Network security prerequisites Direction Source Destination Ports Protocol Outbound Docker host ktranslate image on Docker Hub 443 TCP Outbound Docker host New Relic Event API US Endpoint: https://insights-collector.newrelic.com EU Endpoint: https://insights-collector.eu01.nr-data.net 443 TCP Outbound Docker host New Relic Log API US Endpoint: https://log-api.newrelic.com EU Endpoint: https://log-api.eu.newrelic.com 443 TCP Inbound Source devices for network flow data Docker host 9995 (default) UDP Supported types of network flow data NPM flow monitoring supports the four primary types of network flow data and their derivatives. When running the ktranslate container, you will specify which major type you want to monitor using the -nf.source option. Important The ktranslate container only supports monitoring one type of network flow data type at a time. If you want to monitor several types, each will require a container. IPFIX and NetFlow v9 can be sent to the same container, but we recommend running a separate container as a best practice. Network flow data type -nf.source value IPFIX ipfix NetFlow v5 netflow5 NetFlow v9 netflow9 sFlow sflow AppFlow netflow5 Argus netflow5 cflowd netflow5 J-Flow netflow5 NetStream netflow5 RFlow netflow5 Cisco NSEL netflow9 Scaling network flow collection When planning your strategy for collecting network flows at scale, New Relic recommends 1 CPU per 2000 flows-per-second (120,000 flows-per-minute). Deciding whether to run more small containers to distribute load or fewer large containers to consolidate management is a matter of personal preference. Set up network flow data monitoring in New Relic One Go to one.newrelic.com and click Add more data. Scroll down until you see Network performance monitoring and click Network Flows. Follow the steps in New Relic One. one.newrelic.com > Add more data > Network performance monitoring > Network Flows to set up network flow data monitoring. To get better visibility into your network device performance, set up SNMP data monitoring. Visualize your network performance data in New Relic. Manual setup If you prefer to do the setup manually, proceed with the following steps. In your local machine, from a Linux host with Docker installed, download the ktranslate image from dockerhub by running bash Copy $ docker pull kentik/ktranslate:v2 Copy the snmp-base.yaml file to the local $HOME directory of your Docker user, and discard the container by running bash Copy $ cd . $ id=$(docker create kentik/ktranslate:v2) $ docker cp $id:/etc/ktranslate/snmp-base.yaml . $ docker rm -v $id In the snmp-base.yaml file, add your network flow devices inside the devices key with the following structure: devices: flowDevice: device_name: edge-router device_ip: 10.10.1.254 flow_only: true # Optional user tags user_tags: owning_team: net_eng environment: production Copy Tip If you're already monitoring SNMP data devices that send network flow data, you don't need to add them in your snmp-base.yaml file a second time. Run ktranslate to listen for network flows by running: Tip Add your New Relic license key and your account ID in the $NR_LICENSE_KEY and $NR_ACCOUNT_ID variables respectively. bash Copy $ docker run -d --name ktranslate-sflow --restart unless-stopped --net=host \\ > -v `pwd`/snmp-base.yaml:/snmp-base.yaml \\ > -e NEW_RELIC_API_KEY=$NR_LICENSE_KEY \\ > kentik/ktranslate:v2 \\ > -snmp /snmp-base.yaml \\ > -nr_account_id=$NR_ACCOUNT_ID \\ > -metrics=jchf \\ > -log_level=info \\ > -tee_logs=true \\ > -flow_only=true \\ > -nf.source=sflow \\ > nr1.flow $ ## If your account is located in Europe, you need to add the following option before the nr1.flow line $ ## -nr_region=EU \\ Tip This command assumes collection of sflow data. If you are collecting other flow types, you should change the suffix in the --name flag for the container and update the -nf.source argument as necessary To get better visibility into your network device performance, set up SNMP data monitoring. Visualize your network performance data in New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.91338,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Set up <em>network</em> flow data <em>monitoring</em>",
        "sections": "Set up <em>network</em> flow data <em>monitoring</em>",
        "tags": "<em>Network</em> <em>Performance</em> <em>Monitoring</em>",
        "body": " will specify which major type you want to <em>monitor</em> using the -nf.source option. Important The ktranslate container only supports <em>monitoring</em> one type of <em>network</em> flow data type at a time. If you want to <em>monitor</em> several types, each will require a container. IPFIX and NetFlow v9 can be sent to the same container"
      },
      "id": "612724e128ccbc4ac9f2612a"
    }
  ],
  "/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application": [
    {
      "sections": [
        "Introduction to New Relic One",
        "Tip",
        "Quickly understand context",
        "Query your data more easily",
        "Enhanced dashboards",
        "Build on New Relic One",
        "Whatâ€™s next?"
      ],
      "title": "Introduction to New Relic One",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "c9ba93c83a579625a4ba3364c6046f3c475cba3a",
      "image": "https://docs.newrelic.com/static/2bc08b6d64c16b39697bb43d8e66870e/c1b63/nrone20210722.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-10-24T17:36:54Z",
      "updated_at": "2021-10-24T17:36:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic One is the platform that gives you access to core platform capabilities like querying data and building charts, our more curated observability UI experiences features, and our alerting and Applied Intelligence tools. With New Relic One, you can see and act on all the data throughout your entire system. To access New Relic One: Go to one.newrelic.com. Or, if you report data to the EU data center go to one.eu.newrelic.com. Tip Learn more about New Relic Oneâ€™s basic UI features. Quickly understand context We provide multiple ways to understand your system's dependencies, so you can easily see how everything fits together and troubleshoot problems. New Relic One gives you and your teams a connected view that cuts through complexity! If you want to... Use this Have an overall view of your system, and drill down to get performance details. Use the New Relic Explorer as the front door to New Relic One: observe, group, and filter the performance data from all the entities (that is, all applications, services, hosts, or containers) in your system. Gain extensive visibility into each entity in your solution, its alert status, and how the entities are connected. Use the New Relic Navigator to give you a high density overview of all your entities so you can detect any issues at a glance. And use the New Relic Lookout to spot entities recently experiencing behavior deviations. Provide context for your entities. Add tags to all your entities. Or create tags for teams and all the services they monitor. Use tags to illustrate relationships and contextual information for what you monitor. By thoughtfully tagging your entities, you can connect all the data your teams need to understand their increasingly complex and interdependent systems. See how each part of your system is connected. Service maps illustrate your upstream and downstream dependencies. Visualize the aggregated health and activity data from all you monitor. Group and monitor any entities together into functional team-focused, project-focused groupings, or any other attribute, with workloads. Fetch and analyze specific data. Get more context while you query with the query builder, which surfaces data definitions as you craft and edit queries. Create visuals that showcase your business needs at a glance. Tailor custom dashboards for your unique needs. Find a service or dashboard in a complex environment. Search by name across all accounts in the unified search, or filter the explorer by tags or text. View everything youâ€™re monitoring in one place, like entities or dashboards across your organization. View a list of all the dependencies for a service. The dependencies view tab in an entity summary shows all the dependencies of the entity youâ€™re viewing. Track activity as it moves across your distributed system. Distributed tracing helps you analyze your modern environment. Understand how everything is connected via API. The NerdGraph GraphiQL explorer manages all your entities, tags, and relationships. Query your data more easily On the Browse data menu on the top navigation menu you can easily access your basic telemetry data (metrics, events, logs, and traces). Wherever you go in the UI, Query your data is available. No matter your level of proficiency with our query language, you can create custom queries and charts: Browse your data in a query-less experience with our data explorer. Use your NRQL (our query language) expertise to build custom charts in the query builder. Run PromQL-style queries in the query builder. one.newrelic.com > Query your data: Build NRQL and PROMQL-like queries. Enhanced dashboards one.newrelic.com > Dashboards: Quickly create information dense custom views into the data that matters most to you with dashboards in New Relic One. New Relic One dashboards let you build better visualizations more easily, with more options to customize. Dashboard features include: Perform NRQL queries and create charts and dashboards everywhere in the platform using the query builder. Manage your charts and dashboards easily using our quick-access CRUD menus and editing options. Explore and contextualize data with advanced tooltips and zoom in functions to monitor what your systems are doing in real time. Search your dashboards for attributes and metrics. Send data to your dashboards using our agents, integrations, and APIs. Share dashboards or charts as a .pdf, or embed a chart in an external site. Tip If you previously used New Relic Insights to create dashboards, these are available as New Relic One dashboards. Build on New Relic One If custom charts and dashboards don't solve your current challenge, we give you a framework for building React JavaScript applications that: Live on New Relic One, alongside your other New Relic-monitored data. Feature highly tailored visualizations. Display data from any source you want, whether from a New Relic-monitored entity or data from any service or API. And you can use open source apps built by the community, and contribute your own open source apps. To learn more, see New Relic One applications. Whatâ€™s next? To get started understanding how to get around in New Relic One: See what data you have available with the data explorer. Browse your monitored entities with the New Relic Explorer. Use our NerdGraph API to add tags to your data. Learn about dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 323.73053,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "sections": "<em>Build</em> <em>on</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " easily see how everything fits together and troubleshoot problems. <em>New</em> <em>Relic</em> <em>One</em> gives you and your teams a connected view that cuts through complexity! If you want to... <em>Use</em> this Have an overall view of your system, and drill down to get performance details. <em>Use</em> the <em>New</em> <em>Relic</em> Explorer as the front"
      },
      "id": "603ec19164441f9e704e8896"
    },
    {
      "sections": [
        "What is an entity in New Relic?",
        "What's an entity?",
        "Find and explore entities and entity data",
        "Tip",
        "Group and organize entities",
        "Customize entity data with entity synthesis",
        "Reserved attributes for synthesized entities",
        "Entity relationships",
        "Important",
        "Which relationships are created?",
        "Source: New Relic agent",
        "Source: Infrastructure",
        "Source: Synthetics monitor",
        "Source: Kubernetes",
        "External services"
      ],
      "title": "What is an entity in New Relic?",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "52a3e08bc9103c717d27b153e4fd4f547d6ecc32",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-10-24T17:34:57Z",
      "updated_at": "2021-09-01T17:25:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic monitoring is built around the concept of entities. In this doc, you'll learn how we define entities, what you can do with them, and how you can create your own entities or groupings of entities. What's an entity? From a New Relic perspective, entity is purposefully a broad concept. An entity is anything that a) reports data to New Relic or that contains data that we have access to, and b) is something we've identified with a unique entity ID. For most entities, the ID is indicated by the attribute entityGuid. An entity can be any fundamental data-reporting component, like an application, a host, or a database service, but it can also refer to larger groupings of those components. For example, to monitor a data center, you could aggregate those hosts in New Relic to be a workload (a custom grouping of entities). That workload is, itself, also an entity. Also very important is the relationships between entities. Our behind-the-scenes relationship-mapping helps us understand how entities are connected, how they affect each other. And this allows us to give you the power to configure how any data you're bringing in is related to existing entities, or how it's related to other entities. Our focus on entities and their relationships is important because our goal is to give you practical information about your business-important entities, and not give you an unhelpfully huge stream of data from a huge list of monitored things. With more insight at the entity level, you can better monitor and troubleshoot complex, modern systems. Find and explore entities and entity data Tip You can create new entity types for monitoring any data source. Learn more about entity synthesis. Some tips for finding and understanding entity data: To find an entity's entityGuid and entityName and other metadata: from any list of monitored entities in the New Relic Explorer, click an entity's icon, and click See metadata and tags. For most entities, its GUID is reported as the attribute entityGuid. For workloads, it's workloadGuid. You can run NRQL queries to find entities by their GUID. To see connections between entities, you have several options: When viewing an entity in the UI, use the Related entities UI. Service maps. Distributed tracing. Our NerdGraph API. To group entities together, see Group entities. Customize entity definitions and relationships. To learn technical details about entity types, see our GitHub repo. In an entity type's definition file, you'll see information like: The domain: for example, APM, or Infra. Its type: for example, Application or AWSECSCONTAINERINSTANCE. Default tags. The entityExpirationTime: how long data from that entity lasts in the UI, which is different from database data retention. Group and organize entities You can place entities into groups that reflect business-important relationships in your organization. For example, you might group all entities related to a specific team or department, or related to a specific service. Or you might group multiple hosts together to reflect their grouping in a data center. To group your entities, see: Tag entities. Create workloads, which allow you to group business-important sets of entities. Create entities and customize entity data Customize entity data with entity synthesis If you have telemetry from any source that's not supported by New Relic out of the box, you can propose a mapping for it. Once approved, any telemetry received by New Relic that matches your definition file will be synthesized into an entity. To learn more: For reserved attributes and how entity relationships are defined, keep reading this doc. For how to do the work of modifying existing entity types or creating new ones, see our GitHub repo on entity synthesis. Reserved attributes for synthesized entities These attributes are meant to be synthesized from the telemetry we receive. Do not set them unless you're aware of the implications and consequences. Attribute Description entity.guid Generally, you should not set this attribute field on your telemetry data. New Relic may add this field to ingested data to store a unique identifier for the entity associated with the data point. If telemetry arrives with the entity.guid attribute already present, then New Relic will not change the value. However, it may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. One use case for passing this attribute is to associate ingested telemetry with an entity already created by New Relic. When the entity.guid attribute is sent, the value will override New Relicâ€™s entity identification system (such as entity synthesis definitions) and instead will use the attribute as the data. entity.name This attribute shouldn't be put on ingested telemetry data unless you're trying to override the entity name that would have been selected by New Relicâ€™s entity identification system. While New Relic won't change the value if it's already present on the data, New Relic may add the attribute to your data. Therefore invalid or unexpected values may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. If this field is present on ingested telemetry, its value will be used to name the entity associated with the data point. This name will be used instead of the name selected by New Relicâ€™s entity identification system (for example, entity synthesis definitions). Note that many entities use the name as part of their identification, so changing this field may result in the generation of a new entity. entity.type This attribute shouldn't be put on ingested telemetry data except for certain legacy cases where it's required to distinguish entity types. Passing this field may interfere with entity detection, particularly if unrecognized values are sent in this field. While New Relic won't change the value if already present on the data, the field is not guaranteed to provide unambiguous filtering of telemetry at query-time. Existing entity definitions already have overlapping values, and we recommend avoiding entity.type in favor of other fields for filtering telemetry queries. This field is used by New Relic, meaning that invalid or unexpected values may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. To learn how to do the work of modifying existing entity types or creating new ones, see our GitHub repo on entity synthesis. Entity relationships Connections between entities are automatically created by New Relic based on what we can infer from your telemetry. For example, when two services that communicate using HTTP are instrumented with New Relic, we infer a \"calls/called-by\" relationship between them. When viewing a specific entity in either the New Relic Explorer, Navigator, or Lookout, you can see its Related entities in the entity's mini overview. This gives a visualization of the various entities connected directly to the current entity. You can quickly view important metrics for these related entities and navigate from one entity to another, through all the connected parts of your stack. Tip Learn more about how entities are related with our NerdGraph API. When relationships are not automatically detected, you can manually create them using the \"Add/edit related entities\" link in Related entities. Important Currently, you can only manually create calls/called-by relationships between service entities. Tip To manage manual relationships, you need to have modify and delete capabilities on entity relationships. If you donâ€™t see the edit relationships button, contact your account admin. Which relationships are created? These are the relationships created between entities: Source: New Relic agent Relationship source Relationship type Relationship target Why is the relationship created? Application instrumented with a New Relic agent CALLS Application instrumented with a New Relic agent Relationships between applications monitored by New Relic agents are reported using the DurationByCaller metric. The callee reports the metric. For example, the metric DurationByCaller/Mobile/100/1234/HTTP/all indicates that the caller is APPLICATION 1234 for account 100. Application instrumented with a New Relic agent CALLS Service instrumented with a New Relic agent An application (caller) that calls a service (callee) monitored by New Relic creates a relationship that's reported by the caller using the ExternalApp metric. For example, the metric ExternalApp/dirac.vips.net/100#1234/all indicates that the callee is APPLICATION 1234 for account 100. The metric is reported if the callee successfully responds to the caller. Service instrumented with a New Relic agent CALLS Service instrumented with a New Relic agent When a New Relic agent detects that a service (caller) calls another service (callee) instrumented by New Relic, the callee reports the metric ClientApplication. For example, the metric ClientApplication/100#1234/all indicates that the caller is APPLICATION 1234 for account 100. Service instrumented with a New Relic agent CALLS A datastore instance When an application calls a datastore instance it creates a relationship reported with the DatastoreInstance metric. For example, the metric Datastore/instance/MySQL/172.16.16.3/3306 indicates the datastore instance is vendor: MySQL, host: 172.16.16.3, port: 3306. This metric also supports the legacy datastore instance format Datastore/instance/MySQL/172.16.16.3:3306. Currently we cannot determine whether the datastore instance is instrumented by New Relic and has an entity associated to it. APM agent SERVES Browser agent This relationship is created when an APM agent injects the browser agent into a page. Workload entity CONTAINS Any entity When a workload is created or updated, relationships for each of the entities that belong to the workload are created. Because some workloads are â€œdynamicâ€ (defined by tags), relationships are re-created every 5 minutes. This way entities can join or leave the workload. Source: Infrastructure Relationship source Relationship type Relationship target Why is the relationship created? Infrastructure host HOSTS Application This relationship is created when an application is running in one or more hosts, and the infra agent is running in those hosts. Infrastructure host HOSTS Container This relationship is created when containers are running in one or more hosts, and the host is instrumented with the infra agent. Source: Synthetics monitor Relationship source Relationship type Relationship target Why is the relationship created? Synthetics Monitor CALLS Browser agent This relationship is created when a synthetics monitor checks a page instrumented with the browser agent. Synthetics Monitor CALLS APM application Agent events that contain the attribute nr.syntheticsMonitorId have been described as synthetics monitors (the source) interacting with an APM application (the target). If the header exists and the APM application Id exists, a relationship is created between the monitor and the app. Source: Kubernetes Relationship source Relationship type Relationship target Why is the relationship created? Cluster CONTAINS Pod This relationship is created when a pod is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS Deployment This relationship is created when a deployment is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS DaemonSet This relationship is created when a DaemonSet is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS StatefulSet This relationship is created when a StatefulSet is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS Host This relationship is created when a host that's part of a cluster is instrumented with the New Relic Kubernetes integration. Deployment CONTAINS Pod This relationship is created when a deployment creates a pod in a cluster instrumented with the New Relic Kubernetes integration. DaemonSet CONTAINS Pod This relationship is created when a DaemonSet is created a pod in a cluster instrumented with the New Relic Kubernetes integration. StatefulSet CONTAINS Pod This relationship is created when a StatefulSet creates a pod in a cluster instrumented with the New Relic Kubernetes integration. Pod CONTAINS Container This relationship is created when a pod creates a container in a cluster instrumented with the New Relic Kubernetes integration. Host HOSTS Pod This relationship is created when a pod is running in a host that's part of a cluster instrumented with the New Relic Kubernetes integration. Container HOSTS Application This relationship is created when an application is running in docker, and the hosts where docker is running are instrumented by the the infra agent. External services Relationship source Relationship type Relationship target Why is the relationship created? External service CALLS External service When the relationship is created, the external service reports a span with its name on the service.name attribute and the name of the service that initiates the call in the parent.service.name attribute. Application IS External service A relationship between an application and an external service is created so that users can navigate between them using the related entities component. Browser application instrumented with a New Relic agent CALLS External service A browser application reports an Ajax/HostTransaction metric when calling an external service (URL). Example metric: Ajax/HostTransaction/api.segment.io:443/CallbackTime' Cluster CONTAINS External service When the relationship is created, the external service reports a span with the attribute k8s.cluster.name, the name of the cluster. The cluster must be instrumented with the New Relic Kubernetes integration and the cluster name set for the integration must match the one reported in the span. Pod HOSTS External service When the relationship is created, the external service reports a span with the following attributes: service.name: The name of the service. k8s.cluster.name: The name of the cluster. k8s.pod.name: The name of the pod thatâ€™s running the service. k8s.namespace.name: The namespace where the pod was created. The cluster must be instrumented with the New Relic Kubernetes integration and the cluster name set for the integration must match the one reported in the span.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 154.93745,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "What is an entity in <em>New</em> <em>Relic</em>?",
        "sections": "What is an entity in <em>New</em> <em>Relic</em>?",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": ". If telemetry arrives with the entity.guid attribute already present, then <em>New</em> <em>Relic</em> will not change the value. However, it may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. <em>One</em> <em>use</em> case for passing this attribute is to associate"
      },
      "id": "603ec160e7b9d295f72a07fc"
    },
    {
      "sections": [
        "Dependencies UI: View an entity's upstream and downstream dependencies",
        "Requirements",
        "View dependencies"
      ],
      "title": "Dependencies UI: View an entity's upstream and downstream dependencies",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "2b2f328a6281bb155bcde07efec7f42eae943048",
      "image": "https://docs.newrelic.com/static/aabc5f64a91cc01b6e226df53c62458f/c1b63/new-relic-one-dependencies-UI.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/explore-downstream-dependencies-new-relic-one/",
      "published_at": "2021-10-18T06:29:36Z",
      "updated_at": "2021-08-21T09:29:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In the New Relic Explorer, an entity's Dependencies page shows a filterable list of all the applications, services, databases, and hosts connected to the entity. It shows upstream and downstream dependencies, and provides paths to explore them. Similar to service maps, the dependencies page helps you understand how all of your upstream and downstream services are connected. It also uses the same color coding system used by service maps to show you what's performing well and what isn't. Requirements To view an entity's dependencies, make sure your app uses the minimum required APM agent version: C 1.0.0 or higher Go 1.11 or higher Java 3.9.0 or higher .NET 4.2 or higher Node.js 2.0.0 or higher PHP 4.19.0 or higher Python 2.38.0.31 or higher Ruby 4.3.0 or higher View dependencies To view dependencies for applications, services, databases, and hosts connected to an entity: Go to one.newrelic.com, select Explorer, and select an entity. Select Dependencies. To drill down further, filter the apps, services, databases, or hosts. one.newrelic.com > Explorer > (select an entity) > Dependencies: View a filterable list of all the apps, services, databases, and hosts connected to an entity, and their color-coded health status. You can filter the dependencies page to view specific things that report to the entity. Dependencies include: Services: APM-monitored applications and services. Mobile applications: your mobile apps. Browser applications: your front-end browser apps. External services: external services monitored by APM. External services include out-of-process services such as web services, resources in the cloud, and any other network calls. Databases: your application's database and cache data. Databases are agentless. Because of this, alerts cannot be set for the database, as only the service call is reported to New Relic. Hosts: your infrastructure (servers and hosts).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 151.19214,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": "In the <em>New</em> <em>Relic</em> Explorer, an entity&#x27;s Dependencies page shows a filterable list of all the applications, services, databases, and hosts connected to the entity. It shows upstream and downstream dependencies, and provides paths to explore them. Similar to service maps, the dependencies page helps"
      },
      "id": "603eb2e564441f0fe44e889b"
    }
  ],
  "/docs/new-relic-one/use-new-relic-one/core-concepts/dashboards-api-migration-insights-api-nerdgraph": [
    {
      "sections": [
        "Introduction to New Relic One",
        "Tip",
        "Quickly understand context",
        "Query your data more easily",
        "Enhanced dashboards",
        "Build on New Relic One",
        "Whatâ€™s next?"
      ],
      "title": "Introduction to New Relic One",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "c9ba93c83a579625a4ba3364c6046f3c475cba3a",
      "image": "https://docs.newrelic.com/static/2bc08b6d64c16b39697bb43d8e66870e/c1b63/nrone20210722.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-10-24T17:36:54Z",
      "updated_at": "2021-10-24T17:36:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic One is the platform that gives you access to core platform capabilities like querying data and building charts, our more curated observability UI experiences features, and our alerting and Applied Intelligence tools. With New Relic One, you can see and act on all the data throughout your entire system. To access New Relic One: Go to one.newrelic.com. Or, if you report data to the EU data center go to one.eu.newrelic.com. Tip Learn more about New Relic Oneâ€™s basic UI features. Quickly understand context We provide multiple ways to understand your system's dependencies, so you can easily see how everything fits together and troubleshoot problems. New Relic One gives you and your teams a connected view that cuts through complexity! If you want to... Use this Have an overall view of your system, and drill down to get performance details. Use the New Relic Explorer as the front door to New Relic One: observe, group, and filter the performance data from all the entities (that is, all applications, services, hosts, or containers) in your system. Gain extensive visibility into each entity in your solution, its alert status, and how the entities are connected. Use the New Relic Navigator to give you a high density overview of all your entities so you can detect any issues at a glance. And use the New Relic Lookout to spot entities recently experiencing behavior deviations. Provide context for your entities. Add tags to all your entities. Or create tags for teams and all the services they monitor. Use tags to illustrate relationships and contextual information for what you monitor. By thoughtfully tagging your entities, you can connect all the data your teams need to understand their increasingly complex and interdependent systems. See how each part of your system is connected. Service maps illustrate your upstream and downstream dependencies. Visualize the aggregated health and activity data from all you monitor. Group and monitor any entities together into functional team-focused, project-focused groupings, or any other attribute, with workloads. Fetch and analyze specific data. Get more context while you query with the query builder, which surfaces data definitions as you craft and edit queries. Create visuals that showcase your business needs at a glance. Tailor custom dashboards for your unique needs. Find a service or dashboard in a complex environment. Search by name across all accounts in the unified search, or filter the explorer by tags or text. View everything youâ€™re monitoring in one place, like entities or dashboards across your organization. View a list of all the dependencies for a service. The dependencies view tab in an entity summary shows all the dependencies of the entity youâ€™re viewing. Track activity as it moves across your distributed system. Distributed tracing helps you analyze your modern environment. Understand how everything is connected via API. The NerdGraph GraphiQL explorer manages all your entities, tags, and relationships. Query your data more easily On the Browse data menu on the top navigation menu you can easily access your basic telemetry data (metrics, events, logs, and traces). Wherever you go in the UI, Query your data is available. No matter your level of proficiency with our query language, you can create custom queries and charts: Browse your data in a query-less experience with our data explorer. Use your NRQL (our query language) expertise to build custom charts in the query builder. Run PromQL-style queries in the query builder. one.newrelic.com > Query your data: Build NRQL and PROMQL-like queries. Enhanced dashboards one.newrelic.com > Dashboards: Quickly create information dense custom views into the data that matters most to you with dashboards in New Relic One. New Relic One dashboards let you build better visualizations more easily, with more options to customize. Dashboard features include: Perform NRQL queries and create charts and dashboards everywhere in the platform using the query builder. Manage your charts and dashboards easily using our quick-access CRUD menus and editing options. Explore and contextualize data with advanced tooltips and zoom in functions to monitor what your systems are doing in real time. Search your dashboards for attributes and metrics. Send data to your dashboards using our agents, integrations, and APIs. Share dashboards or charts as a .pdf, or embed a chart in an external site. Tip If you previously used New Relic Insights to create dashboards, these are available as New Relic One dashboards. Build on New Relic One If custom charts and dashboards don't solve your current challenge, we give you a framework for building React JavaScript applications that: Live on New Relic One, alongside your other New Relic-monitored data. Feature highly tailored visualizations. Display data from any source you want, whether from a New Relic-monitored entity or data from any service or API. And you can use open source apps built by the community, and contribute your own open source apps. To learn more, see New Relic One applications. Whatâ€™s next? To get started understanding how to get around in New Relic One: See what data you have available with the data explorer. Browse your monitored entities with the New Relic Explorer. Use our NerdGraph API to add tags to your data. Learn about dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 280.59143,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Enhanced <em>dashboards</em>",
        "body": ". Whatâ€™s next? To get started understanding how to get around in New Relic One: See what data you have available with the data explorer. Browse your monitored entities with the New Relic Explorer. Use our <em>NerdGraph</em> <em>API</em> to add tags to your data. Learn about <em>dashboards</em>."
      },
      "id": "603ec19164441f9e704e8896"
    },
    {
      "sections": [
        "NerdGraph tutorial: Manage data partition rules",
        "Data partition rule schema",
        "Example query of data partitions rules",
        "Create data partitions rules",
        "Update data partitions rules",
        "Delete data partitions rules"
      ],
      "title": "NerdGraph tutorial: Manage data partition rules",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples",
        "Logs"
      ],
      "external_id": "b2a64a1935bf04aadfa82cf15ec7544eb40dcc99",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-data-partition-rules-tutorial/",
      "published_at": "2021-10-24T22:57:21Z",
      "updated_at": "2021-10-24T22:57:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use NerdGraph at api.newrelic.com/graphiql to create, query, and manage your data partition rules for logs. NerdGraph is our GraphQL-format API explorer. Data partition rule schema Available data partition rule fields include: Fields Description id Unique data partition rule identifier. targetDataPartition The name of the data partition. description A description of what this data partition rule represents. matchingCriteria The matching criteria for this data partition rule. Once the rule is enabled, logs matching this criteria will be routed to the specified data partition. retentionPolicy The retention policy of the data partition data. createdAt The date and time the rule was created. createdBy The user who created the rule. updatedAt The date and time the rule was last changed. updatedBy The user who last updated the rule. enabled Whether or not this data partition rule is enabled. deleted Whether or not this data partition rule has been deleted. Deleting a data partition rule does not delete the already routed logs. Example query of data partitions rules This NerdGraph API request example gets all of the data partition rules for a given account. In this example, only a few fields are requested. { actor { account(id: 123456) { logConfigurations { dataPartitionRules { id targetDataPartition description matchingCriteria { attributeName matchingOperator matchingExpression } } } } } } Copy Create data partitions rules This example creates a new data partition rule. Before creating the rule, be sure to review our documentation about organizing data with partitions. mutation { logConfigurationsCreateDataPartitionRule( accountId: 1123456, rule: { targetDataPartition: \"Log_aNewDataPartitionRule\", description: \"Example data partition rule\", matchingCriteria: { attributeName: \"attribute\", matchingMethod: LIKE, matchingExpression: \"'%example%'\" }, retentionPolicy: STANDARD, enabled: true }) { rule { id targetDataPartition description } errors { message type } } } Copy Update data partitions rules This example updates the data partition rule with the given id \"123\". The fields that can be updated are description, matchingCriteria, and enabled. All of them are optional, so you only need to use the ones you want to update. mutation { logConfigurationsUpdateDataPartitionRule( accountId: 1123456, rule: { id: \"123\", description: \"Example data partition rule\", matchingCriteria: { attributeName: \"attribute\", matchingMethod: LIKE, matchingExpression: \"'%example%'\" }, enabled: true }) { rule { id targetDataPartition description } errors { message type } } } Copy Delete data partitions rules This example deletes a data partition rule. Deleting a data partition rule doesn't delete data that has already been partitioned. That data is retained for a given period of time defined by the retentionPolicy field. mutation { logConfigurationsDeleteDataPartitionRule(id: \"1111\", accountId: 123456) { errors { message type } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 269.06583,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: Manage data partition rules",
        "sections": "<em>NerdGraph</em> tutorial: Manage data partition rules",
        "tags": "<em>NerdGraph</em>",
        "body": "You can use <em>NerdGraph</em> at <em>api</em>.newrelic.com&#x2F;graphiql to create, query, and manage your data partition rules for logs. <em>NerdGraph</em> is our <em>Graph</em>QL-format <em>API</em> explorer. Data partition rule schema Available data partition rule fields include: Fields Description id Unique data partition rule identifier"
      },
      "id": "60dedc7a196a674f914ea040"
    },
    {
      "sections": [
        "Get started with log management",
        "Find problems faster, reduce context switching",
        "Bring in your logging data",
        "View your logging data in New Relic",
        "What's next"
      ],
      "title": "Get started with log management",
      "type": "docs",
      "tags": [
        "Logs",
        "Log management",
        "Get started"
      ],
      "external_id": "77761091d3c83970c78e92210970ade2a7441df9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/log-management/get-started/get-started-log-management/",
      "published_at": "2021-10-24T16:43:23Z",
      "updated_at": "2021-10-24T16:43:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "As applications move towards the cloud, microservices architecture is becoming more dispersed, making the ability to monitor logs essential. New Relic offers a fast, scalable log management platform so you can connect your logs with the rest of your telemetry and infrastructure data in a single place. See how it works with this video (approx. 2 minutes). Our log management solution provides deeper visibility into application and infrastructure performance data (events and errors) to reduce mean-time-to-resolve (MTTR) and quickly troubleshoot production incidents. Find problems faster, reduce context switching Log management provides a way to connect your log data with the rest of your application and infrastructure data. You can get to the root cause of problems quickly, without losing context switching between tools. Log management features include: Instantly search through your logs. Visualize your log data directly from the Logs UI. Use logging data to create custom charts, dashboards, and alerts. Troubleshoot performance issues without switching between tools. Visualize everything in a single place. Bring in your logging data To forward your log data to New Relic, you can: Use our infrastructure monitoring agent as a lightweight data collector, without having to install additional software. Select from a wide range of log forwarding plugins, including Amazon, Microsoft, Fluentd, Fluent Bit, Kubernetes, Logstash, and more. Use our OpenTelemetry solutions. Send your log data by using the Log API or TCP endpoint. Once log management is enabled, you can also connect your logs with your APM agent, Kubernetes clusters, or distributed tracing to get additional contextual logging data with our logs in context extensions. View your logging data in New Relic You can explore your logging data in the UI or by API: Logs UI at one.newrelic.com Logs UI for EU region data center if applicable: one.eu.newrelic.com You can also query the Log data type. For example, use NRQL to run: SELECT * FROM Log Copy You can also use NerdGraph, our GraphQL-format API, to request the exact data you need. What's next Ready to get started with our log management solutions? If you don't have one already, create a New Relic account. It's free, forever. Forward your logs to New Relic. Recommendation: Use our infrastructure agent as your log forwarder, so you can get logs in context of your platform and services directly in our UI. For apps monitored by a New Relic APM agent, configure logs in context. Explore the logging data across your platform with our Logs UI in New Relic One, where you can add alerts, query your data, and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 266.1042,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " your logging data in the UI or by <em>API</em>: Logs UI at one.newrelic.com Logs UI for EU region data center if applicable: one.eu.newrelic.com You can also query the Log data type. For example, use NRQL to run: SELECT * FROM Log Copy You can also use <em>NerdGraph</em>, our <em>Graph</em>QL-format <em>API</em>, to request the exact"
      },
      "id": "603ea62ee7b9d249432a07e2"
    }
  ],
  "/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-explorer-view-performance-across-apps-services-hosts": [
    {
      "sections": [
        "Introduction to New Relic One",
        "Tip",
        "Quickly understand context",
        "Query your data more easily",
        "Enhanced dashboards",
        "Build on New Relic One",
        "Whatâ€™s next?"
      ],
      "title": "Introduction to New Relic One",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "c9ba93c83a579625a4ba3364c6046f3c475cba3a",
      "image": "https://docs.newrelic.com/static/2bc08b6d64c16b39697bb43d8e66870e/c1b63/nrone20210722.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-10-24T17:36:54Z",
      "updated_at": "2021-10-24T17:36:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic One is the platform that gives you access to core platform capabilities like querying data and building charts, our more curated observability UI experiences features, and our alerting and Applied Intelligence tools. With New Relic One, you can see and act on all the data throughout your entire system. To access New Relic One: Go to one.newrelic.com. Or, if you report data to the EU data center go to one.eu.newrelic.com. Tip Learn more about New Relic Oneâ€™s basic UI features. Quickly understand context We provide multiple ways to understand your system's dependencies, so you can easily see how everything fits together and troubleshoot problems. New Relic One gives you and your teams a connected view that cuts through complexity! If you want to... Use this Have an overall view of your system, and drill down to get performance details. Use the New Relic Explorer as the front door to New Relic One: observe, group, and filter the performance data from all the entities (that is, all applications, services, hosts, or containers) in your system. Gain extensive visibility into each entity in your solution, its alert status, and how the entities are connected. Use the New Relic Navigator to give you a high density overview of all your entities so you can detect any issues at a glance. And use the New Relic Lookout to spot entities recently experiencing behavior deviations. Provide context for your entities. Add tags to all your entities. Or create tags for teams and all the services they monitor. Use tags to illustrate relationships and contextual information for what you monitor. By thoughtfully tagging your entities, you can connect all the data your teams need to understand their increasingly complex and interdependent systems. See how each part of your system is connected. Service maps illustrate your upstream and downstream dependencies. Visualize the aggregated health and activity data from all you monitor. Group and monitor any entities together into functional team-focused, project-focused groupings, or any other attribute, with workloads. Fetch and analyze specific data. Get more context while you query with the query builder, which surfaces data definitions as you craft and edit queries. Create visuals that showcase your business needs at a glance. Tailor custom dashboards for your unique needs. Find a service or dashboard in a complex environment. Search by name across all accounts in the unified search, or filter the explorer by tags or text. View everything youâ€™re monitoring in one place, like entities or dashboards across your organization. View a list of all the dependencies for a service. The dependencies view tab in an entity summary shows all the dependencies of the entity youâ€™re viewing. Track activity as it moves across your distributed system. Distributed tracing helps you analyze your modern environment. Understand how everything is connected via API. The NerdGraph GraphiQL explorer manages all your entities, tags, and relationships. Query your data more easily On the Browse data menu on the top navigation menu you can easily access your basic telemetry data (metrics, events, logs, and traces). Wherever you go in the UI, Query your data is available. No matter your level of proficiency with our query language, you can create custom queries and charts: Browse your data in a query-less experience with our data explorer. Use your NRQL (our query language) expertise to build custom charts in the query builder. Run PromQL-style queries in the query builder. one.newrelic.com > Query your data: Build NRQL and PROMQL-like queries. Enhanced dashboards one.newrelic.com > Dashboards: Quickly create information dense custom views into the data that matters most to you with dashboards in New Relic One. New Relic One dashboards let you build better visualizations more easily, with more options to customize. Dashboard features include: Perform NRQL queries and create charts and dashboards everywhere in the platform using the query builder. Manage your charts and dashboards easily using our quick-access CRUD menus and editing options. Explore and contextualize data with advanced tooltips and zoom in functions to monitor what your systems are doing in real time. Search your dashboards for attributes and metrics. Send data to your dashboards using our agents, integrations, and APIs. Share dashboards or charts as a .pdf, or embed a chart in an external site. Tip If you previously used New Relic Insights to create dashboards, these are available as New Relic One dashboards. Build on New Relic One If custom charts and dashboards don't solve your current challenge, we give you a framework for building React JavaScript applications that: Live on New Relic One, alongside your other New Relic-monitored data. Feature highly tailored visualizations. Display data from any source you want, whether from a New Relic-monitored entity or data from any service or API. And you can use open source apps built by the community, and contribute your own open source apps. To learn more, see New Relic One applications. Whatâ€™s next? To get started understanding how to get around in New Relic One: See what data you have available with the data explorer. Browse your monitored entities with the New Relic Explorer. Use our NerdGraph API to add tags to your data. Learn about dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 313.34412,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "sections": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> is the platform that gives you access to <em>core</em> platform capabilities like querying data and building charts, our more curated observability UI experiences features, and our alerting and Applied Intelligence tools. With <em>New</em> <em>Relic</em> <em>One</em>, you can see and act on all the data throughout your"
      },
      "id": "603ec19164441f9e704e8896"
    },
    {
      "sections": [
        "What is an entity in New Relic?",
        "What's an entity?",
        "Find and explore entities and entity data",
        "Tip",
        "Group and organize entities",
        "Customize entity data with entity synthesis",
        "Reserved attributes for synthesized entities",
        "Entity relationships",
        "Important",
        "Which relationships are created?",
        "Source: New Relic agent",
        "Source: Infrastructure",
        "Source: Synthetics monitor",
        "Source: Kubernetes",
        "External services"
      ],
      "title": "What is an entity in New Relic?",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "52a3e08bc9103c717d27b153e4fd4f547d6ecc32",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-10-24T17:34:57Z",
      "updated_at": "2021-09-01T17:25:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic monitoring is built around the concept of entities. In this doc, you'll learn how we define entities, what you can do with them, and how you can create your own entities or groupings of entities. What's an entity? From a New Relic perspective, entity is purposefully a broad concept. An entity is anything that a) reports data to New Relic or that contains data that we have access to, and b) is something we've identified with a unique entity ID. For most entities, the ID is indicated by the attribute entityGuid. An entity can be any fundamental data-reporting component, like an application, a host, or a database service, but it can also refer to larger groupings of those components. For example, to monitor a data center, you could aggregate those hosts in New Relic to be a workload (a custom grouping of entities). That workload is, itself, also an entity. Also very important is the relationships between entities. Our behind-the-scenes relationship-mapping helps us understand how entities are connected, how they affect each other. And this allows us to give you the power to configure how any data you're bringing in is related to existing entities, or how it's related to other entities. Our focus on entities and their relationships is important because our goal is to give you practical information about your business-important entities, and not give you an unhelpfully huge stream of data from a huge list of monitored things. With more insight at the entity level, you can better monitor and troubleshoot complex, modern systems. Find and explore entities and entity data Tip You can create new entity types for monitoring any data source. Learn more about entity synthesis. Some tips for finding and understanding entity data: To find an entity's entityGuid and entityName and other metadata: from any list of monitored entities in the New Relic Explorer, click an entity's icon, and click See metadata and tags. For most entities, its GUID is reported as the attribute entityGuid. For workloads, it's workloadGuid. You can run NRQL queries to find entities by their GUID. To see connections between entities, you have several options: When viewing an entity in the UI, use the Related entities UI. Service maps. Distributed tracing. Our NerdGraph API. To group entities together, see Group entities. Customize entity definitions and relationships. To learn technical details about entity types, see our GitHub repo. In an entity type's definition file, you'll see information like: The domain: for example, APM, or Infra. Its type: for example, Application or AWSECSCONTAINERINSTANCE. Default tags. The entityExpirationTime: how long data from that entity lasts in the UI, which is different from database data retention. Group and organize entities You can place entities into groups that reflect business-important relationships in your organization. For example, you might group all entities related to a specific team or department, or related to a specific service. Or you might group multiple hosts together to reflect their grouping in a data center. To group your entities, see: Tag entities. Create workloads, which allow you to group business-important sets of entities. Create entities and customize entity data Customize entity data with entity synthesis If you have telemetry from any source that's not supported by New Relic out of the box, you can propose a mapping for it. Once approved, any telemetry received by New Relic that matches your definition file will be synthesized into an entity. To learn more: For reserved attributes and how entity relationships are defined, keep reading this doc. For how to do the work of modifying existing entity types or creating new ones, see our GitHub repo on entity synthesis. Reserved attributes for synthesized entities These attributes are meant to be synthesized from the telemetry we receive. Do not set them unless you're aware of the implications and consequences. Attribute Description entity.guid Generally, you should not set this attribute field on your telemetry data. New Relic may add this field to ingested data to store a unique identifier for the entity associated with the data point. If telemetry arrives with the entity.guid attribute already present, then New Relic will not change the value. However, it may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. One use case for passing this attribute is to associate ingested telemetry with an entity already created by New Relic. When the entity.guid attribute is sent, the value will override New Relicâ€™s entity identification system (such as entity synthesis definitions) and instead will use the attribute as the data. entity.name This attribute shouldn't be put on ingested telemetry data unless you're trying to override the entity name that would have been selected by New Relicâ€™s entity identification system. While New Relic won't change the value if it's already present on the data, New Relic may add the attribute to your data. Therefore invalid or unexpected values may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. If this field is present on ingested telemetry, its value will be used to name the entity associated with the data point. This name will be used instead of the name selected by New Relicâ€™s entity identification system (for example, entity synthesis definitions). Note that many entities use the name as part of their identification, so changing this field may result in the generation of a new entity. entity.type This attribute shouldn't be put on ingested telemetry data except for certain legacy cases where it's required to distinguish entity types. Passing this field may interfere with entity detection, particularly if unrecognized values are sent in this field. While New Relic won't change the value if already present on the data, the field is not guaranteed to provide unambiguous filtering of telemetry at query-time. Existing entity definitions already have overlapping values, and we recommend avoiding entity.type in favor of other fields for filtering telemetry queries. This field is used by New Relic, meaning that invalid or unexpected values may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. To learn how to do the work of modifying existing entity types or creating new ones, see our GitHub repo on entity synthesis. Entity relationships Connections between entities are automatically created by New Relic based on what we can infer from your telemetry. For example, when two services that communicate using HTTP are instrumented with New Relic, we infer a \"calls/called-by\" relationship between them. When viewing a specific entity in either the New Relic Explorer, Navigator, or Lookout, you can see its Related entities in the entity's mini overview. This gives a visualization of the various entities connected directly to the current entity. You can quickly view important metrics for these related entities and navigate from one entity to another, through all the connected parts of your stack. Tip Learn more about how entities are related with our NerdGraph API. When relationships are not automatically detected, you can manually create them using the \"Add/edit related entities\" link in Related entities. Important Currently, you can only manually create calls/called-by relationships between service entities. Tip To manage manual relationships, you need to have modify and delete capabilities on entity relationships. If you donâ€™t see the edit relationships button, contact your account admin. Which relationships are created? These are the relationships created between entities: Source: New Relic agent Relationship source Relationship type Relationship target Why is the relationship created? Application instrumented with a New Relic agent CALLS Application instrumented with a New Relic agent Relationships between applications monitored by New Relic agents are reported using the DurationByCaller metric. The callee reports the metric. For example, the metric DurationByCaller/Mobile/100/1234/HTTP/all indicates that the caller is APPLICATION 1234 for account 100. Application instrumented with a New Relic agent CALLS Service instrumented with a New Relic agent An application (caller) that calls a service (callee) monitored by New Relic creates a relationship that's reported by the caller using the ExternalApp metric. For example, the metric ExternalApp/dirac.vips.net/100#1234/all indicates that the callee is APPLICATION 1234 for account 100. The metric is reported if the callee successfully responds to the caller. Service instrumented with a New Relic agent CALLS Service instrumented with a New Relic agent When a New Relic agent detects that a service (caller) calls another service (callee) instrumented by New Relic, the callee reports the metric ClientApplication. For example, the metric ClientApplication/100#1234/all indicates that the caller is APPLICATION 1234 for account 100. Service instrumented with a New Relic agent CALLS A datastore instance When an application calls a datastore instance it creates a relationship reported with the DatastoreInstance metric. For example, the metric Datastore/instance/MySQL/172.16.16.3/3306 indicates the datastore instance is vendor: MySQL, host: 172.16.16.3, port: 3306. This metric also supports the legacy datastore instance format Datastore/instance/MySQL/172.16.16.3:3306. Currently we cannot determine whether the datastore instance is instrumented by New Relic and has an entity associated to it. APM agent SERVES Browser agent This relationship is created when an APM agent injects the browser agent into a page. Workload entity CONTAINS Any entity When a workload is created or updated, relationships for each of the entities that belong to the workload are created. Because some workloads are â€œdynamicâ€ (defined by tags), relationships are re-created every 5 minutes. This way entities can join or leave the workload. Source: Infrastructure Relationship source Relationship type Relationship target Why is the relationship created? Infrastructure host HOSTS Application This relationship is created when an application is running in one or more hosts, and the infra agent is running in those hosts. Infrastructure host HOSTS Container This relationship is created when containers are running in one or more hosts, and the host is instrumented with the infra agent. Source: Synthetics monitor Relationship source Relationship type Relationship target Why is the relationship created? Synthetics Monitor CALLS Browser agent This relationship is created when a synthetics monitor checks a page instrumented with the browser agent. Synthetics Monitor CALLS APM application Agent events that contain the attribute nr.syntheticsMonitorId have been described as synthetics monitors (the source) interacting with an APM application (the target). If the header exists and the APM application Id exists, a relationship is created between the monitor and the app. Source: Kubernetes Relationship source Relationship type Relationship target Why is the relationship created? Cluster CONTAINS Pod This relationship is created when a pod is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS Deployment This relationship is created when a deployment is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS DaemonSet This relationship is created when a DaemonSet is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS StatefulSet This relationship is created when a StatefulSet is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS Host This relationship is created when a host that's part of a cluster is instrumented with the New Relic Kubernetes integration. Deployment CONTAINS Pod This relationship is created when a deployment creates a pod in a cluster instrumented with the New Relic Kubernetes integration. DaemonSet CONTAINS Pod This relationship is created when a DaemonSet is created a pod in a cluster instrumented with the New Relic Kubernetes integration. StatefulSet CONTAINS Pod This relationship is created when a StatefulSet creates a pod in a cluster instrumented with the New Relic Kubernetes integration. Pod CONTAINS Container This relationship is created when a pod creates a container in a cluster instrumented with the New Relic Kubernetes integration. Host HOSTS Pod This relationship is created when a pod is running in a host that's part of a cluster instrumented with the New Relic Kubernetes integration. Container HOSTS Application This relationship is created when an application is running in docker, and the hosts where docker is running are instrumented by the the infra agent. External services Relationship source Relationship type Relationship target Why is the relationship created? External service CALLS External service When the relationship is created, the external service reports a span with its name on the service.name attribute and the name of the service that initiates the call in the parent.service.name attribute. Application IS External service A relationship between an application and an external service is created so that users can navigate between them using the related entities component. Browser application instrumented with a New Relic agent CALLS External service A browser application reports an Ajax/HostTransaction metric when calling an external service (URL). Example metric: Ajax/HostTransaction/api.segment.io:443/CallbackTime' Cluster CONTAINS External service When the relationship is created, the external service reports a span with the attribute k8s.cluster.name, the name of the cluster. The cluster must be instrumented with the New Relic Kubernetes integration and the cluster name set for the integration must match the one reported in the span. Pod HOSTS External service When the relationship is created, the external service reports a span with the following attributes: service.name: The name of the service. k8s.cluster.name: The name of the cluster. k8s.pod.name: The name of the pod thatâ€™s running the service. k8s.namespace.name: The namespace where the pod was created. The cluster must be instrumented with the New Relic Kubernetes integration and the cluster name set for the integration must match the one reported in the span.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 225.43378,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "What is an entity in <em>New</em> <em>Relic</em>?",
        "sections": "What is an entity in <em>New</em> <em>Relic</em>?",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": ". If telemetry arrives with the entity.guid attribute already present, then <em>New</em> <em>Relic</em> will not change the value. However, it may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. <em>One</em> <em>use</em> case for passing this attribute is to associate"
      },
      "id": "603ec160e7b9d295f72a07fc"
    },
    {
      "sections": [
        "Use tags to help organize and find your data",
        "Tip",
        "Tag format and limits",
        "Best practices and tips",
        "Tips on keeping tags simple:",
        "Tips on using tags consistently:",
        "Tips on cross-team implementation:",
        "Tag examples",
        "Team-related tags",
        "Environment-related tags",
        "Criticality-related tags",
        "How tags are added",
        "Add tags via UI or API",
        "APM agent tags",
        "Infrastructure data tags",
        "Automate tags with our CLI",
        "Use tags to filter the UI",
        "Custom queries, charts, and alerts",
        "Query and alert on APM tags",
        "Throughput across shards",
        "Transactions per team",
        "Alert on error rate for teams",
        "Query and alert on attributes"
      ],
      "title": "Use tags to help organize and find your data",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e2e2d53776b9109965df9de2a20660e9f60bd479",
      "image": "https://docs.newrelic.com/static/529f55ef72f3e366e6cb4a7be67229b6/c1b63/new-relic-tags-workloads_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/use-tags-help-organize-find-your-data/",
      "published_at": "2021-10-24T17:34:01Z",
      "updated_at": "2021-08-21T09:28:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In the software industry, a tag typically refers to a piece of metadata added to a data set for the purpose of improving data organization and findability. At New Relic, our tags are key:value pairs (like team: operations) added to various sets of data, like monitored apps and hosts, agents, dashboards, and workloads. We make some important attributes available as tags (for example, app metadata like app name and language, and host metadata like host name and AWS region). You can also add your own custom tags. You can use tags in the UI to filter down to relevant data. Here is an example: Here you can see an accountId tag being used to filter workloads to a specific account. Tags help you to: Organize data coming from a large number of sources and/or to a large number of New Relic accounts. Identify teams, roles, environments, or regions to know whoâ€™s responsible for what (see example use cases). Better organize and search dashboards and workloads. Query and chart APM data. Tags are useful for organizing data at a high level. If you want to add more fine-grained detail, like capturing user names or other high-cardinality values, custom attributes or custom events are a better solution. Tip Tags were previously called labels in the New Relic UI. You may sometimes see labelin our code; for example, some of our APM agent config files use a label config option for tags. Tag format and limits Format requirements and limits for tags: The UI has limits on the total number of tags it can display per entity: Limit of 100 for tags reported by default or added via agent/integration configuration. Limit of 100 for custom tags added via UI or API. The following are maximum character length for tags: Key: 128 characters Value: 256 characters When using our API to add tags, a dash (-) in a tag key is interpreted as a minus symbol. If your tag key has a dash, use back ticks around it (like `key-name`). Best practices and tips Before adding tags, we recommend first seeing how our default tags work for you. When you're ready to add your own tags, review the following best practices tips to get the most out of them. Tips on keeping tags simple: Start by adding only tags you know youâ€™ll definitely use. Unused tags create noise and may add confusion. Try to use short tags. Shorter tags are easier to parse, and also the UI may sometimes truncate longer tags. (See character limits.) When possible, use keys and values that are human-readable (for example, region: EMEA is better than Param8323 : 1229072). Avoid including several values like regions: EMEA | US | LATAM in a single tag. We recommend using three different tags for that, like region: emea, region: us, and region: latam. If you want to match multiple tags, you can do that using the advanced options in the filter UI. Tips on using tags consistently: Try to be consistent with tag language across your teams and entities. Be consistent with naming. For example, avoid using both region: emea and reg: emea. Be consistent with format. For example, avoid using both camelCase and kebab-case. Although tag searching is not case-sensitive in the UI and API, try to be consistent with capitalization. For example, avoid using both env: staging and env: Staging. Tips on cross-team implementation: Tags help improve observability and cost allocation. For this reason, responsibility for tag implementation is often assigned to an observability team, SREs, a group of architects, or a cross-team task force. We recommend the people responsible for implementing tags meet and create an internal policy to describe how the tags are defined and which conventions are to be used. Then: Keep this reference manual up to date. Automate the definition of tags when you deploy New Relic agents, at the cloud provider, or through New Relic automation tools, such as the API or Terraform. Create recurring reports that identify entities that are non-compliant with your tagging standards. Tag examples Here are some examples of common ways to use tags to organize data: Team-related tags Creating tags for team names can be helpful to understand which team, group, department, or region was responsible for a change that led to a performance issue. Team examples: team: backend team: frontend team: db Role examples: roles: architecture roles: devops roles: pm Region examples: region: emea region: america region: asia Environment-related tags You can create entities for the environment they belong to. Examples: env: production env: qa env: development env: staging Criticality-related tags You can create tags related to criticality levels, which lets you easier track the most critical issues. Examples: layer: level1 layer: level2 layer: level3 How tags are added Some important attributes, by default, are available for use as tags. For example, the account name, the account ID, and some basic host/server metadata are available as default tags. You can't remove these available-by-default tags. Here are some details about how tags are added for some specific data sources: Add tags via UI or API When you add tags via the UI or API, this occurs at the entity level. This means that, for example, if you have multiple APM agents monitoring a single entity and apply a tag via the UI, that tag is available for all data coming from that entity. To add or delete tags via the UI: Select a monitored entity, like a monitored app or host. Near the entityâ€™s name at the top of the page, select the See metadata and manage tags menu. In the menu that pops up, add or delete a tag. For APM agents, restart your service. To manage tags via API: see our NerdGraph tagging docs. For a guide to using our CLI to automate tagging, see our developer site. APM agent tags You can add tags via the UI and API or you can add tags using APM agent configuration, both methods require you to restart your service. There are differences in how these apply tags: Via agent config: These tags are applied at the agent-level, not the entity/application level. This would be a good option if you have multiple agents monitoring different aspects of the same app (for example, a blue-green deployment model). Via the UI or API: These tags are applied at the entity/application level. Here are links to the agent configuration options: C SDK: not available Java Go .NET Node.js PHP Python Ruby For information on querying APM tags, see Query APM tags. Infrastructure data tags There are several ways tags are added to infrastructure entities and services: Use the UI or API to add tags at the entity level. Infrastructure agent: some attributes are available by default as tags. You can also add custom attributes, which are also available as tags in the UI. On-host integrations: some attributes are available by default as tags. You can also add tags by using integration-specific labels config options (for an example, see the labels config for the Apache integration). Cloud service integrations: by default we report tags and labels that are defined in the cloud service. To add tags, you'd add them on the cloud-service-side. Automate tags with our CLI For a guide to automating tags using our CLI tool, see our developer site. Use tags to filter the UI Use the filter field at the top of the New Relic Explorer to filter down to the entities you care about. You can use multiple filter conditions. To filter down to certain entities using tags: From one.newrelic.com, click Explorer. Click the Filter by... field to see a dropdown of available attributes and tags. You can filter by multiple elements and use advanced search options. To find an entityâ€™s metadata and tags from the UI, here are two options: From a list of entities in the UI, at the far right, select an entity's icon. OR Select an entity. Near the top of the page, select the icon. To use the API to view tags, see our NerdGraph docs. Learn about how to use tags with dashboards and how to use tags with workloads. Custom queries, charts, and alerts Different features handle tags differently. Here are some details about how you can use NRQL to query tag data, or create NRQL condition alerts. Query and alert on APM tags You can query APM tags using NRQL. Minimum agent versions: C: not available Go: 2.3.0 Java: 4.9.0 .NET: 8.17 Node: v4.13.0 PHP: not available Python: v4.10.0.112 Ruby: 6.1.0.352 Here are some query examples: Throughput across shards Given a service that is distributed across nine shards, each shard assigned as an environment, we can plot the transaction throughput on all shards using a wildcard query like: SELECT rate(count(apm.service.transaction.duration), 1 minute) FROM Metric WHERE appName LIKE 'MyApp (%' AND transactionType = 'Other' FACET tags.Environment TIMESERIES Copy Transactions per team To see the number of transactions per service for a specific team, we might use a query like: FROM Transaction SELECT count(*) WHERE tags.Team = 'team-a' FACET tags.Project TIMESERIES Copy Alert on error rate for teams You can use a query for your servicesâ€™ error rate for setting an alert without having to create a rule for each service. Here is the error rate for all services on a team called team-b. And this alert will automatically monitor any new app names added with the team tag. FROM Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Team = 'team-b' FACET appName Copy Related to this, you might create a general rule for a specific service deployed across several environments, so that we have an alarm for a single service monitoring each environment individually: From Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Project = 'MyProject' FACET tags.Environment Copy Query and alert on attributes As explained in the tag sources information, some important attributes are used as tags. You can query all attributes and create custom charts using NRQL, and create NRQL alert conditions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 219.98409,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Use</em> tags to help organize and find your data",
        "sections": "<em>Use</em> tags to help organize and find your data",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " to filter the UI <em>Use</em> the filter field at the top of the <em>New</em> <em>Relic</em> Explorer to filter down to the entities you care about. You can <em>use</em> multiple filter conditions. To filter down to certain entities using tags: From <em>one</em>.newrelic.com, click Explorer. Click the Filter by... field to see a dropdown"
      },
      "id": "603ebd1228ccbc6278eba754"
    }
  ],
  "/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-lookout-monitor-your-estate-glance": [
    {
      "sections": [
        "Introduction to New Relic One",
        "Tip",
        "Quickly understand context",
        "Query your data more easily",
        "Enhanced dashboards",
        "Build on New Relic One",
        "Whatâ€™s next?"
      ],
      "title": "Introduction to New Relic One",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "c9ba93c83a579625a4ba3364c6046f3c475cba3a",
      "image": "https://docs.newrelic.com/static/2bc08b6d64c16b39697bb43d8e66870e/c1b63/nrone20210722.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-10-24T17:36:54Z",
      "updated_at": "2021-10-24T17:36:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic One is the platform that gives you access to core platform capabilities like querying data and building charts, our more curated observability UI experiences features, and our alerting and Applied Intelligence tools. With New Relic One, you can see and act on all the data throughout your entire system. To access New Relic One: Go to one.newrelic.com. Or, if you report data to the EU data center go to one.eu.newrelic.com. Tip Learn more about New Relic Oneâ€™s basic UI features. Quickly understand context We provide multiple ways to understand your system's dependencies, so you can easily see how everything fits together and troubleshoot problems. New Relic One gives you and your teams a connected view that cuts through complexity! If you want to... Use this Have an overall view of your system, and drill down to get performance details. Use the New Relic Explorer as the front door to New Relic One: observe, group, and filter the performance data from all the entities (that is, all applications, services, hosts, or containers) in your system. Gain extensive visibility into each entity in your solution, its alert status, and how the entities are connected. Use the New Relic Navigator to give you a high density overview of all your entities so you can detect any issues at a glance. And use the New Relic Lookout to spot entities recently experiencing behavior deviations. Provide context for your entities. Add tags to all your entities. Or create tags for teams and all the services they monitor. Use tags to illustrate relationships and contextual information for what you monitor. By thoughtfully tagging your entities, you can connect all the data your teams need to understand their increasingly complex and interdependent systems. See how each part of your system is connected. Service maps illustrate your upstream and downstream dependencies. Visualize the aggregated health and activity data from all you monitor. Group and monitor any entities together into functional team-focused, project-focused groupings, or any other attribute, with workloads. Fetch and analyze specific data. Get more context while you query with the query builder, which surfaces data definitions as you craft and edit queries. Create visuals that showcase your business needs at a glance. Tailor custom dashboards for your unique needs. Find a service or dashboard in a complex environment. Search by name across all accounts in the unified search, or filter the explorer by tags or text. View everything youâ€™re monitoring in one place, like entities or dashboards across your organization. View a list of all the dependencies for a service. The dependencies view tab in an entity summary shows all the dependencies of the entity youâ€™re viewing. Track activity as it moves across your distributed system. Distributed tracing helps you analyze your modern environment. Understand how everything is connected via API. The NerdGraph GraphiQL explorer manages all your entities, tags, and relationships. Query your data more easily On the Browse data menu on the top navigation menu you can easily access your basic telemetry data (metrics, events, logs, and traces). Wherever you go in the UI, Query your data is available. No matter your level of proficiency with our query language, you can create custom queries and charts: Browse your data in a query-less experience with our data explorer. Use your NRQL (our query language) expertise to build custom charts in the query builder. Run PromQL-style queries in the query builder. one.newrelic.com > Query your data: Build NRQL and PROMQL-like queries. Enhanced dashboards one.newrelic.com > Dashboards: Quickly create information dense custom views into the data that matters most to you with dashboards in New Relic One. New Relic One dashboards let you build better visualizations more easily, with more options to customize. Dashboard features include: Perform NRQL queries and create charts and dashboards everywhere in the platform using the query builder. Manage your charts and dashboards easily using our quick-access CRUD menus and editing options. Explore and contextualize data with advanced tooltips and zoom in functions to monitor what your systems are doing in real time. Search your dashboards for attributes and metrics. Send data to your dashboards using our agents, integrations, and APIs. Share dashboards or charts as a .pdf, or embed a chart in an external site. Tip If you previously used New Relic Insights to create dashboards, these are available as New Relic One dashboards. Build on New Relic One If custom charts and dashboards don't solve your current challenge, we give you a framework for building React JavaScript applications that: Live on New Relic One, alongside your other New Relic-monitored data. Feature highly tailored visualizations. Display data from any source you want, whether from a New Relic-monitored entity or data from any service or API. And you can use open source apps built by the community, and contribute your own open source apps. To learn more, see New Relic One applications. Whatâ€™s next? To get started understanding how to get around in New Relic One: See what data you have available with the data explorer. Browse your monitored entities with the New Relic Explorer. Use our NerdGraph API to add tags to your data. Learn about dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 313.34412,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "sections": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> is the platform that gives you access to <em>core</em> platform capabilities like querying data and building charts, our more curated observability UI experiences features, and our alerting and Applied Intelligence tools. With <em>New</em> <em>Relic</em> <em>One</em>, you can see and act on all the data throughout your"
      },
      "id": "603ec19164441f9e704e8896"
    },
    {
      "sections": [
        "What is an entity in New Relic?",
        "What's an entity?",
        "Find and explore entities and entity data",
        "Tip",
        "Group and organize entities",
        "Customize entity data with entity synthesis",
        "Reserved attributes for synthesized entities",
        "Entity relationships",
        "Important",
        "Which relationships are created?",
        "Source: New Relic agent",
        "Source: Infrastructure",
        "Source: Synthetics monitor",
        "Source: Kubernetes",
        "External services"
      ],
      "title": "What is an entity in New Relic?",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "52a3e08bc9103c717d27b153e4fd4f547d6ecc32",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-10-24T17:34:57Z",
      "updated_at": "2021-09-01T17:25:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic monitoring is built around the concept of entities. In this doc, you'll learn how we define entities, what you can do with them, and how you can create your own entities or groupings of entities. What's an entity? From a New Relic perspective, entity is purposefully a broad concept. An entity is anything that a) reports data to New Relic or that contains data that we have access to, and b) is something we've identified with a unique entity ID. For most entities, the ID is indicated by the attribute entityGuid. An entity can be any fundamental data-reporting component, like an application, a host, or a database service, but it can also refer to larger groupings of those components. For example, to monitor a data center, you could aggregate those hosts in New Relic to be a workload (a custom grouping of entities). That workload is, itself, also an entity. Also very important is the relationships between entities. Our behind-the-scenes relationship-mapping helps us understand how entities are connected, how they affect each other. And this allows us to give you the power to configure how any data you're bringing in is related to existing entities, or how it's related to other entities. Our focus on entities and their relationships is important because our goal is to give you practical information about your business-important entities, and not give you an unhelpfully huge stream of data from a huge list of monitored things. With more insight at the entity level, you can better monitor and troubleshoot complex, modern systems. Find and explore entities and entity data Tip You can create new entity types for monitoring any data source. Learn more about entity synthesis. Some tips for finding and understanding entity data: To find an entity's entityGuid and entityName and other metadata: from any list of monitored entities in the New Relic Explorer, click an entity's icon, and click See metadata and tags. For most entities, its GUID is reported as the attribute entityGuid. For workloads, it's workloadGuid. You can run NRQL queries to find entities by their GUID. To see connections between entities, you have several options: When viewing an entity in the UI, use the Related entities UI. Service maps. Distributed tracing. Our NerdGraph API. To group entities together, see Group entities. Customize entity definitions and relationships. To learn technical details about entity types, see our GitHub repo. In an entity type's definition file, you'll see information like: The domain: for example, APM, or Infra. Its type: for example, Application or AWSECSCONTAINERINSTANCE. Default tags. The entityExpirationTime: how long data from that entity lasts in the UI, which is different from database data retention. Group and organize entities You can place entities into groups that reflect business-important relationships in your organization. For example, you might group all entities related to a specific team or department, or related to a specific service. Or you might group multiple hosts together to reflect their grouping in a data center. To group your entities, see: Tag entities. Create workloads, which allow you to group business-important sets of entities. Create entities and customize entity data Customize entity data with entity synthesis If you have telemetry from any source that's not supported by New Relic out of the box, you can propose a mapping for it. Once approved, any telemetry received by New Relic that matches your definition file will be synthesized into an entity. To learn more: For reserved attributes and how entity relationships are defined, keep reading this doc. For how to do the work of modifying existing entity types or creating new ones, see our GitHub repo on entity synthesis. Reserved attributes for synthesized entities These attributes are meant to be synthesized from the telemetry we receive. Do not set them unless you're aware of the implications and consequences. Attribute Description entity.guid Generally, you should not set this attribute field on your telemetry data. New Relic may add this field to ingested data to store a unique identifier for the entity associated with the data point. If telemetry arrives with the entity.guid attribute already present, then New Relic will not change the value. However, it may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. One use case for passing this attribute is to associate ingested telemetry with an entity already created by New Relic. When the entity.guid attribute is sent, the value will override New Relicâ€™s entity identification system (such as entity synthesis definitions) and instead will use the attribute as the data. entity.name This attribute shouldn't be put on ingested telemetry data unless you're trying to override the entity name that would have been selected by New Relicâ€™s entity identification system. While New Relic won't change the value if it's already present on the data, New Relic may add the attribute to your data. Therefore invalid or unexpected values may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. If this field is present on ingested telemetry, its value will be used to name the entity associated with the data point. This name will be used instead of the name selected by New Relicâ€™s entity identification system (for example, entity synthesis definitions). Note that many entities use the name as part of their identification, so changing this field may result in the generation of a new entity. entity.type This attribute shouldn't be put on ingested telemetry data except for certain legacy cases where it's required to distinguish entity types. Passing this field may interfere with entity detection, particularly if unrecognized values are sent in this field. While New Relic won't change the value if already present on the data, the field is not guaranteed to provide unambiguous filtering of telemetry at query-time. Existing entity definitions already have overlapping values, and we recommend avoiding entity.type in favor of other fields for filtering telemetry queries. This field is used by New Relic, meaning that invalid or unexpected values may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. To learn how to do the work of modifying existing entity types or creating new ones, see our GitHub repo on entity synthesis. Entity relationships Connections between entities are automatically created by New Relic based on what we can infer from your telemetry. For example, when two services that communicate using HTTP are instrumented with New Relic, we infer a \"calls/called-by\" relationship between them. When viewing a specific entity in either the New Relic Explorer, Navigator, or Lookout, you can see its Related entities in the entity's mini overview. This gives a visualization of the various entities connected directly to the current entity. You can quickly view important metrics for these related entities and navigate from one entity to another, through all the connected parts of your stack. Tip Learn more about how entities are related with our NerdGraph API. When relationships are not automatically detected, you can manually create them using the \"Add/edit related entities\" link in Related entities. Important Currently, you can only manually create calls/called-by relationships between service entities. Tip To manage manual relationships, you need to have modify and delete capabilities on entity relationships. If you donâ€™t see the edit relationships button, contact your account admin. Which relationships are created? These are the relationships created between entities: Source: New Relic agent Relationship source Relationship type Relationship target Why is the relationship created? Application instrumented with a New Relic agent CALLS Application instrumented with a New Relic agent Relationships between applications monitored by New Relic agents are reported using the DurationByCaller metric. The callee reports the metric. For example, the metric DurationByCaller/Mobile/100/1234/HTTP/all indicates that the caller is APPLICATION 1234 for account 100. Application instrumented with a New Relic agent CALLS Service instrumented with a New Relic agent An application (caller) that calls a service (callee) monitored by New Relic creates a relationship that's reported by the caller using the ExternalApp metric. For example, the metric ExternalApp/dirac.vips.net/100#1234/all indicates that the callee is APPLICATION 1234 for account 100. The metric is reported if the callee successfully responds to the caller. Service instrumented with a New Relic agent CALLS Service instrumented with a New Relic agent When a New Relic agent detects that a service (caller) calls another service (callee) instrumented by New Relic, the callee reports the metric ClientApplication. For example, the metric ClientApplication/100#1234/all indicates that the caller is APPLICATION 1234 for account 100. Service instrumented with a New Relic agent CALLS A datastore instance When an application calls a datastore instance it creates a relationship reported with the DatastoreInstance metric. For example, the metric Datastore/instance/MySQL/172.16.16.3/3306 indicates the datastore instance is vendor: MySQL, host: 172.16.16.3, port: 3306. This metric also supports the legacy datastore instance format Datastore/instance/MySQL/172.16.16.3:3306. Currently we cannot determine whether the datastore instance is instrumented by New Relic and has an entity associated to it. APM agent SERVES Browser agent This relationship is created when an APM agent injects the browser agent into a page. Workload entity CONTAINS Any entity When a workload is created or updated, relationships for each of the entities that belong to the workload are created. Because some workloads are â€œdynamicâ€ (defined by tags), relationships are re-created every 5 minutes. This way entities can join or leave the workload. Source: Infrastructure Relationship source Relationship type Relationship target Why is the relationship created? Infrastructure host HOSTS Application This relationship is created when an application is running in one or more hosts, and the infra agent is running in those hosts. Infrastructure host HOSTS Container This relationship is created when containers are running in one or more hosts, and the host is instrumented with the infra agent. Source: Synthetics monitor Relationship source Relationship type Relationship target Why is the relationship created? Synthetics Monitor CALLS Browser agent This relationship is created when a synthetics monitor checks a page instrumented with the browser agent. Synthetics Monitor CALLS APM application Agent events that contain the attribute nr.syntheticsMonitorId have been described as synthetics monitors (the source) interacting with an APM application (the target). If the header exists and the APM application Id exists, a relationship is created between the monitor and the app. Source: Kubernetes Relationship source Relationship type Relationship target Why is the relationship created? Cluster CONTAINS Pod This relationship is created when a pod is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS Deployment This relationship is created when a deployment is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS DaemonSet This relationship is created when a DaemonSet is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS StatefulSet This relationship is created when a StatefulSet is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS Host This relationship is created when a host that's part of a cluster is instrumented with the New Relic Kubernetes integration. Deployment CONTAINS Pod This relationship is created when a deployment creates a pod in a cluster instrumented with the New Relic Kubernetes integration. DaemonSet CONTAINS Pod This relationship is created when a DaemonSet is created a pod in a cluster instrumented with the New Relic Kubernetes integration. StatefulSet CONTAINS Pod This relationship is created when a StatefulSet creates a pod in a cluster instrumented with the New Relic Kubernetes integration. Pod CONTAINS Container This relationship is created when a pod creates a container in a cluster instrumented with the New Relic Kubernetes integration. Host HOSTS Pod This relationship is created when a pod is running in a host that's part of a cluster instrumented with the New Relic Kubernetes integration. Container HOSTS Application This relationship is created when an application is running in docker, and the hosts where docker is running are instrumented by the the infra agent. External services Relationship source Relationship type Relationship target Why is the relationship created? External service CALLS External service When the relationship is created, the external service reports a span with its name on the service.name attribute and the name of the service that initiates the call in the parent.service.name attribute. Application IS External service A relationship between an application and an external service is created so that users can navigate between them using the related entities component. Browser application instrumented with a New Relic agent CALLS External service A browser application reports an Ajax/HostTransaction metric when calling an external service (URL). Example metric: Ajax/HostTransaction/api.segment.io:443/CallbackTime' Cluster CONTAINS External service When the relationship is created, the external service reports a span with the attribute k8s.cluster.name, the name of the cluster. The cluster must be instrumented with the New Relic Kubernetes integration and the cluster name set for the integration must match the one reported in the span. Pod HOSTS External service When the relationship is created, the external service reports a span with the following attributes: service.name: The name of the service. k8s.cluster.name: The name of the cluster. k8s.pod.name: The name of the pod thatâ€™s running the service. k8s.namespace.name: The namespace where the pod was created. The cluster must be instrumented with the New Relic Kubernetes integration and the cluster name set for the integration must match the one reported in the span.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 225.43378,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "What is an entity in <em>New</em> <em>Relic</em>?",
        "sections": "What is an entity in <em>New</em> <em>Relic</em>?",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": ". If telemetry arrives with the entity.guid attribute already present, then <em>New</em> <em>Relic</em> will not change the value. However, it may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. <em>One</em> <em>use</em> case for passing this attribute is to associate"
      },
      "id": "603ec160e7b9d295f72a07fc"
    },
    {
      "sections": [
        "Use tags to help organize and find your data",
        "Tip",
        "Tag format and limits",
        "Best practices and tips",
        "Tips on keeping tags simple:",
        "Tips on using tags consistently:",
        "Tips on cross-team implementation:",
        "Tag examples",
        "Team-related tags",
        "Environment-related tags",
        "Criticality-related tags",
        "How tags are added",
        "Add tags via UI or API",
        "APM agent tags",
        "Infrastructure data tags",
        "Automate tags with our CLI",
        "Use tags to filter the UI",
        "Custom queries, charts, and alerts",
        "Query and alert on APM tags",
        "Throughput across shards",
        "Transactions per team",
        "Alert on error rate for teams",
        "Query and alert on attributes"
      ],
      "title": "Use tags to help organize and find your data",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e2e2d53776b9109965df9de2a20660e9f60bd479",
      "image": "https://docs.newrelic.com/static/529f55ef72f3e366e6cb4a7be67229b6/c1b63/new-relic-tags-workloads_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/use-tags-help-organize-find-your-data/",
      "published_at": "2021-10-24T17:34:01Z",
      "updated_at": "2021-08-21T09:28:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In the software industry, a tag typically refers to a piece of metadata added to a data set for the purpose of improving data organization and findability. At New Relic, our tags are key:value pairs (like team: operations) added to various sets of data, like monitored apps and hosts, agents, dashboards, and workloads. We make some important attributes available as tags (for example, app metadata like app name and language, and host metadata like host name and AWS region). You can also add your own custom tags. You can use tags in the UI to filter down to relevant data. Here is an example: Here you can see an accountId tag being used to filter workloads to a specific account. Tags help you to: Organize data coming from a large number of sources and/or to a large number of New Relic accounts. Identify teams, roles, environments, or regions to know whoâ€™s responsible for what (see example use cases). Better organize and search dashboards and workloads. Query and chart APM data. Tags are useful for organizing data at a high level. If you want to add more fine-grained detail, like capturing user names or other high-cardinality values, custom attributes or custom events are a better solution. Tip Tags were previously called labels in the New Relic UI. You may sometimes see labelin our code; for example, some of our APM agent config files use a label config option for tags. Tag format and limits Format requirements and limits for tags: The UI has limits on the total number of tags it can display per entity: Limit of 100 for tags reported by default or added via agent/integration configuration. Limit of 100 for custom tags added via UI or API. The following are maximum character length for tags: Key: 128 characters Value: 256 characters When using our API to add tags, a dash (-) in a tag key is interpreted as a minus symbol. If your tag key has a dash, use back ticks around it (like `key-name`). Best practices and tips Before adding tags, we recommend first seeing how our default tags work for you. When you're ready to add your own tags, review the following best practices tips to get the most out of them. Tips on keeping tags simple: Start by adding only tags you know youâ€™ll definitely use. Unused tags create noise and may add confusion. Try to use short tags. Shorter tags are easier to parse, and also the UI may sometimes truncate longer tags. (See character limits.) When possible, use keys and values that are human-readable (for example, region: EMEA is better than Param8323 : 1229072). Avoid including several values like regions: EMEA | US | LATAM in a single tag. We recommend using three different tags for that, like region: emea, region: us, and region: latam. If you want to match multiple tags, you can do that using the advanced options in the filter UI. Tips on using tags consistently: Try to be consistent with tag language across your teams and entities. Be consistent with naming. For example, avoid using both region: emea and reg: emea. Be consistent with format. For example, avoid using both camelCase and kebab-case. Although tag searching is not case-sensitive in the UI and API, try to be consistent with capitalization. For example, avoid using both env: staging and env: Staging. Tips on cross-team implementation: Tags help improve observability and cost allocation. For this reason, responsibility for tag implementation is often assigned to an observability team, SREs, a group of architects, or a cross-team task force. We recommend the people responsible for implementing tags meet and create an internal policy to describe how the tags are defined and which conventions are to be used. Then: Keep this reference manual up to date. Automate the definition of tags when you deploy New Relic agents, at the cloud provider, or through New Relic automation tools, such as the API or Terraform. Create recurring reports that identify entities that are non-compliant with your tagging standards. Tag examples Here are some examples of common ways to use tags to organize data: Team-related tags Creating tags for team names can be helpful to understand which team, group, department, or region was responsible for a change that led to a performance issue. Team examples: team: backend team: frontend team: db Role examples: roles: architecture roles: devops roles: pm Region examples: region: emea region: america region: asia Environment-related tags You can create entities for the environment they belong to. Examples: env: production env: qa env: development env: staging Criticality-related tags You can create tags related to criticality levels, which lets you easier track the most critical issues. Examples: layer: level1 layer: level2 layer: level3 How tags are added Some important attributes, by default, are available for use as tags. For example, the account name, the account ID, and some basic host/server metadata are available as default tags. You can't remove these available-by-default tags. Here are some details about how tags are added for some specific data sources: Add tags via UI or API When you add tags via the UI or API, this occurs at the entity level. This means that, for example, if you have multiple APM agents monitoring a single entity and apply a tag via the UI, that tag is available for all data coming from that entity. To add or delete tags via the UI: Select a monitored entity, like a monitored app or host. Near the entityâ€™s name at the top of the page, select the See metadata and manage tags menu. In the menu that pops up, add or delete a tag. For APM agents, restart your service. To manage tags via API: see our NerdGraph tagging docs. For a guide to using our CLI to automate tagging, see our developer site. APM agent tags You can add tags via the UI and API or you can add tags using APM agent configuration, both methods require you to restart your service. There are differences in how these apply tags: Via agent config: These tags are applied at the agent-level, not the entity/application level. This would be a good option if you have multiple agents monitoring different aspects of the same app (for example, a blue-green deployment model). Via the UI or API: These tags are applied at the entity/application level. Here are links to the agent configuration options: C SDK: not available Java Go .NET Node.js PHP Python Ruby For information on querying APM tags, see Query APM tags. Infrastructure data tags There are several ways tags are added to infrastructure entities and services: Use the UI or API to add tags at the entity level. Infrastructure agent: some attributes are available by default as tags. You can also add custom attributes, which are also available as tags in the UI. On-host integrations: some attributes are available by default as tags. You can also add tags by using integration-specific labels config options (for an example, see the labels config for the Apache integration). Cloud service integrations: by default we report tags and labels that are defined in the cloud service. To add tags, you'd add them on the cloud-service-side. Automate tags with our CLI For a guide to automating tags using our CLI tool, see our developer site. Use tags to filter the UI Use the filter field at the top of the New Relic Explorer to filter down to the entities you care about. You can use multiple filter conditions. To filter down to certain entities using tags: From one.newrelic.com, click Explorer. Click the Filter by... field to see a dropdown of available attributes and tags. You can filter by multiple elements and use advanced search options. To find an entityâ€™s metadata and tags from the UI, here are two options: From a list of entities in the UI, at the far right, select an entity's icon. OR Select an entity. Near the top of the page, select the icon. To use the API to view tags, see our NerdGraph docs. Learn about how to use tags with dashboards and how to use tags with workloads. Custom queries, charts, and alerts Different features handle tags differently. Here are some details about how you can use NRQL to query tag data, or create NRQL condition alerts. Query and alert on APM tags You can query APM tags using NRQL. Minimum agent versions: C: not available Go: 2.3.0 Java: 4.9.0 .NET: 8.17 Node: v4.13.0 PHP: not available Python: v4.10.0.112 Ruby: 6.1.0.352 Here are some query examples: Throughput across shards Given a service that is distributed across nine shards, each shard assigned as an environment, we can plot the transaction throughput on all shards using a wildcard query like: SELECT rate(count(apm.service.transaction.duration), 1 minute) FROM Metric WHERE appName LIKE 'MyApp (%' AND transactionType = 'Other' FACET tags.Environment TIMESERIES Copy Transactions per team To see the number of transactions per service for a specific team, we might use a query like: FROM Transaction SELECT count(*) WHERE tags.Team = 'team-a' FACET tags.Project TIMESERIES Copy Alert on error rate for teams You can use a query for your servicesâ€™ error rate for setting an alert without having to create a rule for each service. Here is the error rate for all services on a team called team-b. And this alert will automatically monitor any new app names added with the team tag. FROM Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Team = 'team-b' FACET appName Copy Related to this, you might create a general rule for a specific service deployed across several environments, so that we have an alarm for a single service monitoring each environment individually: From Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Project = 'MyProject' FACET tags.Environment Copy Query and alert on attributes As explained in the tag sources information, some important attributes are used as tags. You can query all attributes and create custom charts using NRQL, and create NRQL alert conditions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 219.98409,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Use</em> tags to help organize and find your data",
        "sections": "<em>Use</em> tags to help organize and find your data",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " to filter the UI <em>Use</em> the filter field at the top of the <em>New</em> <em>Relic</em> Explorer to filter down to the entities you care about. You can <em>use</em> multiple filter conditions. To filter down to certain entities using tags: From <em>one</em>.newrelic.com, click Explorer. Click the Filter by... field to see a dropdown"
      },
      "id": "603ebd1228ccbc6278eba754"
    }
  ],
  "/docs/new-relic-one/use-new-relic-one/core-concepts/transition-new-relic-one-insights": [
    {
      "sections": [
        "Introduction to New Relic One",
        "Tip",
        "Quickly understand context",
        "Query your data more easily",
        "Enhanced dashboards",
        "Build on New Relic One",
        "Whatâ€™s next?"
      ],
      "title": "Introduction to New Relic One",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "c9ba93c83a579625a4ba3364c6046f3c475cba3a",
      "image": "https://docs.newrelic.com/static/2bc08b6d64c16b39697bb43d8e66870e/c1b63/nrone20210722.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-10-24T17:36:54Z",
      "updated_at": "2021-10-24T17:36:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic One is the platform that gives you access to core platform capabilities like querying data and building charts, our more curated observability UI experiences features, and our alerting and Applied Intelligence tools. With New Relic One, you can see and act on all the data throughout your entire system. To access New Relic One: Go to one.newrelic.com. Or, if you report data to the EU data center go to one.eu.newrelic.com. Tip Learn more about New Relic Oneâ€™s basic UI features. Quickly understand context We provide multiple ways to understand your system's dependencies, so you can easily see how everything fits together and troubleshoot problems. New Relic One gives you and your teams a connected view that cuts through complexity! If you want to... Use this Have an overall view of your system, and drill down to get performance details. Use the New Relic Explorer as the front door to New Relic One: observe, group, and filter the performance data from all the entities (that is, all applications, services, hosts, or containers) in your system. Gain extensive visibility into each entity in your solution, its alert status, and how the entities are connected. Use the New Relic Navigator to give you a high density overview of all your entities so you can detect any issues at a glance. And use the New Relic Lookout to spot entities recently experiencing behavior deviations. Provide context for your entities. Add tags to all your entities. Or create tags for teams and all the services they monitor. Use tags to illustrate relationships and contextual information for what you monitor. By thoughtfully tagging your entities, you can connect all the data your teams need to understand their increasingly complex and interdependent systems. See how each part of your system is connected. Service maps illustrate your upstream and downstream dependencies. Visualize the aggregated health and activity data from all you monitor. Group and monitor any entities together into functional team-focused, project-focused groupings, or any other attribute, with workloads. Fetch and analyze specific data. Get more context while you query with the query builder, which surfaces data definitions as you craft and edit queries. Create visuals that showcase your business needs at a glance. Tailor custom dashboards for your unique needs. Find a service or dashboard in a complex environment. Search by name across all accounts in the unified search, or filter the explorer by tags or text. View everything youâ€™re monitoring in one place, like entities or dashboards across your organization. View a list of all the dependencies for a service. The dependencies view tab in an entity summary shows all the dependencies of the entity youâ€™re viewing. Track activity as it moves across your distributed system. Distributed tracing helps you analyze your modern environment. Understand how everything is connected via API. The NerdGraph GraphiQL explorer manages all your entities, tags, and relationships. Query your data more easily On the Browse data menu on the top navigation menu you can easily access your basic telemetry data (metrics, events, logs, and traces). Wherever you go in the UI, Query your data is available. No matter your level of proficiency with our query language, you can create custom queries and charts: Browse your data in a query-less experience with our data explorer. Use your NRQL (our query language) expertise to build custom charts in the query builder. Run PromQL-style queries in the query builder. one.newrelic.com > Query your data: Build NRQL and PROMQL-like queries. Enhanced dashboards one.newrelic.com > Dashboards: Quickly create information dense custom views into the data that matters most to you with dashboards in New Relic One. New Relic One dashboards let you build better visualizations more easily, with more options to customize. Dashboard features include: Perform NRQL queries and create charts and dashboards everywhere in the platform using the query builder. Manage your charts and dashboards easily using our quick-access CRUD menus and editing options. Explore and contextualize data with advanced tooltips and zoom in functions to monitor what your systems are doing in real time. Search your dashboards for attributes and metrics. Send data to your dashboards using our agents, integrations, and APIs. Share dashboards or charts as a .pdf, or embed a chart in an external site. Tip If you previously used New Relic Insights to create dashboards, these are available as New Relic One dashboards. Build on New Relic One If custom charts and dashboards don't solve your current challenge, we give you a framework for building React JavaScript applications that: Live on New Relic One, alongside your other New Relic-monitored data. Feature highly tailored visualizations. Display data from any source you want, whether from a New Relic-monitored entity or data from any service or API. And you can use open source apps built by the community, and contribute your own open source apps. To learn more, see New Relic One applications. Whatâ€™s next? To get started understanding how to get around in New Relic One: See what data you have available with the data explorer. Browse your monitored entities with the New Relic Explorer. Use our NerdGraph API to add tags to your data. Learn about dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 313.3438,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "sections": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> is the platform that gives you access to <em>core</em> platform capabilities like querying data and building charts, our more curated observability UI experiences features, and our alerting and Applied Intelligence tools. With <em>New</em> <em>Relic</em> <em>One</em>, you can see and act on all the data throughout your"
      },
      "id": "603ec19164441f9e704e8896"
    },
    {
      "sections": [
        "What is an entity in New Relic?",
        "What's an entity?",
        "Find and explore entities and entity data",
        "Tip",
        "Group and organize entities",
        "Customize entity data with entity synthesis",
        "Reserved attributes for synthesized entities",
        "Entity relationships",
        "Important",
        "Which relationships are created?",
        "Source: New Relic agent",
        "Source: Infrastructure",
        "Source: Synthetics monitor",
        "Source: Kubernetes",
        "External services"
      ],
      "title": "What is an entity in New Relic?",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "52a3e08bc9103c717d27b153e4fd4f547d6ecc32",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-10-24T17:34:57Z",
      "updated_at": "2021-09-01T17:25:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic monitoring is built around the concept of entities. In this doc, you'll learn how we define entities, what you can do with them, and how you can create your own entities or groupings of entities. What's an entity? From a New Relic perspective, entity is purposefully a broad concept. An entity is anything that a) reports data to New Relic or that contains data that we have access to, and b) is something we've identified with a unique entity ID. For most entities, the ID is indicated by the attribute entityGuid. An entity can be any fundamental data-reporting component, like an application, a host, or a database service, but it can also refer to larger groupings of those components. For example, to monitor a data center, you could aggregate those hosts in New Relic to be a workload (a custom grouping of entities). That workload is, itself, also an entity. Also very important is the relationships between entities. Our behind-the-scenes relationship-mapping helps us understand how entities are connected, how they affect each other. And this allows us to give you the power to configure how any data you're bringing in is related to existing entities, or how it's related to other entities. Our focus on entities and their relationships is important because our goal is to give you practical information about your business-important entities, and not give you an unhelpfully huge stream of data from a huge list of monitored things. With more insight at the entity level, you can better monitor and troubleshoot complex, modern systems. Find and explore entities and entity data Tip You can create new entity types for monitoring any data source. Learn more about entity synthesis. Some tips for finding and understanding entity data: To find an entity's entityGuid and entityName and other metadata: from any list of monitored entities in the New Relic Explorer, click an entity's icon, and click See metadata and tags. For most entities, its GUID is reported as the attribute entityGuid. For workloads, it's workloadGuid. You can run NRQL queries to find entities by their GUID. To see connections between entities, you have several options: When viewing an entity in the UI, use the Related entities UI. Service maps. Distributed tracing. Our NerdGraph API. To group entities together, see Group entities. Customize entity definitions and relationships. To learn technical details about entity types, see our GitHub repo. In an entity type's definition file, you'll see information like: The domain: for example, APM, or Infra. Its type: for example, Application or AWSECSCONTAINERINSTANCE. Default tags. The entityExpirationTime: how long data from that entity lasts in the UI, which is different from database data retention. Group and organize entities You can place entities into groups that reflect business-important relationships in your organization. For example, you might group all entities related to a specific team or department, or related to a specific service. Or you might group multiple hosts together to reflect their grouping in a data center. To group your entities, see: Tag entities. Create workloads, which allow you to group business-important sets of entities. Create entities and customize entity data Customize entity data with entity synthesis If you have telemetry from any source that's not supported by New Relic out of the box, you can propose a mapping for it. Once approved, any telemetry received by New Relic that matches your definition file will be synthesized into an entity. To learn more: For reserved attributes and how entity relationships are defined, keep reading this doc. For how to do the work of modifying existing entity types or creating new ones, see our GitHub repo on entity synthesis. Reserved attributes for synthesized entities These attributes are meant to be synthesized from the telemetry we receive. Do not set them unless you're aware of the implications and consequences. Attribute Description entity.guid Generally, you should not set this attribute field on your telemetry data. New Relic may add this field to ingested data to store a unique identifier for the entity associated with the data point. If telemetry arrives with the entity.guid attribute already present, then New Relic will not change the value. However, it may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. One use case for passing this attribute is to associate ingested telemetry with an entity already created by New Relic. When the entity.guid attribute is sent, the value will override New Relicâ€™s entity identification system (such as entity synthesis definitions) and instead will use the attribute as the data. entity.name This attribute shouldn't be put on ingested telemetry data unless you're trying to override the entity name that would have been selected by New Relicâ€™s entity identification system. While New Relic won't change the value if it's already present on the data, New Relic may add the attribute to your data. Therefore invalid or unexpected values may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. If this field is present on ingested telemetry, its value will be used to name the entity associated with the data point. This name will be used instead of the name selected by New Relicâ€™s entity identification system (for example, entity synthesis definitions). Note that many entities use the name as part of their identification, so changing this field may result in the generation of a new entity. entity.type This attribute shouldn't be put on ingested telemetry data except for certain legacy cases where it's required to distinguish entity types. Passing this field may interfere with entity detection, particularly if unrecognized values are sent in this field. While New Relic won't change the value if already present on the data, the field is not guaranteed to provide unambiguous filtering of telemetry at query-time. Existing entity definitions already have overlapping values, and we recommend avoiding entity.type in favor of other fields for filtering telemetry queries. This field is used by New Relic, meaning that invalid or unexpected values may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. To learn how to do the work of modifying existing entity types or creating new ones, see our GitHub repo on entity synthesis. Entity relationships Connections between entities are automatically created by New Relic based on what we can infer from your telemetry. For example, when two services that communicate using HTTP are instrumented with New Relic, we infer a \"calls/called-by\" relationship between them. When viewing a specific entity in either the New Relic Explorer, Navigator, or Lookout, you can see its Related entities in the entity's mini overview. This gives a visualization of the various entities connected directly to the current entity. You can quickly view important metrics for these related entities and navigate from one entity to another, through all the connected parts of your stack. Tip Learn more about how entities are related with our NerdGraph API. When relationships are not automatically detected, you can manually create them using the \"Add/edit related entities\" link in Related entities. Important Currently, you can only manually create calls/called-by relationships between service entities. Tip To manage manual relationships, you need to have modify and delete capabilities on entity relationships. If you donâ€™t see the edit relationships button, contact your account admin. Which relationships are created? These are the relationships created between entities: Source: New Relic agent Relationship source Relationship type Relationship target Why is the relationship created? Application instrumented with a New Relic agent CALLS Application instrumented with a New Relic agent Relationships between applications monitored by New Relic agents are reported using the DurationByCaller metric. The callee reports the metric. For example, the metric DurationByCaller/Mobile/100/1234/HTTP/all indicates that the caller is APPLICATION 1234 for account 100. Application instrumented with a New Relic agent CALLS Service instrumented with a New Relic agent An application (caller) that calls a service (callee) monitored by New Relic creates a relationship that's reported by the caller using the ExternalApp metric. For example, the metric ExternalApp/dirac.vips.net/100#1234/all indicates that the callee is APPLICATION 1234 for account 100. The metric is reported if the callee successfully responds to the caller. Service instrumented with a New Relic agent CALLS Service instrumented with a New Relic agent When a New Relic agent detects that a service (caller) calls another service (callee) instrumented by New Relic, the callee reports the metric ClientApplication. For example, the metric ClientApplication/100#1234/all indicates that the caller is APPLICATION 1234 for account 100. Service instrumented with a New Relic agent CALLS A datastore instance When an application calls a datastore instance it creates a relationship reported with the DatastoreInstance metric. For example, the metric Datastore/instance/MySQL/172.16.16.3/3306 indicates the datastore instance is vendor: MySQL, host: 172.16.16.3, port: 3306. This metric also supports the legacy datastore instance format Datastore/instance/MySQL/172.16.16.3:3306. Currently we cannot determine whether the datastore instance is instrumented by New Relic and has an entity associated to it. APM agent SERVES Browser agent This relationship is created when an APM agent injects the browser agent into a page. Workload entity CONTAINS Any entity When a workload is created or updated, relationships for each of the entities that belong to the workload are created. Because some workloads are â€œdynamicâ€ (defined by tags), relationships are re-created every 5 minutes. This way entities can join or leave the workload. Source: Infrastructure Relationship source Relationship type Relationship target Why is the relationship created? Infrastructure host HOSTS Application This relationship is created when an application is running in one or more hosts, and the infra agent is running in those hosts. Infrastructure host HOSTS Container This relationship is created when containers are running in one or more hosts, and the host is instrumented with the infra agent. Source: Synthetics monitor Relationship source Relationship type Relationship target Why is the relationship created? Synthetics Monitor CALLS Browser agent This relationship is created when a synthetics monitor checks a page instrumented with the browser agent. Synthetics Monitor CALLS APM application Agent events that contain the attribute nr.syntheticsMonitorId have been described as synthetics monitors (the source) interacting with an APM application (the target). If the header exists and the APM application Id exists, a relationship is created between the monitor and the app. Source: Kubernetes Relationship source Relationship type Relationship target Why is the relationship created? Cluster CONTAINS Pod This relationship is created when a pod is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS Deployment This relationship is created when a deployment is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS DaemonSet This relationship is created when a DaemonSet is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS StatefulSet This relationship is created when a StatefulSet is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS Host This relationship is created when a host that's part of a cluster is instrumented with the New Relic Kubernetes integration. Deployment CONTAINS Pod This relationship is created when a deployment creates a pod in a cluster instrumented with the New Relic Kubernetes integration. DaemonSet CONTAINS Pod This relationship is created when a DaemonSet is created a pod in a cluster instrumented with the New Relic Kubernetes integration. StatefulSet CONTAINS Pod This relationship is created when a StatefulSet creates a pod in a cluster instrumented with the New Relic Kubernetes integration. Pod CONTAINS Container This relationship is created when a pod creates a container in a cluster instrumented with the New Relic Kubernetes integration. Host HOSTS Pod This relationship is created when a pod is running in a host that's part of a cluster instrumented with the New Relic Kubernetes integration. Container HOSTS Application This relationship is created when an application is running in docker, and the hosts where docker is running are instrumented by the the infra agent. External services Relationship source Relationship type Relationship target Why is the relationship created? External service CALLS External service When the relationship is created, the external service reports a span with its name on the service.name attribute and the name of the service that initiates the call in the parent.service.name attribute. Application IS External service A relationship between an application and an external service is created so that users can navigate between them using the related entities component. Browser application instrumented with a New Relic agent CALLS External service A browser application reports an Ajax/HostTransaction metric when calling an external service (URL). Example metric: Ajax/HostTransaction/api.segment.io:443/CallbackTime' Cluster CONTAINS External service When the relationship is created, the external service reports a span with the attribute k8s.cluster.name, the name of the cluster. The cluster must be instrumented with the New Relic Kubernetes integration and the cluster name set for the integration must match the one reported in the span. Pod HOSTS External service When the relationship is created, the external service reports a span with the following attributes: service.name: The name of the service. k8s.cluster.name: The name of the cluster. k8s.pod.name: The name of the pod thatâ€™s running the service. k8s.namespace.name: The namespace where the pod was created. The cluster must be instrumented with the New Relic Kubernetes integration and the cluster name set for the integration must match the one reported in the span.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 225.43376,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "What is an entity in <em>New</em> <em>Relic</em>?",
        "sections": "What is an entity in <em>New</em> <em>Relic</em>?",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": ". If telemetry arrives with the entity.guid attribute already present, then <em>New</em> <em>Relic</em> will not change the value. However, it may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. <em>One</em> <em>use</em> case for passing this attribute is to associate"
      },
      "id": "603ec160e7b9d295f72a07fc"
    },
    {
      "sections": [
        "Use tags to help organize and find your data",
        "Tip",
        "Tag format and limits",
        "Best practices and tips",
        "Tips on keeping tags simple:",
        "Tips on using tags consistently:",
        "Tips on cross-team implementation:",
        "Tag examples",
        "Team-related tags",
        "Environment-related tags",
        "Criticality-related tags",
        "How tags are added",
        "Add tags via UI or API",
        "APM agent tags",
        "Infrastructure data tags",
        "Automate tags with our CLI",
        "Use tags to filter the UI",
        "Custom queries, charts, and alerts",
        "Query and alert on APM tags",
        "Throughput across shards",
        "Transactions per team",
        "Alert on error rate for teams",
        "Query and alert on attributes"
      ],
      "title": "Use tags to help organize and find your data",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e2e2d53776b9109965df9de2a20660e9f60bd479",
      "image": "https://docs.newrelic.com/static/529f55ef72f3e366e6cb4a7be67229b6/c1b63/new-relic-tags-workloads_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/use-tags-help-organize-find-your-data/",
      "published_at": "2021-10-24T17:34:01Z",
      "updated_at": "2021-08-21T09:28:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In the software industry, a tag typically refers to a piece of metadata added to a data set for the purpose of improving data organization and findability. At New Relic, our tags are key:value pairs (like team: operations) added to various sets of data, like monitored apps and hosts, agents, dashboards, and workloads. We make some important attributes available as tags (for example, app metadata like app name and language, and host metadata like host name and AWS region). You can also add your own custom tags. You can use tags in the UI to filter down to relevant data. Here is an example: Here you can see an accountId tag being used to filter workloads to a specific account. Tags help you to: Organize data coming from a large number of sources and/or to a large number of New Relic accounts. Identify teams, roles, environments, or regions to know whoâ€™s responsible for what (see example use cases). Better organize and search dashboards and workloads. Query and chart APM data. Tags are useful for organizing data at a high level. If you want to add more fine-grained detail, like capturing user names or other high-cardinality values, custom attributes or custom events are a better solution. Tip Tags were previously called labels in the New Relic UI. You may sometimes see labelin our code; for example, some of our APM agent config files use a label config option for tags. Tag format and limits Format requirements and limits for tags: The UI has limits on the total number of tags it can display per entity: Limit of 100 for tags reported by default or added via agent/integration configuration. Limit of 100 for custom tags added via UI or API. The following are maximum character length for tags: Key: 128 characters Value: 256 characters When using our API to add tags, a dash (-) in a tag key is interpreted as a minus symbol. If your tag key has a dash, use back ticks around it (like `key-name`). Best practices and tips Before adding tags, we recommend first seeing how our default tags work for you. When you're ready to add your own tags, review the following best practices tips to get the most out of them. Tips on keeping tags simple: Start by adding only tags you know youâ€™ll definitely use. Unused tags create noise and may add confusion. Try to use short tags. Shorter tags are easier to parse, and also the UI may sometimes truncate longer tags. (See character limits.) When possible, use keys and values that are human-readable (for example, region: EMEA is better than Param8323 : 1229072). Avoid including several values like regions: EMEA | US | LATAM in a single tag. We recommend using three different tags for that, like region: emea, region: us, and region: latam. If you want to match multiple tags, you can do that using the advanced options in the filter UI. Tips on using tags consistently: Try to be consistent with tag language across your teams and entities. Be consistent with naming. For example, avoid using both region: emea and reg: emea. Be consistent with format. For example, avoid using both camelCase and kebab-case. Although tag searching is not case-sensitive in the UI and API, try to be consistent with capitalization. For example, avoid using both env: staging and env: Staging. Tips on cross-team implementation: Tags help improve observability and cost allocation. For this reason, responsibility for tag implementation is often assigned to an observability team, SREs, a group of architects, or a cross-team task force. We recommend the people responsible for implementing tags meet and create an internal policy to describe how the tags are defined and which conventions are to be used. Then: Keep this reference manual up to date. Automate the definition of tags when you deploy New Relic agents, at the cloud provider, or through New Relic automation tools, such as the API or Terraform. Create recurring reports that identify entities that are non-compliant with your tagging standards. Tag examples Here are some examples of common ways to use tags to organize data: Team-related tags Creating tags for team names can be helpful to understand which team, group, department, or region was responsible for a change that led to a performance issue. Team examples: team: backend team: frontend team: db Role examples: roles: architecture roles: devops roles: pm Region examples: region: emea region: america region: asia Environment-related tags You can create entities for the environment they belong to. Examples: env: production env: qa env: development env: staging Criticality-related tags You can create tags related to criticality levels, which lets you easier track the most critical issues. Examples: layer: level1 layer: level2 layer: level3 How tags are added Some important attributes, by default, are available for use as tags. For example, the account name, the account ID, and some basic host/server metadata are available as default tags. You can't remove these available-by-default tags. Here are some details about how tags are added for some specific data sources: Add tags via UI or API When you add tags via the UI or API, this occurs at the entity level. This means that, for example, if you have multiple APM agents monitoring a single entity and apply a tag via the UI, that tag is available for all data coming from that entity. To add or delete tags via the UI: Select a monitored entity, like a monitored app or host. Near the entityâ€™s name at the top of the page, select the See metadata and manage tags menu. In the menu that pops up, add or delete a tag. For APM agents, restart your service. To manage tags via API: see our NerdGraph tagging docs. For a guide to using our CLI to automate tagging, see our developer site. APM agent tags You can add tags via the UI and API or you can add tags using APM agent configuration, both methods require you to restart your service. There are differences in how these apply tags: Via agent config: These tags are applied at the agent-level, not the entity/application level. This would be a good option if you have multiple agents monitoring different aspects of the same app (for example, a blue-green deployment model). Via the UI or API: These tags are applied at the entity/application level. Here are links to the agent configuration options: C SDK: not available Java Go .NET Node.js PHP Python Ruby For information on querying APM tags, see Query APM tags. Infrastructure data tags There are several ways tags are added to infrastructure entities and services: Use the UI or API to add tags at the entity level. Infrastructure agent: some attributes are available by default as tags. You can also add custom attributes, which are also available as tags in the UI. On-host integrations: some attributes are available by default as tags. You can also add tags by using integration-specific labels config options (for an example, see the labels config for the Apache integration). Cloud service integrations: by default we report tags and labels that are defined in the cloud service. To add tags, you'd add them on the cloud-service-side. Automate tags with our CLI For a guide to automating tags using our CLI tool, see our developer site. Use tags to filter the UI Use the filter field at the top of the New Relic Explorer to filter down to the entities you care about. You can use multiple filter conditions. To filter down to certain entities using tags: From one.newrelic.com, click Explorer. Click the Filter by... field to see a dropdown of available attributes and tags. You can filter by multiple elements and use advanced search options. To find an entityâ€™s metadata and tags from the UI, here are two options: From a list of entities in the UI, at the far right, select an entity's icon. OR Select an entity. Near the top of the page, select the icon. To use the API to view tags, see our NerdGraph docs. Learn about how to use tags with dashboards and how to use tags with workloads. Custom queries, charts, and alerts Different features handle tags differently. Here are some details about how you can use NRQL to query tag data, or create NRQL condition alerts. Query and alert on APM tags You can query APM tags using NRQL. Minimum agent versions: C: not available Go: 2.3.0 Java: 4.9.0 .NET: 8.17 Node: v4.13.0 PHP: not available Python: v4.10.0.112 Ruby: 6.1.0.352 Here are some query examples: Throughput across shards Given a service that is distributed across nine shards, each shard assigned as an environment, we can plot the transaction throughput on all shards using a wildcard query like: SELECT rate(count(apm.service.transaction.duration), 1 minute) FROM Metric WHERE appName LIKE 'MyApp (%' AND transactionType = 'Other' FACET tags.Environment TIMESERIES Copy Transactions per team To see the number of transactions per service for a specific team, we might use a query like: FROM Transaction SELECT count(*) WHERE tags.Team = 'team-a' FACET tags.Project TIMESERIES Copy Alert on error rate for teams You can use a query for your servicesâ€™ error rate for setting an alert without having to create a rule for each service. Here is the error rate for all services on a team called team-b. And this alert will automatically monitor any new app names added with the team tag. FROM Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Team = 'team-b' FACET appName Copy Related to this, you might create a general rule for a specific service deployed across several environments, so that we have an alarm for a single service monitoring each environment individually: From Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Project = 'MyProject' FACET tags.Environment Copy Query and alert on attributes As explained in the tag sources information, some important attributes are used as tags. You can query all attributes and create custom charts using NRQL, and create NRQL alert conditions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 219.98407,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Use</em> tags to help organize and find your data",
        "sections": "<em>Use</em> tags to help organize and find your data",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " to filter the UI <em>Use</em> the filter field at the top of the <em>New</em> <em>Relic</em> Explorer to filter down to the entities you care about. You can <em>use</em> multiple filter conditions. To filter down to certain entities using tags: From <em>one</em>.newrelic.com, click Explorer. Click the Filter by... field to see a dropdown"
      },
      "id": "603ebd1228ccbc6278eba754"
    }
  ],
  "/docs/new-relic-one/use-new-relic-one/core-concepts/use-tags-help-organize-find-your-data": [
    {
      "sections": [
        "Introduction to New Relic One",
        "Tip",
        "Quickly understand context",
        "Query your data more easily",
        "Enhanced dashboards",
        "Build on New Relic One",
        "Whatâ€™s next?"
      ],
      "title": "Introduction to New Relic One",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "c9ba93c83a579625a4ba3364c6046f3c475cba3a",
      "image": "https://docs.newrelic.com/static/2bc08b6d64c16b39697bb43d8e66870e/c1b63/nrone20210722.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-10-24T17:36:54Z",
      "updated_at": "2021-10-24T17:36:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic One is the platform that gives you access to core platform capabilities like querying data and building charts, our more curated observability UI experiences features, and our alerting and Applied Intelligence tools. With New Relic One, you can see and act on all the data throughout your entire system. To access New Relic One: Go to one.newrelic.com. Or, if you report data to the EU data center go to one.eu.newrelic.com. Tip Learn more about New Relic Oneâ€™s basic UI features. Quickly understand context We provide multiple ways to understand your system's dependencies, so you can easily see how everything fits together and troubleshoot problems. New Relic One gives you and your teams a connected view that cuts through complexity! If you want to... Use this Have an overall view of your system, and drill down to get performance details. Use the New Relic Explorer as the front door to New Relic One: observe, group, and filter the performance data from all the entities (that is, all applications, services, hosts, or containers) in your system. Gain extensive visibility into each entity in your solution, its alert status, and how the entities are connected. Use the New Relic Navigator to give you a high density overview of all your entities so you can detect any issues at a glance. And use the New Relic Lookout to spot entities recently experiencing behavior deviations. Provide context for your entities. Add tags to all your entities. Or create tags for teams and all the services they monitor. Use tags to illustrate relationships and contextual information for what you monitor. By thoughtfully tagging your entities, you can connect all the data your teams need to understand their increasingly complex and interdependent systems. See how each part of your system is connected. Service maps illustrate your upstream and downstream dependencies. Visualize the aggregated health and activity data from all you monitor. Group and monitor any entities together into functional team-focused, project-focused groupings, or any other attribute, with workloads. Fetch and analyze specific data. Get more context while you query with the query builder, which surfaces data definitions as you craft and edit queries. Create visuals that showcase your business needs at a glance. Tailor custom dashboards for your unique needs. Find a service or dashboard in a complex environment. Search by name across all accounts in the unified search, or filter the explorer by tags or text. View everything youâ€™re monitoring in one place, like entities or dashboards across your organization. View a list of all the dependencies for a service. The dependencies view tab in an entity summary shows all the dependencies of the entity youâ€™re viewing. Track activity as it moves across your distributed system. Distributed tracing helps you analyze your modern environment. Understand how everything is connected via API. The NerdGraph GraphiQL explorer manages all your entities, tags, and relationships. Query your data more easily On the Browse data menu on the top navigation menu you can easily access your basic telemetry data (metrics, events, logs, and traces). Wherever you go in the UI, Query your data is available. No matter your level of proficiency with our query language, you can create custom queries and charts: Browse your data in a query-less experience with our data explorer. Use your NRQL (our query language) expertise to build custom charts in the query builder. Run PromQL-style queries in the query builder. one.newrelic.com > Query your data: Build NRQL and PROMQL-like queries. Enhanced dashboards one.newrelic.com > Dashboards: Quickly create information dense custom views into the data that matters most to you with dashboards in New Relic One. New Relic One dashboards let you build better visualizations more easily, with more options to customize. Dashboard features include: Perform NRQL queries and create charts and dashboards everywhere in the platform using the query builder. Manage your charts and dashboards easily using our quick-access CRUD menus and editing options. Explore and contextualize data with advanced tooltips and zoom in functions to monitor what your systems are doing in real time. Search your dashboards for attributes and metrics. Send data to your dashboards using our agents, integrations, and APIs. Share dashboards or charts as a .pdf, or embed a chart in an external site. Tip If you previously used New Relic Insights to create dashboards, these are available as New Relic One dashboards. Build on New Relic One If custom charts and dashboards don't solve your current challenge, we give you a framework for building React JavaScript applications that: Live on New Relic One, alongside your other New Relic-monitored data. Feature highly tailored visualizations. Display data from any source you want, whether from a New Relic-monitored entity or data from any service or API. And you can use open source apps built by the community, and contribute your own open source apps. To learn more, see New Relic One applications. Whatâ€™s next? To get started understanding how to get around in New Relic One: See what data you have available with the data explorer. Browse your monitored entities with the New Relic Explorer. Use our NerdGraph API to add tags to your data. Learn about dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 313.3438,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "sections": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> is the platform that gives you access to <em>core</em> platform capabilities like querying data and building charts, our more curated observability UI experiences features, and our alerting and Applied Intelligence tools. With <em>New</em> <em>Relic</em> <em>One</em>, you can see and act on all the data throughout your"
      },
      "id": "603ec19164441f9e704e8896"
    },
    {
      "sections": [
        "What is an entity in New Relic?",
        "What's an entity?",
        "Find and explore entities and entity data",
        "Tip",
        "Group and organize entities",
        "Customize entity data with entity synthesis",
        "Reserved attributes for synthesized entities",
        "Entity relationships",
        "Important",
        "Which relationships are created?",
        "Source: New Relic agent",
        "Source: Infrastructure",
        "Source: Synthetics monitor",
        "Source: Kubernetes",
        "External services"
      ],
      "title": "What is an entity in New Relic?",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "52a3e08bc9103c717d27b153e4fd4f547d6ecc32",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-10-24T17:34:57Z",
      "updated_at": "2021-09-01T17:25:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic monitoring is built around the concept of entities. In this doc, you'll learn how we define entities, what you can do with them, and how you can create your own entities or groupings of entities. What's an entity? From a New Relic perspective, entity is purposefully a broad concept. An entity is anything that a) reports data to New Relic or that contains data that we have access to, and b) is something we've identified with a unique entity ID. For most entities, the ID is indicated by the attribute entityGuid. An entity can be any fundamental data-reporting component, like an application, a host, or a database service, but it can also refer to larger groupings of those components. For example, to monitor a data center, you could aggregate those hosts in New Relic to be a workload (a custom grouping of entities). That workload is, itself, also an entity. Also very important is the relationships between entities. Our behind-the-scenes relationship-mapping helps us understand how entities are connected, how they affect each other. And this allows us to give you the power to configure how any data you're bringing in is related to existing entities, or how it's related to other entities. Our focus on entities and their relationships is important because our goal is to give you practical information about your business-important entities, and not give you an unhelpfully huge stream of data from a huge list of monitored things. With more insight at the entity level, you can better monitor and troubleshoot complex, modern systems. Find and explore entities and entity data Tip You can create new entity types for monitoring any data source. Learn more about entity synthesis. Some tips for finding and understanding entity data: To find an entity's entityGuid and entityName and other metadata: from any list of monitored entities in the New Relic Explorer, click an entity's icon, and click See metadata and tags. For most entities, its GUID is reported as the attribute entityGuid. For workloads, it's workloadGuid. You can run NRQL queries to find entities by their GUID. To see connections between entities, you have several options: When viewing an entity in the UI, use the Related entities UI. Service maps. Distributed tracing. Our NerdGraph API. To group entities together, see Group entities. Customize entity definitions and relationships. To learn technical details about entity types, see our GitHub repo. In an entity type's definition file, you'll see information like: The domain: for example, APM, or Infra. Its type: for example, Application or AWSECSCONTAINERINSTANCE. Default tags. The entityExpirationTime: how long data from that entity lasts in the UI, which is different from database data retention. Group and organize entities You can place entities into groups that reflect business-important relationships in your organization. For example, you might group all entities related to a specific team or department, or related to a specific service. Or you might group multiple hosts together to reflect their grouping in a data center. To group your entities, see: Tag entities. Create workloads, which allow you to group business-important sets of entities. Create entities and customize entity data Customize entity data with entity synthesis If you have telemetry from any source that's not supported by New Relic out of the box, you can propose a mapping for it. Once approved, any telemetry received by New Relic that matches your definition file will be synthesized into an entity. To learn more: For reserved attributes and how entity relationships are defined, keep reading this doc. For how to do the work of modifying existing entity types or creating new ones, see our GitHub repo on entity synthesis. Reserved attributes for synthesized entities These attributes are meant to be synthesized from the telemetry we receive. Do not set them unless you're aware of the implications and consequences. Attribute Description entity.guid Generally, you should not set this attribute field on your telemetry data. New Relic may add this field to ingested data to store a unique identifier for the entity associated with the data point. If telemetry arrives with the entity.guid attribute already present, then New Relic will not change the value. However, it may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. One use case for passing this attribute is to associate ingested telemetry with an entity already created by New Relic. When the entity.guid attribute is sent, the value will override New Relicâ€™s entity identification system (such as entity synthesis definitions) and instead will use the attribute as the data. entity.name This attribute shouldn't be put on ingested telemetry data unless you're trying to override the entity name that would have been selected by New Relicâ€™s entity identification system. While New Relic won't change the value if it's already present on the data, New Relic may add the attribute to your data. Therefore invalid or unexpected values may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. If this field is present on ingested telemetry, its value will be used to name the entity associated with the data point. This name will be used instead of the name selected by New Relicâ€™s entity identification system (for example, entity synthesis definitions). Note that many entities use the name as part of their identification, so changing this field may result in the generation of a new entity. entity.type This attribute shouldn't be put on ingested telemetry data except for certain legacy cases where it's required to distinguish entity types. Passing this field may interfere with entity detection, particularly if unrecognized values are sent in this field. While New Relic won't change the value if already present on the data, the field is not guaranteed to provide unambiguous filtering of telemetry at query-time. Existing entity definitions already have overlapping values, and we recommend avoiding entity.type in favor of other fields for filtering telemetry queries. This field is used by New Relic, meaning that invalid or unexpected values may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. To learn how to do the work of modifying existing entity types or creating new ones, see our GitHub repo on entity synthesis. Entity relationships Connections between entities are automatically created by New Relic based on what we can infer from your telemetry. For example, when two services that communicate using HTTP are instrumented with New Relic, we infer a \"calls/called-by\" relationship between them. When viewing a specific entity in either the New Relic Explorer, Navigator, or Lookout, you can see its Related entities in the entity's mini overview. This gives a visualization of the various entities connected directly to the current entity. You can quickly view important metrics for these related entities and navigate from one entity to another, through all the connected parts of your stack. Tip Learn more about how entities are related with our NerdGraph API. When relationships are not automatically detected, you can manually create them using the \"Add/edit related entities\" link in Related entities. Important Currently, you can only manually create calls/called-by relationships between service entities. Tip To manage manual relationships, you need to have modify and delete capabilities on entity relationships. If you donâ€™t see the edit relationships button, contact your account admin. Which relationships are created? These are the relationships created between entities: Source: New Relic agent Relationship source Relationship type Relationship target Why is the relationship created? Application instrumented with a New Relic agent CALLS Application instrumented with a New Relic agent Relationships between applications monitored by New Relic agents are reported using the DurationByCaller metric. The callee reports the metric. For example, the metric DurationByCaller/Mobile/100/1234/HTTP/all indicates that the caller is APPLICATION 1234 for account 100. Application instrumented with a New Relic agent CALLS Service instrumented with a New Relic agent An application (caller) that calls a service (callee) monitored by New Relic creates a relationship that's reported by the caller using the ExternalApp metric. For example, the metric ExternalApp/dirac.vips.net/100#1234/all indicates that the callee is APPLICATION 1234 for account 100. The metric is reported if the callee successfully responds to the caller. Service instrumented with a New Relic agent CALLS Service instrumented with a New Relic agent When a New Relic agent detects that a service (caller) calls another service (callee) instrumented by New Relic, the callee reports the metric ClientApplication. For example, the metric ClientApplication/100#1234/all indicates that the caller is APPLICATION 1234 for account 100. Service instrumented with a New Relic agent CALLS A datastore instance When an application calls a datastore instance it creates a relationship reported with the DatastoreInstance metric. For example, the metric Datastore/instance/MySQL/172.16.16.3/3306 indicates the datastore instance is vendor: MySQL, host: 172.16.16.3, port: 3306. This metric also supports the legacy datastore instance format Datastore/instance/MySQL/172.16.16.3:3306. Currently we cannot determine whether the datastore instance is instrumented by New Relic and has an entity associated to it. APM agent SERVES Browser agent This relationship is created when an APM agent injects the browser agent into a page. Workload entity CONTAINS Any entity When a workload is created or updated, relationships for each of the entities that belong to the workload are created. Because some workloads are â€œdynamicâ€ (defined by tags), relationships are re-created every 5 minutes. This way entities can join or leave the workload. Source: Infrastructure Relationship source Relationship type Relationship target Why is the relationship created? Infrastructure host HOSTS Application This relationship is created when an application is running in one or more hosts, and the infra agent is running in those hosts. Infrastructure host HOSTS Container This relationship is created when containers are running in one or more hosts, and the host is instrumented with the infra agent. Source: Synthetics monitor Relationship source Relationship type Relationship target Why is the relationship created? Synthetics Monitor CALLS Browser agent This relationship is created when a synthetics monitor checks a page instrumented with the browser agent. Synthetics Monitor CALLS APM application Agent events that contain the attribute nr.syntheticsMonitorId have been described as synthetics monitors (the source) interacting with an APM application (the target). If the header exists and the APM application Id exists, a relationship is created between the monitor and the app. Source: Kubernetes Relationship source Relationship type Relationship target Why is the relationship created? Cluster CONTAINS Pod This relationship is created when a pod is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS Deployment This relationship is created when a deployment is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS DaemonSet This relationship is created when a DaemonSet is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS StatefulSet This relationship is created when a StatefulSet is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS Host This relationship is created when a host that's part of a cluster is instrumented with the New Relic Kubernetes integration. Deployment CONTAINS Pod This relationship is created when a deployment creates a pod in a cluster instrumented with the New Relic Kubernetes integration. DaemonSet CONTAINS Pod This relationship is created when a DaemonSet is created a pod in a cluster instrumented with the New Relic Kubernetes integration. StatefulSet CONTAINS Pod This relationship is created when a StatefulSet creates a pod in a cluster instrumented with the New Relic Kubernetes integration. Pod CONTAINS Container This relationship is created when a pod creates a container in a cluster instrumented with the New Relic Kubernetes integration. Host HOSTS Pod This relationship is created when a pod is running in a host that's part of a cluster instrumented with the New Relic Kubernetes integration. Container HOSTS Application This relationship is created when an application is running in docker, and the hosts where docker is running are instrumented by the the infra agent. External services Relationship source Relationship type Relationship target Why is the relationship created? External service CALLS External service When the relationship is created, the external service reports a span with its name on the service.name attribute and the name of the service that initiates the call in the parent.service.name attribute. Application IS External service A relationship between an application and an external service is created so that users can navigate between them using the related entities component. Browser application instrumented with a New Relic agent CALLS External service A browser application reports an Ajax/HostTransaction metric when calling an external service (URL). Example metric: Ajax/HostTransaction/api.segment.io:443/CallbackTime' Cluster CONTAINS External service When the relationship is created, the external service reports a span with the attribute k8s.cluster.name, the name of the cluster. The cluster must be instrumented with the New Relic Kubernetes integration and the cluster name set for the integration must match the one reported in the span. Pod HOSTS External service When the relationship is created, the external service reports a span with the following attributes: service.name: The name of the service. k8s.cluster.name: The name of the cluster. k8s.pod.name: The name of the pod thatâ€™s running the service. k8s.namespace.name: The namespace where the pod was created. The cluster must be instrumented with the New Relic Kubernetes integration and the cluster name set for the integration must match the one reported in the span.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 225.43376,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "What is an entity in <em>New</em> <em>Relic</em>?",
        "sections": "What is an entity in <em>New</em> <em>Relic</em>?",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": ". If telemetry arrives with the entity.guid attribute already present, then <em>New</em> <em>Relic</em> will not change the value. However, it may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. <em>One</em> <em>use</em> case for passing this attribute is to associate"
      },
      "id": "603ec160e7b9d295f72a07fc"
    },
    {
      "sections": [
        "New Relic Lookout: Monitor your estate at a glance",
        "Why it matters",
        "Requirements",
        "Get started with New Relic Lookout",
        "Circle visualization and table view",
        "Abnormal golden signals",
        "Instant search",
        "Change view",
        "Drill down into the details",
        "Performance tab",
        "Abnormal History tab",
        "Correlations tab",
        "Profile tab",
        "Traces tab",
        "Create a custom view",
        "Query: Compare the last 15 minutes to the same time 1 day ago",
        "Query: Compare a specific time range to the same range a month ago",
        "Example: Unusual increases in error count"
      ],
      "title": "New Relic Lookout: Monitor your estate at a glance",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "9193dcc8851c185ff5d96f6f93ab412bd1be69e9",
      "image": "https://docs.newrelic.com/static/178b37068bad2a68cff027c8bdcf663a/c1b63/lookout-intro.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-lookout-monitor-your-estate-glance/",
      "published_at": "2021-10-18T02:49:51Z",
      "updated_at": "2021-08-21T09:27:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Lookout provides visibility into your entire estate. It doesn't require any configuration â€” you can query anything in your estate that matters to you right now and understand your system as a whole, or dive deep into causes and effects, so you can quickly get the data you need to take action. Know exactly where to focus your attention with New Relic Lookout. The brighter the color, the more severe the change, and the bigger the size, the bigger the scale. Then dig deeper with correlations and abnormal history to see how it impacts your whole systemâ€”no configuration needed. Why it matters New Relic Lookout helps software teams of any size discover potential issues before they have an impact. Fill gaps in monitoring with full coverage out-of-the-box, no configuration or setup required. Immediately see anything deviating from normal across your entire estate. Proactively spot emerging problems in a real-time visualization of all system components. Gain faster incidents resolution through automatically surfaced causes and effects. Analyze any data in New Relic database (NRDB), including third-party, open, and custom data. Launch into other areas of New Relic One for deeper understanding Requirements New Relic Lookout requires Pro or Enterprise edition. If you are on Standard edition, you can still use the New Relic Lookout view in the New Relic Explorer. If you want to see data spanning 13-months, correlations, profiles, traces, and other details, you must upgrade to a higher edition. Get started with New Relic Lookout To access New Relic Lookout, click the Apps button in New Relic One and locate the New Relic Lookout launcher. You can also access New Relic Lookout directly from the New Relic One header bar, via the More dropdown. Enablement of key service performance indicator data is required for New Relic Lookout to provide value from the data you already have. The default view provides insight into three key Service performance indicators broken down by application: throughput, response time, and errors. These metrics are analyzed to show how the data has behaved during the last five minutes compared to the prior hour. one.newrelic.com > Apps > New Relic Lookout: Anything that significantly deviates from the trend is automatically discovered by New Relic Lookout, which doesn't require any configuration. Circle visualization and table view Each application (or other facet) is represented by a circle. The size of the circles indicate the magnitude of the signal for that application and the color indicates whether the value has significantly decreased or increased in the last five minutes, based on the standard deviation of the prior hour (default evaluation and comparison time windows.) Please note that the type of signal is important when interpreting your results. When you first look at the legend below, you might be tempted to interpret yellow as good and dark purple as bad, but that is not always the case. Here are some examples: In the APM/services golden signals, a dark yellow circle in Throughput might signify that something bad has occurred and led to a drop in traffic. At the same time, a dark purple circle might also be concerning due to unexpected load. Both are significant findings worth exploring. In browser golden signals, a dark purple circle in Page Views might be great, as you are seeing more traffic to your site! With errors golden signals (in all entity types), a large circle, even if gray (not deviating from normal volume), is worth exploring because a high count of errors in your system is important to investigate. The legend allows you to change the colors used to highlight deviating services To change the color palette, click the gear icon by the low-high color legend. This allows you to change the colors used to highlight deviating services. To get a table view of the same data, click the toggle on the right. You can also hover over each color to filter the view by degree lower or higher deviance. Abnormal golden signals On the right, New Relic Lookout displays the most significantly deviating applications (or other facet) in a side panel, weighted by both the magnitude of the performance indicators and the scale of their deviations. Details include the name of the key performance indicator, their magnitude during the recent time window, and the difference between the averages from one time compared to the other. Instant search Click the magnifying glass icon in the side panel to open a search box. Typing into the search box filters the circles, table, and abnormal signals to applications (or other facets) that contain the text. This is a good way to quickly zoom to various subsystems. New Relic Lookout doesn't rerun the analysis when using the instant search. Change view Click the Change View button on the right side panel. The panel that appears shows you all the entity-specific golden signals you can toggle between out of the box. By choosing the Browser Golden Signal or other views, you can change from the default view. Each new view will have the golden signals appropriate for that entity type. Drill down into the details To analyze an application or facet, click a circle, table row, or abnormal golden signal. The details panel shows the degree of deviation of the performance indicator, a link to the affected entity, and recent alert and deployment activity for that entity, when available. Thereâ€™s also an indication of whether the selected evaluation time period would be abnormal or not in reference to other comparison time windows, such as the same time yesterday or the same time last week. This allows you to quickly see if the abnormal behavior is odd in general, or just based on the comparison time window. Performance tab The default tab shows charts for other key performance indicators for the selected application or facet. The charts compare the two time windows being analyzed. You can click their titles to rerun the analysis, focusing on the selected key performance indicator. When the target is a New Relic One application, we show the top transactions, error classes, external services, and database operations, alongside links to the relevant New Relic One features. Abnormal History tab This section analyzes past performance of the selected signal and calls out any time periods with notable abnormalities. Each card represents an abnormal time window and can be clicked for more details. The charts will display any relevant violations and deployments in New Relic. Correlations tab New Relic Lookout can find other signals that began behaving differently around the same time as the selected signal for that entity type. Clicking the name of the signal reruns the analysis, focusing on that key performance indicator. The chart titles link to New Relic One when thereâ€™s an associated entity in your account. Note that correlations currently do not analyze across accounts. The correlated signals displayed are for others in the account of the original application you are viewing. This helps focus the data on correlations that are more likely related to your issue. Profile tab Based on the same technology as New Relicâ€™s error profiles, this tab compares the last five minutes to the prior hour by default (or whatever time windows youâ€™ve selected with query editing) and surfaces any attributes that have significantly different distributions in the events being targeted by the selected signal. For example, if a custom attribute indicated that a recent throughput spike came from one user, that would surface highly in Profiles if most of the traffic usually comes from many users. Traces tab If the entity has distributed traces configured and available in the selected evaluated time window, the Traces section is enabled. Each card shows a summary of a trace and can be clicked for details. The Explore all traces links to the distributed traces application, filtered to the selected entity. Create a custom view To target signals and time windows beyond the default values, click the Change view button and select Custom view. To create your own view: Select the account or subaccount. Select the data type (metrics or events). Different functionality is available depending on the type. In View a chart with, select the metric or event you are interested in. Default is golden signals (throughput, response time, and errors). You can also build custom queries (filters) to target a signal that isn't on the list. In Facet by, select what the circles represent. Default is appName, but you can also choose host or any other facetable attribute available for the signal youâ€™ve selected. If you plan to save/favorite this new view, provide a name in the Name your view box. Keep in mind that you can edit this view at any time using the pencil icon. The default time windows analyzed by New Relic Lookout are the last five minutes compared to the hour before. Use the time controls (View data from and Compare data to) to target other time windows. one.newrelic.com > Apps > New Relic Lookout: All event and metric data in the New Relic database can be queried using the Edit query feature. Click Analyze to begin analyzing the signal youâ€™ve selected. You can also create your own query: Create your query. This query is comparing data from the past thirty minutes to data from the same range a day ago. Change from Basic to Advanced after clicking the Custom view button. Select the data type (metrics or events). Different functionality is available depending on the type. Enter your query using NRQL. Please note that not all NRQL features are available in the Lookout Advanced query feature. By default, the system will run this query using the last five minutes of data compared to the previous hour. Some examples of the syntax for changing the comparison and evaluation time windows are below. Click Analyze to begin analyzing the signal youâ€™ve selected. Query: Compare the last 15 minutes to the same time 1 day ago Please note that the UNTIL NOW portion is required here unlike in standard NRQL. Without the UNTIL NOW added, the system will query a 5 minute slice of data starting 15 minutes ago SINCE 15 minutes AGO UNTIL NOW COMPARE WITH 1 day ago Copy Query: Compare a specific time range to the same range a month ago SINCE '2021-03-07 07:00:00-0500' UNTIL '2021-03-08 07:00:00-0500' COMPARE WITH 1 month ago Copy Or: SINCE 'today at midnight' UNTIL 'now' COMPARE WITH 1 MONTH AGO Copy Example: Unusual increases in error count The default view of New Relic Lookout shows application status across your estate, comparing the last five minutes to the hour before. Under regular operation, most large systems may have a handful of abnormalities, but usually most things will indicate normal behavior. Suddenly, several circles begin to change to red under the Errors section. This indicates that several applications are experiencing unusual increases in error count. It may be that one or two circles for important systems are red, and perhaps much larger than they usually appear. Clicking one of these can provide more information on what is happening. You might see that the error rate is substantially elevated, even thousands of percent higher than normal. To troubleshoot this issue, here's what you might discover in the New Relic Lookout tabs: Performance would show you data about other signals, illuminating the characteristics of the change in system dynamics. Correlations would surface other applications that are affected and how, as well as opportunities to pivot to other applications that may be closer to the underlying causes. Traces, in turn, would show distributed traces, which can provide specific examples of traffic running through those systems. Abnormal history would show other times in the past week with elevated errors, showing whether or not this problem happens regularly, such as every day at the same time or whenever there is a deployment. Profiles might show that all or most of the new errors share common properties, such as all being isolated to just one region/account/user. Combining the information from these sections, not only can you get a sense of what is going on, but also where to focus actions to resolve the problem.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 219.9838,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Lookout: Monitor your estate at a glance",
        "sections": "<em>New</em> <em>Relic</em> Lookout: Monitor your estate at a glance",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " emerging problems in a real-time visualization of all system components. Gain faster incidents resolution through automatically surfaced causes and effects. Analyze any data in <em>New</em> <em>Relic</em> database (NRDB), including third-party, open, and custom data. Launch into other areas of <em>New</em> <em>Relic</em> <em>One</em> for deeper"
      },
      "id": "603e821e64441f5a444e8845"
    }
  ],
  "/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic": [
    {
      "sections": [
        "Introduction to New Relic One",
        "Tip",
        "Quickly understand context",
        "Query your data more easily",
        "Enhanced dashboards",
        "Build on New Relic One",
        "Whatâ€™s next?"
      ],
      "title": "Introduction to New Relic One",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "c9ba93c83a579625a4ba3364c6046f3c475cba3a",
      "image": "https://docs.newrelic.com/static/2bc08b6d64c16b39697bb43d8e66870e/c1b63/nrone20210722.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-10-24T17:36:54Z",
      "updated_at": "2021-10-24T17:36:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic One is the platform that gives you access to core platform capabilities like querying data and building charts, our more curated observability UI experiences features, and our alerting and Applied Intelligence tools. With New Relic One, you can see and act on all the data throughout your entire system. To access New Relic One: Go to one.newrelic.com. Or, if you report data to the EU data center go to one.eu.newrelic.com. Tip Learn more about New Relic Oneâ€™s basic UI features. Quickly understand context We provide multiple ways to understand your system's dependencies, so you can easily see how everything fits together and troubleshoot problems. New Relic One gives you and your teams a connected view that cuts through complexity! If you want to... Use this Have an overall view of your system, and drill down to get performance details. Use the New Relic Explorer as the front door to New Relic One: observe, group, and filter the performance data from all the entities (that is, all applications, services, hosts, or containers) in your system. Gain extensive visibility into each entity in your solution, its alert status, and how the entities are connected. Use the New Relic Navigator to give you a high density overview of all your entities so you can detect any issues at a glance. And use the New Relic Lookout to spot entities recently experiencing behavior deviations. Provide context for your entities. Add tags to all your entities. Or create tags for teams and all the services they monitor. Use tags to illustrate relationships and contextual information for what you monitor. By thoughtfully tagging your entities, you can connect all the data your teams need to understand their increasingly complex and interdependent systems. See how each part of your system is connected. Service maps illustrate your upstream and downstream dependencies. Visualize the aggregated health and activity data from all you monitor. Group and monitor any entities together into functional team-focused, project-focused groupings, or any other attribute, with workloads. Fetch and analyze specific data. Get more context while you query with the query builder, which surfaces data definitions as you craft and edit queries. Create visuals that showcase your business needs at a glance. Tailor custom dashboards for your unique needs. Find a service or dashboard in a complex environment. Search by name across all accounts in the unified search, or filter the explorer by tags or text. View everything youâ€™re monitoring in one place, like entities or dashboards across your organization. View a list of all the dependencies for a service. The dependencies view tab in an entity summary shows all the dependencies of the entity youâ€™re viewing. Track activity as it moves across your distributed system. Distributed tracing helps you analyze your modern environment. Understand how everything is connected via API. The NerdGraph GraphiQL explorer manages all your entities, tags, and relationships. Query your data more easily On the Browse data menu on the top navigation menu you can easily access your basic telemetry data (metrics, events, logs, and traces). Wherever you go in the UI, Query your data is available. No matter your level of proficiency with our query language, you can create custom queries and charts: Browse your data in a query-less experience with our data explorer. Use your NRQL (our query language) expertise to build custom charts in the query builder. Run PromQL-style queries in the query builder. one.newrelic.com > Query your data: Build NRQL and PROMQL-like queries. Enhanced dashboards one.newrelic.com > Dashboards: Quickly create information dense custom views into the data that matters most to you with dashboards in New Relic One. New Relic One dashboards let you build better visualizations more easily, with more options to customize. Dashboard features include: Perform NRQL queries and create charts and dashboards everywhere in the platform using the query builder. Manage your charts and dashboards easily using our quick-access CRUD menus and editing options. Explore and contextualize data with advanced tooltips and zoom in functions to monitor what your systems are doing in real time. Search your dashboards for attributes and metrics. Send data to your dashboards using our agents, integrations, and APIs. Share dashboards or charts as a .pdf, or embed a chart in an external site. Tip If you previously used New Relic Insights to create dashboards, these are available as New Relic One dashboards. Build on New Relic One If custom charts and dashboards don't solve your current challenge, we give you a framework for building React JavaScript applications that: Live on New Relic One, alongside your other New Relic-monitored data. Feature highly tailored visualizations. Display data from any source you want, whether from a New Relic-monitored entity or data from any service or API. And you can use open source apps built by the community, and contribute your own open source apps. To learn more, see New Relic One applications. Whatâ€™s next? To get started understanding how to get around in New Relic One: See what data you have available with the data explorer. Browse your monitored entities with the New Relic Explorer. Use our NerdGraph API to add tags to your data. Learn about dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 313.34354,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "sections": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> is the platform that gives you access to <em>core</em> platform capabilities like querying data and building charts, our more curated observability UI experiences features, and our alerting and Applied Intelligence tools. With <em>New</em> <em>Relic</em> <em>One</em>, you can see and act on all the data throughout your"
      },
      "id": "603ec19164441f9e704e8896"
    },
    {
      "sections": [
        "Use tags to help organize and find your data",
        "Tip",
        "Tag format and limits",
        "Best practices and tips",
        "Tips on keeping tags simple:",
        "Tips on using tags consistently:",
        "Tips on cross-team implementation:",
        "Tag examples",
        "Team-related tags",
        "Environment-related tags",
        "Criticality-related tags",
        "How tags are added",
        "Add tags via UI or API",
        "APM agent tags",
        "Infrastructure data tags",
        "Automate tags with our CLI",
        "Use tags to filter the UI",
        "Custom queries, charts, and alerts",
        "Query and alert on APM tags",
        "Throughput across shards",
        "Transactions per team",
        "Alert on error rate for teams",
        "Query and alert on attributes"
      ],
      "title": "Use tags to help organize and find your data",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e2e2d53776b9109965df9de2a20660e9f60bd479",
      "image": "https://docs.newrelic.com/static/529f55ef72f3e366e6cb4a7be67229b6/c1b63/new-relic-tags-workloads_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/use-tags-help-organize-find-your-data/",
      "published_at": "2021-10-24T17:34:01Z",
      "updated_at": "2021-08-21T09:28:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In the software industry, a tag typically refers to a piece of metadata added to a data set for the purpose of improving data organization and findability. At New Relic, our tags are key:value pairs (like team: operations) added to various sets of data, like monitored apps and hosts, agents, dashboards, and workloads. We make some important attributes available as tags (for example, app metadata like app name and language, and host metadata like host name and AWS region). You can also add your own custom tags. You can use tags in the UI to filter down to relevant data. Here is an example: Here you can see an accountId tag being used to filter workloads to a specific account. Tags help you to: Organize data coming from a large number of sources and/or to a large number of New Relic accounts. Identify teams, roles, environments, or regions to know whoâ€™s responsible for what (see example use cases). Better organize and search dashboards and workloads. Query and chart APM data. Tags are useful for organizing data at a high level. If you want to add more fine-grained detail, like capturing user names or other high-cardinality values, custom attributes or custom events are a better solution. Tip Tags were previously called labels in the New Relic UI. You may sometimes see labelin our code; for example, some of our APM agent config files use a label config option for tags. Tag format and limits Format requirements and limits for tags: The UI has limits on the total number of tags it can display per entity: Limit of 100 for tags reported by default or added via agent/integration configuration. Limit of 100 for custom tags added via UI or API. The following are maximum character length for tags: Key: 128 characters Value: 256 characters When using our API to add tags, a dash (-) in a tag key is interpreted as a minus symbol. If your tag key has a dash, use back ticks around it (like `key-name`). Best practices and tips Before adding tags, we recommend first seeing how our default tags work for you. When you're ready to add your own tags, review the following best practices tips to get the most out of them. Tips on keeping tags simple: Start by adding only tags you know youâ€™ll definitely use. Unused tags create noise and may add confusion. Try to use short tags. Shorter tags are easier to parse, and also the UI may sometimes truncate longer tags. (See character limits.) When possible, use keys and values that are human-readable (for example, region: EMEA is better than Param8323 : 1229072). Avoid including several values like regions: EMEA | US | LATAM in a single tag. We recommend using three different tags for that, like region: emea, region: us, and region: latam. If you want to match multiple tags, you can do that using the advanced options in the filter UI. Tips on using tags consistently: Try to be consistent with tag language across your teams and entities. Be consistent with naming. For example, avoid using both region: emea and reg: emea. Be consistent with format. For example, avoid using both camelCase and kebab-case. Although tag searching is not case-sensitive in the UI and API, try to be consistent with capitalization. For example, avoid using both env: staging and env: Staging. Tips on cross-team implementation: Tags help improve observability and cost allocation. For this reason, responsibility for tag implementation is often assigned to an observability team, SREs, a group of architects, or a cross-team task force. We recommend the people responsible for implementing tags meet and create an internal policy to describe how the tags are defined and which conventions are to be used. Then: Keep this reference manual up to date. Automate the definition of tags when you deploy New Relic agents, at the cloud provider, or through New Relic automation tools, such as the API or Terraform. Create recurring reports that identify entities that are non-compliant with your tagging standards. Tag examples Here are some examples of common ways to use tags to organize data: Team-related tags Creating tags for team names can be helpful to understand which team, group, department, or region was responsible for a change that led to a performance issue. Team examples: team: backend team: frontend team: db Role examples: roles: architecture roles: devops roles: pm Region examples: region: emea region: america region: asia Environment-related tags You can create entities for the environment they belong to. Examples: env: production env: qa env: development env: staging Criticality-related tags You can create tags related to criticality levels, which lets you easier track the most critical issues. Examples: layer: level1 layer: level2 layer: level3 How tags are added Some important attributes, by default, are available for use as tags. For example, the account name, the account ID, and some basic host/server metadata are available as default tags. You can't remove these available-by-default tags. Here are some details about how tags are added for some specific data sources: Add tags via UI or API When you add tags via the UI or API, this occurs at the entity level. This means that, for example, if you have multiple APM agents monitoring a single entity and apply a tag via the UI, that tag is available for all data coming from that entity. To add or delete tags via the UI: Select a monitored entity, like a monitored app or host. Near the entityâ€™s name at the top of the page, select the See metadata and manage tags menu. In the menu that pops up, add or delete a tag. For APM agents, restart your service. To manage tags via API: see our NerdGraph tagging docs. For a guide to using our CLI to automate tagging, see our developer site. APM agent tags You can add tags via the UI and API or you can add tags using APM agent configuration, both methods require you to restart your service. There are differences in how these apply tags: Via agent config: These tags are applied at the agent-level, not the entity/application level. This would be a good option if you have multiple agents monitoring different aspects of the same app (for example, a blue-green deployment model). Via the UI or API: These tags are applied at the entity/application level. Here are links to the agent configuration options: C SDK: not available Java Go .NET Node.js PHP Python Ruby For information on querying APM tags, see Query APM tags. Infrastructure data tags There are several ways tags are added to infrastructure entities and services: Use the UI or API to add tags at the entity level. Infrastructure agent: some attributes are available by default as tags. You can also add custom attributes, which are also available as tags in the UI. On-host integrations: some attributes are available by default as tags. You can also add tags by using integration-specific labels config options (for an example, see the labels config for the Apache integration). Cloud service integrations: by default we report tags and labels that are defined in the cloud service. To add tags, you'd add them on the cloud-service-side. Automate tags with our CLI For a guide to automating tags using our CLI tool, see our developer site. Use tags to filter the UI Use the filter field at the top of the New Relic Explorer to filter down to the entities you care about. You can use multiple filter conditions. To filter down to certain entities using tags: From one.newrelic.com, click Explorer. Click the Filter by... field to see a dropdown of available attributes and tags. You can filter by multiple elements and use advanced search options. To find an entityâ€™s metadata and tags from the UI, here are two options: From a list of entities in the UI, at the far right, select an entity's icon. OR Select an entity. Near the top of the page, select the icon. To use the API to view tags, see our NerdGraph docs. Learn about how to use tags with dashboards and how to use tags with workloads. Custom queries, charts, and alerts Different features handle tags differently. Here are some details about how you can use NRQL to query tag data, or create NRQL condition alerts. Query and alert on APM tags You can query APM tags using NRQL. Minimum agent versions: C: not available Go: 2.3.0 Java: 4.9.0 .NET: 8.17 Node: v4.13.0 PHP: not available Python: v4.10.0.112 Ruby: 6.1.0.352 Here are some query examples: Throughput across shards Given a service that is distributed across nine shards, each shard assigned as an environment, we can plot the transaction throughput on all shards using a wildcard query like: SELECT rate(count(apm.service.transaction.duration), 1 minute) FROM Metric WHERE appName LIKE 'MyApp (%' AND transactionType = 'Other' FACET tags.Environment TIMESERIES Copy Transactions per team To see the number of transactions per service for a specific team, we might use a query like: FROM Transaction SELECT count(*) WHERE tags.Team = 'team-a' FACET tags.Project TIMESERIES Copy Alert on error rate for teams You can use a query for your servicesâ€™ error rate for setting an alert without having to create a rule for each service. Here is the error rate for all services on a team called team-b. And this alert will automatically monitor any new app names added with the team tag. FROM Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Team = 'team-b' FACET appName Copy Related to this, you might create a general rule for a specific service deployed across several environments, so that we have an alarm for a single service monitoring each environment individually: From Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Project = 'MyProject' FACET tags.Environment Copy Query and alert on attributes As explained in the tag sources information, some important attributes are used as tags. You can query all attributes and create custom charts using NRQL, and create NRQL alert conditions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 219.98407,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Use</em> tags to help organize and find your data",
        "sections": "<em>Use</em> tags to help organize and find your data",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " to filter the UI <em>Use</em> the filter field at the top of the <em>New</em> <em>Relic</em> Explorer to filter down to the entities you care about. You can <em>use</em> multiple filter conditions. To filter down to certain entities using tags: From <em>one</em>.newrelic.com, click Explorer. Click the Filter by... field to see a dropdown"
      },
      "id": "603ebd1228ccbc6278eba754"
    },
    {
      "sections": [
        "New Relic Lookout: Monitor your estate at a glance",
        "Why it matters",
        "Requirements",
        "Get started with New Relic Lookout",
        "Circle visualization and table view",
        "Abnormal golden signals",
        "Instant search",
        "Change view",
        "Drill down into the details",
        "Performance tab",
        "Abnormal History tab",
        "Correlations tab",
        "Profile tab",
        "Traces tab",
        "Create a custom view",
        "Query: Compare the last 15 minutes to the same time 1 day ago",
        "Query: Compare a specific time range to the same range a month ago",
        "Example: Unusual increases in error count"
      ],
      "title": "New Relic Lookout: Monitor your estate at a glance",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "9193dcc8851c185ff5d96f6f93ab412bd1be69e9",
      "image": "https://docs.newrelic.com/static/178b37068bad2a68cff027c8bdcf663a/c1b63/lookout-intro.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-lookout-monitor-your-estate-glance/",
      "published_at": "2021-10-18T02:49:51Z",
      "updated_at": "2021-08-21T09:27:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Lookout provides visibility into your entire estate. It doesn't require any configuration â€” you can query anything in your estate that matters to you right now and understand your system as a whole, or dive deep into causes and effects, so you can quickly get the data you need to take action. Know exactly where to focus your attention with New Relic Lookout. The brighter the color, the more severe the change, and the bigger the size, the bigger the scale. Then dig deeper with correlations and abnormal history to see how it impacts your whole systemâ€”no configuration needed. Why it matters New Relic Lookout helps software teams of any size discover potential issues before they have an impact. Fill gaps in monitoring with full coverage out-of-the-box, no configuration or setup required. Immediately see anything deviating from normal across your entire estate. Proactively spot emerging problems in a real-time visualization of all system components. Gain faster incidents resolution through automatically surfaced causes and effects. Analyze any data in New Relic database (NRDB), including third-party, open, and custom data. Launch into other areas of New Relic One for deeper understanding Requirements New Relic Lookout requires Pro or Enterprise edition. If you are on Standard edition, you can still use the New Relic Lookout view in the New Relic Explorer. If you want to see data spanning 13-months, correlations, profiles, traces, and other details, you must upgrade to a higher edition. Get started with New Relic Lookout To access New Relic Lookout, click the Apps button in New Relic One and locate the New Relic Lookout launcher. You can also access New Relic Lookout directly from the New Relic One header bar, via the More dropdown. Enablement of key service performance indicator data is required for New Relic Lookout to provide value from the data you already have. The default view provides insight into three key Service performance indicators broken down by application: throughput, response time, and errors. These metrics are analyzed to show how the data has behaved during the last five minutes compared to the prior hour. one.newrelic.com > Apps > New Relic Lookout: Anything that significantly deviates from the trend is automatically discovered by New Relic Lookout, which doesn't require any configuration. Circle visualization and table view Each application (or other facet) is represented by a circle. The size of the circles indicate the magnitude of the signal for that application and the color indicates whether the value has significantly decreased or increased in the last five minutes, based on the standard deviation of the prior hour (default evaluation and comparison time windows.) Please note that the type of signal is important when interpreting your results. When you first look at the legend below, you might be tempted to interpret yellow as good and dark purple as bad, but that is not always the case. Here are some examples: In the APM/services golden signals, a dark yellow circle in Throughput might signify that something bad has occurred and led to a drop in traffic. At the same time, a dark purple circle might also be concerning due to unexpected load. Both are significant findings worth exploring. In browser golden signals, a dark purple circle in Page Views might be great, as you are seeing more traffic to your site! With errors golden signals (in all entity types), a large circle, even if gray (not deviating from normal volume), is worth exploring because a high count of errors in your system is important to investigate. The legend allows you to change the colors used to highlight deviating services To change the color palette, click the gear icon by the low-high color legend. This allows you to change the colors used to highlight deviating services. To get a table view of the same data, click the toggle on the right. You can also hover over each color to filter the view by degree lower or higher deviance. Abnormal golden signals On the right, New Relic Lookout displays the most significantly deviating applications (or other facet) in a side panel, weighted by both the magnitude of the performance indicators and the scale of their deviations. Details include the name of the key performance indicator, their magnitude during the recent time window, and the difference between the averages from one time compared to the other. Instant search Click the magnifying glass icon in the side panel to open a search box. Typing into the search box filters the circles, table, and abnormal signals to applications (or other facets) that contain the text. This is a good way to quickly zoom to various subsystems. New Relic Lookout doesn't rerun the analysis when using the instant search. Change view Click the Change View button on the right side panel. The panel that appears shows you all the entity-specific golden signals you can toggle between out of the box. By choosing the Browser Golden Signal or other views, you can change from the default view. Each new view will have the golden signals appropriate for that entity type. Drill down into the details To analyze an application or facet, click a circle, table row, or abnormal golden signal. The details panel shows the degree of deviation of the performance indicator, a link to the affected entity, and recent alert and deployment activity for that entity, when available. Thereâ€™s also an indication of whether the selected evaluation time period would be abnormal or not in reference to other comparison time windows, such as the same time yesterday or the same time last week. This allows you to quickly see if the abnormal behavior is odd in general, or just based on the comparison time window. Performance tab The default tab shows charts for other key performance indicators for the selected application or facet. The charts compare the two time windows being analyzed. You can click their titles to rerun the analysis, focusing on the selected key performance indicator. When the target is a New Relic One application, we show the top transactions, error classes, external services, and database operations, alongside links to the relevant New Relic One features. Abnormal History tab This section analyzes past performance of the selected signal and calls out any time periods with notable abnormalities. Each card represents an abnormal time window and can be clicked for more details. The charts will display any relevant violations and deployments in New Relic. Correlations tab New Relic Lookout can find other signals that began behaving differently around the same time as the selected signal for that entity type. Clicking the name of the signal reruns the analysis, focusing on that key performance indicator. The chart titles link to New Relic One when thereâ€™s an associated entity in your account. Note that correlations currently do not analyze across accounts. The correlated signals displayed are for others in the account of the original application you are viewing. This helps focus the data on correlations that are more likely related to your issue. Profile tab Based on the same technology as New Relicâ€™s error profiles, this tab compares the last five minutes to the prior hour by default (or whatever time windows youâ€™ve selected with query editing) and surfaces any attributes that have significantly different distributions in the events being targeted by the selected signal. For example, if a custom attribute indicated that a recent throughput spike came from one user, that would surface highly in Profiles if most of the traffic usually comes from many users. Traces tab If the entity has distributed traces configured and available in the selected evaluated time window, the Traces section is enabled. Each card shows a summary of a trace and can be clicked for details. The Explore all traces links to the distributed traces application, filtered to the selected entity. Create a custom view To target signals and time windows beyond the default values, click the Change view button and select Custom view. To create your own view: Select the account or subaccount. Select the data type (metrics or events). Different functionality is available depending on the type. In View a chart with, select the metric or event you are interested in. Default is golden signals (throughput, response time, and errors). You can also build custom queries (filters) to target a signal that isn't on the list. In Facet by, select what the circles represent. Default is appName, but you can also choose host or any other facetable attribute available for the signal youâ€™ve selected. If you plan to save/favorite this new view, provide a name in the Name your view box. Keep in mind that you can edit this view at any time using the pencil icon. The default time windows analyzed by New Relic Lookout are the last five minutes compared to the hour before. Use the time controls (View data from and Compare data to) to target other time windows. one.newrelic.com > Apps > New Relic Lookout: All event and metric data in the New Relic database can be queried using the Edit query feature. Click Analyze to begin analyzing the signal youâ€™ve selected. You can also create your own query: Create your query. This query is comparing data from the past thirty minutes to data from the same range a day ago. Change from Basic to Advanced after clicking the Custom view button. Select the data type (metrics or events). Different functionality is available depending on the type. Enter your query using NRQL. Please note that not all NRQL features are available in the Lookout Advanced query feature. By default, the system will run this query using the last five minutes of data compared to the previous hour. Some examples of the syntax for changing the comparison and evaluation time windows are below. Click Analyze to begin analyzing the signal youâ€™ve selected. Query: Compare the last 15 minutes to the same time 1 day ago Please note that the UNTIL NOW portion is required here unlike in standard NRQL. Without the UNTIL NOW added, the system will query a 5 minute slice of data starting 15 minutes ago SINCE 15 minutes AGO UNTIL NOW COMPARE WITH 1 day ago Copy Query: Compare a specific time range to the same range a month ago SINCE '2021-03-07 07:00:00-0500' UNTIL '2021-03-08 07:00:00-0500' COMPARE WITH 1 month ago Copy Or: SINCE 'today at midnight' UNTIL 'now' COMPARE WITH 1 MONTH AGO Copy Example: Unusual increases in error count The default view of New Relic Lookout shows application status across your estate, comparing the last five minutes to the hour before. Under regular operation, most large systems may have a handful of abnormalities, but usually most things will indicate normal behavior. Suddenly, several circles begin to change to red under the Errors section. This indicates that several applications are experiencing unusual increases in error count. It may be that one or two circles for important systems are red, and perhaps much larger than they usually appear. Clicking one of these can provide more information on what is happening. You might see that the error rate is substantially elevated, even thousands of percent higher than normal. To troubleshoot this issue, here's what you might discover in the New Relic Lookout tabs: Performance would show you data about other signals, illuminating the characteristics of the change in system dynamics. Correlations would surface other applications that are affected and how, as well as opportunities to pivot to other applications that may be closer to the underlying causes. Traces, in turn, would show distributed traces, which can provide specific examples of traffic running through those systems. Abnormal history would show other times in the past week with elevated errors, showing whether or not this problem happens regularly, such as every day at the same time or whenever there is a deployment. Profiles might show that all or most of the new errors share common properties, such as all being isolated to just one region/account/user. Combining the information from these sections, not only can you get a sense of what is going on, but also where to focus actions to resolve the problem.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 219.9838,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Lookout: Monitor your estate at a glance",
        "sections": "<em>New</em> <em>Relic</em> Lookout: Monitor your estate at a glance",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " emerging problems in a real-time visualization of all system components. Gain faster incidents resolution through automatically surfaced causes and effects. Analyze any data in <em>New</em> <em>Relic</em> database (NRDB), including third-party, open, and custom data. Launch into other areas of <em>New</em> <em>Relic</em> <em>One</em> for deeper"
      },
      "id": "603e821e64441f5a444e8845"
    }
  ],
  "/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one": [
    {
      "sections": [
        "New Relic Lookout: Monitor your estate at a glance",
        "Why it matters",
        "Requirements",
        "Get started with New Relic Lookout",
        "Circle visualization and table view",
        "Abnormal golden signals",
        "Instant search",
        "Change view",
        "Drill down into the details",
        "Performance tab",
        "Abnormal History tab",
        "Correlations tab",
        "Profile tab",
        "Traces tab",
        "Create a custom view",
        "Query: Compare the last 15 minutes to the same time 1 day ago",
        "Query: Compare a specific time range to the same range a month ago",
        "Example: Unusual increases in error count"
      ],
      "title": "New Relic Lookout: Monitor your estate at a glance",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "9193dcc8851c185ff5d96f6f93ab412bd1be69e9",
      "image": "https://docs.newrelic.com/static/178b37068bad2a68cff027c8bdcf663a/c1b63/lookout-intro.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-lookout-monitor-your-estate-glance/",
      "published_at": "2021-10-18T02:49:51Z",
      "updated_at": "2021-08-21T09:27:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Lookout provides visibility into your entire estate. It doesn't require any configuration â€” you can query anything in your estate that matters to you right now and understand your system as a whole, or dive deep into causes and effects, so you can quickly get the data you need to take action. Know exactly where to focus your attention with New Relic Lookout. The brighter the color, the more severe the change, and the bigger the size, the bigger the scale. Then dig deeper with correlations and abnormal history to see how it impacts your whole systemâ€”no configuration needed. Why it matters New Relic Lookout helps software teams of any size discover potential issues before they have an impact. Fill gaps in monitoring with full coverage out-of-the-box, no configuration or setup required. Immediately see anything deviating from normal across your entire estate. Proactively spot emerging problems in a real-time visualization of all system components. Gain faster incidents resolution through automatically surfaced causes and effects. Analyze any data in New Relic database (NRDB), including third-party, open, and custom data. Launch into other areas of New Relic One for deeper understanding Requirements New Relic Lookout requires Pro or Enterprise edition. If you are on Standard edition, you can still use the New Relic Lookout view in the New Relic Explorer. If you want to see data spanning 13-months, correlations, profiles, traces, and other details, you must upgrade to a higher edition. Get started with New Relic Lookout To access New Relic Lookout, click the Apps button in New Relic One and locate the New Relic Lookout launcher. You can also access New Relic Lookout directly from the New Relic One header bar, via the More dropdown. Enablement of key service performance indicator data is required for New Relic Lookout to provide value from the data you already have. The default view provides insight into three key Service performance indicators broken down by application: throughput, response time, and errors. These metrics are analyzed to show how the data has behaved during the last five minutes compared to the prior hour. one.newrelic.com > Apps > New Relic Lookout: Anything that significantly deviates from the trend is automatically discovered by New Relic Lookout, which doesn't require any configuration. Circle visualization and table view Each application (or other facet) is represented by a circle. The size of the circles indicate the magnitude of the signal for that application and the color indicates whether the value has significantly decreased or increased in the last five minutes, based on the standard deviation of the prior hour (default evaluation and comparison time windows.) Please note that the type of signal is important when interpreting your results. When you first look at the legend below, you might be tempted to interpret yellow as good and dark purple as bad, but that is not always the case. Here are some examples: In the APM/services golden signals, a dark yellow circle in Throughput might signify that something bad has occurred and led to a drop in traffic. At the same time, a dark purple circle might also be concerning due to unexpected load. Both are significant findings worth exploring. In browser golden signals, a dark purple circle in Page Views might be great, as you are seeing more traffic to your site! With errors golden signals (in all entity types), a large circle, even if gray (not deviating from normal volume), is worth exploring because a high count of errors in your system is important to investigate. The legend allows you to change the colors used to highlight deviating services To change the color palette, click the gear icon by the low-high color legend. This allows you to change the colors used to highlight deviating services. To get a table view of the same data, click the toggle on the right. You can also hover over each color to filter the view by degree lower or higher deviance. Abnormal golden signals On the right, New Relic Lookout displays the most significantly deviating applications (or other facet) in a side panel, weighted by both the magnitude of the performance indicators and the scale of their deviations. Details include the name of the key performance indicator, their magnitude during the recent time window, and the difference between the averages from one time compared to the other. Instant search Click the magnifying glass icon in the side panel to open a search box. Typing into the search box filters the circles, table, and abnormal signals to applications (or other facets) that contain the text. This is a good way to quickly zoom to various subsystems. New Relic Lookout doesn't rerun the analysis when using the instant search. Change view Click the Change View button on the right side panel. The panel that appears shows you all the entity-specific golden signals you can toggle between out of the box. By choosing the Browser Golden Signal or other views, you can change from the default view. Each new view will have the golden signals appropriate for that entity type. Drill down into the details To analyze an application or facet, click a circle, table row, or abnormal golden signal. The details panel shows the degree of deviation of the performance indicator, a link to the affected entity, and recent alert and deployment activity for that entity, when available. Thereâ€™s also an indication of whether the selected evaluation time period would be abnormal or not in reference to other comparison time windows, such as the same time yesterday or the same time last week. This allows you to quickly see if the abnormal behavior is odd in general, or just based on the comparison time window. Performance tab The default tab shows charts for other key performance indicators for the selected application or facet. The charts compare the two time windows being analyzed. You can click their titles to rerun the analysis, focusing on the selected key performance indicator. When the target is a New Relic One application, we show the top transactions, error classes, external services, and database operations, alongside links to the relevant New Relic One features. Abnormal History tab This section analyzes past performance of the selected signal and calls out any time periods with notable abnormalities. Each card represents an abnormal time window and can be clicked for more details. The charts will display any relevant violations and deployments in New Relic. Correlations tab New Relic Lookout can find other signals that began behaving differently around the same time as the selected signal for that entity type. Clicking the name of the signal reruns the analysis, focusing on that key performance indicator. The chart titles link to New Relic One when thereâ€™s an associated entity in your account. Note that correlations currently do not analyze across accounts. The correlated signals displayed are for others in the account of the original application you are viewing. This helps focus the data on correlations that are more likely related to your issue. Profile tab Based on the same technology as New Relicâ€™s error profiles, this tab compares the last five minutes to the prior hour by default (or whatever time windows youâ€™ve selected with query editing) and surfaces any attributes that have significantly different distributions in the events being targeted by the selected signal. For example, if a custom attribute indicated that a recent throughput spike came from one user, that would surface highly in Profiles if most of the traffic usually comes from many users. Traces tab If the entity has distributed traces configured and available in the selected evaluated time window, the Traces section is enabled. Each card shows a summary of a trace and can be clicked for details. The Explore all traces links to the distributed traces application, filtered to the selected entity. Create a custom view To target signals and time windows beyond the default values, click the Change view button and select Custom view. To create your own view: Select the account or subaccount. Select the data type (metrics or events). Different functionality is available depending on the type. In View a chart with, select the metric or event you are interested in. Default is golden signals (throughput, response time, and errors). You can also build custom queries (filters) to target a signal that isn't on the list. In Facet by, select what the circles represent. Default is appName, but you can also choose host or any other facetable attribute available for the signal youâ€™ve selected. If you plan to save/favorite this new view, provide a name in the Name your view box. Keep in mind that you can edit this view at any time using the pencil icon. The default time windows analyzed by New Relic Lookout are the last five minutes compared to the hour before. Use the time controls (View data from and Compare data to) to target other time windows. one.newrelic.com > Apps > New Relic Lookout: All event and metric data in the New Relic database can be queried using the Edit query feature. Click Analyze to begin analyzing the signal youâ€™ve selected. You can also create your own query: Create your query. This query is comparing data from the past thirty minutes to data from the same range a day ago. Change from Basic to Advanced after clicking the Custom view button. Select the data type (metrics or events). Different functionality is available depending on the type. Enter your query using NRQL. Please note that not all NRQL features are available in the Lookout Advanced query feature. By default, the system will run this query using the last five minutes of data compared to the previous hour. Some examples of the syntax for changing the comparison and evaluation time windows are below. Click Analyze to begin analyzing the signal youâ€™ve selected. Query: Compare the last 15 minutes to the same time 1 day ago Please note that the UNTIL NOW portion is required here unlike in standard NRQL. Without the UNTIL NOW added, the system will query a 5 minute slice of data starting 15 minutes ago SINCE 15 minutes AGO UNTIL NOW COMPARE WITH 1 day ago Copy Query: Compare a specific time range to the same range a month ago SINCE '2021-03-07 07:00:00-0500' UNTIL '2021-03-08 07:00:00-0500' COMPARE WITH 1 month ago Copy Or: SINCE 'today at midnight' UNTIL 'now' COMPARE WITH 1 MONTH AGO Copy Example: Unusual increases in error count The default view of New Relic Lookout shows application status across your estate, comparing the last five minutes to the hour before. Under regular operation, most large systems may have a handful of abnormalities, but usually most things will indicate normal behavior. Suddenly, several circles begin to change to red under the Errors section. This indicates that several applications are experiencing unusual increases in error count. It may be that one or two circles for important systems are red, and perhaps much larger than they usually appear. Clicking one of these can provide more information on what is happening. You might see that the error rate is substantially elevated, even thousands of percent higher than normal. To troubleshoot this issue, here's what you might discover in the New Relic Lookout tabs: Performance would show you data about other signals, illuminating the characteristics of the change in system dynamics. Correlations would surface other applications that are affected and how, as well as opportunities to pivot to other applications that may be closer to the underlying causes. Traces, in turn, would show distributed traces, which can provide specific examples of traffic running through those systems. Abnormal history would show other times in the past week with elevated errors, showing whether or not this problem happens regularly, such as every day at the same time or whenever there is a deployment. Profiles might show that all or most of the new errors share common properties, such as all being isolated to just one region/account/user. Combining the information from these sections, not only can you get a sense of what is going on, but also where to focus actions to resolve the problem.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 154.00587,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Lookout: Monitor your estate at a glance",
        "sections": "<em>Get</em> <em>started</em> with <em>New</em> <em>Relic</em> Lookout",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " to a higher edition. <em>Get</em> <em>started</em> with <em>New</em> <em>Relic</em> Lookout To access <em>New</em> <em>Relic</em> Lookout, click the Apps button in <em>New</em> <em>Relic</em> <em>One</em> and locate the <em>New</em> <em>Relic</em> Lookout launcher. You can also access <em>New</em> <em>Relic</em> Lookout directly from the <em>New</em> <em>Relic</em> <em>One</em> header bar, via the More dropdown. Enablement of key service"
      },
      "id": "603e821e64441f5a444e8845"
    },
    {
      "sections": [
        "What is an entity in New Relic?",
        "What's an entity?",
        "Find and explore entities and entity data",
        "Tip",
        "Group and organize entities",
        "Customize entity data with entity synthesis",
        "Reserved attributes for synthesized entities",
        "Entity relationships",
        "Important",
        "Which relationships are created?",
        "Source: New Relic agent",
        "Source: Infrastructure",
        "Source: Synthetics monitor",
        "Source: Kubernetes",
        "External services"
      ],
      "title": "What is an entity in New Relic?",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "52a3e08bc9103c717d27b153e4fd4f547d6ecc32",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-10-24T17:34:57Z",
      "updated_at": "2021-09-01T17:25:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic monitoring is built around the concept of entities. In this doc, you'll learn how we define entities, what you can do with them, and how you can create your own entities or groupings of entities. What's an entity? From a New Relic perspective, entity is purposefully a broad concept. An entity is anything that a) reports data to New Relic or that contains data that we have access to, and b) is something we've identified with a unique entity ID. For most entities, the ID is indicated by the attribute entityGuid. An entity can be any fundamental data-reporting component, like an application, a host, or a database service, but it can also refer to larger groupings of those components. For example, to monitor a data center, you could aggregate those hosts in New Relic to be a workload (a custom grouping of entities). That workload is, itself, also an entity. Also very important is the relationships between entities. Our behind-the-scenes relationship-mapping helps us understand how entities are connected, how they affect each other. And this allows us to give you the power to configure how any data you're bringing in is related to existing entities, or how it's related to other entities. Our focus on entities and their relationships is important because our goal is to give you practical information about your business-important entities, and not give you an unhelpfully huge stream of data from a huge list of monitored things. With more insight at the entity level, you can better monitor and troubleshoot complex, modern systems. Find and explore entities and entity data Tip You can create new entity types for monitoring any data source. Learn more about entity synthesis. Some tips for finding and understanding entity data: To find an entity's entityGuid and entityName and other metadata: from any list of monitored entities in the New Relic Explorer, click an entity's icon, and click See metadata and tags. For most entities, its GUID is reported as the attribute entityGuid. For workloads, it's workloadGuid. You can run NRQL queries to find entities by their GUID. To see connections between entities, you have several options: When viewing an entity in the UI, use the Related entities UI. Service maps. Distributed tracing. Our NerdGraph API. To group entities together, see Group entities. Customize entity definitions and relationships. To learn technical details about entity types, see our GitHub repo. In an entity type's definition file, you'll see information like: The domain: for example, APM, or Infra. Its type: for example, Application or AWSECSCONTAINERINSTANCE. Default tags. The entityExpirationTime: how long data from that entity lasts in the UI, which is different from database data retention. Group and organize entities You can place entities into groups that reflect business-important relationships in your organization. For example, you might group all entities related to a specific team or department, or related to a specific service. Or you might group multiple hosts together to reflect their grouping in a data center. To group your entities, see: Tag entities. Create workloads, which allow you to group business-important sets of entities. Create entities and customize entity data Customize entity data with entity synthesis If you have telemetry from any source that's not supported by New Relic out of the box, you can propose a mapping for it. Once approved, any telemetry received by New Relic that matches your definition file will be synthesized into an entity. To learn more: For reserved attributes and how entity relationships are defined, keep reading this doc. For how to do the work of modifying existing entity types or creating new ones, see our GitHub repo on entity synthesis. Reserved attributes for synthesized entities These attributes are meant to be synthesized from the telemetry we receive. Do not set them unless you're aware of the implications and consequences. Attribute Description entity.guid Generally, you should not set this attribute field on your telemetry data. New Relic may add this field to ingested data to store a unique identifier for the entity associated with the data point. If telemetry arrives with the entity.guid attribute already present, then New Relic will not change the value. However, it may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. One use case for passing this attribute is to associate ingested telemetry with an entity already created by New Relic. When the entity.guid attribute is sent, the value will override New Relicâ€™s entity identification system (such as entity synthesis definitions) and instead will use the attribute as the data. entity.name This attribute shouldn't be put on ingested telemetry data unless you're trying to override the entity name that would have been selected by New Relicâ€™s entity identification system. While New Relic won't change the value if it's already present on the data, New Relic may add the attribute to your data. Therefore invalid or unexpected values may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. If this field is present on ingested telemetry, its value will be used to name the entity associated with the data point. This name will be used instead of the name selected by New Relicâ€™s entity identification system (for example, entity synthesis definitions). Note that many entities use the name as part of their identification, so changing this field may result in the generation of a new entity. entity.type This attribute shouldn't be put on ingested telemetry data except for certain legacy cases where it's required to distinguish entity types. Passing this field may interfere with entity detection, particularly if unrecognized values are sent in this field. While New Relic won't change the value if already present on the data, the field is not guaranteed to provide unambiguous filtering of telemetry at query-time. Existing entity definitions already have overlapping values, and we recommend avoiding entity.type in favor of other fields for filtering telemetry queries. This field is used by New Relic, meaning that invalid or unexpected values may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. To learn how to do the work of modifying existing entity types or creating new ones, see our GitHub repo on entity synthesis. Entity relationships Connections between entities are automatically created by New Relic based on what we can infer from your telemetry. For example, when two services that communicate using HTTP are instrumented with New Relic, we infer a \"calls/called-by\" relationship between them. When viewing a specific entity in either the New Relic Explorer, Navigator, or Lookout, you can see its Related entities in the entity's mini overview. This gives a visualization of the various entities connected directly to the current entity. You can quickly view important metrics for these related entities and navigate from one entity to another, through all the connected parts of your stack. Tip Learn more about how entities are related with our NerdGraph API. When relationships are not automatically detected, you can manually create them using the \"Add/edit related entities\" link in Related entities. Important Currently, you can only manually create calls/called-by relationships between service entities. Tip To manage manual relationships, you need to have modify and delete capabilities on entity relationships. If you donâ€™t see the edit relationships button, contact your account admin. Which relationships are created? These are the relationships created between entities: Source: New Relic agent Relationship source Relationship type Relationship target Why is the relationship created? Application instrumented with a New Relic agent CALLS Application instrumented with a New Relic agent Relationships between applications monitored by New Relic agents are reported using the DurationByCaller metric. The callee reports the metric. For example, the metric DurationByCaller/Mobile/100/1234/HTTP/all indicates that the caller is APPLICATION 1234 for account 100. Application instrumented with a New Relic agent CALLS Service instrumented with a New Relic agent An application (caller) that calls a service (callee) monitored by New Relic creates a relationship that's reported by the caller using the ExternalApp metric. For example, the metric ExternalApp/dirac.vips.net/100#1234/all indicates that the callee is APPLICATION 1234 for account 100. The metric is reported if the callee successfully responds to the caller. Service instrumented with a New Relic agent CALLS Service instrumented with a New Relic agent When a New Relic agent detects that a service (caller) calls another service (callee) instrumented by New Relic, the callee reports the metric ClientApplication. For example, the metric ClientApplication/100#1234/all indicates that the caller is APPLICATION 1234 for account 100. Service instrumented with a New Relic agent CALLS A datastore instance When an application calls a datastore instance it creates a relationship reported with the DatastoreInstance metric. For example, the metric Datastore/instance/MySQL/172.16.16.3/3306 indicates the datastore instance is vendor: MySQL, host: 172.16.16.3, port: 3306. This metric also supports the legacy datastore instance format Datastore/instance/MySQL/172.16.16.3:3306. Currently we cannot determine whether the datastore instance is instrumented by New Relic and has an entity associated to it. APM agent SERVES Browser agent This relationship is created when an APM agent injects the browser agent into a page. Workload entity CONTAINS Any entity When a workload is created or updated, relationships for each of the entities that belong to the workload are created. Because some workloads are â€œdynamicâ€ (defined by tags), relationships are re-created every 5 minutes. This way entities can join or leave the workload. Source: Infrastructure Relationship source Relationship type Relationship target Why is the relationship created? Infrastructure host HOSTS Application This relationship is created when an application is running in one or more hosts, and the infra agent is running in those hosts. Infrastructure host HOSTS Container This relationship is created when containers are running in one or more hosts, and the host is instrumented with the infra agent. Source: Synthetics monitor Relationship source Relationship type Relationship target Why is the relationship created? Synthetics Monitor CALLS Browser agent This relationship is created when a synthetics monitor checks a page instrumented with the browser agent. Synthetics Monitor CALLS APM application Agent events that contain the attribute nr.syntheticsMonitorId have been described as synthetics monitors (the source) interacting with an APM application (the target). If the header exists and the APM application Id exists, a relationship is created between the monitor and the app. Source: Kubernetes Relationship source Relationship type Relationship target Why is the relationship created? Cluster CONTAINS Pod This relationship is created when a pod is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS Deployment This relationship is created when a deployment is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS DaemonSet This relationship is created when a DaemonSet is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS StatefulSet This relationship is created when a StatefulSet is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS Host This relationship is created when a host that's part of a cluster is instrumented with the New Relic Kubernetes integration. Deployment CONTAINS Pod This relationship is created when a deployment creates a pod in a cluster instrumented with the New Relic Kubernetes integration. DaemonSet CONTAINS Pod This relationship is created when a DaemonSet is created a pod in a cluster instrumented with the New Relic Kubernetes integration. StatefulSet CONTAINS Pod This relationship is created when a StatefulSet creates a pod in a cluster instrumented with the New Relic Kubernetes integration. Pod CONTAINS Container This relationship is created when a pod creates a container in a cluster instrumented with the New Relic Kubernetes integration. Host HOSTS Pod This relationship is created when a pod is running in a host that's part of a cluster instrumented with the New Relic Kubernetes integration. Container HOSTS Application This relationship is created when an application is running in docker, and the hosts where docker is running are instrumented by the the infra agent. External services Relationship source Relationship type Relationship target Why is the relationship created? External service CALLS External service When the relationship is created, the external service reports a span with its name on the service.name attribute and the name of the service that initiates the call in the parent.service.name attribute. Application IS External service A relationship between an application and an external service is created so that users can navigate between them using the related entities component. Browser application instrumented with a New Relic agent CALLS External service A browser application reports an Ajax/HostTransaction metric when calling an external service (URL). Example metric: Ajax/HostTransaction/api.segment.io:443/CallbackTime' Cluster CONTAINS External service When the relationship is created, the external service reports a span with the attribute k8s.cluster.name, the name of the cluster. The cluster must be instrumented with the New Relic Kubernetes integration and the cluster name set for the integration must match the one reported in the span. Pod HOSTS External service When the relationship is created, the external service reports a span with the following attributes: service.name: The name of the service. k8s.cluster.name: The name of the cluster. k8s.pod.name: The name of the pod thatâ€™s running the service. k8s.namespace.name: The namespace where the pod was created. The cluster must be instrumented with the New Relic Kubernetes integration and the cluster name set for the integration must match the one reported in the span.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 151.3515,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "What is an entity in <em>New</em> <em>Relic</em>?",
        "sections": "What is an entity in <em>New</em> <em>Relic</em>?",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": ". If telemetry arrives with the entity.guid attribute already present, then <em>New</em> <em>Relic</em> will not change the value. However, it may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. <em>One</em> <em>use</em> case for passing this attribute is to associate"
      },
      "id": "603ec160e7b9d295f72a07fc"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "New Relic One: a programmable platform",
        "Tip"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-10-24T16:39:15Z",
      "updated_at": "2021-07-27T13:37:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that canâ€™t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Hereâ€™s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic's browser monitoring. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 148.62157,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " a <em>New</em> <em>Relic</em>-monitored entity or data from another service or API. <em>Get</em> <em>started</em> Keep reading to learn more about what you can do with <em>New</em> <em>Relic</em> <em>One</em> apps. If you want to <em>get</em> <em>started</em> building quickly, first read the requirements. <em>New</em> <em>Relic</em> <em>One</em>: a programmable platform We strive to have an automated user"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    }
  ],
  "/docs/new-relic-one/use-new-relic-one/ui-data/automaps": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/whats-new/2021/10/nr1-automap/",
      "sections": [
        "Get a visual map of related entities with New Relic One Automap"
      ],
      "published_at": "2021-10-24T23:14:08Z",
      "title": "Get a visual map of related entities with New Relic One Automap",
      "updated_at": "2021-10-24T23:14:07Z",
      "type": "docs",
      "external_id": "4b8bc363a4ce4508e7ac829bc190ac09d5615ebe",
      "document_type": "nr1_announcement",
      "popularity": 1,
      "body": "To resolve issues affecting a cluster of services in your architecture, you need to identify both where AND when issues originate. Today, with New Relic One Automap, you can. When selecting a service, you can locate Automap in the Related entities section of the slide-out panel. Click the Map view button. Then, using Automap Timewarp, you can step backward in time and understand how the issue propagated through the architecture and track the issue back to where and when it all started. Check out the documentation to learn more.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 273.20557,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get a visual map of related <em>entities</em> with New Relic One <em>Automap</em>",
        "sections": "Get a visual map of related <em>entities</em> with New Relic One <em>Automap</em>",
        "body": "To resolve issues affecting a cluster of services in your architecture, you need to identify both where AND when issues originate. Today, with New Relic One <em>Automap</em>, you can. When selecting a service, you can locate <em>Automap</em> in the Related <em>entities</em> section of the slide-out panel. Click the Map view"
      },
      "id": "616c097a28ccbc6387002225"
    },
    {
      "sections": [
        "Introduction to service maps",
        "Tip",
        "Access service maps",
        "Identify operational issues"
      ],
      "title": "Introduction to service maps",
      "type": "docs",
      "tags": [
        "Understand dependencies",
        "Understand system dependencies",
        "Service maps"
      ],
      "external_id": "aca003c282581d2ec459e9584199739e40b0d04e",
      "image": "https://docs.newrelic.com/static/89460254fa31376b446585fb72b476a1/c1b63/NR1_service_maps.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/service-maps/introduction-service-maps/",
      "published_at": "2021-10-24T13:07:15Z",
      "updated_at": "2021-10-24T01:51:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Service maps are visual, customizable representations of your architecture. Maps automatically show your app's connections and dependencies, including applications, databases, hosts, servers, and out-of-process services. Tip In the New Relic UI, your out-of-process services are referred to as web external or background external data. Health indicators and performance metrics show you the current operational status for every part of your architecture. Service maps help you: Understand how apps and services in your architecture connect and communicate. Quickly see the current health and operational state of your entire environment. Troubleshoot operational issues and understand the impact of problems down to the host and instance level. Collaborate and drive shared understanding of an architecture. Access service maps Two options are available in New Relic One: the current service maps and the legacy APM service maps. To access the different service maps: Type To view maps Purpose Current service maps Go to one.newrelic.com > Explorer > (select an entity) > Monitor > Service map Service maps give you increased access to all the entities across your accounts, and help you understand how your entire environment is connected. Legacy APM service maps Go to one.newrelic.com > More > Service maps Legacy APM service maps let you create, customize, and share maps related to an individual app. Identify operational issues Service maps are color-coded to provide a quick look at the current status of your environment. Select nodes on a map to view additional performance metrics, and a full list and health check of each node's connections. The map automatically connects nodes into the map, so you can see which apps on the map connect to others. This helps you troubleshoot and assess the impact of a performance problem between a calling application and a specific database. With service maps, you can view your service and its status in the context of its up and downstream dependencies. Use maps in New Relic One to identify the root cause when troubleshooting an incident. Check out How to use service maps for details about these topics: View all your entities without any setup: most entities are automatically connected to their dependencies in service maps. View entities all across your organization's accounts. Add a map to a dashboard. one.newrelic.com > Explorer > (select an entity) > Monitor > Service map: Service maps show your dependencies and how they're performing.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.74944,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " and operational state of your entire environment. <em>Troubleshoot</em> operational issues and understand the impact of problems down to the host and instance level. Collaborate and drive shared understanding of an architecture. Access service maps Two options are available in New Relic One: the current service maps"
      },
      "id": "60450348e7b9d26e905799d4"
    },
    {
      "sections": [
        "How to use service maps",
        "Requirements",
        "Minimum versions when distributed tracing is enabled",
        "Minimum versions when distributed tracing is NOT enabled",
        "Add or remove connections to an entity",
        "Color coded for alerts",
        "Understand dependencies using API",
        "Externals and databases in maps",
        "Missing nodes"
      ],
      "title": "How to use service maps",
      "type": "docs",
      "tags": [
        "Understand dependencies",
        "Understand system dependencies",
        "Service maps"
      ],
      "external_id": "34d576d70a4393eea903e46c6dc9297303f821eb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/service-maps/how-use-service-maps/",
      "published_at": "2021-10-24T13:02:13Z",
      "updated_at": "2021-10-24T01:51:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here is information about how to use the current service maps feature. For help using the earlier service maps feature, see Legacy APM service maps. Service maps helps you visualize dependencies quickly and easily across your environment. They help you see how all your entities work together across your system. You can use service maps to troubleshoot problems, see how your environment works together, and ensure that issues donâ€™t have downstream repercussions. Service maps also supports cross-account access so help you see relationships between entities for all your accounts. Requirements Service maps work with distributed tracing to connect relationships between entities. Service maps are still functional if you have not enabled distributed tracing, but we recommend having distributed tracing enabled for all agents. This ensures a more consistent experience while using service maps. For best results, update existing agents to the latest version. The required minimum agent versions for maps are: Minimum versions when distributed tracing is enabled The required minimum agent versions for maps using distributed tracing are: C SDK 1.1.0 or higher Go agent 2.1.0 or higher Java agent 4.3.0 or higher .NET agent 8.6.45.0 or higher Node.js agent 4.7.0 or higher PHP agent 8.4 or higher Python agent 4.2.0.100 or higher Ruby agent 5.3.0.346 or higher Minimum versions when distributed tracing is NOT enabled The minimum version requirements for maps not using distributed tracing are: C SDK: not available Go 1.11 or higher Java 3.9.0 or higher .NET 4.2 or higher Node.js 2.0.0 or higher PHP 4.19.0 or higher Python 2.38.0.31 or higher Ruby 4.3.0 or higher Add or remove connections to an entity To view service maps, from one.newrelic.com click Explorer. Once you select an entity to view, you can select service maps from the sidebar. The map shows your upstream and downstream services: entities toward the left are upstream, entities toward the right are downstream. To add or remove connections to an entity: Hover over the entity in the map that you want to alter. Click add or remove more connections. In the connection list, keep boxes checked for the entities that you want to appear in the map. Unchecked entities will be removed from the map. Color coded for alerts Each entity in a map displays a color dependent on its performance. Green: there are currently no violations for this entities performance. Yellow: there is an open warning violation for this entity. Red: there is an open critical violation for this entity. Gray: no alert conditions have been set for the entity White: agent not reporting. This means that the agent installed on the entity is not reporting any data. This is expected behavior for databases or externals. Understand dependencies using API You can discover the same relationship connections available in service maps with NerdGraph. For more information and examples, see the NerdGraph GraphiQL relationships API tutorial. Externals and databases in maps In the New Relic UI, your out-of-process services are referred to as web external or background external data. Externals and databases have slightly different features in service maps than other entity types: Unlike other entities that appear in service maps, externals are aggregates. Clicking on an external service in the map shows you the list of all the external services that are rolled up into the one external entity. This is to reduce map clutter, as some entities can have dozens of externals being reported. Databases are agentless. Because of this, alerts cannot be set for the database, as only see the service call is reported to New Relic. Missing nodes If you are unable to view certain entities in New Relic One service maps, see Troubleshooting: Missing or obfuscated data in New Relic One.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.662704,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add or remove connections to an <em>entity</em>",
        "body": " your system. You can use service maps to <em>troubleshoot</em> problems, see how your environment works together, and ensure that issues donâ€™t have downstream repercussions. Service maps also supports cross-account access so help you see relationships between <em>entities</em> for all your accounts. Requirements"
      },
      "id": "603ec23264441fb02c4e8893"
    }
  ],
  "/docs/new-relic-one/use-new-relic-one/ui-data/basic-ui-features": [
    {
      "sections": [
        "Introduction to New Relic One",
        "Tip",
        "Quickly understand context",
        "Query your data more easily",
        "Enhanced dashboards",
        "Build on New Relic One",
        "Whatâ€™s next?"
      ],
      "title": "Introduction to New Relic One",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "c9ba93c83a579625a4ba3364c6046f3c475cba3a",
      "image": "https://docs.newrelic.com/static/2bc08b6d64c16b39697bb43d8e66870e/c1b63/nrone20210722.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-10-24T17:36:54Z",
      "updated_at": "2021-10-24T17:36:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic One is the platform that gives you access to core platform capabilities like querying data and building charts, our more curated observability UI experiences features, and our alerting and Applied Intelligence tools. With New Relic One, you can see and act on all the data throughout your entire system. To access New Relic One: Go to one.newrelic.com. Or, if you report data to the EU data center go to one.eu.newrelic.com. Tip Learn more about New Relic Oneâ€™s basic UI features. Quickly understand context We provide multiple ways to understand your system's dependencies, so you can easily see how everything fits together and troubleshoot problems. New Relic One gives you and your teams a connected view that cuts through complexity! If you want to... Use this Have an overall view of your system, and drill down to get performance details. Use the New Relic Explorer as the front door to New Relic One: observe, group, and filter the performance data from all the entities (that is, all applications, services, hosts, or containers) in your system. Gain extensive visibility into each entity in your solution, its alert status, and how the entities are connected. Use the New Relic Navigator to give you a high density overview of all your entities so you can detect any issues at a glance. And use the New Relic Lookout to spot entities recently experiencing behavior deviations. Provide context for your entities. Add tags to all your entities. Or create tags for teams and all the services they monitor. Use tags to illustrate relationships and contextual information for what you monitor. By thoughtfully tagging your entities, you can connect all the data your teams need to understand their increasingly complex and interdependent systems. See how each part of your system is connected. Service maps illustrate your upstream and downstream dependencies. Visualize the aggregated health and activity data from all you monitor. Group and monitor any entities together into functional team-focused, project-focused groupings, or any other attribute, with workloads. Fetch and analyze specific data. Get more context while you query with the query builder, which surfaces data definitions as you craft and edit queries. Create visuals that showcase your business needs at a glance. Tailor custom dashboards for your unique needs. Find a service or dashboard in a complex environment. Search by name across all accounts in the unified search, or filter the explorer by tags or text. View everything youâ€™re monitoring in one place, like entities or dashboards across your organization. View a list of all the dependencies for a service. The dependencies view tab in an entity summary shows all the dependencies of the entity youâ€™re viewing. Track activity as it moves across your distributed system. Distributed tracing helps you analyze your modern environment. Understand how everything is connected via API. The NerdGraph GraphiQL explorer manages all your entities, tags, and relationships. Query your data more easily On the Browse data menu on the top navigation menu you can easily access your basic telemetry data (metrics, events, logs, and traces). Wherever you go in the UI, Query your data is available. No matter your level of proficiency with our query language, you can create custom queries and charts: Browse your data in a query-less experience with our data explorer. Use your NRQL (our query language) expertise to build custom charts in the query builder. Run PromQL-style queries in the query builder. one.newrelic.com > Query your data: Build NRQL and PROMQL-like queries. Enhanced dashboards one.newrelic.com > Dashboards: Quickly create information dense custom views into the data that matters most to you with dashboards in New Relic One. New Relic One dashboards let you build better visualizations more easily, with more options to customize. Dashboard features include: Perform NRQL queries and create charts and dashboards everywhere in the platform using the query builder. Manage your charts and dashboards easily using our quick-access CRUD menus and editing options. Explore and contextualize data with advanced tooltips and zoom in functions to monitor what your systems are doing in real time. Search your dashboards for attributes and metrics. Send data to your dashboards using our agents, integrations, and APIs. Share dashboards or charts as a .pdf, or embed a chart in an external site. Tip If you previously used New Relic Insights to create dashboards, these are available as New Relic One dashboards. Build on New Relic One If custom charts and dashboards don't solve your current challenge, we give you a framework for building React JavaScript applications that: Live on New Relic One, alongside your other New Relic-monitored data. Feature highly tailored visualizations. Display data from any source you want, whether from a New Relic-monitored entity or data from any service or API. And you can use open source apps built by the community, and contribute your own open source apps. To learn more, see New Relic One applications. Whatâ€™s next? To get started understanding how to get around in New Relic One: See what data you have available with the data explorer. Browse your monitored entities with the New Relic Explorer. Use our NerdGraph API to add tags to your data. Learn about dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 333.71106,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "sections": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> is the platform that gives you access to core platform capabilities like querying <em>data</em> and building charts, our more curated observability <em>UI</em> experiences features, and our alerting and Applied Intelligence tools. With <em>New</em> <em>Relic</em> <em>One</em>, you can see and act on all the <em>data</em> throughout your"
      },
      "id": "603ec19164441f9e704e8896"
    },
    {
      "sections": [
        "Dependencies UI: View an entity's upstream and downstream dependencies",
        "Requirements",
        "View dependencies"
      ],
      "title": "Dependencies UI: View an entity's upstream and downstream dependencies",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "2b2f328a6281bb155bcde07efec7f42eae943048",
      "image": "https://docs.newrelic.com/static/aabc5f64a91cc01b6e226df53c62458f/c1b63/new-relic-one-dependencies-UI.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/explore-downstream-dependencies-new-relic-one/",
      "published_at": "2021-10-18T06:29:36Z",
      "updated_at": "2021-08-21T09:29:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In the New Relic Explorer, an entity's Dependencies page shows a filterable list of all the applications, services, databases, and hosts connected to the entity. It shows upstream and downstream dependencies, and provides paths to explore them. Similar to service maps, the dependencies page helps you understand how all of your upstream and downstream services are connected. It also uses the same color coding system used by service maps to show you what's performing well and what isn't. Requirements To view an entity's dependencies, make sure your app uses the minimum required APM agent version: C 1.0.0 or higher Go 1.11 or higher Java 3.9.0 or higher .NET 4.2 or higher Node.js 2.0.0 or higher PHP 4.19.0 or higher Python 2.38.0.31 or higher Ruby 4.3.0 or higher View dependencies To view dependencies for applications, services, databases, and hosts connected to an entity: Go to one.newrelic.com, select Explorer, and select an entity. Select Dependencies. To drill down further, filter the apps, services, databases, or hosts. one.newrelic.com > Explorer > (select an entity) > Dependencies: View a filterable list of all the apps, services, databases, and hosts connected to an entity, and their color-coded health status. You can filter the dependencies page to view specific things that report to the entity. Dependencies include: Services: APM-monitored applications and services. Mobile applications: your mobile apps. Browser applications: your front-end browser apps. External services: external services monitored by APM. External services include out-of-process services such as web services, resources in the cloud, and any other network calls. Databases: your application's database and cache data. Databases are agentless. Because of this, alerts cannot be set for the database, as only the service call is reported to New Relic. Hosts: your infrastructure (servers and hosts).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 214.0389,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Dependencies <em>UI</em>: View an entity&#x27;s upstream <em>and</em> downstream dependencies",
        "sections": "Dependencies <em>UI</em>: View an entity&#x27;s upstream <em>and</em> downstream dependencies",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " services: external services monitored by APM. External services include out-of-process services such as web services, resources in the cloud, and any other network calls. Databases: your application&#x27;s database and cache <em>data</em>. Databases are agentless. Because of this, alerts cannot be set for the database, as only the service call is reported to <em>New</em> <em>Relic</em>. Hosts: your infrastructure (servers and hosts)."
      },
      "id": "603eb2e564441f0fe44e889b"
    },
    {
      "sections": [
        "New Relic feature end of life announcements July 2020",
        "Old Kubernetes integration agent versions",
        "Monitor listing page and Synthetic labels",
        "\"Rollup by\" in Synthetics",
        "Embedded charts",
        "Legacy distributed tracing UI",
        "Violations changes",
        "Connected agents page",
        "Inactive apps in New Relic One",
        "Synthetic monitor alert notifications and conditions"
      ],
      "title": "New Relic feature end of life announcements July 2020",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "1db1d6b3df6d5ac3b983f78f3264cab332cff05a",
      "image": "https://docs.newrelic.com/static/f2b139d12bd8cdc13a9907b7874a4452/0a867/nrone-embed-bb062520.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/new-relic-feature-end-life-announcements-july-2020/",
      "published_at": "2021-10-24T15:50:03Z",
      "updated_at": "2021-07-22T05:05:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In order to improve your New Relic experience we've made some big improvements to our platform. As a result, we'll be ending support for some old features over the next few weeks. Many have already been publicly announced as \"end-of-life.\" These changes represent our commitment to improve your interactions with our platform. Our mission is one observability platform that unites your telemetry data, connects your full stack, and helps you build more perfect software. To that end we're focusing on simplifying your experience for troubleshooting, alerting, and visualizing data. Here are more details on what's changed, with some helpful links and guides on how to take advantage of new capabilities to achieve the same goals. As always, we're here to help. Please connect with us in the Explorers Hub, or contact your account team with any questions. Old Kubernetes integration agent versions To improve our unified experience, starting from Wednesday, August 12, 2020, Kubernetes integrations that use v1.7 or older will be deprecated. The UI experience in the infrastructure.newrelic.com domain will no longer be available; it will only be available in New Relic One. If you are already using the latest Kubernetes agent version, no action is necessary. If you are using v1.7 or older, you must update your integration in order to continue viewing Kubernetes performance data. Follow the instructions in our documentation to upgrade to the latest version of the Kubernetes integration. Action items for a successful transition: Review the Kubernetes agent deprecation notice. Follow standard procedures to upgrade your Kubernetes agent to the latest version. Learn about the Kubernetes cluster explorer UI in New Relic One. For more information, see the Explorers Hub post. Monitor listing page and Synthetic labels To improve the experience of Synthetic monitors and labels, we've moved both experiences into the New Relic One platform. If you use the REST API for Synthetic label management, you must update to the tags API moving forward. The good news: with the NerdGraph tags API, you can organize and group all your entities in a single request. For more information about any of the following, see the Explorers Hub post. Action items for a successful transition: Synthetic monitors transition Comments Monitor index list When migration is completed, no action is needed on your part to use the new Synthetics entity listing pages. The new experience will be available to you automatically after July 20, 2020. For more information, learn how the explorer in New Relic One replaces the Synthetics monitors index. Existing Synthetics labels You may have already seen an option in the UI to migrate your Synthetics monitor labels to New Relic One tags. If you did not select that option, we've got you covered. Automatic migration from labels to tags starts begins July 8, 2020. For more information, learn how tagging in New Relic One replaces labels for Synthetics monitors. REST API If you use the REST API for Synthetics label management, follow these steps to update to the tags API: Learn more about NerdGraph. Review the NerdGraph tagging API tutorial. Make sure you have a Personal API key to use NerdGraph. Follow the procedures in the Explorers Hub post (look for the How do I transition my scripts from the Synthetics API to the tag API (NerdGraph)? section), and update your existing tags with the GraphiQL explorer at api.newrelic.com/graphiql. NerdGraph is our GraphQL API, a query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph calls get all the data you need in a single request. NerdGraph also makes it easier to evolve APIs over time. \"Rollup by\" in Synthetics Synthetics is moving to New Relic One to provide a single platform for observability of your complex software systems. To do this we are unifying the tools you use to tag (or label) your services, applications, and monitors. The specific feature that is end-of-life is the Rollup by feature under the Search monitors dropdown menu. You can group monitors by tags in New Relic One without needing a separate Rollup by dropdown. No changes will be required to use the new Synthetic monitor listing pages. The new experiences will be available to you after July 20, 2020. Documentation: Tagging in New Relic One replaces labels for Synthetics monitors. Explorer in New Relic One replaces Synthetics monitors index. Action items for a successful transition: If you currently use Synthetics rollups: Follow the procedures in the Explorer Hub post to recreate the rollups that are being retired. Go to the Explorers Hub post about the rollups EOL. In particular, look for How can New Relic Workloads help me visualize groups of applications and monitors? in the post's FAQs section. Follow the procedures in the Explorers Hub post to recreate the rollups that are being retired. Embedded charts In order to reduce redundancy and provide a more unified experience, the embedded charts functionality will be replaced by the New Relic One Get chart. Embedded charts currently in use and hosted outside the New Relic domain will continue to function. The changes will include: The name on the chart's menu that generates them will change from Embed to Get chart link. For charts that are no longer supported, Embed will be replaced with Get chart link is not supported for this chart. The APM UI page that lists all embedded chart links will no longer be available. Documentation: Explorers Hub post New Relic One's enhanced query builder functionality replaces the EOL embed chart functionality. Action items for a successful transition: You can generate a publicly accessible link to add to internal and external websites. Users do not need to be logged in to New Relic to see the chart link. The ability to embed a chart will remain, but instead of clicking Embed (which will be removed from the UI), you will click Get chart link (which is in the same location). This gives you the ability to get links with an even broader range of chart visuals and behaviors than the one we are retiring. Here's an example of how it looks in New Relic One: To replace existing chart links you created with Embed, create new URLs with New Relic One's Get chart link, and insert them in webpages where they're used. If you have an embedded chart and get the message Get chart link is not supported for this chart, simply run a different query, select an available chart type, and then select Embed. Legacy distributed tracing UI To standardize our user experience, we will be deprecating the older distributed tracing UI, which exists within the rpm.newrelic.com domain. You can access distributed tracing through New Relic One, which provides a superior experience with all the functionality supported in the duplicate UI that is end-of-life. Documentation: Global and service-specific distributed tracing views in New Relic One Deprecated distributed tracing UI Action items for a successful transition: No action required, but you can get ready for the new UI experience. New Relic One's distributed tracing page builds on capabilities you are already familiar with. Get acquainted with the enhanced distributed tracing features in New Relic One, including search and filter capabilities with cross-account trace details, query options with the NerdGraph API, and histogram charts (which can help you quickly understand trace distribution for important values such as duration). Review the trace sampling options available with head-based sampling (standard distributed tracing) and tail-based sampling (Infinite Tracing). Violations changes In order to provide a unified experience, we're deprecating browser, mobile, and synthetics monitor violations and replacing them with the New Relic One equivalent. New Relic One users can access violations by using any of these options: Click the Alerts and AI link in New Relic One's main UI. Review the entity list activity stream. See alert details from inside a specific entity via the new indicator for Operational, Warning, and Critical violations. You will see alert details automatically when navigating to one.newrelic.com. Documentation: Applied Intelligence and alerting in New Relic One Browser alert violations (moving to New Relic One) Mobile violations (moving to New Relic One) Monitor violations (moving to New Relic One) Action items for a successful transition: No action required, but you can get ready for the new UI experience. Here's an example of the detailed information about an Alerts violation for a selected entity in New Relic One. Violation details in New Relic One Comments Holistic view From New Relic One's homepage, the entity list presents an activity stream of all entities with alert violations. You no longer need to jump around individual lists of end-user, mobile, or monitor violations. Enhanced troubleshooting tools From New Relic One's homepage, you will also see an Alerts & AI (Applied Intelligence) link. From here you can solve problems faster with anomaly detection, incident correlation, and noise reduction. Specific violation From a selected entity, you will see a new button identifying the violation as Operational, Warning, or Critical, as well as entity metadata and useful details about the incident. Connected agents page Finding your connected agents has never been easier! You can already do this via the Query your data link in New Relic One. Simply run these NrDailyUsage queries to get a list of connected agents and hosts. The old Connected agents page is end-of-life and will be removed. Documentation: Explorers Hub post NRQL query tools NrDailyUsage data definition Action items for a successful transition: To query your connected apps and hosts, you can use existing NRQL query tools, such as New Relic One's query builder or the GraphQL API. Recommendation: For best results exploring comprehensive data about your apps and hosts, use the query builder in New Relic One or the NerdGraph API. Inactive apps in New Relic One Starting June 8, 2020, New Relic One will not continue to display any APM application that hasn't reported data for 93 days. To match our published APM data retention guidelines, applications that have not reported data will be available within the New Relic UI for 90 days. After 90 days, those applications will be removed from the UI. However, key metrics will continue to be available via the New Relic REST API based on subscription level. This is why the application name will remain reserved until the application is permanently deleted via the REST API Explorer. Action items for a successful transition: If you want to reuse an app name for an old app that is no longer reporting data: Use the REST API v2 or API Explorer to get summary data, including app ID, name, health status (look for gray), last reported, etc. Uninstall the agent for your app. Use the REST API or API Explorer to delete the apps. Synthetic monitor alert notifications and conditions In order to provide a unified experience, we're deprecating Synthetics monitor alert notifications and condition violations. We are replacing these pages with a new Synthetics monitor overview experience in New Relic One. This new experience provides visibility into a monitor's open violations and alert conditions with the monitor results in a single view, removing the need to open multiple tabs to view violations or alert conditions. Action items for a successful transition: No action required, but you can get ready for the new UI experience by reviewing our documentation about New Relic Applied Intelligence, which includes: The alerting functionality you are already familiar with in New Relic Alerts, and more Incident Intelligence, which reduces noise and accelerates your incident resolution process Proactive Detection, which surfaces relevant issues and provides automatic explanations to their cause",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.65674,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> feature end of life announcements July 2020",
        "sections": "Inactive apps in <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " To improve our unified experience, starting from Wednesday, August 12, 2020, Kubernetes integrations that <em>use</em> v1.7 or older will be deprecated. The <em>UI</em> experience in the infrastructure.newrelic.com domain will no longer be available; it will only be available in <em>New</em> <em>Relic</em> <em>One</em>. If you are already using"
      },
      "id": "603e795364441ff1924e8872"
    }
  ],
  "/docs/new-relic-one/use-new-relic-one/ui-data/explore-downstream-dependencies-new-relic-one": [
    {
      "sections": [
        "Introduction to New Relic One",
        "Tip",
        "Quickly understand context",
        "Query your data more easily",
        "Enhanced dashboards",
        "Build on New Relic One",
        "Whatâ€™s next?"
      ],
      "title": "Introduction to New Relic One",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "c9ba93c83a579625a4ba3364c6046f3c475cba3a",
      "image": "https://docs.newrelic.com/static/2bc08b6d64c16b39697bb43d8e66870e/c1b63/nrone20210722.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-10-24T17:36:54Z",
      "updated_at": "2021-10-24T17:36:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic One is the platform that gives you access to core platform capabilities like querying data and building charts, our more curated observability UI experiences features, and our alerting and Applied Intelligence tools. With New Relic One, you can see and act on all the data throughout your entire system. To access New Relic One: Go to one.newrelic.com. Or, if you report data to the EU data center go to one.eu.newrelic.com. Tip Learn more about New Relic Oneâ€™s basic UI features. Quickly understand context We provide multiple ways to understand your system's dependencies, so you can easily see how everything fits together and troubleshoot problems. New Relic One gives you and your teams a connected view that cuts through complexity! If you want to... Use this Have an overall view of your system, and drill down to get performance details. Use the New Relic Explorer as the front door to New Relic One: observe, group, and filter the performance data from all the entities (that is, all applications, services, hosts, or containers) in your system. Gain extensive visibility into each entity in your solution, its alert status, and how the entities are connected. Use the New Relic Navigator to give you a high density overview of all your entities so you can detect any issues at a glance. And use the New Relic Lookout to spot entities recently experiencing behavior deviations. Provide context for your entities. Add tags to all your entities. Or create tags for teams and all the services they monitor. Use tags to illustrate relationships and contextual information for what you monitor. By thoughtfully tagging your entities, you can connect all the data your teams need to understand their increasingly complex and interdependent systems. See how each part of your system is connected. Service maps illustrate your upstream and downstream dependencies. Visualize the aggregated health and activity data from all you monitor. Group and monitor any entities together into functional team-focused, project-focused groupings, or any other attribute, with workloads. Fetch and analyze specific data. Get more context while you query with the query builder, which surfaces data definitions as you craft and edit queries. Create visuals that showcase your business needs at a glance. Tailor custom dashboards for your unique needs. Find a service or dashboard in a complex environment. Search by name across all accounts in the unified search, or filter the explorer by tags or text. View everything youâ€™re monitoring in one place, like entities or dashboards across your organization. View a list of all the dependencies for a service. The dependencies view tab in an entity summary shows all the dependencies of the entity youâ€™re viewing. Track activity as it moves across your distributed system. Distributed tracing helps you analyze your modern environment. Understand how everything is connected via API. The NerdGraph GraphiQL explorer manages all your entities, tags, and relationships. Query your data more easily On the Browse data menu on the top navigation menu you can easily access your basic telemetry data (metrics, events, logs, and traces). Wherever you go in the UI, Query your data is available. No matter your level of proficiency with our query language, you can create custom queries and charts: Browse your data in a query-less experience with our data explorer. Use your NRQL (our query language) expertise to build custom charts in the query builder. Run PromQL-style queries in the query builder. one.newrelic.com > Query your data: Build NRQL and PROMQL-like queries. Enhanced dashboards one.newrelic.com > Dashboards: Quickly create information dense custom views into the data that matters most to you with dashboards in New Relic One. New Relic One dashboards let you build better visualizations more easily, with more options to customize. Dashboard features include: Perform NRQL queries and create charts and dashboards everywhere in the platform using the query builder. Manage your charts and dashboards easily using our quick-access CRUD menus and editing options. Explore and contextualize data with advanced tooltips and zoom in functions to monitor what your systems are doing in real time. Search your dashboards for attributes and metrics. Send data to your dashboards using our agents, integrations, and APIs. Share dashboards or charts as a .pdf, or embed a chart in an external site. Tip If you previously used New Relic Insights to create dashboards, these are available as New Relic One dashboards. Build on New Relic One If custom charts and dashboards don't solve your current challenge, we give you a framework for building React JavaScript applications that: Live on New Relic One, alongside your other New Relic-monitored data. Feature highly tailored visualizations. Display data from any source you want, whether from a New Relic-monitored entity or data from any service or API. And you can use open source apps built by the community, and contribute your own open source apps. To learn more, see New Relic One applications. Whatâ€™s next? To get started understanding how to get around in New Relic One: See what data you have available with the data explorer. Browse your monitored entities with the New Relic Explorer. Use our NerdGraph API to add tags to your data. Learn about dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 333.71075,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "sections": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> is the platform that gives you access to core platform capabilities like querying <em>data</em> and building charts, our more curated observability <em>UI</em> experiences features, and our alerting and Applied Intelligence tools. With <em>New</em> <em>Relic</em> <em>One</em>, you can see and act on all the <em>data</em> throughout your"
      },
      "id": "603ec19164441f9e704e8896"
    },
    {
      "sections": [
        "Basic platform UI: search, share, chart UI, customize navigation, and more",
        "Observe your platform",
        "Customize the navigation bar and shortcuts",
        "Light and dark mode",
        "Search accounts and entities",
        "Chart and query features",
        "Share New Relic views with others",
        "Account and user settings",
        "Other UI experiences"
      ],
      "title": "Basic platform UI: search, share, chart UI, customize navigation, and more",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "b3cdcfc60a2821dfa5bee9766aba483cc3389398",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/basic-ui-features/",
      "published_at": "2021-10-24T17:34:56Z",
      "updated_at": "2021-08-21T09:29:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic One has some basic UI functions that are widely available across the platform. Understanding these features will help you find and analyze your data more easily. Observe your platform New Relic One gives you full access to the data from all the entities in your stack. Go to the New Relic Explorer at one.newrelic.com to see a full list of entities, identify overall behaviors, filter them to locate sources of performance issues, or plan improvements for your system. Customize the navigation bar and shortcuts Select the edit icon at the right end of the navigation bar to customize your view. Home, Explorer, Browse data, Dashboards, and Alerts & AI are fixed, but you can favorite up to six more elements to display on the bar as well. The rest will go on the More group. Navigation shortcuts are a faster way to find entities and apps that are relevant to you. Mouse over any menu item for quick access to your favorite entities, those you recently visited, or just to search without having to navigate to a specific section. If you click on an entity, you can choose to open it in the same browser tab or in a new one. Light and dark mode See Light and dark mode. Search accounts and entities Access Quick find clicking the button, near the top right of the New Relic One UI. Some details about your search: You can search across all accounts that you have been granted access to in your organization. For more about account access, see Factors affecting access. Entities that cease to exist are available in search for eight days. If your organization has multiple accounts, use the account picker at the top left corner to select accounts. Chart and query features You can add most charts to a new or existing dashboard. Here are some query and chart features available across all or most of the platform: If you want to... Do this... Start querying your data Mouse over Browse data and select metrics, events, logs, or traces for a direct access to any of those types of data. Also, at the top of any UI page, select Query your data to access the data explorer and query builder. View a chart's query For some charts, you can view the NRQL query used to generate that chart. This can help you understand a chart better or use it as the basis for a new query. Choose time range Drag across a section of a chart to zoom in on that time range. Or, use the time picker in the top right corner of the UI to select pre-set time ranges or set a custom one. View chart details Mouse over a chart to see a pop-up with more detail. For some charts, selecting a point on the chart will take you to a UI page with more information about that metric. Hide or return chart elements To hide or unhide a displayed chart element, select that element's name below the chart. The chart display will adjust to reflect the absence or presence of that element. Share New Relic views with others Here are some options for sharing New Relic UI pages and visualizations. If you want to... Do this... Share UI pages and dashboards To share an entire New Relic UI page, click Share near the top of the UI to copy the URL. Share charts If New Relic charts are built with NRQL queries, they have a menu that exposes various options, including sharing options like Get as image and Get chart link. Some notes about sharing: The person you share with may not have access to view the data from that account. To solve that, someone on your team with New Relic user management abilities must add that person to the account. If someone can't access a custom dashboard, it may be that it is set to private. Read more about dashboard permissions. Some sharing options have associated time ranges, which may impact later viewings of it. For example, if you use a chart's Get chart link option and that chart is set to 'Last 30 minutes', when viewed it will show the last 30 minutes, not the time range displayed when it was shared. To share a specific time range, you must select that time range in the UI. Account and user settings To find account settings and user preferences, use the account dropdown, located at the top right of the UI, beside your user name. Other UI experiences This has been a look at a few basic platform UI experiences. For more about the UI, search for docs related to the specific New Relic solution you're using.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 214.0389,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Basic platform <em>UI</em>: search, share, chart <em>UI</em>, customize navigation, <em>and</em> more",
        "sections": "Share <em>New</em> <em>Relic</em> views with others",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> has some basic <em>UI</em> functions that are widely available across the platform. Understanding these features will help you find and analyze your <em>data</em> more easily. Observe your platform <em>New</em> <em>Relic</em> <em>One</em> gives you full access to the <em>data</em> from all the entities in your stack. Go to the <em>New</em> <em>Relic</em>"
      },
      "id": "603ec1f964441f5b0e4e8860"
    },
    {
      "sections": [
        "New Relic feature end of life announcements July 2020",
        "Old Kubernetes integration agent versions",
        "Monitor listing page and Synthetic labels",
        "\"Rollup by\" in Synthetics",
        "Embedded charts",
        "Legacy distributed tracing UI",
        "Violations changes",
        "Connected agents page",
        "Inactive apps in New Relic One",
        "Synthetic monitor alert notifications and conditions"
      ],
      "title": "New Relic feature end of life announcements July 2020",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "1db1d6b3df6d5ac3b983f78f3264cab332cff05a",
      "image": "https://docs.newrelic.com/static/f2b139d12bd8cdc13a9907b7874a4452/0a867/nrone-embed-bb062520.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/new-relic-feature-end-life-announcements-july-2020/",
      "published_at": "2021-10-24T15:50:03Z",
      "updated_at": "2021-07-22T05:05:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In order to improve your New Relic experience we've made some big improvements to our platform. As a result, we'll be ending support for some old features over the next few weeks. Many have already been publicly announced as \"end-of-life.\" These changes represent our commitment to improve your interactions with our platform. Our mission is one observability platform that unites your telemetry data, connects your full stack, and helps you build more perfect software. To that end we're focusing on simplifying your experience for troubleshooting, alerting, and visualizing data. Here are more details on what's changed, with some helpful links and guides on how to take advantage of new capabilities to achieve the same goals. As always, we're here to help. Please connect with us in the Explorers Hub, or contact your account team with any questions. Old Kubernetes integration agent versions To improve our unified experience, starting from Wednesday, August 12, 2020, Kubernetes integrations that use v1.7 or older will be deprecated. The UI experience in the infrastructure.newrelic.com domain will no longer be available; it will only be available in New Relic One. If you are already using the latest Kubernetes agent version, no action is necessary. If you are using v1.7 or older, you must update your integration in order to continue viewing Kubernetes performance data. Follow the instructions in our documentation to upgrade to the latest version of the Kubernetes integration. Action items for a successful transition: Review the Kubernetes agent deprecation notice. Follow standard procedures to upgrade your Kubernetes agent to the latest version. Learn about the Kubernetes cluster explorer UI in New Relic One. For more information, see the Explorers Hub post. Monitor listing page and Synthetic labels To improve the experience of Synthetic monitors and labels, we've moved both experiences into the New Relic One platform. If you use the REST API for Synthetic label management, you must update to the tags API moving forward. The good news: with the NerdGraph tags API, you can organize and group all your entities in a single request. For more information about any of the following, see the Explorers Hub post. Action items for a successful transition: Synthetic monitors transition Comments Monitor index list When migration is completed, no action is needed on your part to use the new Synthetics entity listing pages. The new experience will be available to you automatically after July 20, 2020. For more information, learn how the explorer in New Relic One replaces the Synthetics monitors index. Existing Synthetics labels You may have already seen an option in the UI to migrate your Synthetics monitor labels to New Relic One tags. If you did not select that option, we've got you covered. Automatic migration from labels to tags starts begins July 8, 2020. For more information, learn how tagging in New Relic One replaces labels for Synthetics monitors. REST API If you use the REST API for Synthetics label management, follow these steps to update to the tags API: Learn more about NerdGraph. Review the NerdGraph tagging API tutorial. Make sure you have a Personal API key to use NerdGraph. Follow the procedures in the Explorers Hub post (look for the How do I transition my scripts from the Synthetics API to the tag API (NerdGraph)? section), and update your existing tags with the GraphiQL explorer at api.newrelic.com/graphiql. NerdGraph is our GraphQL API, a query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph calls get all the data you need in a single request. NerdGraph also makes it easier to evolve APIs over time. \"Rollup by\" in Synthetics Synthetics is moving to New Relic One to provide a single platform for observability of your complex software systems. To do this we are unifying the tools you use to tag (or label) your services, applications, and monitors. The specific feature that is end-of-life is the Rollup by feature under the Search monitors dropdown menu. You can group monitors by tags in New Relic One without needing a separate Rollup by dropdown. No changes will be required to use the new Synthetic monitor listing pages. The new experiences will be available to you after July 20, 2020. Documentation: Tagging in New Relic One replaces labels for Synthetics monitors. Explorer in New Relic One replaces Synthetics monitors index. Action items for a successful transition: If you currently use Synthetics rollups: Follow the procedures in the Explorer Hub post to recreate the rollups that are being retired. Go to the Explorers Hub post about the rollups EOL. In particular, look for How can New Relic Workloads help me visualize groups of applications and monitors? in the post's FAQs section. Follow the procedures in the Explorers Hub post to recreate the rollups that are being retired. Embedded charts In order to reduce redundancy and provide a more unified experience, the embedded charts functionality will be replaced by the New Relic One Get chart. Embedded charts currently in use and hosted outside the New Relic domain will continue to function. The changes will include: The name on the chart's menu that generates them will change from Embed to Get chart link. For charts that are no longer supported, Embed will be replaced with Get chart link is not supported for this chart. The APM UI page that lists all embedded chart links will no longer be available. Documentation: Explorers Hub post New Relic One's enhanced query builder functionality replaces the EOL embed chart functionality. Action items for a successful transition: You can generate a publicly accessible link to add to internal and external websites. Users do not need to be logged in to New Relic to see the chart link. The ability to embed a chart will remain, but instead of clicking Embed (which will be removed from the UI), you will click Get chart link (which is in the same location). This gives you the ability to get links with an even broader range of chart visuals and behaviors than the one we are retiring. Here's an example of how it looks in New Relic One: To replace existing chart links you created with Embed, create new URLs with New Relic One's Get chart link, and insert them in webpages where they're used. If you have an embedded chart and get the message Get chart link is not supported for this chart, simply run a different query, select an available chart type, and then select Embed. Legacy distributed tracing UI To standardize our user experience, we will be deprecating the older distributed tracing UI, which exists within the rpm.newrelic.com domain. You can access distributed tracing through New Relic One, which provides a superior experience with all the functionality supported in the duplicate UI that is end-of-life. Documentation: Global and service-specific distributed tracing views in New Relic One Deprecated distributed tracing UI Action items for a successful transition: No action required, but you can get ready for the new UI experience. New Relic One's distributed tracing page builds on capabilities you are already familiar with. Get acquainted with the enhanced distributed tracing features in New Relic One, including search and filter capabilities with cross-account trace details, query options with the NerdGraph API, and histogram charts (which can help you quickly understand trace distribution for important values such as duration). Review the trace sampling options available with head-based sampling (standard distributed tracing) and tail-based sampling (Infinite Tracing). Violations changes In order to provide a unified experience, we're deprecating browser, mobile, and synthetics monitor violations and replacing them with the New Relic One equivalent. New Relic One users can access violations by using any of these options: Click the Alerts and AI link in New Relic One's main UI. Review the entity list activity stream. See alert details from inside a specific entity via the new indicator for Operational, Warning, and Critical violations. You will see alert details automatically when navigating to one.newrelic.com. Documentation: Applied Intelligence and alerting in New Relic One Browser alert violations (moving to New Relic One) Mobile violations (moving to New Relic One) Monitor violations (moving to New Relic One) Action items for a successful transition: No action required, but you can get ready for the new UI experience. Here's an example of the detailed information about an Alerts violation for a selected entity in New Relic One. Violation details in New Relic One Comments Holistic view From New Relic One's homepage, the entity list presents an activity stream of all entities with alert violations. You no longer need to jump around individual lists of end-user, mobile, or monitor violations. Enhanced troubleshooting tools From New Relic One's homepage, you will also see an Alerts & AI (Applied Intelligence) link. From here you can solve problems faster with anomaly detection, incident correlation, and noise reduction. Specific violation From a selected entity, you will see a new button identifying the violation as Operational, Warning, or Critical, as well as entity metadata and useful details about the incident. Connected agents page Finding your connected agents has never been easier! You can already do this via the Query your data link in New Relic One. Simply run these NrDailyUsage queries to get a list of connected agents and hosts. The old Connected agents page is end-of-life and will be removed. Documentation: Explorers Hub post NRQL query tools NrDailyUsage data definition Action items for a successful transition: To query your connected apps and hosts, you can use existing NRQL query tools, such as New Relic One's query builder or the GraphQL API. Recommendation: For best results exploring comprehensive data about your apps and hosts, use the query builder in New Relic One or the NerdGraph API. Inactive apps in New Relic One Starting June 8, 2020, New Relic One will not continue to display any APM application that hasn't reported data for 93 days. To match our published APM data retention guidelines, applications that have not reported data will be available within the New Relic UI for 90 days. After 90 days, those applications will be removed from the UI. However, key metrics will continue to be available via the New Relic REST API based on subscription level. This is why the application name will remain reserved until the application is permanently deleted via the REST API Explorer. Action items for a successful transition: If you want to reuse an app name for an old app that is no longer reporting data: Use the REST API v2 or API Explorer to get summary data, including app ID, name, health status (look for gray), last reported, etc. Uninstall the agent for your app. Use the REST API or API Explorer to delete the apps. Synthetic monitor alert notifications and conditions In order to provide a unified experience, we're deprecating Synthetics monitor alert notifications and condition violations. We are replacing these pages with a new Synthetics monitor overview experience in New Relic One. This new experience provides visibility into a monitor's open violations and alert conditions with the monitor results in a single view, removing the need to open multiple tabs to view violations or alert conditions. Action items for a successful transition: No action required, but you can get ready for the new UI experience by reviewing our documentation about New Relic Applied Intelligence, which includes: The alerting functionality you are already familiar with in New Relic Alerts, and more Incident Intelligence, which reduces noise and accelerates your incident resolution process Proactive Detection, which surfaces relevant issues and provides automatic explanations to their cause",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.65674,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> feature end of life announcements July 2020",
        "sections": "Inactive apps in <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " To improve our unified experience, starting from Wednesday, August 12, 2020, Kubernetes integrations that <em>use</em> v1.7 or older will be deprecated. The <em>UI</em> experience in the infrastructure.newrelic.com domain will no longer be available; it will only be available in <em>New</em> <em>Relic</em> <em>One</em>. If you are already using"
      },
      "id": "603e795364441ff1924e8872"
    }
  ],
  "/docs/new-relic-one/use-new-relic-one/ui-data/maps-in-context": [
    {
      "image": "https://docs.newrelic.com/static/4ddf877f5025e8c91b680450e6d61f22/2bef9/automaps-overview.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/automaps/",
      "sections": [
        "Automap for troubleshooting entities",
        "How it works",
        "Important",
        "Open automap",
        "Explore the history",
        "Timewarp cursor: go back in time",
        "Controls: See only what you need to see",
        "Map symbols"
      ],
      "published_at": "2021-10-24T17:34:57Z",
      "title": "Automap for troubleshooting entities",
      "updated_at": "2021-10-24T17:34:56Z",
      "type": "docs",
      "external_id": "fda18aaaf60b60b39db33b2d22fd89523cb6ae20",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic automap feature displays entity-centric maps to help you troubleshoot incidents that cascade through interconnected services. With automap, you can pinpoint when and where an issue began by viewing the dependencies that affect your services. To use automap, you need a New Relic account. If you don't already have one, you can sign up here for a free account. Here's an example of where you could start troubleshooting with automap. How it works New Relic automap displays relationships between entities in your architecture. For version 1, the relationships displayed in automap are based on direct calls between services. For example, APM services are represented as vertices (hexagons) and direct calls are represented as edges (lines) on the graph. This shows you how these services depend on one another. Automap displays only the entities related to the source entity that have experienced a change in health status within three hours after the automap was launched. So, it may not show all entities related to the source entity. To understand entities and relationships, as well as how the entity platform synthesizes both from telemetry data, see entities and relationships. Important Automap auto-expand logic relies on the health status of an entity, which is largely determined by the alert status of that entity. For optimal troubleshooting with automap, ensure that your alerts are properly configured. Open automap Automap appears on any Related entities pane for supported entity types: In Explorer, insert a filter to find your entity/service (for example, alerts). Click on the entity/service. On the Summary page, go to Related entities in the right pane. Click Map view: The Map view button is only available for the following types of entities: Entity type Description Icon APM|APPLICATION Application service instrumented with a New Relic APM agent BROWSER|APPLICATION Browser application instrumented with New Relic Browser agent EXT|SERVICE Services instrumented with OpenTelemetry, including Pixie-instrumented services MOBILE|APPLICATION Mobile app instrumented with a New Relic agent NR1|WORKLOAD Workload SYNTH|MONITOR Synthetic monitor Explore the history Unlike simple navigation maps, such as New Relic maps in context, automap helps you understand how problems developed by allowing you to scroll backwards and forwards in time. You can also screen out entities you're not interested in. Timewarp cursor: go back in time To identify exactly when and where an incident originated, simply move the Timewarp cursor to see health status changes for the entities on the map. If you don't see the Timewarp cursor, click the clock icon in the upper-right of the automap. When you scroll through the history, you see when anomalous behavior was detected by New Relic Lookout. Hereâ€™s an example of scrolling that reveals that the issue occurred between FulfillmentService and BillingService: Controls: See only what you need to see With the controls menu available below the Timewarp cursor, you can de-emphasize certain entities on the map by unchecking those options. For example, you can hide the healthy service to focus only on those alerting as you browse the timeline: Here is an example of how the controls work: Map symbols Here's a table showing the various health status icons: Health status Icon Critical Warning Not alerting Not configured Anomaly",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 321.2967,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Automap for troubleshooting <em>entities</em>",
        "sections": "Automap for troubleshooting <em>entities</em>",
        "body": "The New Relic automap feature displays <em>entity</em>-centric <em>maps</em> to help you troubleshoot incidents that cascade through interconnected services. With automap, you can pinpoint when and where an issue began by viewing the dependencies that affect your services. To use automap, you need a New Relic"
      },
      "id": "61663ed6196a67c3bd3c717b"
    },
    {
      "sections": [
        "How to use service maps",
        "Requirements",
        "Minimum versions when distributed tracing is enabled",
        "Minimum versions when distributed tracing is NOT enabled",
        "Add or remove connections to an entity",
        "Color coded for alerts",
        "Understand dependencies using API",
        "Externals and databases in maps",
        "Missing nodes"
      ],
      "title": "How to use service maps",
      "type": "docs",
      "tags": [
        "Understand dependencies",
        "Understand system dependencies",
        "Service maps"
      ],
      "external_id": "34d576d70a4393eea903e46c6dc9297303f821eb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/service-maps/how-use-service-maps/",
      "published_at": "2021-10-24T13:02:13Z",
      "updated_at": "2021-10-24T01:51:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here is information about how to use the current service maps feature. For help using the earlier service maps feature, see Legacy APM service maps. Service maps helps you visualize dependencies quickly and easily across your environment. They help you see how all your entities work together across your system. You can use service maps to troubleshoot problems, see how your environment works together, and ensure that issues donâ€™t have downstream repercussions. Service maps also supports cross-account access so help you see relationships between entities for all your accounts. Requirements Service maps work with distributed tracing to connect relationships between entities. Service maps are still functional if you have not enabled distributed tracing, but we recommend having distributed tracing enabled for all agents. This ensures a more consistent experience while using service maps. For best results, update existing agents to the latest version. The required minimum agent versions for maps are: Minimum versions when distributed tracing is enabled The required minimum agent versions for maps using distributed tracing are: C SDK 1.1.0 or higher Go agent 2.1.0 or higher Java agent 4.3.0 or higher .NET agent 8.6.45.0 or higher Node.js agent 4.7.0 or higher PHP agent 8.4 or higher Python agent 4.2.0.100 or higher Ruby agent 5.3.0.346 or higher Minimum versions when distributed tracing is NOT enabled The minimum version requirements for maps not using distributed tracing are: C SDK: not available Go 1.11 or higher Java 3.9.0 or higher .NET 4.2 or higher Node.js 2.0.0 or higher PHP 4.19.0 or higher Python 2.38.0.31 or higher Ruby 4.3.0 or higher Add or remove connections to an entity To view service maps, from one.newrelic.com click Explorer. Once you select an entity to view, you can select service maps from the sidebar. The map shows your upstream and downstream services: entities toward the left are upstream, entities toward the right are downstream. To add or remove connections to an entity: Hover over the entity in the map that you want to alter. Click add or remove more connections. In the connection list, keep boxes checked for the entities that you want to appear in the map. Unchecked entities will be removed from the map. Color coded for alerts Each entity in a map displays a color dependent on its performance. Green: there are currently no violations for this entities performance. Yellow: there is an open warning violation for this entity. Red: there is an open critical violation for this entity. Gray: no alert conditions have been set for the entity White: agent not reporting. This means that the agent installed on the entity is not reporting any data. This is expected behavior for databases or externals. Understand dependencies using API You can discover the same relationship connections available in service maps with NerdGraph. For more information and examples, see the NerdGraph GraphiQL relationships API tutorial. Externals and databases in maps In the New Relic UI, your out-of-process services are referred to as web external or background external data. Externals and databases have slightly different features in service maps than other entity types: Unlike other entities that appear in service maps, externals are aggregates. Clicking on an external service in the map shows you the list of all the external services that are rolled up into the one external entity. This is to reduce map clutter, as some entities can have dozens of externals being reported. Databases are agentless. Because of this, alerts cannot be set for the database, as only see the service call is reported to New Relic. Missing nodes If you are unable to view certain entities in New Relic One service maps, see Troubleshooting: Missing or obfuscated data in New Relic One.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 273.3095,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "How to use service <em>maps</em>",
        "sections": "Externals and databases <em>in</em> <em>maps</em>",
        "tags": "Service <em>maps</em>",
        "body": " to view, you can select service <em>maps</em> from the sidebar. The <em>map</em> shows your upstream and downstream services: entities toward the left are upstream, entities toward the right are downstream. To add or remove connections to an <em>entity</em>: Hover over the <em>entity</em> in the <em>map</em> that you want to alter. Click add"
      },
      "id": "603ec23264441fb02c4e8893"
    },
    {
      "sections": [
        "Introduction to New Relic One",
        "Tip",
        "Quickly understand context",
        "Query your data more easily",
        "Enhanced dashboards",
        "Build on New Relic One",
        "Whatâ€™s next?"
      ],
      "title": "Introduction to New Relic One",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "c9ba93c83a579625a4ba3364c6046f3c475cba3a",
      "image": "https://docs.newrelic.com/static/2bc08b6d64c16b39697bb43d8e66870e/c1b63/nrone20210722.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-10-24T17:36:54Z",
      "updated_at": "2021-10-24T17:36:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic One is the platform that gives you access to core platform capabilities like querying data and building charts, our more curated observability UI experiences features, and our alerting and Applied Intelligence tools. With New Relic One, you can see and act on all the data throughout your entire system. To access New Relic One: Go to one.newrelic.com. Or, if you report data to the EU data center go to one.eu.newrelic.com. Tip Learn more about New Relic Oneâ€™s basic UI features. Quickly understand context We provide multiple ways to understand your system's dependencies, so you can easily see how everything fits together and troubleshoot problems. New Relic One gives you and your teams a connected view that cuts through complexity! If you want to... Use this Have an overall view of your system, and drill down to get performance details. Use the New Relic Explorer as the front door to New Relic One: observe, group, and filter the performance data from all the entities (that is, all applications, services, hosts, or containers) in your system. Gain extensive visibility into each entity in your solution, its alert status, and how the entities are connected. Use the New Relic Navigator to give you a high density overview of all your entities so you can detect any issues at a glance. And use the New Relic Lookout to spot entities recently experiencing behavior deviations. Provide context for your entities. Add tags to all your entities. Or create tags for teams and all the services they monitor. Use tags to illustrate relationships and contextual information for what you monitor. By thoughtfully tagging your entities, you can connect all the data your teams need to understand their increasingly complex and interdependent systems. See how each part of your system is connected. Service maps illustrate your upstream and downstream dependencies. Visualize the aggregated health and activity data from all you monitor. Group and monitor any entities together into functional team-focused, project-focused groupings, or any other attribute, with workloads. Fetch and analyze specific data. Get more context while you query with the query builder, which surfaces data definitions as you craft and edit queries. Create visuals that showcase your business needs at a glance. Tailor custom dashboards for your unique needs. Find a service or dashboard in a complex environment. Search by name across all accounts in the unified search, or filter the explorer by tags or text. View everything youâ€™re monitoring in one place, like entities or dashboards across your organization. View a list of all the dependencies for a service. The dependencies view tab in an entity summary shows all the dependencies of the entity youâ€™re viewing. Track activity as it moves across your distributed system. Distributed tracing helps you analyze your modern environment. Understand how everything is connected via API. The NerdGraph GraphiQL explorer manages all your entities, tags, and relationships. Query your data more easily On the Browse data menu on the top navigation menu you can easily access your basic telemetry data (metrics, events, logs, and traces). Wherever you go in the UI, Query your data is available. No matter your level of proficiency with our query language, you can create custom queries and charts: Browse your data in a query-less experience with our data explorer. Use your NRQL (our query language) expertise to build custom charts in the query builder. Run PromQL-style queries in the query builder. one.newrelic.com > Query your data: Build NRQL and PROMQL-like queries. Enhanced dashboards one.newrelic.com > Dashboards: Quickly create information dense custom views into the data that matters most to you with dashboards in New Relic One. New Relic One dashboards let you build better visualizations more easily, with more options to customize. Dashboard features include: Perform NRQL queries and create charts and dashboards everywhere in the platform using the query builder. Manage your charts and dashboards easily using our quick-access CRUD menus and editing options. Explore and contextualize data with advanced tooltips and zoom in functions to monitor what your systems are doing in real time. Search your dashboards for attributes and metrics. Send data to your dashboards using our agents, integrations, and APIs. Share dashboards or charts as a .pdf, or embed a chart in an external site. Tip If you previously used New Relic Insights to create dashboards, these are available as New Relic One dashboards. Build on New Relic One If custom charts and dashboards don't solve your current challenge, we give you a framework for building React JavaScript applications that: Live on New Relic One, alongside your other New Relic-monitored data. Feature highly tailored visualizations. Display data from any source you want, whether from a New Relic-monitored entity or data from any service or API. And you can use open source apps built by the community, and contribute your own open source apps. To learn more, see New Relic One applications. Whatâ€™s next? To get started understanding how to get around in New Relic One: See what data you have available with the data explorer. Browse your monitored entities with the New Relic Explorer. Use our NerdGraph API to add tags to your data. Learn about dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 249.52603,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> to New Relic One",
        "sections": "<em>Introduction</em> to New Relic One",
        "body": ". Feature highly tailored visualizations. <em>Display</em> data from any source you want, whether from a New Relic-monitored <em>entity</em> or data from any service or API. And you can use open source apps built by the community, and contribute your own open source apps. To learn more, see New Relic One applications"
      },
      "id": "603ec19164441f9e704e8896"
    }
  ],
  "/docs/new-relic-one/use-new-relic-one/ui-data/metric-normalization-rules": [
    {
      "sections": [
        "Introduction to New Relic One",
        "Tip",
        "Quickly understand context",
        "Query your data more easily",
        "Enhanced dashboards",
        "Build on New Relic One",
        "Whatâ€™s next?"
      ],
      "title": "Introduction to New Relic One",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "c9ba93c83a579625a4ba3364c6046f3c475cba3a",
      "image": "https://docs.newrelic.com/static/2bc08b6d64c16b39697bb43d8e66870e/c1b63/nrone20210722.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-10-24T17:36:54Z",
      "updated_at": "2021-10-24T17:36:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic One is the platform that gives you access to core platform capabilities like querying data and building charts, our more curated observability UI experiences features, and our alerting and Applied Intelligence tools. With New Relic One, you can see and act on all the data throughout your entire system. To access New Relic One: Go to one.newrelic.com. Or, if you report data to the EU data center go to one.eu.newrelic.com. Tip Learn more about New Relic Oneâ€™s basic UI features. Quickly understand context We provide multiple ways to understand your system's dependencies, so you can easily see how everything fits together and troubleshoot problems. New Relic One gives you and your teams a connected view that cuts through complexity! If you want to... Use this Have an overall view of your system, and drill down to get performance details. Use the New Relic Explorer as the front door to New Relic One: observe, group, and filter the performance data from all the entities (that is, all applications, services, hosts, or containers) in your system. Gain extensive visibility into each entity in your solution, its alert status, and how the entities are connected. Use the New Relic Navigator to give you a high density overview of all your entities so you can detect any issues at a glance. And use the New Relic Lookout to spot entities recently experiencing behavior deviations. Provide context for your entities. Add tags to all your entities. Or create tags for teams and all the services they monitor. Use tags to illustrate relationships and contextual information for what you monitor. By thoughtfully tagging your entities, you can connect all the data your teams need to understand their increasingly complex and interdependent systems. See how each part of your system is connected. Service maps illustrate your upstream and downstream dependencies. Visualize the aggregated health and activity data from all you monitor. Group and monitor any entities together into functional team-focused, project-focused groupings, or any other attribute, with workloads. Fetch and analyze specific data. Get more context while you query with the query builder, which surfaces data definitions as you craft and edit queries. Create visuals that showcase your business needs at a glance. Tailor custom dashboards for your unique needs. Find a service or dashboard in a complex environment. Search by name across all accounts in the unified search, or filter the explorer by tags or text. View everything youâ€™re monitoring in one place, like entities or dashboards across your organization. View a list of all the dependencies for a service. The dependencies view tab in an entity summary shows all the dependencies of the entity youâ€™re viewing. Track activity as it moves across your distributed system. Distributed tracing helps you analyze your modern environment. Understand how everything is connected via API. The NerdGraph GraphiQL explorer manages all your entities, tags, and relationships. Query your data more easily On the Browse data menu on the top navigation menu you can easily access your basic telemetry data (metrics, events, logs, and traces). Wherever you go in the UI, Query your data is available. No matter your level of proficiency with our query language, you can create custom queries and charts: Browse your data in a query-less experience with our data explorer. Use your NRQL (our query language) expertise to build custom charts in the query builder. Run PromQL-style queries in the query builder. one.newrelic.com > Query your data: Build NRQL and PROMQL-like queries. Enhanced dashboards one.newrelic.com > Dashboards: Quickly create information dense custom views into the data that matters most to you with dashboards in New Relic One. New Relic One dashboards let you build better visualizations more easily, with more options to customize. Dashboard features include: Perform NRQL queries and create charts and dashboards everywhere in the platform using the query builder. Manage your charts and dashboards easily using our quick-access CRUD menus and editing options. Explore and contextualize data with advanced tooltips and zoom in functions to monitor what your systems are doing in real time. Search your dashboards for attributes and metrics. Send data to your dashboards using our agents, integrations, and APIs. Share dashboards or charts as a .pdf, or embed a chart in an external site. Tip If you previously used New Relic Insights to create dashboards, these are available as New Relic One dashboards. Build on New Relic One If custom charts and dashboards don't solve your current challenge, we give you a framework for building React JavaScript applications that: Live on New Relic One, alongside your other New Relic-monitored data. Feature highly tailored visualizations. Display data from any source you want, whether from a New Relic-monitored entity or data from any service or API. And you can use open source apps built by the community, and contribute your own open source apps. To learn more, see New Relic One applications. Whatâ€™s next? To get started understanding how to get around in New Relic One: See what data you have available with the data explorer. Browse your monitored entities with the New Relic Explorer. Use our NerdGraph API to add tags to your data. Learn about dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 333.71045,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "sections": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> is the platform that gives you access to core platform capabilities like querying <em>data</em> and building charts, our more curated observability <em>UI</em> experiences features, and our alerting and Applied Intelligence tools. With <em>New</em> <em>Relic</em> <em>One</em>, you can see and act on all the <em>data</em> throughout your"
      },
      "id": "603ec19164441f9e704e8896"
    },
    {
      "sections": [
        "Dependencies UI: View an entity's upstream and downstream dependencies",
        "Requirements",
        "View dependencies"
      ],
      "title": "Dependencies UI: View an entity's upstream and downstream dependencies",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "2b2f328a6281bb155bcde07efec7f42eae943048",
      "image": "https://docs.newrelic.com/static/aabc5f64a91cc01b6e226df53c62458f/c1b63/new-relic-one-dependencies-UI.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/explore-downstream-dependencies-new-relic-one/",
      "published_at": "2021-10-18T06:29:36Z",
      "updated_at": "2021-08-21T09:29:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In the New Relic Explorer, an entity's Dependencies page shows a filterable list of all the applications, services, databases, and hosts connected to the entity. It shows upstream and downstream dependencies, and provides paths to explore them. Similar to service maps, the dependencies page helps you understand how all of your upstream and downstream services are connected. It also uses the same color coding system used by service maps to show you what's performing well and what isn't. Requirements To view an entity's dependencies, make sure your app uses the minimum required APM agent version: C 1.0.0 or higher Go 1.11 or higher Java 3.9.0 or higher .NET 4.2 or higher Node.js 2.0.0 or higher PHP 4.19.0 or higher Python 2.38.0.31 or higher Ruby 4.3.0 or higher View dependencies To view dependencies for applications, services, databases, and hosts connected to an entity: Go to one.newrelic.com, select Explorer, and select an entity. Select Dependencies. To drill down further, filter the apps, services, databases, or hosts. one.newrelic.com > Explorer > (select an entity) > Dependencies: View a filterable list of all the apps, services, databases, and hosts connected to an entity, and their color-coded health status. You can filter the dependencies page to view specific things that report to the entity. Dependencies include: Services: APM-monitored applications and services. Mobile applications: your mobile apps. Browser applications: your front-end browser apps. External services: external services monitored by APM. External services include out-of-process services such as web services, resources in the cloud, and any other network calls. Databases: your application's database and cache data. Databases are agentless. Because of this, alerts cannot be set for the database, as only the service call is reported to New Relic. Hosts: your infrastructure (servers and hosts).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 214.03888,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Dependencies <em>UI</em>: View an entity&#x27;s upstream <em>and</em> downstream dependencies",
        "sections": "Dependencies <em>UI</em>: View an entity&#x27;s upstream <em>and</em> downstream dependencies",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " services: external services monitored by APM. External services include out-of-process services such as web services, resources in the cloud, and any other network calls. Databases: your application&#x27;s database and cache <em>data</em>. Databases are agentless. Because of this, alerts cannot be set for the database, as only the service call is reported to <em>New</em> <em>Relic</em>. Hosts: your infrastructure (servers and hosts)."
      },
      "id": "603eb2e564441f0fe44e889b"
    },
    {
      "sections": [
        "Basic platform UI: search, share, chart UI, customize navigation, and more",
        "Observe your platform",
        "Customize the navigation bar and shortcuts",
        "Light and dark mode",
        "Search accounts and entities",
        "Chart and query features",
        "Share New Relic views with others",
        "Account and user settings",
        "Other UI experiences"
      ],
      "title": "Basic platform UI: search, share, chart UI, customize navigation, and more",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "b3cdcfc60a2821dfa5bee9766aba483cc3389398",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/basic-ui-features/",
      "published_at": "2021-10-24T17:34:56Z",
      "updated_at": "2021-08-21T09:29:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic One has some basic UI functions that are widely available across the platform. Understanding these features will help you find and analyze your data more easily. Observe your platform New Relic One gives you full access to the data from all the entities in your stack. Go to the New Relic Explorer at one.newrelic.com to see a full list of entities, identify overall behaviors, filter them to locate sources of performance issues, or plan improvements for your system. Customize the navigation bar and shortcuts Select the edit icon at the right end of the navigation bar to customize your view. Home, Explorer, Browse data, Dashboards, and Alerts & AI are fixed, but you can favorite up to six more elements to display on the bar as well. The rest will go on the More group. Navigation shortcuts are a faster way to find entities and apps that are relevant to you. Mouse over any menu item for quick access to your favorite entities, those you recently visited, or just to search without having to navigate to a specific section. If you click on an entity, you can choose to open it in the same browser tab or in a new one. Light and dark mode See Light and dark mode. Search accounts and entities Access Quick find clicking the button, near the top right of the New Relic One UI. Some details about your search: You can search across all accounts that you have been granted access to in your organization. For more about account access, see Factors affecting access. Entities that cease to exist are available in search for eight days. If your organization has multiple accounts, use the account picker at the top left corner to select accounts. Chart and query features You can add most charts to a new or existing dashboard. Here are some query and chart features available across all or most of the platform: If you want to... Do this... Start querying your data Mouse over Browse data and select metrics, events, logs, or traces for a direct access to any of those types of data. Also, at the top of any UI page, select Query your data to access the data explorer and query builder. View a chart's query For some charts, you can view the NRQL query used to generate that chart. This can help you understand a chart better or use it as the basis for a new query. Choose time range Drag across a section of a chart to zoom in on that time range. Or, use the time picker in the top right corner of the UI to select pre-set time ranges or set a custom one. View chart details Mouse over a chart to see a pop-up with more detail. For some charts, selecting a point on the chart will take you to a UI page with more information about that metric. Hide or return chart elements To hide or unhide a displayed chart element, select that element's name below the chart. The chart display will adjust to reflect the absence or presence of that element. Share New Relic views with others Here are some options for sharing New Relic UI pages and visualizations. If you want to... Do this... Share UI pages and dashboards To share an entire New Relic UI page, click Share near the top of the UI to copy the URL. Share charts If New Relic charts are built with NRQL queries, they have a menu that exposes various options, including sharing options like Get as image and Get chart link. Some notes about sharing: The person you share with may not have access to view the data from that account. To solve that, someone on your team with New Relic user management abilities must add that person to the account. If someone can't access a custom dashboard, it may be that it is set to private. Read more about dashboard permissions. Some sharing options have associated time ranges, which may impact later viewings of it. For example, if you use a chart's Get chart link option and that chart is set to 'Last 30 minutes', when viewed it will show the last 30 minutes, not the time range displayed when it was shared. To share a specific time range, you must select that time range in the UI. Account and user settings To find account settings and user preferences, use the account dropdown, located at the top right of the UI, beside your user name. Other UI experiences This has been a look at a few basic platform UI experiences. For more about the UI, search for docs related to the specific New Relic solution you're using.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 214.03888,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Basic platform <em>UI</em>: search, share, chart <em>UI</em>, customize navigation, <em>and</em> more",
        "sections": "Share <em>New</em> <em>Relic</em> views with others",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> has some basic <em>UI</em> functions that are widely available across the platform. Understanding these features will help you find and analyze your <em>data</em> more easily. Observe your platform <em>New</em> <em>Relic</em> <em>One</em> gives you full access to the <em>data</em> from all the entities in your stack. Go to the <em>New</em> <em>Relic</em>"
      },
      "id": "603ec1f964441f5b0e4e8860"
    }
  ],
  "/docs/new-relic-one/use-new-relic-one/ui-data/new-relic-feature-end-life-announcements-july-2020": [
    {
      "sections": [
        "Introduction to New Relic One",
        "Tip",
        "Quickly understand context",
        "Query your data more easily",
        "Enhanced dashboards",
        "Build on New Relic One",
        "Whatâ€™s next?"
      ],
      "title": "Introduction to New Relic One",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "c9ba93c83a579625a4ba3364c6046f3c475cba3a",
      "image": "https://docs.newrelic.com/static/2bc08b6d64c16b39697bb43d8e66870e/c1b63/nrone20210722.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-10-24T17:36:54Z",
      "updated_at": "2021-10-24T17:36:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic One is the platform that gives you access to core platform capabilities like querying data and building charts, our more curated observability UI experiences features, and our alerting and Applied Intelligence tools. With New Relic One, you can see and act on all the data throughout your entire system. To access New Relic One: Go to one.newrelic.com. Or, if you report data to the EU data center go to one.eu.newrelic.com. Tip Learn more about New Relic Oneâ€™s basic UI features. Quickly understand context We provide multiple ways to understand your system's dependencies, so you can easily see how everything fits together and troubleshoot problems. New Relic One gives you and your teams a connected view that cuts through complexity! If you want to... Use this Have an overall view of your system, and drill down to get performance details. Use the New Relic Explorer as the front door to New Relic One: observe, group, and filter the performance data from all the entities (that is, all applications, services, hosts, or containers) in your system. Gain extensive visibility into each entity in your solution, its alert status, and how the entities are connected. Use the New Relic Navigator to give you a high density overview of all your entities so you can detect any issues at a glance. And use the New Relic Lookout to spot entities recently experiencing behavior deviations. Provide context for your entities. Add tags to all your entities. Or create tags for teams and all the services they monitor. Use tags to illustrate relationships and contextual information for what you monitor. By thoughtfully tagging your entities, you can connect all the data your teams need to understand their increasingly complex and interdependent systems. See how each part of your system is connected. Service maps illustrate your upstream and downstream dependencies. Visualize the aggregated health and activity data from all you monitor. Group and monitor any entities together into functional team-focused, project-focused groupings, or any other attribute, with workloads. Fetch and analyze specific data. Get more context while you query with the query builder, which surfaces data definitions as you craft and edit queries. Create visuals that showcase your business needs at a glance. Tailor custom dashboards for your unique needs. Find a service or dashboard in a complex environment. Search by name across all accounts in the unified search, or filter the explorer by tags or text. View everything youâ€™re monitoring in one place, like entities or dashboards across your organization. View a list of all the dependencies for a service. The dependencies view tab in an entity summary shows all the dependencies of the entity youâ€™re viewing. Track activity as it moves across your distributed system. Distributed tracing helps you analyze your modern environment. Understand how everything is connected via API. The NerdGraph GraphiQL explorer manages all your entities, tags, and relationships. Query your data more easily On the Browse data menu on the top navigation menu you can easily access your basic telemetry data (metrics, events, logs, and traces). Wherever you go in the UI, Query your data is available. No matter your level of proficiency with our query language, you can create custom queries and charts: Browse your data in a query-less experience with our data explorer. Use your NRQL (our query language) expertise to build custom charts in the query builder. Run PromQL-style queries in the query builder. one.newrelic.com > Query your data: Build NRQL and PROMQL-like queries. Enhanced dashboards one.newrelic.com > Dashboards: Quickly create information dense custom views into the data that matters most to you with dashboards in New Relic One. New Relic One dashboards let you build better visualizations more easily, with more options to customize. Dashboard features include: Perform NRQL queries and create charts and dashboards everywhere in the platform using the query builder. Manage your charts and dashboards easily using our quick-access CRUD menus and editing options. Explore and contextualize data with advanced tooltips and zoom in functions to monitor what your systems are doing in real time. Search your dashboards for attributes and metrics. Send data to your dashboards using our agents, integrations, and APIs. Share dashboards or charts as a .pdf, or embed a chart in an external site. Tip If you previously used New Relic Insights to create dashboards, these are available as New Relic One dashboards. Build on New Relic One If custom charts and dashboards don't solve your current challenge, we give you a framework for building React JavaScript applications that: Live on New Relic One, alongside your other New Relic-monitored data. Feature highly tailored visualizations. Display data from any source you want, whether from a New Relic-monitored entity or data from any service or API. And you can use open source apps built by the community, and contribute your own open source apps. To learn more, see New Relic One applications. Whatâ€™s next? To get started understanding how to get around in New Relic One: See what data you have available with the data explorer. Browse your monitored entities with the New Relic Explorer. Use our NerdGraph API to add tags to your data. Learn about dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 333.71045,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "sections": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> is the platform that gives you access to core platform capabilities like querying <em>data</em> and building charts, our more curated observability <em>UI</em> experiences features, and our alerting and Applied Intelligence tools. With <em>New</em> <em>Relic</em> <em>One</em>, you can see and act on all the <em>data</em> throughout your"
      },
      "id": "603ec19164441f9e704e8896"
    },
    {
      "sections": [
        "Dependencies UI: View an entity's upstream and downstream dependencies",
        "Requirements",
        "View dependencies"
      ],
      "title": "Dependencies UI: View an entity's upstream and downstream dependencies",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "2b2f328a6281bb155bcde07efec7f42eae943048",
      "image": "https://docs.newrelic.com/static/aabc5f64a91cc01b6e226df53c62458f/c1b63/new-relic-one-dependencies-UI.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/explore-downstream-dependencies-new-relic-one/",
      "published_at": "2021-10-18T06:29:36Z",
      "updated_at": "2021-08-21T09:29:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In the New Relic Explorer, an entity's Dependencies page shows a filterable list of all the applications, services, databases, and hosts connected to the entity. It shows upstream and downstream dependencies, and provides paths to explore them. Similar to service maps, the dependencies page helps you understand how all of your upstream and downstream services are connected. It also uses the same color coding system used by service maps to show you what's performing well and what isn't. Requirements To view an entity's dependencies, make sure your app uses the minimum required APM agent version: C 1.0.0 or higher Go 1.11 or higher Java 3.9.0 or higher .NET 4.2 or higher Node.js 2.0.0 or higher PHP 4.19.0 or higher Python 2.38.0.31 or higher Ruby 4.3.0 or higher View dependencies To view dependencies for applications, services, databases, and hosts connected to an entity: Go to one.newrelic.com, select Explorer, and select an entity. Select Dependencies. To drill down further, filter the apps, services, databases, or hosts. one.newrelic.com > Explorer > (select an entity) > Dependencies: View a filterable list of all the apps, services, databases, and hosts connected to an entity, and their color-coded health status. You can filter the dependencies page to view specific things that report to the entity. Dependencies include: Services: APM-monitored applications and services. Mobile applications: your mobile apps. Browser applications: your front-end browser apps. External services: external services monitored by APM. External services include out-of-process services such as web services, resources in the cloud, and any other network calls. Databases: your application's database and cache data. Databases are agentless. Because of this, alerts cannot be set for the database, as only the service call is reported to New Relic. Hosts: your infrastructure (servers and hosts).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 214.03888,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Dependencies <em>UI</em>: View an entity&#x27;s upstream <em>and</em> downstream dependencies",
        "sections": "Dependencies <em>UI</em>: View an entity&#x27;s upstream <em>and</em> downstream dependencies",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " services: external services monitored by APM. External services include out-of-process services such as web services, resources in the cloud, and any other network calls. Databases: your application&#x27;s database and cache <em>data</em>. Databases are agentless. Because of this, alerts cannot be set for the database, as only the service call is reported to <em>New</em> <em>Relic</em>. Hosts: your infrastructure (servers and hosts)."
      },
      "id": "603eb2e564441f0fe44e889b"
    },
    {
      "sections": [
        "Basic platform UI: search, share, chart UI, customize navigation, and more",
        "Observe your platform",
        "Customize the navigation bar and shortcuts",
        "Light and dark mode",
        "Search accounts and entities",
        "Chart and query features",
        "Share New Relic views with others",
        "Account and user settings",
        "Other UI experiences"
      ],
      "title": "Basic platform UI: search, share, chart UI, customize navigation, and more",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "b3cdcfc60a2821dfa5bee9766aba483cc3389398",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/basic-ui-features/",
      "published_at": "2021-10-24T17:34:56Z",
      "updated_at": "2021-08-21T09:29:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic One has some basic UI functions that are widely available across the platform. Understanding these features will help you find and analyze your data more easily. Observe your platform New Relic One gives you full access to the data from all the entities in your stack. Go to the New Relic Explorer at one.newrelic.com to see a full list of entities, identify overall behaviors, filter them to locate sources of performance issues, or plan improvements for your system. Customize the navigation bar and shortcuts Select the edit icon at the right end of the navigation bar to customize your view. Home, Explorer, Browse data, Dashboards, and Alerts & AI are fixed, but you can favorite up to six more elements to display on the bar as well. The rest will go on the More group. Navigation shortcuts are a faster way to find entities and apps that are relevant to you. Mouse over any menu item for quick access to your favorite entities, those you recently visited, or just to search without having to navigate to a specific section. If you click on an entity, you can choose to open it in the same browser tab or in a new one. Light and dark mode See Light and dark mode. Search accounts and entities Access Quick find clicking the button, near the top right of the New Relic One UI. Some details about your search: You can search across all accounts that you have been granted access to in your organization. For more about account access, see Factors affecting access. Entities that cease to exist are available in search for eight days. If your organization has multiple accounts, use the account picker at the top left corner to select accounts. Chart and query features You can add most charts to a new or existing dashboard. Here are some query and chart features available across all or most of the platform: If you want to... Do this... Start querying your data Mouse over Browse data and select metrics, events, logs, or traces for a direct access to any of those types of data. Also, at the top of any UI page, select Query your data to access the data explorer and query builder. View a chart's query For some charts, you can view the NRQL query used to generate that chart. This can help you understand a chart better or use it as the basis for a new query. Choose time range Drag across a section of a chart to zoom in on that time range. Or, use the time picker in the top right corner of the UI to select pre-set time ranges or set a custom one. View chart details Mouse over a chart to see a pop-up with more detail. For some charts, selecting a point on the chart will take you to a UI page with more information about that metric. Hide or return chart elements To hide or unhide a displayed chart element, select that element's name below the chart. The chart display will adjust to reflect the absence or presence of that element. Share New Relic views with others Here are some options for sharing New Relic UI pages and visualizations. If you want to... Do this... Share UI pages and dashboards To share an entire New Relic UI page, click Share near the top of the UI to copy the URL. Share charts If New Relic charts are built with NRQL queries, they have a menu that exposes various options, including sharing options like Get as image and Get chart link. Some notes about sharing: The person you share with may not have access to view the data from that account. To solve that, someone on your team with New Relic user management abilities must add that person to the account. If someone can't access a custom dashboard, it may be that it is set to private. Read more about dashboard permissions. Some sharing options have associated time ranges, which may impact later viewings of it. For example, if you use a chart's Get chart link option and that chart is set to 'Last 30 minutes', when viewed it will show the last 30 minutes, not the time range displayed when it was shared. To share a specific time range, you must select that time range in the UI. Account and user settings To find account settings and user preferences, use the account dropdown, located at the top right of the UI, beside your user name. Other UI experiences This has been a look at a few basic platform UI experiences. For more about the UI, search for docs related to the specific New Relic solution you're using.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 214.03888,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Basic platform <em>UI</em>: search, share, chart <em>UI</em>, customize navigation, <em>and</em> more",
        "sections": "Share <em>New</em> <em>Relic</em> views with others",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> has some basic <em>UI</em> functions that are widely available across the platform. Understanding these features will help you find and analyze your <em>data</em> more easily. Observe your platform <em>New</em> <em>Relic</em> <em>One</em> gives you full access to the <em>data</em> from all the entities in your stack. Go to the <em>New</em> <em>Relic</em>"
      },
      "id": "603ec1f964441f5b0e4e8860"
    }
  ],
  "/docs/new-relic-one/use-new-relic-one/ui-data/service-maps/how-use-service-maps": [
    {
      "sections": [
        "Introduction to service maps",
        "Tip",
        "Access service maps",
        "Identify operational issues"
      ],
      "title": "Introduction to service maps",
      "type": "docs",
      "tags": [
        "Understand dependencies",
        "Understand system dependencies",
        "Service maps"
      ],
      "external_id": "aca003c282581d2ec459e9584199739e40b0d04e",
      "image": "https://docs.newrelic.com/static/89460254fa31376b446585fb72b476a1/c1b63/NR1_service_maps.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/service-maps/introduction-service-maps/",
      "published_at": "2021-10-24T13:07:15Z",
      "updated_at": "2021-10-24T01:51:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Service maps are visual, customizable representations of your architecture. Maps automatically show your app's connections and dependencies, including applications, databases, hosts, servers, and out-of-process services. Tip In the New Relic UI, your out-of-process services are referred to as web external or background external data. Health indicators and performance metrics show you the current operational status for every part of your architecture. Service maps help you: Understand how apps and services in your architecture connect and communicate. Quickly see the current health and operational state of your entire environment. Troubleshoot operational issues and understand the impact of problems down to the host and instance level. Collaborate and drive shared understanding of an architecture. Access service maps Two options are available in New Relic One: the current service maps and the legacy APM service maps. To access the different service maps: Type To view maps Purpose Current service maps Go to one.newrelic.com > Explorer > (select an entity) > Monitor > Service map Service maps give you increased access to all the entities across your accounts, and help you understand how your entire environment is connected. Legacy APM service maps Go to one.newrelic.com > More > Service maps Legacy APM service maps let you create, customize, and share maps related to an individual app. Identify operational issues Service maps are color-coded to provide a quick look at the current status of your environment. Select nodes on a map to view additional performance metrics, and a full list and health check of each node's connections. The map automatically connects nodes into the map, so you can see which apps on the map connect to others. This helps you troubleshoot and assess the impact of a performance problem between a calling application and a specific database. With service maps, you can view your service and its status in the context of its up and downstream dependencies. Use maps in New Relic One to identify the root cause when troubleshooting an incident. Check out How to use service maps for details about these topics: View all your entities without any setup: most entities are automatically connected to their dependencies in service maps. View entities all across your organization's accounts. Add a map to a dashboard. one.newrelic.com > Explorer > (select an entity) > Monitor > Service map: Service maps show your dependencies and how they're performing.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 515.0309,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>service</em> <em>maps</em>",
        "sections": "Introduction to <em>service</em> <em>maps</em>",
        "tags": "<em>Understand</em> <em>system</em> <em>dependencies</em>",
        "body": " and the legacy APM <em>service</em> <em>maps</em>. To access the different <em>service</em> <em>maps</em>: Type To view <em>maps</em> Purpose Current <em>service</em> <em>maps</em> Go to one.newrelic.com &gt; Explorer &gt; (select an entity) &gt; Monitor &gt; <em>Service</em> <em>map</em> <em>Service</em> <em>maps</em> give you increased access to all the entities across your accounts, and help you <em>understand</em>"
      },
      "id": "60450348e7b9d26e905799d4"
    },
    {
      "sections": [
        "Troubleshooting: Missing entities in service maps",
        "Problem",
        "Solution",
        "Tip"
      ],
      "title": "Troubleshooting: Missing entities in service maps",
      "type": "docs",
      "tags": [
        "Understand dependencies",
        "Understand system dependencies",
        "Service maps"
      ],
      "external_id": "44f9c026ad8e1c9d6ba02bd1ec2f2deecbc26832",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/service-maps/troubleshooting-missing-entities-service-maps/",
      "published_at": "2021-10-24T12:02:27Z",
      "updated_at": "2021-10-24T01:50:44Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When using service maps, you can't view the full set of entities or the relationships between entities that you expect to see. Solution Make sure that the entities are being monitored with an agent. If you have a mix of agents with some having distributed tracing turned on and some having it turned off, you will not see the relations between those agents. The solution for this scenario is to run all agents either with distributed tracing turned on (preferred) or turn it off for all agents. If this does not remedy the issue, the service you're trying to view may require manual instrumentation. When you view applications and services that we automatically instrument in service maps, you'll usually see complete and detailed data for those nodes in the distributed tracing UI. However, you may notice that some of these services or applications are missing from service maps. Tip Some browser apps are exceptions to this, and may be missing because: Relationships for copy and paste browser agents are not detected. Only the relationships for injected browser agents is shown (the app the agent is injected into). Call relationships (for example, AJAX calling to other apps) are not displayed. If services or apps are missing, you may want to implement custom instrumentation of applications or specific transactions to see more detail in traces. Some examples of when you may need to do this: Transactions not automatically instrumented. To ensure your application is automatically instrumented, read the compatibility and requirements documentation for the agent you're using. If an application isn't automatically instrumented, or if you'd like to add instrumentation of specific activity, see Custom instrumentation. All Go applications. The Go agent, unlike other agents, requires manual instrumentation of your code. For instructions, see Instrument a Go application. A service doesn't use HTTP. If a service doesn't communicate via HTTP, the agent won't send distributed tracing headers. This may be the case for some non-web applications or message queues. To remedy this, use the distributed tracing APIs to instrument either the calling or called application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 515.01685,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Troubleshooting: Missing entities in <em>service</em> <em>maps</em>",
        "sections": "Troubleshooting: Missing entities in <em>service</em> <em>maps</em>",
        "tags": "<em>Understand</em> <em>system</em> <em>dependencies</em>",
        "body": "Problem When using <em>service</em> <em>maps</em>, you can&#x27;t view the full set of entities or the relationships between entities that you expect to see. Solution Make sure that the entities are being monitored with an agent. If you have a mix of agents with some having distributed tracing turned on and some having"
      },
      "id": "603eb369196a67b4aaa83d8d"
    },
    {
      "sections": [
        "Legacy APM service maps",
        "Requirements",
        "Create maps",
        "Important",
        "Save and rename maps",
        "Save",
        "Rename",
        "Add or remove nodes on maps",
        "Applications and mobile apps",
        "Browser, databases, external services, connected apps",
        "Custom nodes",
        "Move around the map",
        "Select, arrange, group nodes",
        "Select nodes",
        "Arrange nodes",
        "Caution",
        "Group and ungroup nodes",
        "Add maps and charts to dashboards",
        "Delete maps",
        "Identify issues with external services",
        "Visualize and monitor complex architectures",
        "Nodes",
        "Node arrangement and grouping",
        "Incoming and outgoing connections",
        "View performance summary",
        "Map list and app/service list panels",
        "Health status and performance metrics",
        "View all connected apps and services",
        "Traffic light mode",
        "Midnight mode"
      ],
      "title": "Legacy APM service maps",
      "type": "docs",
      "tags": [
        "Understand dependencies",
        "Understand system dependencies",
        "Service maps"
      ],
      "external_id": "01918fc622e45cdba5aabfc94c9d55803544c06d",
      "image": "https://docs.newrelic.com/static/535d1f8a57752280221e9a9f9a40c9fc/8bac5/traffic-lights_service-maps_APM.jpg",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/service-maps/service-maps-apm/",
      "published_at": "2021-10-24T13:26:50Z",
      "updated_at": "2021-10-24T01:34:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here is information about using the legacy APM service maps feature to create, customize, and use service maps. For help using the current service maps feature, see How to use service maps. Requirements The legacy service map features in APM depend on your New Relic agent version: Feature Requirements App visibility For your app to appear in service maps, one of the following must be true: Your app must have the minimum agent version required for distributed tracing and have distributed tracing enabled. Note: Mobile monitoring doesn't support distributed tracing yet and will not show relationships to apps that have distributed tracing enabled. Your app must have the minimum APM agent version required for cross app tracing and have cross app tracing enabled. Host and instance visibility To view specific hosts, instances, and types of database information, your agent must meet the same minimum agent versions as the APM database and instance feature and use any of the compatible database drivers. Database-only visibility APM's service maps feature includes the ability to opt out of the deeper, host and instance level view. However, to view databases in service maps without the instance-level details, you must still meet the same minimum agent versions as the Database and slow queries features. Create maps The APM service maps feature helps you create your first map by providing default map or architecture suggestions that automatically build a default map (if you have more than ten reporting apps). To view these suggested maps, go to one.newrelic.com > More > Service Maps > Suggested maps. To create a new map: Do one of the following: Start from scratch: Go to one.newrelic.com > More > Service maps > Map list > Create new map . Copy an existing map: Go to one.newrelic.com > More > Service maps > (select a map) > Save as new. Name your map. Rearrange, group, or add nodes on the map as needed. Important Previously, you could have private service maps. Now, all users can view, edit, and delete all existing or new service maps in the account. Save and rename maps Here are some tips about saving and renaming maps: Save To save changes to a map, select Save. To create a copy of the current map, select Save as new. Rename To rename a map: Go to one.newrelic.com > More > Service maps > (select a map). Select the pencil icon next to the map name. Change the name, then select Save. Add or remove nodes on maps After you create or save a map, build out your map by adding nodes to it. Nodes are added to the map differently based on the node type. To remove any node from the map, mouse over the node, then select the remove X icon. Applications and mobile apps Nodes for applications or mobile apps need to be added to the map in order to add any other nodes. Nodes are added and connected into the map as you select them. The check mark icon means that node is already on the map. To add New Relic monitored apps or plugins to maps: Go to one.newrelic.com > More > Service maps > (select a map) > App/Service. Select any applications from the App/Service list. Rearrange or group together as needed. Browser, databases, external services, connected apps In the New Relic UI, your out-of-process services are referred to as web external or background external data. To add browser apps, databases, external services, or other connected apps to the map: Select an incoming or outgoing connection widget. From the list of connections, mouse over an app or service, then select the plus icon. Rearrange as needed. Custom nodes To add a custom node to the map: Go to one.newrelic.com > More > Service maps > (select a map) > App/Service. From the App/Service list, select Create custom node. Name the node. Add connections: Select the left (for incoming) or right (for outgoing) arrow icons. Then select the plus icon on your target node. Select Save. Rearrange as needed. To add or remove custom node connections: Mouse over the custom node and select the pencil icon. Select the left (for incoming) or right (for outgoing) arrow icons. To add a connection, select the plus icon. To remove a connection, select the minus icon. Select Save. Move around the map Move around the map by panning or zooming in and out. If you want to... Do this... Pan the map In pan mode, click and drag. In drag-select mode, hold the Alt key, then click and drag. Zoom in and out In either mode, zoom in and out by scrolling the mouse wheel. View your entire map in traffic light mode Zoom out until node details fade out and are replaced by health status colors. Toggle the traffic light view on and off Select Views, then select Traffic light mode. View all the nodes and their dependencies Select Discover your environment. Drill down into more detail from a node Use standard UI functions. Select, arrange, group nodes Click on a node to select it and view its performance summary. You can also select multiple nodes at once, to group and ungroup them: Select nodes To select one node, click on the node. To select multiple nodes: Click the drag-select icon to switch to drag-select mode. Click and drag the mouse to draw a square around the nodes you want to select. OR Hold the Shift key and click on each node you want to select. Arrange nodes Caution Auto-arrange cannot be undone. Consider saving a copy of your map first. To arrange nodes on the map, select one or more node, then drag to a snap point on the map. To automatically organize all your nodes and connections, select Auto-arrange map. Group and ungroup nodes If you want to... Do this... Group nodes together on the map Select two or more nodes, then select Create group. Name your new group Mouse over the group, then select the pencil icon. Rename an existing group Select the pencil icon. Remove nodes from a group Select the group, then select the minus icon for each item you want to remove. Add maps and charts to dashboards one.newrelic.com > Dashboards: adding a service map to a dashboard provides context for the data being reported and where it's coming from. You can add legacy service maps to a dashboard. For example, if you have a dashboard showcasing performance metrics for several entities, adding a service map to the dashboard shows how all the entities are related and provides additional context about your system. To add a service map to a dashboard: Go to one.newrelic.com and select the Explorer. Select an entity from the index. Click on Service map. Click Add to dashboard. Search for the dashboard you want to add the map to. Delete maps To delete a map: Go to one.newrelic.com > More > Service maps > (select a map). Select the map name's pencil icon. Select Delete map. Identify issues with external services If your app connects to an external service that New Relic does not monitor (for example, a third-party API), New Relic watches the service for a week in order to baseline its response time. If New Relic can collect a statistically significant number of data points (more than 100), New Relic compares the current response time to this baseline and uses this to set the health status indicator: Green: Response time from the service is less than 1.75 times the baseline. Yellow: Response time from the service is longer than 1.75 times the baseline. Red: Response time from the service is longer than 2.5 times the baseline. Gray: Alerts concluded it does not have enough data to determine the health status. Purple: Alerts cannot yet conclude if it has enough data to determine the health status. Visualize and monitor complex architectures Use service maps to visualize and monitor complex architectures. For a tutorial introducing the latest features, select the service map's question icon. Nodes Nodes are the basic building blocks for your map. You can add a variety of node types including: Node type Description New Relic APM-monitored app Add your app to the map to view their connections to databases, browser apps, out-of-process services, and other instrumented apps. (In the New Relic UI, your out-of-process services are also referred to as web external or background external data.) Browser apps Automatically detected for each app and added via the incoming connections widget. Only displays browser apps linked to an APM app (standalone browser apps are not supported). New Relic mobile monitoring apps Automatically detected and added via the app/service list panel. Plugins, including Databases Automatically detected for each app and added via the connections widget. Databases in service maps require the same agent versions as the new Database page features. External services Service maps automatically detects external services (visible in the connections widget), to track your app's external dependencies and monitor the health of those connections. Custom nodes Add custom nodes via the app/service list panel to include apps and services not automatically instrumented by New Relic (for example, load balancers, implementation planning, and so on). Group nodes A group node contains multiple other nodes. For apps, group nodes include a summarized health status indicator for all nodes in the group. Node arrangement and grouping Click and drag a node to move it around the map, for a customizable view of your architecture. App nodes can also be grouped together into a single node to better organize related apps and services. Grouped nodes include summarized health status indicator for all nodes in the group. To remove items from a group, mouse over the group and select the pencil pencil icon, then select the minus minus-circle icon to remove the item from the group. Incoming and outgoing connections Service maps automatically detects incoming and outgoing connections based on HTTP calls between entities. Mouse over a node to highlight the node's connections. Widgets at the end of each node display a count of that node's connections, and you can click on those widgets to add related entities to the map: View performance summary Click on an app to view its performance over the last 30 minutes. The chart defaults to Response time, but you can view other metrics by selecting any of the available Apdex, Throughput, or Error rate links. While charts use the last 30 minutes of performance data, the service map as a whole is based on the last five minutes. View the app in APM or browser and view its labels by selecting the overflow ellipsis-v icon. Click the app name again to hide the summary charts, and select the overflow ellipsis-h icon again to hide other details. Map list and app/service list panels Select the Map list panel to: Search for and view your maps, and access other users' shared maps. Create a new map. Select the App/Service List panel to: Add new apps, mobile apps, and plugins to your map. Create custom nodes and add them to the map. Health status and performance metrics You can see health status indicators for most nodes. Except for out-of-process services (external services or background services), entities use the health status indicators used by New Relic Alerts. For out-of-process (external) services, the health status indicator measures the health of the connection to the external service. View all connected apps and services The Discover your environment feature allows you to view all of your apps, services, and dependencies together with a single click. This feature detects all connected applications and services (including externals and databases) to give you a comprehensive view of your overall software architecture environment. To view all connected apps and services: In APM, select Service maps. From your Map list, select Discover your environment to display all of your nodes. Hover over any node to view its dependencies and how it connects to other parts of your service map. Click on individual nodes to zoom in and view their details. The Discover your environment feature may not be available if you are using an older New Relic agent version. See Troubleshooting cross application tracing for version information. This feature may also not be available for highly complex service maps with many elements. Go to one.newrelic.com > More > Service maps > Map list > Discover your environment: Use this option to view all of your nodes and their dependencies in one place. Traffic light mode Traffic light mode lets you view the health status of your entire architecture at a glance. This feature helps you quickly find service and app problems, even within a complex environment with many nodes. To toggle this mode, select the Views tab, then select Traffic light mode. When traffic lights mode is On, zooming out far enough on a service map eventually causes the nodes to switch from displaying textual information, to only health status colors. Click on individual nodes to zoom in and view more details. Traffic light mode is on by default. When traffic lights mode is Off, service map nodes retain their textual information and do not switch to health status colors, No matter how far you zoom out. one.newrelic.com > More > Service maps > Views > Traffic light mode: When traffic light mode is enabled, zooming out of your service map displays nodes in health status colors. Midnight mode Midnight mode inverts the screen's colors, going from a white background to a dark background. Midnight mode reduces eye strain, especially in low light environments. To toggle this mode, select the Views tab, then select Midnight mode.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 514.61475,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Legacy APM <em>service</em> <em>maps</em>",
        "sections": "Legacy APM <em>service</em> <em>maps</em>",
        "tags": "<em>Understand</em> <em>system</em> <em>dependencies</em>",
        "body": "Here is information about using the legacy APM <em>service</em> <em>maps</em> feature to create, customize, and use <em>service</em> <em>maps</em>. For help using the current <em>service</em> <em>maps</em> feature, see How to use <em>service</em> <em>maps</em>. Requirements The legacy <em>service</em> <em>map</em> features in APM <em>depend</em> on your New Relic agent version: Feature"
      },
      "id": "60446a3a28ccbc04a2313970"
    }
  ],
  "/docs/new-relic-one/use-new-relic-one/ui-data/service-maps/introduction-service-maps": [
    {
      "sections": [
        "How to use service maps",
        "Requirements",
        "Minimum versions when distributed tracing is enabled",
        "Minimum versions when distributed tracing is NOT enabled",
        "Add or remove connections to an entity",
        "Color coded for alerts",
        "Understand dependencies using API",
        "Externals and databases in maps",
        "Missing nodes"
      ],
      "title": "How to use service maps",
      "type": "docs",
      "tags": [
        "Understand dependencies",
        "Understand system dependencies",
        "Service maps"
      ],
      "external_id": "34d576d70a4393eea903e46c6dc9297303f821eb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/service-maps/how-use-service-maps/",
      "published_at": "2021-10-24T13:02:13Z",
      "updated_at": "2021-10-24T01:51:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here is information about how to use the current service maps feature. For help using the earlier service maps feature, see Legacy APM service maps. Service maps helps you visualize dependencies quickly and easily across your environment. They help you see how all your entities work together across your system. You can use service maps to troubleshoot problems, see how your environment works together, and ensure that issues donâ€™t have downstream repercussions. Service maps also supports cross-account access so help you see relationships between entities for all your accounts. Requirements Service maps work with distributed tracing to connect relationships between entities. Service maps are still functional if you have not enabled distributed tracing, but we recommend having distributed tracing enabled for all agents. This ensures a more consistent experience while using service maps. For best results, update existing agents to the latest version. The required minimum agent versions for maps are: Minimum versions when distributed tracing is enabled The required minimum agent versions for maps using distributed tracing are: C SDK 1.1.0 or higher Go agent 2.1.0 or higher Java agent 4.3.0 or higher .NET agent 8.6.45.0 or higher Node.js agent 4.7.0 or higher PHP agent 8.4 or higher Python agent 4.2.0.100 or higher Ruby agent 5.3.0.346 or higher Minimum versions when distributed tracing is NOT enabled The minimum version requirements for maps not using distributed tracing are: C SDK: not available Go 1.11 or higher Java 3.9.0 or higher .NET 4.2 or higher Node.js 2.0.0 or higher PHP 4.19.0 or higher Python 2.38.0.31 or higher Ruby 4.3.0 or higher Add or remove connections to an entity To view service maps, from one.newrelic.com click Explorer. Once you select an entity to view, you can select service maps from the sidebar. The map shows your upstream and downstream services: entities toward the left are upstream, entities toward the right are downstream. To add or remove connections to an entity: Hover over the entity in the map that you want to alter. Click add or remove more connections. In the connection list, keep boxes checked for the entities that you want to appear in the map. Unchecked entities will be removed from the map. Color coded for alerts Each entity in a map displays a color dependent on its performance. Green: there are currently no violations for this entities performance. Yellow: there is an open warning violation for this entity. Red: there is an open critical violation for this entity. Gray: no alert conditions have been set for the entity White: agent not reporting. This means that the agent installed on the entity is not reporting any data. This is expected behavior for databases or externals. Understand dependencies using API You can discover the same relationship connections available in service maps with NerdGraph. For more information and examples, see the NerdGraph GraphiQL relationships API tutorial. Externals and databases in maps In the New Relic UI, your out-of-process services are referred to as web external or background external data. Externals and databases have slightly different features in service maps than other entity types: Unlike other entities that appear in service maps, externals are aggregates. Clicking on an external service in the map shows you the list of all the external services that are rolled up into the one external entity. This is to reduce map clutter, as some entities can have dozens of externals being reported. Databases are agentless. Because of this, alerts cannot be set for the database, as only see the service call is reported to New Relic. Missing nodes If you are unable to view certain entities in New Relic One service maps, see Troubleshooting: Missing or obfuscated data in New Relic One.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 515.0304,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "How to use <em>service</em> <em>maps</em>",
        "sections": "How to use <em>service</em> <em>maps</em>",
        "tags": "<em>Understand</em> <em>system</em> <em>dependencies</em>",
        "body": " data. This is expected behavior for databases or externals. <em>Understand</em> <em>dependencies</em> using API You can discover the same relationship connections available in <em>service</em> <em>maps</em> with NerdGraph. For more information and examples, see the NerdGraph GraphiQL relationships API tutorial. Externals"
      },
      "id": "603ec23264441fb02c4e8893"
    },
    {
      "sections": [
        "Troubleshooting: Missing entities in service maps",
        "Problem",
        "Solution",
        "Tip"
      ],
      "title": "Troubleshooting: Missing entities in service maps",
      "type": "docs",
      "tags": [
        "Understand dependencies",
        "Understand system dependencies",
        "Service maps"
      ],
      "external_id": "44f9c026ad8e1c9d6ba02bd1ec2f2deecbc26832",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/service-maps/troubleshooting-missing-entities-service-maps/",
      "published_at": "2021-10-24T12:02:27Z",
      "updated_at": "2021-10-24T01:50:44Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When using service maps, you can't view the full set of entities or the relationships between entities that you expect to see. Solution Make sure that the entities are being monitored with an agent. If you have a mix of agents with some having distributed tracing turned on and some having it turned off, you will not see the relations between those agents. The solution for this scenario is to run all agents either with distributed tracing turned on (preferred) or turn it off for all agents. If this does not remedy the issue, the service you're trying to view may require manual instrumentation. When you view applications and services that we automatically instrument in service maps, you'll usually see complete and detailed data for those nodes in the distributed tracing UI. However, you may notice that some of these services or applications are missing from service maps. Tip Some browser apps are exceptions to this, and may be missing because: Relationships for copy and paste browser agents are not detected. Only the relationships for injected browser agents is shown (the app the agent is injected into). Call relationships (for example, AJAX calling to other apps) are not displayed. If services or apps are missing, you may want to implement custom instrumentation of applications or specific transactions to see more detail in traces. Some examples of when you may need to do this: Transactions not automatically instrumented. To ensure your application is automatically instrumented, read the compatibility and requirements documentation for the agent you're using. If an application isn't automatically instrumented, or if you'd like to add instrumentation of specific activity, see Custom instrumentation. All Go applications. The Go agent, unlike other agents, requires manual instrumentation of your code. For instructions, see Instrument a Go application. A service doesn't use HTTP. If a service doesn't communicate via HTTP, the agent won't send distributed tracing headers. This may be the case for some non-web applications or message queues. To remedy this, use the distributed tracing APIs to instrument either the calling or called application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 515.0164,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Troubleshooting: Missing entities in <em>service</em> <em>maps</em>",
        "sections": "Troubleshooting: Missing entities in <em>service</em> <em>maps</em>",
        "tags": "<em>Understand</em> <em>system</em> <em>dependencies</em>",
        "body": "Problem When using <em>service</em> <em>maps</em>, you can&#x27;t view the full set of entities or the relationships between entities that you expect to see. Solution Make sure that the entities are being monitored with an agent. If you have a mix of agents with some having distributed tracing turned on and some having"
      },
      "id": "603eb369196a67b4aaa83d8d"
    },
    {
      "sections": [
        "Legacy APM service maps",
        "Requirements",
        "Create maps",
        "Important",
        "Save and rename maps",
        "Save",
        "Rename",
        "Add or remove nodes on maps",
        "Applications and mobile apps",
        "Browser, databases, external services, connected apps",
        "Custom nodes",
        "Move around the map",
        "Select, arrange, group nodes",
        "Select nodes",
        "Arrange nodes",
        "Caution",
        "Group and ungroup nodes",
        "Add maps and charts to dashboards",
        "Delete maps",
        "Identify issues with external services",
        "Visualize and monitor complex architectures",
        "Nodes",
        "Node arrangement and grouping",
        "Incoming and outgoing connections",
        "View performance summary",
        "Map list and app/service list panels",
        "Health status and performance metrics",
        "View all connected apps and services",
        "Traffic light mode",
        "Midnight mode"
      ],
      "title": "Legacy APM service maps",
      "type": "docs",
      "tags": [
        "Understand dependencies",
        "Understand system dependencies",
        "Service maps"
      ],
      "external_id": "01918fc622e45cdba5aabfc94c9d55803544c06d",
      "image": "https://docs.newrelic.com/static/535d1f8a57752280221e9a9f9a40c9fc/8bac5/traffic-lights_service-maps_APM.jpg",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/service-maps/service-maps-apm/",
      "published_at": "2021-10-24T13:26:50Z",
      "updated_at": "2021-10-24T01:34:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here is information about using the legacy APM service maps feature to create, customize, and use service maps. For help using the current service maps feature, see How to use service maps. Requirements The legacy service map features in APM depend on your New Relic agent version: Feature Requirements App visibility For your app to appear in service maps, one of the following must be true: Your app must have the minimum agent version required for distributed tracing and have distributed tracing enabled. Note: Mobile monitoring doesn't support distributed tracing yet and will not show relationships to apps that have distributed tracing enabled. Your app must have the minimum APM agent version required for cross app tracing and have cross app tracing enabled. Host and instance visibility To view specific hosts, instances, and types of database information, your agent must meet the same minimum agent versions as the APM database and instance feature and use any of the compatible database drivers. Database-only visibility APM's service maps feature includes the ability to opt out of the deeper, host and instance level view. However, to view databases in service maps without the instance-level details, you must still meet the same minimum agent versions as the Database and slow queries features. Create maps The APM service maps feature helps you create your first map by providing default map or architecture suggestions that automatically build a default map (if you have more than ten reporting apps). To view these suggested maps, go to one.newrelic.com > More > Service Maps > Suggested maps. To create a new map: Do one of the following: Start from scratch: Go to one.newrelic.com > More > Service maps > Map list > Create new map . Copy an existing map: Go to one.newrelic.com > More > Service maps > (select a map) > Save as new. Name your map. Rearrange, group, or add nodes on the map as needed. Important Previously, you could have private service maps. Now, all users can view, edit, and delete all existing or new service maps in the account. Save and rename maps Here are some tips about saving and renaming maps: Save To save changes to a map, select Save. To create a copy of the current map, select Save as new. Rename To rename a map: Go to one.newrelic.com > More > Service maps > (select a map). Select the pencil icon next to the map name. Change the name, then select Save. Add or remove nodes on maps After you create or save a map, build out your map by adding nodes to it. Nodes are added to the map differently based on the node type. To remove any node from the map, mouse over the node, then select the remove X icon. Applications and mobile apps Nodes for applications or mobile apps need to be added to the map in order to add any other nodes. Nodes are added and connected into the map as you select them. The check mark icon means that node is already on the map. To add New Relic monitored apps or plugins to maps: Go to one.newrelic.com > More > Service maps > (select a map) > App/Service. Select any applications from the App/Service list. Rearrange or group together as needed. Browser, databases, external services, connected apps In the New Relic UI, your out-of-process services are referred to as web external or background external data. To add browser apps, databases, external services, or other connected apps to the map: Select an incoming or outgoing connection widget. From the list of connections, mouse over an app or service, then select the plus icon. Rearrange as needed. Custom nodes To add a custom node to the map: Go to one.newrelic.com > More > Service maps > (select a map) > App/Service. From the App/Service list, select Create custom node. Name the node. Add connections: Select the left (for incoming) or right (for outgoing) arrow icons. Then select the plus icon on your target node. Select Save. Rearrange as needed. To add or remove custom node connections: Mouse over the custom node and select the pencil icon. Select the left (for incoming) or right (for outgoing) arrow icons. To add a connection, select the plus icon. To remove a connection, select the minus icon. Select Save. Move around the map Move around the map by panning or zooming in and out. If you want to... Do this... Pan the map In pan mode, click and drag. In drag-select mode, hold the Alt key, then click and drag. Zoom in and out In either mode, zoom in and out by scrolling the mouse wheel. View your entire map in traffic light mode Zoom out until node details fade out and are replaced by health status colors. Toggle the traffic light view on and off Select Views, then select Traffic light mode. View all the nodes and their dependencies Select Discover your environment. Drill down into more detail from a node Use standard UI functions. Select, arrange, group nodes Click on a node to select it and view its performance summary. You can also select multiple nodes at once, to group and ungroup them: Select nodes To select one node, click on the node. To select multiple nodes: Click the drag-select icon to switch to drag-select mode. Click and drag the mouse to draw a square around the nodes you want to select. OR Hold the Shift key and click on each node you want to select. Arrange nodes Caution Auto-arrange cannot be undone. Consider saving a copy of your map first. To arrange nodes on the map, select one or more node, then drag to a snap point on the map. To automatically organize all your nodes and connections, select Auto-arrange map. Group and ungroup nodes If you want to... Do this... Group nodes together on the map Select two or more nodes, then select Create group. Name your new group Mouse over the group, then select the pencil icon. Rename an existing group Select the pencil icon. Remove nodes from a group Select the group, then select the minus icon for each item you want to remove. Add maps and charts to dashboards one.newrelic.com > Dashboards: adding a service map to a dashboard provides context for the data being reported and where it's coming from. You can add legacy service maps to a dashboard. For example, if you have a dashboard showcasing performance metrics for several entities, adding a service map to the dashboard shows how all the entities are related and provides additional context about your system. To add a service map to a dashboard: Go to one.newrelic.com and select the Explorer. Select an entity from the index. Click on Service map. Click Add to dashboard. Search for the dashboard you want to add the map to. Delete maps To delete a map: Go to one.newrelic.com > More > Service maps > (select a map). Select the map name's pencil icon. Select Delete map. Identify issues with external services If your app connects to an external service that New Relic does not monitor (for example, a third-party API), New Relic watches the service for a week in order to baseline its response time. If New Relic can collect a statistically significant number of data points (more than 100), New Relic compares the current response time to this baseline and uses this to set the health status indicator: Green: Response time from the service is less than 1.75 times the baseline. Yellow: Response time from the service is longer than 1.75 times the baseline. Red: Response time from the service is longer than 2.5 times the baseline. Gray: Alerts concluded it does not have enough data to determine the health status. Purple: Alerts cannot yet conclude if it has enough data to determine the health status. Visualize and monitor complex architectures Use service maps to visualize and monitor complex architectures. For a tutorial introducing the latest features, select the service map's question icon. Nodes Nodes are the basic building blocks for your map. You can add a variety of node types including: Node type Description New Relic APM-monitored app Add your app to the map to view their connections to databases, browser apps, out-of-process services, and other instrumented apps. (In the New Relic UI, your out-of-process services are also referred to as web external or background external data.) Browser apps Automatically detected for each app and added via the incoming connections widget. Only displays browser apps linked to an APM app (standalone browser apps are not supported). New Relic mobile monitoring apps Automatically detected and added via the app/service list panel. Plugins, including Databases Automatically detected for each app and added via the connections widget. Databases in service maps require the same agent versions as the new Database page features. External services Service maps automatically detects external services (visible in the connections widget), to track your app's external dependencies and monitor the health of those connections. Custom nodes Add custom nodes via the app/service list panel to include apps and services not automatically instrumented by New Relic (for example, load balancers, implementation planning, and so on). Group nodes A group node contains multiple other nodes. For apps, group nodes include a summarized health status indicator for all nodes in the group. Node arrangement and grouping Click and drag a node to move it around the map, for a customizable view of your architecture. App nodes can also be grouped together into a single node to better organize related apps and services. Grouped nodes include summarized health status indicator for all nodes in the group. To remove items from a group, mouse over the group and select the pencil pencil icon, then select the minus minus-circle icon to remove the item from the group. Incoming and outgoing connections Service maps automatically detects incoming and outgoing connections based on HTTP calls between entities. Mouse over a node to highlight the node's connections. Widgets at the end of each node display a count of that node's connections, and you can click on those widgets to add related entities to the map: View performance summary Click on an app to view its performance over the last 30 minutes. The chart defaults to Response time, but you can view other metrics by selecting any of the available Apdex, Throughput, or Error rate links. While charts use the last 30 minutes of performance data, the service map as a whole is based on the last five minutes. View the app in APM or browser and view its labels by selecting the overflow ellipsis-v icon. Click the app name again to hide the summary charts, and select the overflow ellipsis-h icon again to hide other details. Map list and app/service list panels Select the Map list panel to: Search for and view your maps, and access other users' shared maps. Create a new map. Select the App/Service List panel to: Add new apps, mobile apps, and plugins to your map. Create custom nodes and add them to the map. Health status and performance metrics You can see health status indicators for most nodes. Except for out-of-process services (external services or background services), entities use the health status indicators used by New Relic Alerts. For out-of-process (external) services, the health status indicator measures the health of the connection to the external service. View all connected apps and services The Discover your environment feature allows you to view all of your apps, services, and dependencies together with a single click. This feature detects all connected applications and services (including externals and databases) to give you a comprehensive view of your overall software architecture environment. To view all connected apps and services: In APM, select Service maps. From your Map list, select Discover your environment to display all of your nodes. Hover over any node to view its dependencies and how it connects to other parts of your service map. Click on individual nodes to zoom in and view their details. The Discover your environment feature may not be available if you are using an older New Relic agent version. See Troubleshooting cross application tracing for version information. This feature may also not be available for highly complex service maps with many elements. Go to one.newrelic.com > More > Service maps > Map list > Discover your environment: Use this option to view all of your nodes and their dependencies in one place. Traffic light mode Traffic light mode lets you view the health status of your entire architecture at a glance. This feature helps you quickly find service and app problems, even within a complex environment with many nodes. To toggle this mode, select the Views tab, then select Traffic light mode. When traffic lights mode is On, zooming out far enough on a service map eventually causes the nodes to switch from displaying textual information, to only health status colors. Click on individual nodes to zoom in and view more details. Traffic light mode is on by default. When traffic lights mode is Off, service map nodes retain their textual information and do not switch to health status colors, No matter how far you zoom out. one.newrelic.com > More > Service maps > Views > Traffic light mode: When traffic light mode is enabled, zooming out of your service map displays nodes in health status colors. Midnight mode Midnight mode inverts the screen's colors, going from a white background to a dark background. Midnight mode reduces eye strain, especially in low light environments. To toggle this mode, select the Views tab, then select Midnight mode.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 514.6144,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Legacy APM <em>service</em> <em>maps</em>",
        "sections": "Legacy APM <em>service</em> <em>maps</em>",
        "tags": "<em>Understand</em> <em>system</em> <em>dependencies</em>",
        "body": "Here is information about using the legacy APM <em>service</em> <em>maps</em> feature to create, customize, and use <em>service</em> <em>maps</em>. For help using the current <em>service</em> <em>maps</em> feature, see How to use <em>service</em> <em>maps</em>. Requirements The legacy <em>service</em> <em>map</em> features in APM <em>depend</em> on your New Relic agent version: Feature"
      },
      "id": "60446a3a28ccbc04a2313970"
    }
  ],
  "/docs/new-relic-one/use-new-relic-one/ui-data/service-maps/service-maps-apm": [
    {
      "sections": [
        "How to use service maps",
        "Requirements",
        "Minimum versions when distributed tracing is enabled",
        "Minimum versions when distributed tracing is NOT enabled",
        "Add or remove connections to an entity",
        "Color coded for alerts",
        "Understand dependencies using API",
        "Externals and databases in maps",
        "Missing nodes"
      ],
      "title": "How to use service maps",
      "type": "docs",
      "tags": [
        "Understand dependencies",
        "Understand system dependencies",
        "Service maps"
      ],
      "external_id": "34d576d70a4393eea903e46c6dc9297303f821eb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/service-maps/how-use-service-maps/",
      "published_at": "2021-10-24T13:02:13Z",
      "updated_at": "2021-10-24T01:51:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here is information about how to use the current service maps feature. For help using the earlier service maps feature, see Legacy APM service maps. Service maps helps you visualize dependencies quickly and easily across your environment. They help you see how all your entities work together across your system. You can use service maps to troubleshoot problems, see how your environment works together, and ensure that issues donâ€™t have downstream repercussions. Service maps also supports cross-account access so help you see relationships between entities for all your accounts. Requirements Service maps work with distributed tracing to connect relationships between entities. Service maps are still functional if you have not enabled distributed tracing, but we recommend having distributed tracing enabled for all agents. This ensures a more consistent experience while using service maps. For best results, update existing agents to the latest version. The required minimum agent versions for maps are: Minimum versions when distributed tracing is enabled The required minimum agent versions for maps using distributed tracing are: C SDK 1.1.0 or higher Go agent 2.1.0 or higher Java agent 4.3.0 or higher .NET agent 8.6.45.0 or higher Node.js agent 4.7.0 or higher PHP agent 8.4 or higher Python agent 4.2.0.100 or higher Ruby agent 5.3.0.346 or higher Minimum versions when distributed tracing is NOT enabled The minimum version requirements for maps not using distributed tracing are: C SDK: not available Go 1.11 or higher Java 3.9.0 or higher .NET 4.2 or higher Node.js 2.0.0 or higher PHP 4.19.0 or higher Python 2.38.0.31 or higher Ruby 4.3.0 or higher Add or remove connections to an entity To view service maps, from one.newrelic.com click Explorer. Once you select an entity to view, you can select service maps from the sidebar. The map shows your upstream and downstream services: entities toward the left are upstream, entities toward the right are downstream. To add or remove connections to an entity: Hover over the entity in the map that you want to alter. Click add or remove more connections. In the connection list, keep boxes checked for the entities that you want to appear in the map. Unchecked entities will be removed from the map. Color coded for alerts Each entity in a map displays a color dependent on its performance. Green: there are currently no violations for this entities performance. Yellow: there is an open warning violation for this entity. Red: there is an open critical violation for this entity. Gray: no alert conditions have been set for the entity White: agent not reporting. This means that the agent installed on the entity is not reporting any data. This is expected behavior for databases or externals. Understand dependencies using API You can discover the same relationship connections available in service maps with NerdGraph. For more information and examples, see the NerdGraph GraphiQL relationships API tutorial. Externals and databases in maps In the New Relic UI, your out-of-process services are referred to as web external or background external data. Externals and databases have slightly different features in service maps than other entity types: Unlike other entities that appear in service maps, externals are aggregates. Clicking on an external service in the map shows you the list of all the external services that are rolled up into the one external entity. This is to reduce map clutter, as some entities can have dozens of externals being reported. Databases are agentless. Because of this, alerts cannot be set for the database, as only see the service call is reported to New Relic. Missing nodes If you are unable to view certain entities in New Relic One service maps, see Troubleshooting: Missing or obfuscated data in New Relic One.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 515.0304,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "How to use <em>service</em> <em>maps</em>",
        "sections": "How to use <em>service</em> <em>maps</em>",
        "tags": "<em>Understand</em> <em>system</em> <em>dependencies</em>",
        "body": " data. This is expected behavior for databases or externals. <em>Understand</em> <em>dependencies</em> using API You can discover the same relationship connections available in <em>service</em> <em>maps</em> with NerdGraph. For more information and examples, see the NerdGraph GraphiQL relationships API tutorial. Externals"
      },
      "id": "603ec23264441fb02c4e8893"
    },
    {
      "sections": [
        "Introduction to service maps",
        "Tip",
        "Access service maps",
        "Identify operational issues"
      ],
      "title": "Introduction to service maps",
      "type": "docs",
      "tags": [
        "Understand dependencies",
        "Understand system dependencies",
        "Service maps"
      ],
      "external_id": "aca003c282581d2ec459e9584199739e40b0d04e",
      "image": "https://docs.newrelic.com/static/89460254fa31376b446585fb72b476a1/c1b63/NR1_service_maps.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/service-maps/introduction-service-maps/",
      "published_at": "2021-10-24T13:07:15Z",
      "updated_at": "2021-10-24T01:51:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Service maps are visual, customizable representations of your architecture. Maps automatically show your app's connections and dependencies, including applications, databases, hosts, servers, and out-of-process services. Tip In the New Relic UI, your out-of-process services are referred to as web external or background external data. Health indicators and performance metrics show you the current operational status for every part of your architecture. Service maps help you: Understand how apps and services in your architecture connect and communicate. Quickly see the current health and operational state of your entire environment. Troubleshoot operational issues and understand the impact of problems down to the host and instance level. Collaborate and drive shared understanding of an architecture. Access service maps Two options are available in New Relic One: the current service maps and the legacy APM service maps. To access the different service maps: Type To view maps Purpose Current service maps Go to one.newrelic.com > Explorer > (select an entity) > Monitor > Service map Service maps give you increased access to all the entities across your accounts, and help you understand how your entire environment is connected. Legacy APM service maps Go to one.newrelic.com > More > Service maps Legacy APM service maps let you create, customize, and share maps related to an individual app. Identify operational issues Service maps are color-coded to provide a quick look at the current status of your environment. Select nodes on a map to view additional performance metrics, and a full list and health check of each node's connections. The map automatically connects nodes into the map, so you can see which apps on the map connect to others. This helps you troubleshoot and assess the impact of a performance problem between a calling application and a specific database. With service maps, you can view your service and its status in the context of its up and downstream dependencies. Use maps in New Relic One to identify the root cause when troubleshooting an incident. Check out How to use service maps for details about these topics: View all your entities without any setup: most entities are automatically connected to their dependencies in service maps. View entities all across your organization's accounts. Add a map to a dashboard. one.newrelic.com > Explorer > (select an entity) > Monitor > Service map: Service maps show your dependencies and how they're performing.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 515.0304,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>service</em> <em>maps</em>",
        "sections": "Introduction to <em>service</em> <em>maps</em>",
        "tags": "<em>Understand</em> <em>system</em> <em>dependencies</em>",
        "body": " and the legacy APM <em>service</em> <em>maps</em>. To access the different <em>service</em> <em>maps</em>: Type To view <em>maps</em> Purpose Current <em>service</em> <em>maps</em> Go to one.newrelic.com &gt; Explorer &gt; (select an entity) &gt; Monitor &gt; <em>Service</em> <em>map</em> <em>Service</em> <em>maps</em> give you increased access to all the entities across your accounts, and help you <em>understand</em>"
      },
      "id": "60450348e7b9d26e905799d4"
    },
    {
      "sections": [
        "Troubleshooting: Missing entities in service maps",
        "Problem",
        "Solution",
        "Tip"
      ],
      "title": "Troubleshooting: Missing entities in service maps",
      "type": "docs",
      "tags": [
        "Understand dependencies",
        "Understand system dependencies",
        "Service maps"
      ],
      "external_id": "44f9c026ad8e1c9d6ba02bd1ec2f2deecbc26832",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/service-maps/troubleshooting-missing-entities-service-maps/",
      "published_at": "2021-10-24T12:02:27Z",
      "updated_at": "2021-10-24T01:50:44Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When using service maps, you can't view the full set of entities or the relationships between entities that you expect to see. Solution Make sure that the entities are being monitored with an agent. If you have a mix of agents with some having distributed tracing turned on and some having it turned off, you will not see the relations between those agents. The solution for this scenario is to run all agents either with distributed tracing turned on (preferred) or turn it off for all agents. If this does not remedy the issue, the service you're trying to view may require manual instrumentation. When you view applications and services that we automatically instrument in service maps, you'll usually see complete and detailed data for those nodes in the distributed tracing UI. However, you may notice that some of these services or applications are missing from service maps. Tip Some browser apps are exceptions to this, and may be missing because: Relationships for copy and paste browser agents are not detected. Only the relationships for injected browser agents is shown (the app the agent is injected into). Call relationships (for example, AJAX calling to other apps) are not displayed. If services or apps are missing, you may want to implement custom instrumentation of applications or specific transactions to see more detail in traces. Some examples of when you may need to do this: Transactions not automatically instrumented. To ensure your application is automatically instrumented, read the compatibility and requirements documentation for the agent you're using. If an application isn't automatically instrumented, or if you'd like to add instrumentation of specific activity, see Custom instrumentation. All Go applications. The Go agent, unlike other agents, requires manual instrumentation of your code. For instructions, see Instrument a Go application. A service doesn't use HTTP. If a service doesn't communicate via HTTP, the agent won't send distributed tracing headers. This may be the case for some non-web applications or message queues. To remedy this, use the distributed tracing APIs to instrument either the calling or called application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 515.0164,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Troubleshooting: Missing entities in <em>service</em> <em>maps</em>",
        "sections": "Troubleshooting: Missing entities in <em>service</em> <em>maps</em>",
        "tags": "<em>Understand</em> <em>system</em> <em>dependencies</em>",
        "body": "Problem When using <em>service</em> <em>maps</em>, you can&#x27;t view the full set of entities or the relationships between entities that you expect to see. Solution Make sure that the entities are being monitored with an agent. If you have a mix of agents with some having distributed tracing turned on and some having"
      },
      "id": "603eb369196a67b4aaa83d8d"
    }
  ],
  "/docs/new-relic-one/use-new-relic-one/ui-data/service-maps/troubleshooting-missing-entities-service-maps": [
    {
      "sections": [
        "How to use service maps",
        "Requirements",
        "Minimum versions when distributed tracing is enabled",
        "Minimum versions when distributed tracing is NOT enabled",
        "Add or remove connections to an entity",
        "Color coded for alerts",
        "Understand dependencies using API",
        "Externals and databases in maps",
        "Missing nodes"
      ],
      "title": "How to use service maps",
      "type": "docs",
      "tags": [
        "Understand dependencies",
        "Understand system dependencies",
        "Service maps"
      ],
      "external_id": "34d576d70a4393eea903e46c6dc9297303f821eb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/service-maps/how-use-service-maps/",
      "published_at": "2021-10-24T13:02:13Z",
      "updated_at": "2021-10-24T01:51:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here is information about how to use the current service maps feature. For help using the earlier service maps feature, see Legacy APM service maps. Service maps helps you visualize dependencies quickly and easily across your environment. They help you see how all your entities work together across your system. You can use service maps to troubleshoot problems, see how your environment works together, and ensure that issues donâ€™t have downstream repercussions. Service maps also supports cross-account access so help you see relationships between entities for all your accounts. Requirements Service maps work with distributed tracing to connect relationships between entities. Service maps are still functional if you have not enabled distributed tracing, but we recommend having distributed tracing enabled for all agents. This ensures a more consistent experience while using service maps. For best results, update existing agents to the latest version. The required minimum agent versions for maps are: Minimum versions when distributed tracing is enabled The required minimum agent versions for maps using distributed tracing are: C SDK 1.1.0 or higher Go agent 2.1.0 or higher Java agent 4.3.0 or higher .NET agent 8.6.45.0 or higher Node.js agent 4.7.0 or higher PHP agent 8.4 or higher Python agent 4.2.0.100 or higher Ruby agent 5.3.0.346 or higher Minimum versions when distributed tracing is NOT enabled The minimum version requirements for maps not using distributed tracing are: C SDK: not available Go 1.11 or higher Java 3.9.0 or higher .NET 4.2 or higher Node.js 2.0.0 or higher PHP 4.19.0 or higher Python 2.38.0.31 or higher Ruby 4.3.0 or higher Add or remove connections to an entity To view service maps, from one.newrelic.com click Explorer. Once you select an entity to view, you can select service maps from the sidebar. The map shows your upstream and downstream services: entities toward the left are upstream, entities toward the right are downstream. To add or remove connections to an entity: Hover over the entity in the map that you want to alter. Click add or remove more connections. In the connection list, keep boxes checked for the entities that you want to appear in the map. Unchecked entities will be removed from the map. Color coded for alerts Each entity in a map displays a color dependent on its performance. Green: there are currently no violations for this entities performance. Yellow: there is an open warning violation for this entity. Red: there is an open critical violation for this entity. Gray: no alert conditions have been set for the entity White: agent not reporting. This means that the agent installed on the entity is not reporting any data. This is expected behavior for databases or externals. Understand dependencies using API You can discover the same relationship connections available in service maps with NerdGraph. For more information and examples, see the NerdGraph GraphiQL relationships API tutorial. Externals and databases in maps In the New Relic UI, your out-of-process services are referred to as web external or background external data. Externals and databases have slightly different features in service maps than other entity types: Unlike other entities that appear in service maps, externals are aggregates. Clicking on an external service in the map shows you the list of all the external services that are rolled up into the one external entity. This is to reduce map clutter, as some entities can have dozens of externals being reported. Databases are agentless. Because of this, alerts cannot be set for the database, as only see the service call is reported to New Relic. Missing nodes If you are unable to view certain entities in New Relic One service maps, see Troubleshooting: Missing or obfuscated data in New Relic One.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 515.03,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "How to use <em>service</em> <em>maps</em>",
        "sections": "How to use <em>service</em> <em>maps</em>",
        "tags": "<em>Understand</em> <em>system</em> <em>dependencies</em>",
        "body": " data. This is expected behavior for databases or externals. <em>Understand</em> <em>dependencies</em> using API You can discover the same relationship connections available in <em>service</em> <em>maps</em> with NerdGraph. For more information and examples, see the NerdGraph GraphiQL relationships API tutorial. Externals"
      },
      "id": "603ec23264441fb02c4e8893"
    },
    {
      "sections": [
        "Introduction to service maps",
        "Tip",
        "Access service maps",
        "Identify operational issues"
      ],
      "title": "Introduction to service maps",
      "type": "docs",
      "tags": [
        "Understand dependencies",
        "Understand system dependencies",
        "Service maps"
      ],
      "external_id": "aca003c282581d2ec459e9584199739e40b0d04e",
      "image": "https://docs.newrelic.com/static/89460254fa31376b446585fb72b476a1/c1b63/NR1_service_maps.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/service-maps/introduction-service-maps/",
      "published_at": "2021-10-24T13:07:15Z",
      "updated_at": "2021-10-24T01:51:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Service maps are visual, customizable representations of your architecture. Maps automatically show your app's connections and dependencies, including applications, databases, hosts, servers, and out-of-process services. Tip In the New Relic UI, your out-of-process services are referred to as web external or background external data. Health indicators and performance metrics show you the current operational status for every part of your architecture. Service maps help you: Understand how apps and services in your architecture connect and communicate. Quickly see the current health and operational state of your entire environment. Troubleshoot operational issues and understand the impact of problems down to the host and instance level. Collaborate and drive shared understanding of an architecture. Access service maps Two options are available in New Relic One: the current service maps and the legacy APM service maps. To access the different service maps: Type To view maps Purpose Current service maps Go to one.newrelic.com > Explorer > (select an entity) > Monitor > Service map Service maps give you increased access to all the entities across your accounts, and help you understand how your entire environment is connected. Legacy APM service maps Go to one.newrelic.com > More > Service maps Legacy APM service maps let you create, customize, and share maps related to an individual app. Identify operational issues Service maps are color-coded to provide a quick look at the current status of your environment. Select nodes on a map to view additional performance metrics, and a full list and health check of each node's connections. The map automatically connects nodes into the map, so you can see which apps on the map connect to others. This helps you troubleshoot and assess the impact of a performance problem between a calling application and a specific database. With service maps, you can view your service and its status in the context of its up and downstream dependencies. Use maps in New Relic One to identify the root cause when troubleshooting an incident. Check out How to use service maps for details about these topics: View all your entities without any setup: most entities are automatically connected to their dependencies in service maps. View entities all across your organization's accounts. Add a map to a dashboard. one.newrelic.com > Explorer > (select an entity) > Monitor > Service map: Service maps show your dependencies and how they're performing.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 515.03,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>service</em> <em>maps</em>",
        "sections": "Introduction to <em>service</em> <em>maps</em>",
        "tags": "<em>Understand</em> <em>system</em> <em>dependencies</em>",
        "body": " and the legacy APM <em>service</em> <em>maps</em>. To access the different <em>service</em> <em>maps</em>: Type To view <em>maps</em> Purpose Current <em>service</em> <em>maps</em> Go to one.newrelic.com &gt; Explorer &gt; (select an entity) &gt; Monitor &gt; <em>Service</em> <em>map</em> <em>Service</em> <em>maps</em> give you increased access to all the entities across your accounts, and help you <em>understand</em>"
      },
      "id": "60450348e7b9d26e905799d4"
    },
    {
      "sections": [
        "Legacy APM service maps",
        "Requirements",
        "Create maps",
        "Important",
        "Save and rename maps",
        "Save",
        "Rename",
        "Add or remove nodes on maps",
        "Applications and mobile apps",
        "Browser, databases, external services, connected apps",
        "Custom nodes",
        "Move around the map",
        "Select, arrange, group nodes",
        "Select nodes",
        "Arrange nodes",
        "Caution",
        "Group and ungroup nodes",
        "Add maps and charts to dashboards",
        "Delete maps",
        "Identify issues with external services",
        "Visualize and monitor complex architectures",
        "Nodes",
        "Node arrangement and grouping",
        "Incoming and outgoing connections",
        "View performance summary",
        "Map list and app/service list panels",
        "Health status and performance metrics",
        "View all connected apps and services",
        "Traffic light mode",
        "Midnight mode"
      ],
      "title": "Legacy APM service maps",
      "type": "docs",
      "tags": [
        "Understand dependencies",
        "Understand system dependencies",
        "Service maps"
      ],
      "external_id": "01918fc622e45cdba5aabfc94c9d55803544c06d",
      "image": "https://docs.newrelic.com/static/535d1f8a57752280221e9a9f9a40c9fc/8bac5/traffic-lights_service-maps_APM.jpg",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/service-maps/service-maps-apm/",
      "published_at": "2021-10-24T13:26:50Z",
      "updated_at": "2021-10-24T01:34:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here is information about using the legacy APM service maps feature to create, customize, and use service maps. For help using the current service maps feature, see How to use service maps. Requirements The legacy service map features in APM depend on your New Relic agent version: Feature Requirements App visibility For your app to appear in service maps, one of the following must be true: Your app must have the minimum agent version required for distributed tracing and have distributed tracing enabled. Note: Mobile monitoring doesn't support distributed tracing yet and will not show relationships to apps that have distributed tracing enabled. Your app must have the minimum APM agent version required for cross app tracing and have cross app tracing enabled. Host and instance visibility To view specific hosts, instances, and types of database information, your agent must meet the same minimum agent versions as the APM database and instance feature and use any of the compatible database drivers. Database-only visibility APM's service maps feature includes the ability to opt out of the deeper, host and instance level view. However, to view databases in service maps without the instance-level details, you must still meet the same minimum agent versions as the Database and slow queries features. Create maps The APM service maps feature helps you create your first map by providing default map or architecture suggestions that automatically build a default map (if you have more than ten reporting apps). To view these suggested maps, go to one.newrelic.com > More > Service Maps > Suggested maps. To create a new map: Do one of the following: Start from scratch: Go to one.newrelic.com > More > Service maps > Map list > Create new map . Copy an existing map: Go to one.newrelic.com > More > Service maps > (select a map) > Save as new. Name your map. Rearrange, group, or add nodes on the map as needed. Important Previously, you could have private service maps. Now, all users can view, edit, and delete all existing or new service maps in the account. Save and rename maps Here are some tips about saving and renaming maps: Save To save changes to a map, select Save. To create a copy of the current map, select Save as new. Rename To rename a map: Go to one.newrelic.com > More > Service maps > (select a map). Select the pencil icon next to the map name. Change the name, then select Save. Add or remove nodes on maps After you create or save a map, build out your map by adding nodes to it. Nodes are added to the map differently based on the node type. To remove any node from the map, mouse over the node, then select the remove X icon. Applications and mobile apps Nodes for applications or mobile apps need to be added to the map in order to add any other nodes. Nodes are added and connected into the map as you select them. The check mark icon means that node is already on the map. To add New Relic monitored apps or plugins to maps: Go to one.newrelic.com > More > Service maps > (select a map) > App/Service. Select any applications from the App/Service list. Rearrange or group together as needed. Browser, databases, external services, connected apps In the New Relic UI, your out-of-process services are referred to as web external or background external data. To add browser apps, databases, external services, or other connected apps to the map: Select an incoming or outgoing connection widget. From the list of connections, mouse over an app or service, then select the plus icon. Rearrange as needed. Custom nodes To add a custom node to the map: Go to one.newrelic.com > More > Service maps > (select a map) > App/Service. From the App/Service list, select Create custom node. Name the node. Add connections: Select the left (for incoming) or right (for outgoing) arrow icons. Then select the plus icon on your target node. Select Save. Rearrange as needed. To add or remove custom node connections: Mouse over the custom node and select the pencil icon. Select the left (for incoming) or right (for outgoing) arrow icons. To add a connection, select the plus icon. To remove a connection, select the minus icon. Select Save. Move around the map Move around the map by panning or zooming in and out. If you want to... Do this... Pan the map In pan mode, click and drag. In drag-select mode, hold the Alt key, then click and drag. Zoom in and out In either mode, zoom in and out by scrolling the mouse wheel. View your entire map in traffic light mode Zoom out until node details fade out and are replaced by health status colors. Toggle the traffic light view on and off Select Views, then select Traffic light mode. View all the nodes and their dependencies Select Discover your environment. Drill down into more detail from a node Use standard UI functions. Select, arrange, group nodes Click on a node to select it and view its performance summary. You can also select multiple nodes at once, to group and ungroup them: Select nodes To select one node, click on the node. To select multiple nodes: Click the drag-select icon to switch to drag-select mode. Click and drag the mouse to draw a square around the nodes you want to select. OR Hold the Shift key and click on each node you want to select. Arrange nodes Caution Auto-arrange cannot be undone. Consider saving a copy of your map first. To arrange nodes on the map, select one or more node, then drag to a snap point on the map. To automatically organize all your nodes and connections, select Auto-arrange map. Group and ungroup nodes If you want to... Do this... Group nodes together on the map Select two or more nodes, then select Create group. Name your new group Mouse over the group, then select the pencil icon. Rename an existing group Select the pencil icon. Remove nodes from a group Select the group, then select the minus icon for each item you want to remove. Add maps and charts to dashboards one.newrelic.com > Dashboards: adding a service map to a dashboard provides context for the data being reported and where it's coming from. You can add legacy service maps to a dashboard. For example, if you have a dashboard showcasing performance metrics for several entities, adding a service map to the dashboard shows how all the entities are related and provides additional context about your system. To add a service map to a dashboard: Go to one.newrelic.com and select the Explorer. Select an entity from the index. Click on Service map. Click Add to dashboard. Search for the dashboard you want to add the map to. Delete maps To delete a map: Go to one.newrelic.com > More > Service maps > (select a map). Select the map name's pencil icon. Select Delete map. Identify issues with external services If your app connects to an external service that New Relic does not monitor (for example, a third-party API), New Relic watches the service for a week in order to baseline its response time. If New Relic can collect a statistically significant number of data points (more than 100), New Relic compares the current response time to this baseline and uses this to set the health status indicator: Green: Response time from the service is less than 1.75 times the baseline. Yellow: Response time from the service is longer than 1.75 times the baseline. Red: Response time from the service is longer than 2.5 times the baseline. Gray: Alerts concluded it does not have enough data to determine the health status. Purple: Alerts cannot yet conclude if it has enough data to determine the health status. Visualize and monitor complex architectures Use service maps to visualize and monitor complex architectures. For a tutorial introducing the latest features, select the service map's question icon. Nodes Nodes are the basic building blocks for your map. You can add a variety of node types including: Node type Description New Relic APM-monitored app Add your app to the map to view their connections to databases, browser apps, out-of-process services, and other instrumented apps. (In the New Relic UI, your out-of-process services are also referred to as web external or background external data.) Browser apps Automatically detected for each app and added via the incoming connections widget. Only displays browser apps linked to an APM app (standalone browser apps are not supported). New Relic mobile monitoring apps Automatically detected and added via the app/service list panel. Plugins, including Databases Automatically detected for each app and added via the connections widget. Databases in service maps require the same agent versions as the new Database page features. External services Service maps automatically detects external services (visible in the connections widget), to track your app's external dependencies and monitor the health of those connections. Custom nodes Add custom nodes via the app/service list panel to include apps and services not automatically instrumented by New Relic (for example, load balancers, implementation planning, and so on). Group nodes A group node contains multiple other nodes. For apps, group nodes include a summarized health status indicator for all nodes in the group. Node arrangement and grouping Click and drag a node to move it around the map, for a customizable view of your architecture. App nodes can also be grouped together into a single node to better organize related apps and services. Grouped nodes include summarized health status indicator for all nodes in the group. To remove items from a group, mouse over the group and select the pencil pencil icon, then select the minus minus-circle icon to remove the item from the group. Incoming and outgoing connections Service maps automatically detects incoming and outgoing connections based on HTTP calls between entities. Mouse over a node to highlight the node's connections. Widgets at the end of each node display a count of that node's connections, and you can click on those widgets to add related entities to the map: View performance summary Click on an app to view its performance over the last 30 minutes. The chart defaults to Response time, but you can view other metrics by selecting any of the available Apdex, Throughput, or Error rate links. While charts use the last 30 minutes of performance data, the service map as a whole is based on the last five minutes. View the app in APM or browser and view its labels by selecting the overflow ellipsis-v icon. Click the app name again to hide the summary charts, and select the overflow ellipsis-h icon again to hide other details. Map list and app/service list panels Select the Map list panel to: Search for and view your maps, and access other users' shared maps. Create a new map. Select the App/Service List panel to: Add new apps, mobile apps, and plugins to your map. Create custom nodes and add them to the map. Health status and performance metrics You can see health status indicators for most nodes. Except for out-of-process services (external services or background services), entities use the health status indicators used by New Relic Alerts. For out-of-process (external) services, the health status indicator measures the health of the connection to the external service. View all connected apps and services The Discover your environment feature allows you to view all of your apps, services, and dependencies together with a single click. This feature detects all connected applications and services (including externals and databases) to give you a comprehensive view of your overall software architecture environment. To view all connected apps and services: In APM, select Service maps. From your Map list, select Discover your environment to display all of your nodes. Hover over any node to view its dependencies and how it connects to other parts of your service map. Click on individual nodes to zoom in and view their details. The Discover your environment feature may not be available if you are using an older New Relic agent version. See Troubleshooting cross application tracing for version information. This feature may also not be available for highly complex service maps with many elements. Go to one.newrelic.com > More > Service maps > Map list > Discover your environment: Use this option to view all of your nodes and their dependencies in one place. Traffic light mode Traffic light mode lets you view the health status of your entire architecture at a glance. This feature helps you quickly find service and app problems, even within a complex environment with many nodes. To toggle this mode, select the Views tab, then select Traffic light mode. When traffic lights mode is On, zooming out far enough on a service map eventually causes the nodes to switch from displaying textual information, to only health status colors. Click on individual nodes to zoom in and view more details. Traffic light mode is on by default. When traffic lights mode is Off, service map nodes retain their textual information and do not switch to health status colors, No matter how far you zoom out. one.newrelic.com > More > Service maps > Views > Traffic light mode: When traffic light mode is enabled, zooming out of your service map displays nodes in health status colors. Midnight mode Midnight mode inverts the screen's colors, going from a white background to a dark background. Midnight mode reduces eye strain, especially in low light environments. To toggle this mode, select the Views tab, then select Midnight mode.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 514.6139,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Legacy APM <em>service</em> <em>maps</em>",
        "sections": "Legacy APM <em>service</em> <em>maps</em>",
        "tags": "<em>Understand</em> <em>system</em> <em>dependencies</em>",
        "body": "Here is information about using the legacy APM <em>service</em> <em>maps</em> feature to create, customize, and use <em>service</em> <em>maps</em>. For help using the current <em>service</em> <em>maps</em> feature, see How to use <em>service</em> <em>maps</em>. Requirements The legacy <em>service</em> <em>map</em> features in APM <em>depend</em> on your New Relic agent version: Feature"
      },
      "id": "60446a3a28ccbc04a2313970"
    }
  ],
  "/docs/new-relic-one/use-new-relic-one/workloads/use-workloads": [
    {
      "sections": [
        "Introduction to New Relic One",
        "Tip",
        "Quickly understand context",
        "Query your data more easily",
        "Enhanced dashboards",
        "Build on New Relic One",
        "Whatâ€™s next?"
      ],
      "title": "Introduction to New Relic One",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "c9ba93c83a579625a4ba3364c6046f3c475cba3a",
      "image": "https://docs.newrelic.com/static/2bc08b6d64c16b39697bb43d8e66870e/c1b63/nrone20210722.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-10-24T17:36:54Z",
      "updated_at": "2021-10-24T17:36:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic One is the platform that gives you access to core platform capabilities like querying data and building charts, our more curated observability UI experiences features, and our alerting and Applied Intelligence tools. With New Relic One, you can see and act on all the data throughout your entire system. To access New Relic One: Go to one.newrelic.com. Or, if you report data to the EU data center go to one.eu.newrelic.com. Tip Learn more about New Relic Oneâ€™s basic UI features. Quickly understand context We provide multiple ways to understand your system's dependencies, so you can easily see how everything fits together and troubleshoot problems. New Relic One gives you and your teams a connected view that cuts through complexity! If you want to... Use this Have an overall view of your system, and drill down to get performance details. Use the New Relic Explorer as the front door to New Relic One: observe, group, and filter the performance data from all the entities (that is, all applications, services, hosts, or containers) in your system. Gain extensive visibility into each entity in your solution, its alert status, and how the entities are connected. Use the New Relic Navigator to give you a high density overview of all your entities so you can detect any issues at a glance. And use the New Relic Lookout to spot entities recently experiencing behavior deviations. Provide context for your entities. Add tags to all your entities. Or create tags for teams and all the services they monitor. Use tags to illustrate relationships and contextual information for what you monitor. By thoughtfully tagging your entities, you can connect all the data your teams need to understand their increasingly complex and interdependent systems. See how each part of your system is connected. Service maps illustrate your upstream and downstream dependencies. Visualize the aggregated health and activity data from all you monitor. Group and monitor any entities together into functional team-focused, project-focused groupings, or any other attribute, with workloads. Fetch and analyze specific data. Get more context while you query with the query builder, which surfaces data definitions as you craft and edit queries. Create visuals that showcase your business needs at a glance. Tailor custom dashboards for your unique needs. Find a service or dashboard in a complex environment. Search by name across all accounts in the unified search, or filter the explorer by tags or text. View everything youâ€™re monitoring in one place, like entities or dashboards across your organization. View a list of all the dependencies for a service. The dependencies view tab in an entity summary shows all the dependencies of the entity youâ€™re viewing. Track activity as it moves across your distributed system. Distributed tracing helps you analyze your modern environment. Understand how everything is connected via API. The NerdGraph GraphiQL explorer manages all your entities, tags, and relationships. Query your data more easily On the Browse data menu on the top navigation menu you can easily access your basic telemetry data (metrics, events, logs, and traces). Wherever you go in the UI, Query your data is available. No matter your level of proficiency with our query language, you can create custom queries and charts: Browse your data in a query-less experience with our data explorer. Use your NRQL (our query language) expertise to build custom charts in the query builder. Run PromQL-style queries in the query builder. one.newrelic.com > Query your data: Build NRQL and PROMQL-like queries. Enhanced dashboards one.newrelic.com > Dashboards: Quickly create information dense custom views into the data that matters most to you with dashboards in New Relic One. New Relic One dashboards let you build better visualizations more easily, with more options to customize. Dashboard features include: Perform NRQL queries and create charts and dashboards everywhere in the platform using the query builder. Manage your charts and dashboards easily using our quick-access CRUD menus and editing options. Explore and contextualize data with advanced tooltips and zoom in functions to monitor what your systems are doing in real time. Search your dashboards for attributes and metrics. Send data to your dashboards using our agents, integrations, and APIs. Share dashboards or charts as a .pdf, or embed a chart in an external site. Tip If you previously used New Relic Insights to create dashboards, these are available as New Relic One dashboards. Build on New Relic One If custom charts and dashboards don't solve your current challenge, we give you a framework for building React JavaScript applications that: Live on New Relic One, alongside your other New Relic-monitored data. Feature highly tailored visualizations. Display data from any source you want, whether from a New Relic-monitored entity or data from any service or API. And you can use open source apps built by the community, and contribute your own open source apps. To learn more, see New Relic One applications. Whatâ€™s next? To get started understanding how to get around in New Relic One: See what data you have available with the data explorer. Browse your monitored entities with the New Relic Explorer. Use our NerdGraph API to add tags to your data. Learn about dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 356.79605,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "sections": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " easily see how everything fits together and troubleshoot problems. <em>New</em> <em>Relic</em> <em>One</em> gives you and your teams a connected view that cuts through complexity! If you want to... <em>Use</em> this Have an overall view of your system, and drill down to get performance details. <em>Use</em> the <em>New</em> <em>Relic</em> Explorer as the front"
      },
      "id": "603ec19164441f9e704e8896"
    },
    {
      "sections": [
        "Workloads: Isolate and resolve incidents faster",
        "What is a workload in New Relic?",
        "Tip",
        "Why it matters",
        "Requirements",
        "Impact of accounts on the workload permissions and content",
        "Workload account",
        "Scope accounts"
      ],
      "title": "Workloads: Isolate and resolve incidents faster",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "858e74779a209ac0eb948405c311e59a71eb8d9b",
      "image": "https://docs.newrelic.com/static/bb2929677005af573675e7eceead70de/c1b63/1_workload_health_tab.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster/",
      "published_at": "2021-10-24T19:11:37Z",
      "updated_at": "2021-07-30T01:57:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our workloads feature gives you the ability to group and monitor entities based on a team or a set of responsibilities, providing aggregated health and activity data from frontend to backend services across your entire stack. Workloads help you understand the status of complex systems, detect issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a New Relic account for free! No credit card required. What is a workload in New Relic? New Relic monitors a wide range of entities and data, from client-side applications and backend APIs, to the underlying infrastructure. To make sense of this large data set, we give you the ability to create and monitor workloads. Workloads give you the ability to group and monitor entities based on a team or a set of responsibilities, and provide an aggregated view of the health and activity of the entities in the workload. Thus, you can understand better how your business logic is working, from frontend to backend services, across your entire stack. Here are some workload examples: A serverless application that includes an API gateway, a few serverless functions, and a managed database and storage. A browser application and the backend APIs that support it. A collection of Java microservices and the infrastructure they run on. Here's a workload: one.newrelic.com > Explorer > Workloads > (selected workload): The workloads UI provides a curated view of how the entities in your workload are performing. The charts you see will depend on the types of entities you've included to the workload. Tip Learn how to use workloads. Why it matters Workloads give you visibility into the end-to-end availability and consumption of resources across an entire service, and provide you a way to define whatâ€™s relevant to you. You can use workloads to group together entities that are important to a specific team or project, so you can better browse and isolate the most relevant data for that service. Because our UI gives you cross-account access, you can add entities to your workload from any of the accounts you have access to. A workload can include: Any New Relic-monitored entity, including services, browser apps, mobile apps, databases, and hosts. Dashboards. Other workloads: this is useful for complex teams who need to divide and overlap workloads. Requirements Requirements for creating and managing workloads: All users for an account can view that account's workloads. To create, edit, and delete workloads, you must have a user role with that permission. Impact of accounts on the workload permissions and content Workloads can group and display entities from multiple accounts to provide complete observability of complex systems. When creating a workload, you must set: The workload account Scope accounts Learn how to find a New Relic account ID. Workload account The workload account is where any workload-specific data is stored. For example, a workload might generate NrAuditEvent data, and you would find that data by querying the workload account. The workload account determines the user permissions that govern which users can see and manage the workload, through the account roles. Once created, the workload account canâ€™t be changed. Scope accounts Scope accounts are the accounts from which a workload fetches entity data. In other words, the scope accounts provide the content for a workload. Users who donâ€™t have access to all of a workload's scope accounts may not be able to see complete workload data. Scope accounts can be updated at any point in time by any user with workload management capabilities on the workload account. By default, all accounts that the workload creator has access to at the moment of the workload creation are set as scope accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 198.88339,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Workloads</em>: Isolate and resolve incidents faster",
        "sections": "What is a <em>workload</em> in <em>New</em> <em>Relic</em>?",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " of the accounts you have access to. A <em>workload</em> can include: Any <em>New</em> <em>Relic</em>-monitored entity, including services, browser apps, mobile apps, databases, and hosts. Dashboards. Other <em>workloads</em>: this is useful for complex teams who need to divide and overlap <em>workloads</em>. Requirements Requirements for creating"
      },
      "id": "6043cb93196a67f988960f76"
    },
    {
      "sections": [
        "Workload status views and notifications",
        "Why it matters",
        "Get started with workload status",
        "Obtain your workload status",
        "Save views with sets of workloads",
        "Get notified when the workload status changes"
      ],
      "title": "Workload status views and notifications",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "1633f322d9f0c907a9636e0c71aee7a0a38ba85b",
      "image": "https://docs.newrelic.com/static/5ea6d75d1efb047eda59eee3f12e08a9/c1b63/workloads_views.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workload-status-views-notifications/",
      "published_at": "2021-10-24T16:34:27Z",
      "updated_at": "2021-05-10T14:02:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The workload status, which is derived from the alerting status of the entities in your workload, informs you about how your workload is behaving. Why it matters Workload status: Is a quick indicator of how your system is doing, and tells you if you need to take action on any of your workloads in just a glance. Adapts to your needs and to how important each entity is. Allows you to share the status of your workloads. Other teams that depend on your services or infrastructure can learn the status of the workload without them needing to understand your systemâ€™s architecture details, or look at custom dashboards. Get started with workload status New Relic One provides a status value for all entities, which is based on the results of New Relic alerts. You can check the color-coded alert status for each entity on the New Relic Explorer, or consume the alert status value through the API. For example, you may see a red alert status indicating that a critical violation is in progress. With Workloads you can group entities that are part of a complex system and obtain a single, global value that summarizes the status of all the entities in your workload. Thus, you can quickly detect when the workload stops being operational, or anticipate any potential incident or loss of quality of service. Obtain your workload status A workload can have one of the following status values: Operational: The workload is working fine. Degraded: The workload is showing some degradation in performance or errors, but itâ€™s still providing an acceptable level of service, and you donâ€™t need to take any urgent action. Critical or Disrupted: The workload is not providing an acceptable level of service, and you need to take urgent action. Unknown: You havenâ€™t configured how to calculate workload status, or there arenâ€™t any alert conditions set up that can determine the status of the workload entities. To learn how to define or edit the workload status, refer to Workload status configuration. Save views with sets of workloads If you usually need to see the status of a certain group of workloads, you can save views that contain only those workloads. The tile view mode helps you quickly find your workloads and see their status at a glance. To create a view, follow these steps: Go to one.newrelic.com and click on More > Workload views. Click on Add view. Give the view a meaningful name (such as the name of a team or business unit), and select an account to associate the view with. Select the workloads you want to include in the view, by their name or tags. Save the new view. Status views are most useful for teams that are accountable for more than one workload, support roles, and business unit managers. Get notified when the workload status changes You may need to follow the status of a workload, either because it represents the services your team is accountable for, or because your own services depend on that workload, which is managed by another team. The status of all workloads is calculated regularly and the result is stored in NRDB through a WorkloadStatus event. This allows you to set up an alert condition to notify you whenever the Workload goes into a Disrupted or Degraded status. To set up the alert condition follow these steps: Go to one.newrelic.com and select Alerts & AI. Select the policy where you want to add the new alert condition, or create a new policy with the appropriate notification channel. Then click on Create a condition. Where prompted to Select a product, click NRQL. Add the following NRQL query: SELECT latest(statusValueCode) FROM WorkloadStatus WHERE workloadGuid = '<GUID>' FACET workloadGuid as 'entity.guid', entity.name Copy You can obtain the workload GUID by clicking on the See metadata and manage tags on the workload UI. Write the WHERE clause so the alert condition applies to just one workload (as in the example) or more than one. Or remove the WHERE clause if you want the alert condition to apply to all the workloads on the account. By adding the FACET you can use these fields on the alert description, as explained below. Set one of the following static thresholds: (Recommended) Critical when the query returns a value equal to 3 for at least 1 minute, if you want to be notified when the workload status is disrupted. Critical when the query returns a value equal to 2 for at least 1 minute, if you want to be notified when the workload status is degraded. Remember that a warning threshold doesn't generate an incident or send a notification. As a result, you need to create two alert conditions with a critical threshold (as explained above) if you want to be notified of any status change. Complete the alert condition: Set a violation time limit, to automatically force-close a long-lasting violation after the selected amount of time you select. Choose to fill data gaps with last known value. Optionally, you can also add a custom violation description that includes the workload name and permanent link to the UI in the alert notification: Workload: {{tag.entity.name}} Direct link: https://one.newrelic.com/redirect/entity/{{tag.entity.guid}} Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 186.10683,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Workload</em> status views and notifications",
        "sections": "Save views with sets of <em>workloads</em>",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " at custom dashboards. Get started with <em>workload</em> status <em>New</em> <em>Relic</em> <em>One</em> provides a status value for all entities, which is based on the results of <em>New</em> <em>Relic</em> alerts. You can check the color-coded alert status for each entity on the <em>New</em> <em>Relic</em> Explorer, or consume the alert status value through the API"
      },
      "id": "603e967564441ff8cd4e8855"
    }
  ],
  "/docs/new-relic-one/use-new-relic-one/workloads/workload-status-configuration": [
    {
      "sections": [
        "Introduction to New Relic One",
        "Tip",
        "Quickly understand context",
        "Query your data more easily",
        "Enhanced dashboards",
        "Build on New Relic One",
        "Whatâ€™s next?"
      ],
      "title": "Introduction to New Relic One",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "c9ba93c83a579625a4ba3364c6046f3c475cba3a",
      "image": "https://docs.newrelic.com/static/2bc08b6d64c16b39697bb43d8e66870e/c1b63/nrone20210722.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-10-24T17:36:54Z",
      "updated_at": "2021-10-24T17:36:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic One is the platform that gives you access to core platform capabilities like querying data and building charts, our more curated observability UI experiences features, and our alerting and Applied Intelligence tools. With New Relic One, you can see and act on all the data throughout your entire system. To access New Relic One: Go to one.newrelic.com. Or, if you report data to the EU data center go to one.eu.newrelic.com. Tip Learn more about New Relic Oneâ€™s basic UI features. Quickly understand context We provide multiple ways to understand your system's dependencies, so you can easily see how everything fits together and troubleshoot problems. New Relic One gives you and your teams a connected view that cuts through complexity! If you want to... Use this Have an overall view of your system, and drill down to get performance details. Use the New Relic Explorer as the front door to New Relic One: observe, group, and filter the performance data from all the entities (that is, all applications, services, hosts, or containers) in your system. Gain extensive visibility into each entity in your solution, its alert status, and how the entities are connected. Use the New Relic Navigator to give you a high density overview of all your entities so you can detect any issues at a glance. And use the New Relic Lookout to spot entities recently experiencing behavior deviations. Provide context for your entities. Add tags to all your entities. Or create tags for teams and all the services they monitor. Use tags to illustrate relationships and contextual information for what you monitor. By thoughtfully tagging your entities, you can connect all the data your teams need to understand their increasingly complex and interdependent systems. See how each part of your system is connected. Service maps illustrate your upstream and downstream dependencies. Visualize the aggregated health and activity data from all you monitor. Group and monitor any entities together into functional team-focused, project-focused groupings, or any other attribute, with workloads. Fetch and analyze specific data. Get more context while you query with the query builder, which surfaces data definitions as you craft and edit queries. Create visuals that showcase your business needs at a glance. Tailor custom dashboards for your unique needs. Find a service or dashboard in a complex environment. Search by name across all accounts in the unified search, or filter the explorer by tags or text. View everything youâ€™re monitoring in one place, like entities or dashboards across your organization. View a list of all the dependencies for a service. The dependencies view tab in an entity summary shows all the dependencies of the entity youâ€™re viewing. Track activity as it moves across your distributed system. Distributed tracing helps you analyze your modern environment. Understand how everything is connected via API. The NerdGraph GraphiQL explorer manages all your entities, tags, and relationships. Query your data more easily On the Browse data menu on the top navigation menu you can easily access your basic telemetry data (metrics, events, logs, and traces). Wherever you go in the UI, Query your data is available. No matter your level of proficiency with our query language, you can create custom queries and charts: Browse your data in a query-less experience with our data explorer. Use your NRQL (our query language) expertise to build custom charts in the query builder. Run PromQL-style queries in the query builder. one.newrelic.com > Query your data: Build NRQL and PROMQL-like queries. Enhanced dashboards one.newrelic.com > Dashboards: Quickly create information dense custom views into the data that matters most to you with dashboards in New Relic One. New Relic One dashboards let you build better visualizations more easily, with more options to customize. Dashboard features include: Perform NRQL queries and create charts and dashboards everywhere in the platform using the query builder. Manage your charts and dashboards easily using our quick-access CRUD menus and editing options. Explore and contextualize data with advanced tooltips and zoom in functions to monitor what your systems are doing in real time. Search your dashboards for attributes and metrics. Send data to your dashboards using our agents, integrations, and APIs. Share dashboards or charts as a .pdf, or embed a chart in an external site. Tip If you previously used New Relic Insights to create dashboards, these are available as New Relic One dashboards. Build on New Relic One If custom charts and dashboards don't solve your current challenge, we give you a framework for building React JavaScript applications that: Live on New Relic One, alongside your other New Relic-monitored data. Feature highly tailored visualizations. Display data from any source you want, whether from a New Relic-monitored entity or data from any service or API. And you can use open source apps built by the community, and contribute your own open source apps. To learn more, see New Relic One applications. Whatâ€™s next? To get started understanding how to get around in New Relic One: See what data you have available with the data explorer. Browse your monitored entities with the New Relic Explorer. Use our NerdGraph API to add tags to your data. Learn about dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 356.79572,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "sections": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " easily see how everything fits together and troubleshoot problems. <em>New</em> <em>Relic</em> <em>One</em> gives you and your teams a connected view that cuts through complexity! If you want to... <em>Use</em> this Have an overall view of your system, and drill down to get performance details. <em>Use</em> the <em>New</em> <em>Relic</em> Explorer as the front"
      },
      "id": "603ec19164441f9e704e8896"
    },
    {
      "sections": [
        "Workloads: Isolate and resolve incidents faster",
        "What is a workload in New Relic?",
        "Tip",
        "Why it matters",
        "Requirements",
        "Impact of accounts on the workload permissions and content",
        "Workload account",
        "Scope accounts"
      ],
      "title": "Workloads: Isolate and resolve incidents faster",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "858e74779a209ac0eb948405c311e59a71eb8d9b",
      "image": "https://docs.newrelic.com/static/bb2929677005af573675e7eceead70de/c1b63/1_workload_health_tab.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster/",
      "published_at": "2021-10-24T19:11:37Z",
      "updated_at": "2021-07-30T01:57:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our workloads feature gives you the ability to group and monitor entities based on a team or a set of responsibilities, providing aggregated health and activity data from frontend to backend services across your entire stack. Workloads help you understand the status of complex systems, detect issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a New Relic account for free! No credit card required. What is a workload in New Relic? New Relic monitors a wide range of entities and data, from client-side applications and backend APIs, to the underlying infrastructure. To make sense of this large data set, we give you the ability to create and monitor workloads. Workloads give you the ability to group and monitor entities based on a team or a set of responsibilities, and provide an aggregated view of the health and activity of the entities in the workload. Thus, you can understand better how your business logic is working, from frontend to backend services, across your entire stack. Here are some workload examples: A serverless application that includes an API gateway, a few serverless functions, and a managed database and storage. A browser application and the backend APIs that support it. A collection of Java microservices and the infrastructure they run on. Here's a workload: one.newrelic.com > Explorer > Workloads > (selected workload): The workloads UI provides a curated view of how the entities in your workload are performing. The charts you see will depend on the types of entities you've included to the workload. Tip Learn how to use workloads. Why it matters Workloads give you visibility into the end-to-end availability and consumption of resources across an entire service, and provide you a way to define whatâ€™s relevant to you. You can use workloads to group together entities that are important to a specific team or project, so you can better browse and isolate the most relevant data for that service. Because our UI gives you cross-account access, you can add entities to your workload from any of the accounts you have access to. A workload can include: Any New Relic-monitored entity, including services, browser apps, mobile apps, databases, and hosts. Dashboards. Other workloads: this is useful for complex teams who need to divide and overlap workloads. Requirements Requirements for creating and managing workloads: All users for an account can view that account's workloads. To create, edit, and delete workloads, you must have a user role with that permission. Impact of accounts on the workload permissions and content Workloads can group and display entities from multiple accounts to provide complete observability of complex systems. When creating a workload, you must set: The workload account Scope accounts Learn how to find a New Relic account ID. Workload account The workload account is where any workload-specific data is stored. For example, a workload might generate NrAuditEvent data, and you would find that data by querying the workload account. The workload account determines the user permissions that govern which users can see and manage the workload, through the account roles. Once created, the workload account canâ€™t be changed. Scope accounts Scope accounts are the accounts from which a workload fetches entity data. In other words, the scope accounts provide the content for a workload. Users who donâ€™t have access to all of a workload's scope accounts may not be able to see complete workload data. Scope accounts can be updated at any point in time by any user with workload management capabilities on the workload account. By default, all accounts that the workload creator has access to at the moment of the workload creation are set as scope accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 198.88339,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Workloads</em>: Isolate and resolve incidents faster",
        "sections": "What is a <em>workload</em> in <em>New</em> <em>Relic</em>?",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " of the accounts you have access to. A <em>workload</em> can include: Any <em>New</em> <em>Relic</em>-monitored entity, including services, browser apps, mobile apps, databases, and hosts. Dashboards. Other <em>workloads</em>: this is useful for complex teams who need to divide and overlap <em>workloads</em>. Requirements Requirements for creating"
      },
      "id": "6043cb93196a67f988960f76"
    },
    {
      "sections": [
        "Workload status views and notifications",
        "Why it matters",
        "Get started with workload status",
        "Obtain your workload status",
        "Save views with sets of workloads",
        "Get notified when the workload status changes"
      ],
      "title": "Workload status views and notifications",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "1633f322d9f0c907a9636e0c71aee7a0a38ba85b",
      "image": "https://docs.newrelic.com/static/5ea6d75d1efb047eda59eee3f12e08a9/c1b63/workloads_views.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workload-status-views-notifications/",
      "published_at": "2021-10-24T16:34:27Z",
      "updated_at": "2021-05-10T14:02:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The workload status, which is derived from the alerting status of the entities in your workload, informs you about how your workload is behaving. Why it matters Workload status: Is a quick indicator of how your system is doing, and tells you if you need to take action on any of your workloads in just a glance. Adapts to your needs and to how important each entity is. Allows you to share the status of your workloads. Other teams that depend on your services or infrastructure can learn the status of the workload without them needing to understand your systemâ€™s architecture details, or look at custom dashboards. Get started with workload status New Relic One provides a status value for all entities, which is based on the results of New Relic alerts. You can check the color-coded alert status for each entity on the New Relic Explorer, or consume the alert status value through the API. For example, you may see a red alert status indicating that a critical violation is in progress. With Workloads you can group entities that are part of a complex system and obtain a single, global value that summarizes the status of all the entities in your workload. Thus, you can quickly detect when the workload stops being operational, or anticipate any potential incident or loss of quality of service. Obtain your workload status A workload can have one of the following status values: Operational: The workload is working fine. Degraded: The workload is showing some degradation in performance or errors, but itâ€™s still providing an acceptable level of service, and you donâ€™t need to take any urgent action. Critical or Disrupted: The workload is not providing an acceptable level of service, and you need to take urgent action. Unknown: You havenâ€™t configured how to calculate workload status, or there arenâ€™t any alert conditions set up that can determine the status of the workload entities. To learn how to define or edit the workload status, refer to Workload status configuration. Save views with sets of workloads If you usually need to see the status of a certain group of workloads, you can save views that contain only those workloads. The tile view mode helps you quickly find your workloads and see their status at a glance. To create a view, follow these steps: Go to one.newrelic.com and click on More > Workload views. Click on Add view. Give the view a meaningful name (such as the name of a team or business unit), and select an account to associate the view with. Select the workloads you want to include in the view, by their name or tags. Save the new view. Status views are most useful for teams that are accountable for more than one workload, support roles, and business unit managers. Get notified when the workload status changes You may need to follow the status of a workload, either because it represents the services your team is accountable for, or because your own services depend on that workload, which is managed by another team. The status of all workloads is calculated regularly and the result is stored in NRDB through a WorkloadStatus event. This allows you to set up an alert condition to notify you whenever the Workload goes into a Disrupted or Degraded status. To set up the alert condition follow these steps: Go to one.newrelic.com and select Alerts & AI. Select the policy where you want to add the new alert condition, or create a new policy with the appropriate notification channel. Then click on Create a condition. Where prompted to Select a product, click NRQL. Add the following NRQL query: SELECT latest(statusValueCode) FROM WorkloadStatus WHERE workloadGuid = '<GUID>' FACET workloadGuid as 'entity.guid', entity.name Copy You can obtain the workload GUID by clicking on the See metadata and manage tags on the workload UI. Write the WHERE clause so the alert condition applies to just one workload (as in the example) or more than one. Or remove the WHERE clause if you want the alert condition to apply to all the workloads on the account. By adding the FACET you can use these fields on the alert description, as explained below. Set one of the following static thresholds: (Recommended) Critical when the query returns a value equal to 3 for at least 1 minute, if you want to be notified when the workload status is disrupted. Critical when the query returns a value equal to 2 for at least 1 minute, if you want to be notified when the workload status is degraded. Remember that a warning threshold doesn't generate an incident or send a notification. As a result, you need to create two alert conditions with a critical threshold (as explained above) if you want to be notified of any status change. Complete the alert condition: Set a violation time limit, to automatically force-close a long-lasting violation after the selected amount of time you select. Choose to fill data gaps with last known value. Optionally, you can also add a custom violation description that includes the workload name and permanent link to the UI in the alert notification: Workload: {{tag.entity.name}} Direct link: https://one.newrelic.com/redirect/entity/{{tag.entity.guid}} Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 186.10683,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Workload</em> status views and notifications",
        "sections": "Save views with sets of <em>workloads</em>",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " at custom dashboards. Get started with <em>workload</em> status <em>New</em> <em>Relic</em> <em>One</em> provides a status value for all entities, which is based on the results of <em>New</em> <em>Relic</em> alerts. You can check the color-coded alert status for each entity on the <em>New</em> <em>Relic</em> Explorer, or consume the alert status value through the API"
      },
      "id": "603e967564441ff8cd4e8855"
    }
  ],
  "/docs/new-relic-one/use-new-relic-one/workloads/workload-status-views-notifications": [
    {
      "sections": [
        "Introduction to New Relic One",
        "Tip",
        "Quickly understand context",
        "Query your data more easily",
        "Enhanced dashboards",
        "Build on New Relic One",
        "Whatâ€™s next?"
      ],
      "title": "Introduction to New Relic One",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "c9ba93c83a579625a4ba3364c6046f3c475cba3a",
      "image": "https://docs.newrelic.com/static/2bc08b6d64c16b39697bb43d8e66870e/c1b63/nrone20210722.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-10-24T17:36:54Z",
      "updated_at": "2021-10-24T17:36:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic One is the platform that gives you access to core platform capabilities like querying data and building charts, our more curated observability UI experiences features, and our alerting and Applied Intelligence tools. With New Relic One, you can see and act on all the data throughout your entire system. To access New Relic One: Go to one.newrelic.com. Or, if you report data to the EU data center go to one.eu.newrelic.com. Tip Learn more about New Relic Oneâ€™s basic UI features. Quickly understand context We provide multiple ways to understand your system's dependencies, so you can easily see how everything fits together and troubleshoot problems. New Relic One gives you and your teams a connected view that cuts through complexity! If you want to... Use this Have an overall view of your system, and drill down to get performance details. Use the New Relic Explorer as the front door to New Relic One: observe, group, and filter the performance data from all the entities (that is, all applications, services, hosts, or containers) in your system. Gain extensive visibility into each entity in your solution, its alert status, and how the entities are connected. Use the New Relic Navigator to give you a high density overview of all your entities so you can detect any issues at a glance. And use the New Relic Lookout to spot entities recently experiencing behavior deviations. Provide context for your entities. Add tags to all your entities. Or create tags for teams and all the services they monitor. Use tags to illustrate relationships and contextual information for what you monitor. By thoughtfully tagging your entities, you can connect all the data your teams need to understand their increasingly complex and interdependent systems. See how each part of your system is connected. Service maps illustrate your upstream and downstream dependencies. Visualize the aggregated health and activity data from all you monitor. Group and monitor any entities together into functional team-focused, project-focused groupings, or any other attribute, with workloads. Fetch and analyze specific data. Get more context while you query with the query builder, which surfaces data definitions as you craft and edit queries. Create visuals that showcase your business needs at a glance. Tailor custom dashboards for your unique needs. Find a service or dashboard in a complex environment. Search by name across all accounts in the unified search, or filter the explorer by tags or text. View everything youâ€™re monitoring in one place, like entities or dashboards across your organization. View a list of all the dependencies for a service. The dependencies view tab in an entity summary shows all the dependencies of the entity youâ€™re viewing. Track activity as it moves across your distributed system. Distributed tracing helps you analyze your modern environment. Understand how everything is connected via API. The NerdGraph GraphiQL explorer manages all your entities, tags, and relationships. Query your data more easily On the Browse data menu on the top navigation menu you can easily access your basic telemetry data (metrics, events, logs, and traces). Wherever you go in the UI, Query your data is available. No matter your level of proficiency with our query language, you can create custom queries and charts: Browse your data in a query-less experience with our data explorer. Use your NRQL (our query language) expertise to build custom charts in the query builder. Run PromQL-style queries in the query builder. one.newrelic.com > Query your data: Build NRQL and PROMQL-like queries. Enhanced dashboards one.newrelic.com > Dashboards: Quickly create information dense custom views into the data that matters most to you with dashboards in New Relic One. New Relic One dashboards let you build better visualizations more easily, with more options to customize. Dashboard features include: Perform NRQL queries and create charts and dashboards everywhere in the platform using the query builder. Manage your charts and dashboards easily using our quick-access CRUD menus and editing options. Explore and contextualize data with advanced tooltips and zoom in functions to monitor what your systems are doing in real time. Search your dashboards for attributes and metrics. Send data to your dashboards using our agents, integrations, and APIs. Share dashboards or charts as a .pdf, or embed a chart in an external site. Tip If you previously used New Relic Insights to create dashboards, these are available as New Relic One dashboards. Build on New Relic One If custom charts and dashboards don't solve your current challenge, we give you a framework for building React JavaScript applications that: Live on New Relic One, alongside your other New Relic-monitored data. Feature highly tailored visualizations. Display data from any source you want, whether from a New Relic-monitored entity or data from any service or API. And you can use open source apps built by the community, and contribute your own open source apps. To learn more, see New Relic One applications. Whatâ€™s next? To get started understanding how to get around in New Relic One: See what data you have available with the data explorer. Browse your monitored entities with the New Relic Explorer. Use our NerdGraph API to add tags to your data. Learn about dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 356.79572,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "sections": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " easily see how everything fits together and troubleshoot problems. <em>New</em> <em>Relic</em> <em>One</em> gives you and your teams a connected view that cuts through complexity! If you want to... <em>Use</em> this Have an overall view of your system, and drill down to get performance details. <em>Use</em> the <em>New</em> <em>Relic</em> Explorer as the front"
      },
      "id": "603ec19164441f9e704e8896"
    },
    {
      "sections": [
        "Workloads: Isolate and resolve incidents faster",
        "What is a workload in New Relic?",
        "Tip",
        "Why it matters",
        "Requirements",
        "Impact of accounts on the workload permissions and content",
        "Workload account",
        "Scope accounts"
      ],
      "title": "Workloads: Isolate and resolve incidents faster",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "858e74779a209ac0eb948405c311e59a71eb8d9b",
      "image": "https://docs.newrelic.com/static/bb2929677005af573675e7eceead70de/c1b63/1_workload_health_tab.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster/",
      "published_at": "2021-10-24T19:11:37Z",
      "updated_at": "2021-07-30T01:57:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our workloads feature gives you the ability to group and monitor entities based on a team or a set of responsibilities, providing aggregated health and activity data from frontend to backend services across your entire stack. Workloads help you understand the status of complex systems, detect issues, understand the cause and impact of an incident, and resolve those issues quickly. Want to try it? Create a New Relic account for free! No credit card required. What is a workload in New Relic? New Relic monitors a wide range of entities and data, from client-side applications and backend APIs, to the underlying infrastructure. To make sense of this large data set, we give you the ability to create and monitor workloads. Workloads give you the ability to group and monitor entities based on a team or a set of responsibilities, and provide an aggregated view of the health and activity of the entities in the workload. Thus, you can understand better how your business logic is working, from frontend to backend services, across your entire stack. Here are some workload examples: A serverless application that includes an API gateway, a few serverless functions, and a managed database and storage. A browser application and the backend APIs that support it. A collection of Java microservices and the infrastructure they run on. Here's a workload: one.newrelic.com > Explorer > Workloads > (selected workload): The workloads UI provides a curated view of how the entities in your workload are performing. The charts you see will depend on the types of entities you've included to the workload. Tip Learn how to use workloads. Why it matters Workloads give you visibility into the end-to-end availability and consumption of resources across an entire service, and provide you a way to define whatâ€™s relevant to you. You can use workloads to group together entities that are important to a specific team or project, so you can better browse and isolate the most relevant data for that service. Because our UI gives you cross-account access, you can add entities to your workload from any of the accounts you have access to. A workload can include: Any New Relic-monitored entity, including services, browser apps, mobile apps, databases, and hosts. Dashboards. Other workloads: this is useful for complex teams who need to divide and overlap workloads. Requirements Requirements for creating and managing workloads: All users for an account can view that account's workloads. To create, edit, and delete workloads, you must have a user role with that permission. Impact of accounts on the workload permissions and content Workloads can group and display entities from multiple accounts to provide complete observability of complex systems. When creating a workload, you must set: The workload account Scope accounts Learn how to find a New Relic account ID. Workload account The workload account is where any workload-specific data is stored. For example, a workload might generate NrAuditEvent data, and you would find that data by querying the workload account. The workload account determines the user permissions that govern which users can see and manage the workload, through the account roles. Once created, the workload account canâ€™t be changed. Scope accounts Scope accounts are the accounts from which a workload fetches entity data. In other words, the scope accounts provide the content for a workload. Users who donâ€™t have access to all of a workload's scope accounts may not be able to see complete workload data. Scope accounts can be updated at any point in time by any user with workload management capabilities on the workload account. By default, all accounts that the workload creator has access to at the moment of the workload creation are set as scope accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 198.88339,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Workloads</em>: Isolate and resolve incidents faster",
        "sections": "What is a <em>workload</em> in <em>New</em> <em>Relic</em>?",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " of the accounts you have access to. A <em>workload</em> can include: Any <em>New</em> <em>Relic</em>-monitored entity, including services, browser apps, mobile apps, databases, and hosts. Dashboards. Other <em>workloads</em>: this is useful for complex teams who need to divide and overlap <em>workloads</em>. Requirements Requirements for creating"
      },
      "id": "6043cb93196a67f988960f76"
    },
    {
      "sections": [
        "Use workloads",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-10-24T17:36:55Z",
      "updated_at": "2021-06-03T10:04:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are three main tabs (Health, Activity, and Owner) plus the header. The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If youâ€™ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time youâ€™ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, youâ€™ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here's the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. The Owner tab gives you information about the team responsible for the workload. It looks like this: It contains: The team responsible for the workload. You can include more than one team. The workload description. Share the mission of the workload, and the business logic it represents: Is it a web application? An API? A backend process? Fill in any details that are relevant to your team, or to other teams in your organization. Contact information. From the drop-down menu, choose how your team prefers to be contacted. Links to the most relevant resources to operate the workload. Here you can add links to runbooks, code repositories, productivity tools, or anything else related to the workload that you need at hand. Finally, the header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts theyâ€™ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workloadâ€™s dashboard: From a workloadâ€™s Overview page, select a dashboard. Add search terms to filter the dashboard to a view thatâ€™s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 185.99843,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Use</em> <em>workloads</em>",
        "sections": "<em>Use</em> <em>workloads</em>",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " on your organization structure and goals. <em>one</em>.newrelic.com &gt; Explorer &gt; <em>Workloads</em> &gt; Create a <em>workload</em>: When you create a <em>workload</em>, you choose the associated accounts and monitored entities. You can <em>use</em> <em>New</em> <em>Relic</em> <em>One</em> or the NerdGraph API to create a <em>workload</em>. Follow these steps to create a <em>workload</em> using"
      },
      "id": "603e81e8196a67c972a83db1"
    }
  ],
  "/docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster": [
    {
      "sections": [
        "Introduction to New Relic One",
        "Tip",
        "Quickly understand context",
        "Query your data more easily",
        "Enhanced dashboards",
        "Build on New Relic One",
        "Whatâ€™s next?"
      ],
      "title": "Introduction to New Relic One",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "c9ba93c83a579625a4ba3364c6046f3c475cba3a",
      "image": "https://docs.newrelic.com/static/2bc08b6d64c16b39697bb43d8e66870e/c1b63/nrone20210722.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-10-24T17:36:54Z",
      "updated_at": "2021-10-24T17:36:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic One is the platform that gives you access to core platform capabilities like querying data and building charts, our more curated observability UI experiences features, and our alerting and Applied Intelligence tools. With New Relic One, you can see and act on all the data throughout your entire system. To access New Relic One: Go to one.newrelic.com. Or, if you report data to the EU data center go to one.eu.newrelic.com. Tip Learn more about New Relic Oneâ€™s basic UI features. Quickly understand context We provide multiple ways to understand your system's dependencies, so you can easily see how everything fits together and troubleshoot problems. New Relic One gives you and your teams a connected view that cuts through complexity! If you want to... Use this Have an overall view of your system, and drill down to get performance details. Use the New Relic Explorer as the front door to New Relic One: observe, group, and filter the performance data from all the entities (that is, all applications, services, hosts, or containers) in your system. Gain extensive visibility into each entity in your solution, its alert status, and how the entities are connected. Use the New Relic Navigator to give you a high density overview of all your entities so you can detect any issues at a glance. And use the New Relic Lookout to spot entities recently experiencing behavior deviations. Provide context for your entities. Add tags to all your entities. Or create tags for teams and all the services they monitor. Use tags to illustrate relationships and contextual information for what you monitor. By thoughtfully tagging your entities, you can connect all the data your teams need to understand their increasingly complex and interdependent systems. See how each part of your system is connected. Service maps illustrate your upstream and downstream dependencies. Visualize the aggregated health and activity data from all you monitor. Group and monitor any entities together into functional team-focused, project-focused groupings, or any other attribute, with workloads. Fetch and analyze specific data. Get more context while you query with the query builder, which surfaces data definitions as you craft and edit queries. Create visuals that showcase your business needs at a glance. Tailor custom dashboards for your unique needs. Find a service or dashboard in a complex environment. Search by name across all accounts in the unified search, or filter the explorer by tags or text. View everything youâ€™re monitoring in one place, like entities or dashboards across your organization. View a list of all the dependencies for a service. The dependencies view tab in an entity summary shows all the dependencies of the entity youâ€™re viewing. Track activity as it moves across your distributed system. Distributed tracing helps you analyze your modern environment. Understand how everything is connected via API. The NerdGraph GraphiQL explorer manages all your entities, tags, and relationships. Query your data more easily On the Browse data menu on the top navigation menu you can easily access your basic telemetry data (metrics, events, logs, and traces). Wherever you go in the UI, Query your data is available. No matter your level of proficiency with our query language, you can create custom queries and charts: Browse your data in a query-less experience with our data explorer. Use your NRQL (our query language) expertise to build custom charts in the query builder. Run PromQL-style queries in the query builder. one.newrelic.com > Query your data: Build NRQL and PROMQL-like queries. Enhanced dashboards one.newrelic.com > Dashboards: Quickly create information dense custom views into the data that matters most to you with dashboards in New Relic One. New Relic One dashboards let you build better visualizations more easily, with more options to customize. Dashboard features include: Perform NRQL queries and create charts and dashboards everywhere in the platform using the query builder. Manage your charts and dashboards easily using our quick-access CRUD menus and editing options. Explore and contextualize data with advanced tooltips and zoom in functions to monitor what your systems are doing in real time. Search your dashboards for attributes and metrics. Send data to your dashboards using our agents, integrations, and APIs. Share dashboards or charts as a .pdf, or embed a chart in an external site. Tip If you previously used New Relic Insights to create dashboards, these are available as New Relic One dashboards. Build on New Relic One If custom charts and dashboards don't solve your current challenge, we give you a framework for building React JavaScript applications that: Live on New Relic One, alongside your other New Relic-monitored data. Feature highly tailored visualizations. Display data from any source you want, whether from a New Relic-monitored entity or data from any service or API. And you can use open source apps built by the community, and contribute your own open source apps. To learn more, see New Relic One applications. Whatâ€™s next? To get started understanding how to get around in New Relic One: See what data you have available with the data explorer. Browse your monitored entities with the New Relic Explorer. Use our NerdGraph API to add tags to your data. Learn about dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 356.7954,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "sections": "Introduction to <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " easily see how everything fits together and troubleshoot problems. <em>New</em> <em>Relic</em> <em>One</em> gives you and your teams a connected view that cuts through complexity! If you want to... <em>Use</em> this Have an overall view of your system, and drill down to get performance details. <em>Use</em> the <em>New</em> <em>Relic</em> Explorer as the front"
      },
      "id": "603ec19164441f9e704e8896"
    },
    {
      "sections": [
        "Workload status views and notifications",
        "Why it matters",
        "Get started with workload status",
        "Obtain your workload status",
        "Save views with sets of workloads",
        "Get notified when the workload status changes"
      ],
      "title": "Workload status views and notifications",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "1633f322d9f0c907a9636e0c71aee7a0a38ba85b",
      "image": "https://docs.newrelic.com/static/5ea6d75d1efb047eda59eee3f12e08a9/c1b63/workloads_views.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workload-status-views-notifications/",
      "published_at": "2021-10-24T16:34:27Z",
      "updated_at": "2021-05-10T14:02:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The workload status, which is derived from the alerting status of the entities in your workload, informs you about how your workload is behaving. Why it matters Workload status: Is a quick indicator of how your system is doing, and tells you if you need to take action on any of your workloads in just a glance. Adapts to your needs and to how important each entity is. Allows you to share the status of your workloads. Other teams that depend on your services or infrastructure can learn the status of the workload without them needing to understand your systemâ€™s architecture details, or look at custom dashboards. Get started with workload status New Relic One provides a status value for all entities, which is based on the results of New Relic alerts. You can check the color-coded alert status for each entity on the New Relic Explorer, or consume the alert status value through the API. For example, you may see a red alert status indicating that a critical violation is in progress. With Workloads you can group entities that are part of a complex system and obtain a single, global value that summarizes the status of all the entities in your workload. Thus, you can quickly detect when the workload stops being operational, or anticipate any potential incident or loss of quality of service. Obtain your workload status A workload can have one of the following status values: Operational: The workload is working fine. Degraded: The workload is showing some degradation in performance or errors, but itâ€™s still providing an acceptable level of service, and you donâ€™t need to take any urgent action. Critical or Disrupted: The workload is not providing an acceptable level of service, and you need to take urgent action. Unknown: You havenâ€™t configured how to calculate workload status, or there arenâ€™t any alert conditions set up that can determine the status of the workload entities. To learn how to define or edit the workload status, refer to Workload status configuration. Save views with sets of workloads If you usually need to see the status of a certain group of workloads, you can save views that contain only those workloads. The tile view mode helps you quickly find your workloads and see their status at a glance. To create a view, follow these steps: Go to one.newrelic.com and click on More > Workload views. Click on Add view. Give the view a meaningful name (such as the name of a team or business unit), and select an account to associate the view with. Select the workloads you want to include in the view, by their name or tags. Save the new view. Status views are most useful for teams that are accountable for more than one workload, support roles, and business unit managers. Get notified when the workload status changes You may need to follow the status of a workload, either because it represents the services your team is accountable for, or because your own services depend on that workload, which is managed by another team. The status of all workloads is calculated regularly and the result is stored in NRDB through a WorkloadStatus event. This allows you to set up an alert condition to notify you whenever the Workload goes into a Disrupted or Degraded status. To set up the alert condition follow these steps: Go to one.newrelic.com and select Alerts & AI. Select the policy where you want to add the new alert condition, or create a new policy with the appropriate notification channel. Then click on Create a condition. Where prompted to Select a product, click NRQL. Add the following NRQL query: SELECT latest(statusValueCode) FROM WorkloadStatus WHERE workloadGuid = '<GUID>' FACET workloadGuid as 'entity.guid', entity.name Copy You can obtain the workload GUID by clicking on the See metadata and manage tags on the workload UI. Write the WHERE clause so the alert condition applies to just one workload (as in the example) or more than one. Or remove the WHERE clause if you want the alert condition to apply to all the workloads on the account. By adding the FACET you can use these fields on the alert description, as explained below. Set one of the following static thresholds: (Recommended) Critical when the query returns a value equal to 3 for at least 1 minute, if you want to be notified when the workload status is disrupted. Critical when the query returns a value equal to 2 for at least 1 minute, if you want to be notified when the workload status is degraded. Remember that a warning threshold doesn't generate an incident or send a notification. As a result, you need to create two alert conditions with a critical threshold (as explained above) if you want to be notified of any status change. Complete the alert condition: Set a violation time limit, to automatically force-close a long-lasting violation after the selected amount of time you select. Choose to fill data gaps with last known value. Optionally, you can also add a custom violation description that includes the workload name and permanent link to the UI in the alert notification: Workload: {{tag.entity.name}} Direct link: https://one.newrelic.com/redirect/entity/{{tag.entity.guid}} Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 186.10683,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Workload</em> status views and notifications",
        "sections": "Save views with sets of <em>workloads</em>",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " at custom dashboards. Get started with <em>workload</em> status <em>New</em> <em>Relic</em> <em>One</em> provides a status value for all entities, which is based on the results of <em>New</em> <em>Relic</em> alerts. You can check the color-coded alert status for each entity on the <em>New</em> <em>Relic</em> Explorer, or consume the alert status value through the API"
      },
      "id": "603e967564441ff8cd4e8855"
    },
    {
      "sections": [
        "Use workloads",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-10-24T17:36:55Z",
      "updated_at": "2021-06-03T10:04:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are three main tabs (Health, Activity, and Owner) plus the header. The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If youâ€™ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time youâ€™ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, youâ€™ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here's the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. The Owner tab gives you information about the team responsible for the workload. It looks like this: It contains: The team responsible for the workload. You can include more than one team. The workload description. Share the mission of the workload, and the business logic it represents: Is it a web application? An API? A backend process? Fill in any details that are relevant to your team, or to other teams in your organization. Contact information. From the drop-down menu, choose how your team prefers to be contacted. Links to the most relevant resources to operate the workload. Here you can add links to runbooks, code repositories, productivity tools, or anything else related to the workload that you need at hand. Finally, the header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts theyâ€™ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workloadâ€™s dashboard: From a workloadâ€™s Overview page, select a dashboard. Add search terms to filter the dashboard to a view thatâ€™s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 185.99843,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Use</em> <em>workloads</em>",
        "sections": "<em>Use</em> <em>workloads</em>",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " on your organization structure and goals. <em>one</em>.newrelic.com &gt; Explorer &gt; <em>Workloads</em> &gt; Create a <em>workload</em>: When you create a <em>workload</em>, you choose the associated accounts and monitored entities. You can <em>use</em> <em>New</em> <em>Relic</em> <em>One</em> or the NerdGraph API to create a <em>workload</em>. Follow these steps to create a <em>workload</em> using"
      },
      "id": "603e81e8196a67c972a83db1"
    }
  ],
  "/docs/new-relic-partnerships/partner-integration-guide/appendix/version-history": [
    {
      "sections": [
        "Support resources for New Relic partners",
        "Tip",
        "New Relic Support",
        "Documentation",
        "Agent documentation",
        "Agent release notes",
        "Online Technical Community"
      ],
      "title": "Support resources for New Relic partners",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Getting started"
      ],
      "external_id": "56246fb8462659d929766125f8afbbc429f42ee5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/getting-started/support-resources-new-relic-partners/",
      "published_at": "2021-10-24T19:04:24Z",
      "updated_at": "2021-09-08T00:27:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document is for New Relic partners. After you complete your partnership integration, you will be introduced to your technical contacts at New Relic. Use these channels for non-urgent escalations. Tip If you are not a New Relic partner, see New Relic's resources for finding help or filing a support ticket. New Relic Support To obtain support for partner accounts, create a ticket at support.newrelic.com. If you need to call New Relic directly, contact your Business Development representative. Documentation Documentation from New Relic's docs site is an important resource for your support group when providing Level 1 support to your New Relic subscribers. Posting these links on your support pages is an effective way to encourage self help and reduce your support efforts. Top level entry point for New Relic documentation: docs.newrelic.com. From here you can select information about New Relic products and features by category. Tip The docs site includes a Partnerships category with information for New Relic partners and some partnership customers. Here are the five most commonly consulted articles on the New Relic docs site. Providing easily found and direct links to these articles can provide many users with self-serve answers to their questions. Create your New Relic account Name your application Configure the agent Not seeing data Apdex: Measuring user satisfaction Agent documentation Here are links to New Relic documentation categories organized by APM agent languages: Go Java .NET Node.js PHP Python Ruby Agent release notes Here are links to New Relic release notes organized by agent languages: Go Java .NET Node.js PHP Python Ruby Online Technical Community The New Relic Explorers Hub brings together the expertise of New Relic employees, our Partners, and our community regarding all things New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.99316,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Support resources for <em>New</em> <em>Relic</em> <em>partners</em>",
        "sections": "Support resources for <em>New</em> <em>Relic</em> <em>partners</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "This document is for <em>New</em> <em>Relic</em> partners. After you complete your <em>partnership</em> <em>integration</em>, you will be introduced to your technical contacts at <em>New</em> <em>Relic</em>. Use these channels for non-urgent escalations. Tip If you are not a <em>New</em> <em>Relic</em> <em>partner</em>, see <em>New</em> <em>Relic</em>&#x27;s resources for finding help or filing"
      },
      "id": "60450ecf28ccbc45632c6095"
    },
    {
      "sections": [
        "Intro to Partnership API",
        "Requirements",
        "Customer partnership restrictions",
        "Password requirements",
        "Things you can do",
        "Get started"
      ],
      "title": "Intro to Partnership API",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Partner account maintenance"
      ],
      "external_id": "074cf4e7c590dfa2332284a7b7f394e2f7ba45ec",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/partner-account-maintenance/partner-api/",
      "published_at": "2021-10-24T18:56:43Z",
      "updated_at": "2021-09-14T13:44:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Partnership API allows New Relic partners, and New Relic accounts set up as customer partnerships, to manage accounts, users, and subscription-related settings. Requirements The Partnership API can be used by two types of New Relic accounts: partners (managed service providers, resellers) and customer partnerships (larger customers who have been given access to our partnership account structure). These docs are for version 2 of the Partner API. Earlier versions have been deprecated. If you have problems with an older integration, upgrade to version 2. Access to the partnership account structure and the Partnership API requires prior setup and approval by New Relic. Partnership API calls require authentication with both your partnership owner account's REST API key and your Partner ID. Accounts that are genuine New Relic partners (managed service providers, resellers) have no restrictions on using the API. Accounts set up as customer partnerships have restrictions that follow. Customer partnership restrictions If your New Relic organization is set up as a customer partnership, there are some restrictions in place if your organization is on our newer pricing plan or our newer user model. Details: Pricing plan. If youâ€™re on New Relic One pricing, you can't use API calls that govern our original pricing plan. The API impacts are: You can't use the subscription object You can't use the NerdGraph Provisioning API. User model. If your New Relic account has been converted to be entirely on the New Relic One user model, you can no longer use API calls that create or govern users on our original user model. The API impacts are: You can't use the user object. Instead, you'd manage users with these user management docs. For the account object: you can't add users via the users field. Instead, you'd manage users with these user management docs. To determine your pricing plan or user model, see Overview of pricing and user model changes. Password requirements Passwords passed for account creation have these requirements: 8 to 50 characters in length Only contain letters, numbers, or special characters Cannot contain spaces Must contain at least 1 letter Must contain at least 1 number or special character Things you can do Here is an overview of the API's functionality. Account: The account object is what you use to create and update accounts. You can do the following with it: Create new Show Update Cancel Show usage Set primary admin (some accounts) Set subscription (some accounts) There is also a child account object for creating child accounts. Users: Some organizations that meet the requirements can use the user object to: Add user access to account Remove user access from account Subscription: Organizations that meet the requirements and are on our original product pricing plan can use the subscription object to configure various subscription-related traits. Get started To start using the Partnership API, see the Partner API reference docs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.34187,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro to <em>Partnership</em> API",
        "sections": "Intro to <em>Partnership</em> API",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "Our <em>Partnership</em> API allows <em>New</em> <em>Relic</em> partners, and <em>New</em> <em>Relic</em> accounts set up as customer <em>partnerships</em>, to manage accounts, users, and subscription-related settings. Requirements The <em>Partnership</em> API can be used by two types of <em>New</em> <em>Relic</em> accounts: partners (managed service providers, resellers"
      },
      "id": "603ed42328ccbcd4b3eba7ca"
    },
    {
      "sections": [
        "Partnership admin console",
        "Console components",
        "Partnership configuration settings",
        "Customer activity monitoring",
        "State-of-the-Partnership report",
        "Partner customer monitoring",
        "View an arbitrary customer",
        "Viewing detailed customer data"
      ],
      "title": "Partnership admin console",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Getting started"
      ],
      "external_id": "670e4d2e1db957100b23a7b8b0af6bf50cc8c996",
      "image": "https://docs.newrelic.com/static/43369c88523ebf526ae58fa5719d4efe/0abdd/crop-partnership-owner-account-settings.png",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/getting-started/partnership-admin-console/",
      "published_at": "2021-10-24T18:55:04Z",
      "updated_at": "2021-07-02T15:19:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Partnership Admin Console is the interface for managing your customers' accounts and integration with New Relic. To access the console, sign into the partnership owner account, and go to: https://partner-admin-console.newrelic.com/accounts/ACCOUNT_ID/admin_console/ Copy You can also access the console from the New Relic UI: Go to one.newrelic.com > (account dropdown) > Account settings. From the left menu bar, select Partnerships. one.newrelic.com > (account dropdown) > Account settings > Partnerships: Partnership owners can access the Partnership Admin Console from their account settings in the New Relic UI. Console components The Partnership Admin Console has two main components: Partnership configuration settings Customer activity monitoring If multiple partnerships are associated with the New Relic parent account, the menu also includes an option to switch partnership accounts. Partnership configuration settings In developing your integration with New Relic, you must specify a number of settings. For your convenience these settings are grouped together in the partnership console, including URLs for header/footer and various redirects, SSO configuration, andÂ keys and the ability to manipulate them. Customer activity monitoring New Relic provides you with two tools for managing your customers: State-of-the-Partnership reports and live monitoring of all deployed New Relic agents in your partnership. Both of these tools provide insight into your customers who are using New Relic. They can be used to identify up-sale opportunities or to assist your support group in proactive support. State-of-the-Partnership report The State-of-the-Partnership report provides a summary of your customers with New Relic accounts and their activities. The report is broken down by language of the agents deployed, the agent version and the language version for each account. This report is run weekly for each partner. It is available on request from your New Relic Business Development contact. This report is an excellent way to see which of your customers with New Relic accounts are in fact using the service. Partner customer monitoring The Partner customer monitoring facility provides application performance data on the New Relic enabled applications that are running on your service. This facility allows you to easily identify customers experiencing performance problems. Where the performance problems are caused by under capacity, these customers are excellent sales opportunities. Alternatively your support or services organization will find this information useful in pre-emptively identifying customer issues or as good prospects for consulting services. View an arbitrary customer To view activity of a customer that does not appear in any of the filtered views: Go to one.newrelic.com > (account dropdown) > Switch accounts > Other accounts. New Relic will list all of the reporting accounts in the partnership. You can filter or search the list. Viewing detailed customer data Under normal circumstances a partner will be able to see only the summary level data in a customer's New Relic account. Through the Partnership Admin Console, partners will be permitted to drill down to the more detailed presentation. If you want to drill down from the Partnership Admin Console, add your user (typically support@partner.com or something similar) to the account. Typically this will be done at account creation. Avoid provisioning this user as the account Owner.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 122.4169,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> admin console",
        "sections": "<em>Partnership</em> admin console",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "The <em>Partnership</em> Admin Console is the interface for managing your customers&#x27; accounts and <em>integration</em> with <em>New</em> <em>Relic</em>. To access the console, sign into the <em>partnership</em> owner account, and go to: https:&#x2F;&#x2F;<em>partner</em>-admin-console.newrelic.com&#x2F;accounts&#x2F;ACCOUNT_ID&#x2F;admin_console&#x2F; Copy You can also access"
      },
      "id": "603ed3e3196a6735baa83dad"
    }
  ],
  "/docs/new-relic-partnerships/partner-integration-guide/getting-started/co-branding-new-relic-partners": [
    {
      "sections": [
        "Support resources for New Relic partners",
        "Tip",
        "New Relic Support",
        "Documentation",
        "Agent documentation",
        "Agent release notes",
        "Online Technical Community"
      ],
      "title": "Support resources for New Relic partners",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Getting started"
      ],
      "external_id": "56246fb8462659d929766125f8afbbc429f42ee5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/getting-started/support-resources-new-relic-partners/",
      "published_at": "2021-10-24T19:04:24Z",
      "updated_at": "2021-09-08T00:27:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document is for New Relic partners. After you complete your partnership integration, you will be introduced to your technical contacts at New Relic. Use these channels for non-urgent escalations. Tip If you are not a New Relic partner, see New Relic's resources for finding help or filing a support ticket. New Relic Support To obtain support for partner accounts, create a ticket at support.newrelic.com. If you need to call New Relic directly, contact your Business Development representative. Documentation Documentation from New Relic's docs site is an important resource for your support group when providing Level 1 support to your New Relic subscribers. Posting these links on your support pages is an effective way to encourage self help and reduce your support efforts. Top level entry point for New Relic documentation: docs.newrelic.com. From here you can select information about New Relic products and features by category. Tip The docs site includes a Partnerships category with information for New Relic partners and some partnership customers. Here are the five most commonly consulted articles on the New Relic docs site. Providing easily found and direct links to these articles can provide many users with self-serve answers to their questions. Create your New Relic account Name your application Configure the agent Not seeing data Apdex: Measuring user satisfaction Agent documentation Here are links to New Relic documentation categories organized by APM agent languages: Go Java .NET Node.js PHP Python Ruby Agent release notes Here are links to New Relic release notes organized by agent languages: Go Java .NET Node.js PHP Python Ruby Online Technical Community The New Relic Explorers Hub brings together the expertise of New Relic employees, our Partners, and our community regarding all things New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 168.87439,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Support resources for <em>New</em> <em>Relic</em> <em>partners</em>",
        "sections": "Support resources for <em>New</em> <em>Relic</em> <em>partners</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "This document is for <em>New</em> <em>Relic</em> partners. After you complete your <em>partnership</em> <em>integration</em>, you will be introduced to your technical contacts at <em>New</em> <em>Relic</em>. Use these channels for non-urgent escalations. Tip If you are not a <em>New</em> <em>Relic</em> <em>partner</em>, see <em>New</em> <em>Relic</em>&#x27;s resources for finding help or filing"
      },
      "id": "60450ecf28ccbc45632c6095"
    },
    {
      "sections": [
        "Partnership admin console",
        "Console components",
        "Partnership configuration settings",
        "Customer activity monitoring",
        "State-of-the-Partnership report",
        "Partner customer monitoring",
        "View an arbitrary customer",
        "Viewing detailed customer data"
      ],
      "title": "Partnership admin console",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Getting started"
      ],
      "external_id": "670e4d2e1db957100b23a7b8b0af6bf50cc8c996",
      "image": "https://docs.newrelic.com/static/43369c88523ebf526ae58fa5719d4efe/0abdd/crop-partnership-owner-account-settings.png",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/getting-started/partnership-admin-console/",
      "published_at": "2021-10-24T18:55:04Z",
      "updated_at": "2021-07-02T15:19:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Partnership Admin Console is the interface for managing your customers' accounts and integration with New Relic. To access the console, sign into the partnership owner account, and go to: https://partner-admin-console.newrelic.com/accounts/ACCOUNT_ID/admin_console/ Copy You can also access the console from the New Relic UI: Go to one.newrelic.com > (account dropdown) > Account settings. From the left menu bar, select Partnerships. one.newrelic.com > (account dropdown) > Account settings > Partnerships: Partnership owners can access the Partnership Admin Console from their account settings in the New Relic UI. Console components The Partnership Admin Console has two main components: Partnership configuration settings Customer activity monitoring If multiple partnerships are associated with the New Relic parent account, the menu also includes an option to switch partnership accounts. Partnership configuration settings In developing your integration with New Relic, you must specify a number of settings. For your convenience these settings are grouped together in the partnership console, including URLs for header/footer and various redirects, SSO configuration, andÂ keys and the ability to manipulate them. Customer activity monitoring New Relic provides you with two tools for managing your customers: State-of-the-Partnership reports and live monitoring of all deployed New Relic agents in your partnership. Both of these tools provide insight into your customers who are using New Relic. They can be used to identify up-sale opportunities or to assist your support group in proactive support. State-of-the-Partnership report The State-of-the-Partnership report provides a summary of your customers with New Relic accounts and their activities. The report is broken down by language of the agents deployed, the agent version and the language version for each account. This report is run weekly for each partner. It is available on request from your New Relic Business Development contact. This report is an excellent way to see which of your customers with New Relic accounts are in fact using the service. Partner customer monitoring The Partner customer monitoring facility provides application performance data on the New Relic enabled applications that are running on your service. This facility allows you to easily identify customers experiencing performance problems. Where the performance problems are caused by under capacity, these customers are excellent sales opportunities. Alternatively your support or services organization will find this information useful in pre-emptively identifying customer issues or as good prospects for consulting services. View an arbitrary customer To view activity of a customer that does not appear in any of the filtered views: Go to one.newrelic.com > (account dropdown) > Switch accounts > Other accounts. New Relic will list all of the reporting accounts in the partnership. You can filter or search the list. Viewing detailed customer data Under normal circumstances a partner will be able to see only the summary level data in a customer's New Relic account. Through the Partnership Admin Console, partners will be permitted to drill down to the more detailed presentation. If you want to drill down from the Partnership Admin Console, add your user (typically support@partner.com or something similar) to the account. Typically this will be done at account creation. Avoid provisioning this user as the account Owner.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 153.1417,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> admin console",
        "sections": "<em>Partnership</em> admin console",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "The <em>Partnership</em> Admin Console is the interface for managing your customers&#x27; accounts and <em>integration</em> with <em>New</em> <em>Relic</em>. To access the console, sign into the <em>partnership</em> owner account, and go to: https:&#x2F;&#x2F;<em>partner</em>-admin-console.newrelic.com&#x2F;accounts&#x2F;ACCOUNT_ID&#x2F;admin_console&#x2F; Copy You can also access"
      },
      "id": "603ed3e3196a6735baa83dad"
    },
    {
      "sections": [
        "Partner integration requirements",
        "Process",
        "Accelerated process",
        "Typical component tasks"
      ],
      "title": "Partner integration requirements",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Getting started"
      ],
      "external_id": "5df8f0dc281afba95823d8896a55ceec56cd4a8a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/getting-started/partner-integration-requirements/",
      "published_at": "2021-10-24T18:55:04Z",
      "updated_at": "2021-03-16T10:06:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Thank you for your interest in partnering with New Relic. We look forward to providing your customers with powerful, easy-to-use application performance monitoring. This guide explains how to bundle New Relic services with yours. An effective bundling includes technical tasks (such as agent provisioning and console integration) as well as marketing and promotional activities (such as branding and awareness generation). Process To achieve a full and productive integration with New Relic you will need to: What How Integrate your user console with New Relic. Update your user portal to automatically create New Relic accounts and make them available to your customers in a convenient, compelling, co-branded way. Provision the New Relic agent. For your customers to benefit from New Relic, they will need our monitoring agent installed into their apps. Update your provisioning systems to install New Relic automatically. Generate awareness. Integrate and deploy New Relic facilities for displaying sample application reporting data to customers. Establish support and sustaining engineering processes. Agree on a process for support coordination and refresh of New Relic software. Set up communication. Tip: We've found that partners typically complete integration with one to two developer weeks of effort. For more information, see Typical component tasks. Accelerated process Where circumstances and/or proximity permit, we have found that bringing your developers on site to New Relic's San Francisco offices can dramatically accelerate development of your integration. At New Relic's offices your developers will work in close proximity to the engineering team that is responsible for the development and maintenance of New Relic's APIs. Development issues that would under other circumstances require hours or days to resolve can be addressed in minutes. Typically development time for an integration can be cut in half. Should you elect to pursue this option, please talk to your New Relic technical contact. Typical component tasks The checklist for creating a successful integration will vary with each partner and specific circumstances. As a general guide, here's a typical outline of the components and rough sequencing of tasks involved in creating an integration with New Relic. Done Component tasks of a typical partner integration Finalize business relationship. Have introductory conference call or meeting for technical team. Review partner integration documentation and other integration materials. Review roles and responsibilities. Develop integration plan with timeline. Plan account and agent provisioning. Create and deploy account provisioning system. Determine which agents and how to provision. Create and deploy webpages to support provisioning and deployment. Set up test partnership and accounts on New Relic's staging server. Plan for co-branding. Create and deploy CSS. Create and deploy header and footer. Create branded URL (cname). Drive adoption through creating awareness. Add the New Relic widget to the user console. Use data API integration. Test integration on staging. Set up partnership on New Relic's production server. Modify integration to point to production server. Test integration on production. Establish a support plan. Designate support contacts. Introduce New Relic Support to your technical support team. Create sustaining engineering plans. Get test account. Prepare for launch. Walk through integration review and signoff (conference call). Document final signup flow. Coordinate on launch co-marketing and PR. Go live!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.17238,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partner</em> <em>integration</em> requirements",
        "sections": "<em>Partner</em> <em>integration</em> requirements",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": " will vary with each <em>partner</em> and specific circumstances. As a general <em>guide</em>, here&#x27;s a typical outline of the components and rough sequencing of tasks involved in creating an <em>integration</em> with <em>New</em> <em>Relic</em>. Done Component tasks of a typical <em>partner</em> <em>integration</em> Finalize business relationship. Have"
      },
      "id": "603ed3e728ccbcba09eba7b7"
    }
  ],
  "/docs/new-relic-partnerships/partner-integration-guide/getting-started/partner-integration-requirements": [
    {
      "sections": [
        "Support resources for New Relic partners",
        "Tip",
        "New Relic Support",
        "Documentation",
        "Agent documentation",
        "Agent release notes",
        "Online Technical Community"
      ],
      "title": "Support resources for New Relic partners",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Getting started"
      ],
      "external_id": "56246fb8462659d929766125f8afbbc429f42ee5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/getting-started/support-resources-new-relic-partners/",
      "published_at": "2021-10-24T19:04:24Z",
      "updated_at": "2021-09-08T00:27:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document is for New Relic partners. After you complete your partnership integration, you will be introduced to your technical contacts at New Relic. Use these channels for non-urgent escalations. Tip If you are not a New Relic partner, see New Relic's resources for finding help or filing a support ticket. New Relic Support To obtain support for partner accounts, create a ticket at support.newrelic.com. If you need to call New Relic directly, contact your Business Development representative. Documentation Documentation from New Relic's docs site is an important resource for your support group when providing Level 1 support to your New Relic subscribers. Posting these links on your support pages is an effective way to encourage self help and reduce your support efforts. Top level entry point for New Relic documentation: docs.newrelic.com. From here you can select information about New Relic products and features by category. Tip The docs site includes a Partnerships category with information for New Relic partners and some partnership customers. Here are the five most commonly consulted articles on the New Relic docs site. Providing easily found and direct links to these articles can provide many users with self-serve answers to their questions. Create your New Relic account Name your application Configure the agent Not seeing data Apdex: Measuring user satisfaction Agent documentation Here are links to New Relic documentation categories organized by APM agent languages: Go Java .NET Node.js PHP Python Ruby Agent release notes Here are links to New Relic release notes organized by agent languages: Go Java .NET Node.js PHP Python Ruby Online Technical Community The New Relic Explorers Hub brings together the expertise of New Relic employees, our Partners, and our community regarding all things New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 168.87439,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Support resources for <em>New</em> <em>Relic</em> <em>partners</em>",
        "sections": "Support resources for <em>New</em> <em>Relic</em> <em>partners</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "This document is for <em>New</em> <em>Relic</em> partners. After you complete your <em>partnership</em> <em>integration</em>, you will be introduced to your technical contacts at <em>New</em> <em>Relic</em>. Use these channels for non-urgent escalations. Tip If you are not a <em>New</em> <em>Relic</em> <em>partner</em>, see <em>New</em> <em>Relic</em>&#x27;s resources for finding help or filing"
      },
      "id": "60450ecf28ccbc45632c6095"
    },
    {
      "sections": [
        "Partnership admin console",
        "Console components",
        "Partnership configuration settings",
        "Customer activity monitoring",
        "State-of-the-Partnership report",
        "Partner customer monitoring",
        "View an arbitrary customer",
        "Viewing detailed customer data"
      ],
      "title": "Partnership admin console",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Getting started"
      ],
      "external_id": "670e4d2e1db957100b23a7b8b0af6bf50cc8c996",
      "image": "https://docs.newrelic.com/static/43369c88523ebf526ae58fa5719d4efe/0abdd/crop-partnership-owner-account-settings.png",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/getting-started/partnership-admin-console/",
      "published_at": "2021-10-24T18:55:04Z",
      "updated_at": "2021-07-02T15:19:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Partnership Admin Console is the interface for managing your customers' accounts and integration with New Relic. To access the console, sign into the partnership owner account, and go to: https://partner-admin-console.newrelic.com/accounts/ACCOUNT_ID/admin_console/ Copy You can also access the console from the New Relic UI: Go to one.newrelic.com > (account dropdown) > Account settings. From the left menu bar, select Partnerships. one.newrelic.com > (account dropdown) > Account settings > Partnerships: Partnership owners can access the Partnership Admin Console from their account settings in the New Relic UI. Console components The Partnership Admin Console has two main components: Partnership configuration settings Customer activity monitoring If multiple partnerships are associated with the New Relic parent account, the menu also includes an option to switch partnership accounts. Partnership configuration settings In developing your integration with New Relic, you must specify a number of settings. For your convenience these settings are grouped together in the partnership console, including URLs for header/footer and various redirects, SSO configuration, andÂ keys and the ability to manipulate them. Customer activity monitoring New Relic provides you with two tools for managing your customers: State-of-the-Partnership reports and live monitoring of all deployed New Relic agents in your partnership. Both of these tools provide insight into your customers who are using New Relic. They can be used to identify up-sale opportunities or to assist your support group in proactive support. State-of-the-Partnership report The State-of-the-Partnership report provides a summary of your customers with New Relic accounts and their activities. The report is broken down by language of the agents deployed, the agent version and the language version for each account. This report is run weekly for each partner. It is available on request from your New Relic Business Development contact. This report is an excellent way to see which of your customers with New Relic accounts are in fact using the service. Partner customer monitoring The Partner customer monitoring facility provides application performance data on the New Relic enabled applications that are running on your service. This facility allows you to easily identify customers experiencing performance problems. Where the performance problems are caused by under capacity, these customers are excellent sales opportunities. Alternatively your support or services organization will find this information useful in pre-emptively identifying customer issues or as good prospects for consulting services. View an arbitrary customer To view activity of a customer that does not appear in any of the filtered views: Go to one.newrelic.com > (account dropdown) > Switch accounts > Other accounts. New Relic will list all of the reporting accounts in the partnership. You can filter or search the list. Viewing detailed customer data Under normal circumstances a partner will be able to see only the summary level data in a customer's New Relic account. Through the Partnership Admin Console, partners will be permitted to drill down to the more detailed presentation. If you want to drill down from the Partnership Admin Console, add your user (typically support@partner.com or something similar) to the account. Typically this will be done at account creation. Avoid provisioning this user as the account Owner.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 153.1417,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> admin console",
        "sections": "<em>Partnership</em> admin console",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "The <em>Partnership</em> Admin Console is the interface for managing your customers&#x27; accounts and <em>integration</em> with <em>New</em> <em>Relic</em>. To access the console, sign into the <em>partnership</em> owner account, and go to: https:&#x2F;&#x2F;<em>partner</em>-admin-console.newrelic.com&#x2F;accounts&#x2F;ACCOUNT_ID&#x2F;admin_console&#x2F; Copy You can also access"
      },
      "id": "603ed3e3196a6735baa83dad"
    },
    {
      "sections": [
        "Co-branding for New Relic partners",
        "Co-branding example",
        "Headers and footers",
        "Tip",
        "Layouts and styles",
        "Sub-domains"
      ],
      "title": "Co-branding for New Relic partners",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Getting started"
      ],
      "external_id": "62a555ec5ade26eda9c5f40b96ab25873c89da1a",
      "image": "https://docs.newrelic.com/static/9bc57293646e4fe206ffe0a20ce06406/3996e/screen-co-branding-heroku.png",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/getting-started/co-branding-new-relic-partners/",
      "published_at": "2021-10-24T19:13:35Z",
      "updated_at": "2021-03-16T10:06:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Partners who bundle New Relic into their console can \"skin\" New Relic with their own look and feel, including customized layouts, menus, and sub-domains. Co-branding example This example is from Heroku's New Relic integration. In this case Heroku has chosen to use a header only. New Relic partner co-branding example: Here is an example of co-branding with New Relic by using a header. Headers and footers To implement headers and footers: Create a header and/or footer page, consisting of content enclosed in < div> tags. Make sure the pages do not import any CSS or contain any inline CSS. Take any CSS needed for the header and footer, and make it available in a separate CSS file. For example, prepend a custom string such as yourcompany_ to the various style names, to avoid overriding New Relic's standard style definitions. Post the three files to publicly accessible locations hosted by the partner. Use https so your customers do not see any mixed content warnings. For example: https://yourcompany.com/newrelic_header.htm https://yourcompany.com/newrelic_footer.htm https://yourcompany.com/newrelic_styles.css Copy Enter the URLs for the header, footer, and CSS page locations into the appropriate fields in the New Relic Partnership console. Tip To view the headers, log in to one of the accounts in the partnership. Layouts and styles Header and footer layouts and styles are loaded and cached on New Relic's collector servers for insertion into each page output. Updates made to the layout on the partner's site are automatically refreshed hourly. Customized links to the partner's website may be added to the layout. If single sign-on is enabled, the partner may inject customer-specific information into the New Relic user session for use by the layout. For more information, see Single sign on and access control. Sub-domains Partners can optionally display a custom subdomain; for example, yourcompany.newrelic.com, to customers accessing New Relic accounts. To arrange this, contact New Relic's Business Enablement team.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.17238,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Co-branding for <em>New</em> <em>Relic</em> <em>partners</em>",
        "sections": "Co-branding for <em>New</em> <em>Relic</em> <em>partners</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "Partners who bundle <em>New</em> <em>Relic</em> into their console can &quot;skin&quot; <em>New</em> <em>Relic</em> with their own look and feel, including customized layouts, menus, and sub-domains. Co-branding example This example is from Heroku&#x27;s <em>New</em> <em>Relic</em> <em>integration</em>. In this case Heroku has chosen to use a header only. <em>New</em> <em>Relic</em> <em>partner</em>"
      },
      "id": "603ec8b428ccbc9be1eba7a8"
    }
  ]
}