---
componentType: default
headingText: What's next?
---


<ButtonLink
  role="button"
  to="/install/postgresql"
  variant="primary"
>
  Reset the form
</ButtonLink>



## PostgreSQL users and permissions [#users-permissions]

If you also want to obtain table and index-related metrics (for example, table size and index size), the PostgreSQL role used by the integration (`new_relic`) also needs `SELECT` permissions on the tables from which it will gather metrics from. For example, to allow the integration to collect metrics from all the tables and indexes present in the database (in the public `schema`), use the following:

```sql
GRANT SELECT ON ALL TABLES IN SCHEMA public TO new_relic;
```

If you also want to obtain query-level metrics from the PostgreSQL custom query config file, the PostgreSQL role used by the integration (`new_relic`)  needs to be added to the (`pg_read_all_stats`) role. This is due to the user leveraging the (`pg_stat_statements`) extension.

```sql
GRANT pg_read_all_stats TO new_relic;
```

Enabling the `pg_stat_statements` extension may require you to manually create it from a query prompt:

```sql
CREATE EXTENSION pg_stat_statements;
```

## The `postgresql-config.yml` file [#examples]

The `postgresql-config.yml`file is the integration's YAML-format configuration where you can place required login credentials and configure how data is collected. Which options you change depend on your setup and preference. The configuration file has common settings applicable to all integrations, such as `interval`, `timeout`, `inventory_source`.

Specific settings related to PostgreSQL are defined using the env section of the `postgresql-config.yml`file. These settings control the connection to your PostgreSQL instance as well as other security settings and features.

{/* <Callout variant="tip">
  **Enhance your SQL Server tags:** The `labels` section shown in these examples is key to enriching your PostgreSQL Server entities with custom tags. For a comprehensive understanding of how to leverage these tags, including how `label.` prefixed custom attributes from the infrastructure agent can also become tags, and how these tags behave in the UI, refer to our detailed guide on [Enhanced tags for New Relic database entities](/docs/infrastructure/host-integrations/db-entity-tags).
</Callout>

*/}

See these more complex config examples.

<CollapserGroup>
  <Collapser
    id="example-postgresSQL-collection-config"
    title="PostgreSQL configuration collection file"
  >
    * JSON array: Interpreted as a list of database names from which to collect all relevant metrics, including any tables and indexes belonging to that database.

      For example:

      ```yml
      collection_list: '["postgres"]'
      ```

    * JSON object: only entities specified in the object will be collected, no automatic discovery will be performed. The levels of JSON are `database name -> schema name -> table name -> index name`.

      For example:

      ```yml
      collection_list: '{"postgres":{"public":{"pg_table1":["pg_index1","pg_index2"],"pg_table2":[]}}}'
      ```

    * `ALL`: collect metrics for all databases, schemas, tables, and indexes discovered.

      For example:

      ```yml
      collection_list: 'ALL'
      ```

      ```yml
      integrations:
        - name: nri-postgresql
          env:
            USERNAME: postgres
            PASSWORD: pass
            HOSTNAME: psql-sample.localnet
            PORT: 5432
            DATABASE: postgres

            COLLECT_DB_LOCK_METRICS: false
            COLLECTION_LIST: '{"postgres":{"public":{"pg_table1":["pg_index1","pg_index2"],"pg_table2":[]}}}'
            # Enable query performance monitoring by setting its value to true to obtain query monitoring metrics.
            ENABLE_QUERY_MONITORING: 'true'
            # Set the threshold for query response time (in ms) to retrieve individual query performance metrics. Defaults to 1.
            # QUERY_MONITORING_RESPONSE_TIME_THRESHOLD: '1' 
            # The number of records for each query performance metrics - Defaults to 20
            # QUERY_MONITORING_COUNT_THRESHOLD: '20' 
            TIMEOUT:  10
          interval: 15s
          labels:
            env: production
            role: postgresql
          inventory_source: config/postgresql
      ```
  </Collapser>

  <Collapser
    id="example-postgresSQL-managed-db-service-config"
    title="PostgreSQL Azure Flexible and AWS RDS/Aurora configuration file"
  >
    * Azure/AWS SSL Enabled Options: Azure Database for PostgreSQL - Flexible Server requires an SSL connection by default. However, AWS RDS/Aurora instances using PostgreSQL 12 or above may also require SSL if the `require_secure_transport` parameter is set to `ON`. To connect with SSL, set the following options to `true` in your `postgresql-config.yml` file:

      For example:

      ```yml
      ENABLE_SSL: "true"
      TRUST_SERVER_CERTIFICATE: "true"
      ```

    * Azure/AWS SSL Disabled Options: In addition to the settings above, the following SSL settings should be commented out or removed from the config. This is due to the config trusting the server certificate above.

      For example:

      ```yml
      # SSL_ROOT_CERT_LOCATION: /etc/newrelic-infra/root_cert.crt
      # SSL_CERT_LOCATION: /etc/newrelic-infra/postgresql.crt
      # SSL_KEY_LOCATION: /etc/newrelic-infra/postgresql.key
      ```

    * Summary: Once these settings are in place, the complete Azure/AWS config file should look like the one below. Note: the infra agent and Postgresql integration should be installed on a host with network access to the database instances.

      For example:

      ```yml
      integrations:
        - name: nri-postgresql
          env:
            USERNAME: newrelic
            PASSWORD: password
            HOSTNAME: AWS-or-Azure-instance-name
            PORT: 5432
            DATABASE: postgres
            COLLECT_DB_LOCK_METRICS: false
            COLLECTION_LIST: 'ALL'
            # Enable query performance monitoring by setting its value to true to obtain query monitoring metrics.
            ENABLE_QUERY_MONITORING: 'true'
            # Set the threshold for query response time (in ms) to retrieve individual query performance metrics. Defaults to 1.
            # QUERY_MONITORING_RESPONSE_TIME_THRESHOLD: '1' 
            # The number of records for each query performance metrics - Defaults to 20
            # QUERY_MONITORING_COUNT_THRESHOLD: '20' 
            ENABLE_SSL: "true"
            TRUST_SERVER_CERTIFICATE: "true"
            # SSL_ROOT_CERT_LOCATION: /etc/newrelic-infra/root_cert.crt
            # SSL_CERT_LOCATION: /etc/newrelic-infra/postgresql.crt
            # SSL_KEY_LOCATION: /etc/newrelic-infra/postgresql.key
            TIMEOUT:  10
          interval: 15s
          labels:
            env: production
            role: postgresql
          inventory_source: config/postgresql
      ```
  </Collapser>

  <Collapser
    id="example-postgresSQL-SSL-config"
    title="PostgreSQL SSL configuration collection file"
  >
    ```yml
    integrations:
      - name: nri-postgresql
        env:
          USERNAME: postgres
          PASSWORD: pass
          HOSTNAME: psql-sample.localnet
          PORT: 5432
          DATABASE: postgres

          COLLECT_DB_LOCK_METRICS: false
          COLLECTION_LIST: '["postgres"]'
          # Enable query performance monitoring by setting its value to true to obtain query monitoring metrics.
          ENABLE_QUERY_MONITORING: 'true'
          # Set the threshold for query response time (in ms) to retrieve individual query performance metrics. Defaults to 1.
          # QUERY_MONITORING_RESPONSE_TIME_THRESHOLD: '1' 
          # The number of records for each query performance metrics - Defaults to 20
          # QUERY_MONITORING_COUNT_THRESHOLD: '20' 
          ENABLE_SSL: true
          TRUST_SERVER_CERTIFICATE: false
          SSL_ROOT_CERT_LOCATION: /etc/newrelic-infra/root_cert.crt
          SSL_CERT_LOCATION: /etc/newrelic-infra/postgresql.crt
          SSL_KEY_LOCATION: /etc/newrelic-infra/postgresql.key
          TIMEOUT:  10
        interval: 15s
        labels:
          env: production
          role: postgresql
        inventory_source: config/postgresql
    ```
  </Collapser>

  <Collapser
    id="example-postgresSQL-custom-query-config"
    title="PostgreSQL custom query"
  >
    ```yml
    integrations:
      - name: nri-postgresql
        env:
          USERNAME: postgres
          PASSWORD: pass
          HOSTNAME: psql-sample.localnet
          PORT: 5432
          DATABASE: postgres

          COLLECT_DB_LOCK_METRICS: false
          COLLECTION_LIST: ALL
          # Enable query performance monitoring by setting its value to true to obtain query monitoring metrics.
          ENABLE_QUERY_MONITORING: 'true'
          # Set the threshold for query response time (in ms) to retrieve individual query performance metrics. Defaults to 1.
          # QUERY_MONITORING_RESPONSE_TIME_THRESHOLD: '1' 
          # The number of records for each query performance metrics - Defaults to 20
          # QUERY_MONITORING_COUNT_THRESHOLD: '20'
          CUSTOM_METRICS_QUERY: >-
            select
              'rows_inserted' as "metric_name",
              'delta' as "metric_type",
              sd.tup_inserted as "metric_value",
              sd.datid as "database_id"
              from pg_stat_database sd;
          TIMEOUT:  10
        interval: 15s
        labels:
          env: production
          role: postgresql
        inventory_source: config/postgresql
    ```
  </Collapser>

  <Collapser
    id="example-postgresSQL-custom-query-config-file"
    title="PostgreSQL custom query config file"
  >
    An additional YAML configuration file with one or more custom SQL can be defined and the integration will need the path to the file in the CUSTOM_METRICS_CONFIG parameter.

    * postgresql-config.yml

      ```yml
      integrations:
        - name: nri-postgresql
          env:
            USERNAME: postgres
            PASSWORD: pass
            HOSTNAME: psql-sample.localnet
            PORT: 5432
            DATABASE: postgres

            COLLECT_DB_LOCK_METRICS: false
            COLLECTION_LIST: ALL
            # Enable query performance monitoring by setting its value to true to obtain query monitoring metrics.
            ENABLE_QUERY_MONITORING: 'true'
            # Set the threshold for query response time (in ms) to retrieve individual query performance metrics. Defaults to 1.
            # QUERY_MONITORING_RESPONSE_TIME_THRESHOLD: '1' 
            # The number of records for each query performance metrics - Defaults to 20
            # QUERY_MONITORING_COUNT_THRESHOLD: '20'
            CUSTOM_METRICS_CONFIG: "path/to/postgresql-custom-query.yml"
            TIMEOUT:  10
          interval: 15s
          labels:
            env: production
            role: postgresql
          inventory_source: config/postgresql
      ```

    * postgresql-custom-query.yml

      ```yml
      ---
      queries:

        # Metric names are set to the column names in the query results
        - query: >-
            SELECT
            BG.checkpoints_timed AS scheduled_checkpoints_performed,
            BG.checkpoints_req AS requested_checkpoints_performed,
            BG.buffers_checkpoint AS buffers_written_during_checkpoint,
            BG.buffers_clean AS buffers_written_by_background_writer,
            BG.maxwritten_clean AS background_writer_stops,
            BG.buffers_backend AS buffers_written_by_backend,
            BG.buffers_alloc AS buffers_allocated
            FROM pg_stat_bgwriter BG;

          # database defaults to the auth database in the main config
          database: new_frontier_config_dev

          # If not set explicitly here, metric type will default to
          # 'gauge' for numbers and 'attribute' for strings
          metric_types:
            buffers_allocated: rate

          # If unset, sample_name defaults to PostgresqlCustomSample
          sample_name: MyCustomSample
      ```
  </Collapser>
</CollapserGroup>

<Callout variant="tip">

  If you've enabled query performance monitoring but aren't seeing data, check your response time threshold. Only queries with a response time exceeding the `QUERY_MONITORING_RESPONSE_TIME_THRESHOLD` are sent to New Relic. Try lowering this value to capture data from faster queries.

</Callout>

For more about the general structure of on-host integration configuration, see [On-host integration configuration overview](/docs/integrations/integrations-sdk/file-specifications/host-integration-configuration-overview).

## Metrics collected by the integration [#metrics]

The PostgreSQL integration collects the following metrics. Some metric names are prefixed with a category indicator and a period, such as `db.` or `index.`.

<CollapserGroup>
  <Collapser
    id="databaseSample"
    title="PostgresqlDatabaseSample metrics"
  >
    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            PostgreSQLDatabaseSample attributes
          </th>

          <th>
            Description
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `db.connections`
          </td>

          <td>
            Number of backends currently connected to this database.
          </td>
        </tr>

        <tr>
          <td>
            `db.maxconnections`
          </td>

          <td>
            The maximum number of concurrent connections to the database server.
          </td>
        </tr>

        <tr>
          <td>
            `db.commitsPerSecond`
          </td>

          <td>
            Committed transactions per second.
          </td>
        </tr>

        <tr>
          <td>
            `db.rollbacksPerSecond`
          </td>

          <td>
            Transactions rolled back per second.
          </td>
        </tr>

        <tr>
          <td>
            `db.readsPerSecond`
          </td>

          <td>
            Number of disk blocks read in this database per second.
          </td>
        </tr>

        <tr>
          <td>
            `db.bufferHitsPerSecond`
          </td>

          <td>
            Number of times disk blocks were found already in the buffer cache, so that a read was not necessary. This only includes hits in the PostgreSQL buffer cache, not the operating system's file system cache.
          </td>
        </tr>

        <tr>
          <td>
            `db.rowsReturnedPerSecond`
          </td>

          <td>
            Rows returned by queries per second.
          </td>
        </tr>

        <tr>
          <td>
            `db.rowsFetchedPerSecond`
          </td>

          <td>
            Rows fetched by queries per second.
          </td>
        </tr>

        <tr>
          <td>
            `db.rowsInsertedPerSecond`
          </td>

          <td>
            Rows inserted per second.
          </td>
        </tr>

        <tr>
          <td>
            `db.rowsUpdatedPerSecond`
          </td>

          <td>
            Rows updated per second.
          </td>
        </tr>

        <tr>
          <td>
            `db.rowsDeletedPerSecond`
          </td>

          <td>
            Rows deleted per second.
          </td>
        </tr>

        <tr>
          <td>
            `db.conflicts.tablespacePerSecond`
          </td>

          <td>
            Number of queries in this database that have been canceled due to dropped tablespaces.
          </td>
        </tr>

        <tr>
          <td>
            `db.conflicts.locksPerSecond`
          </td>

          <td>
            Number of queries in this database that have been canceled due to lock timeouts.
          </td>
        </tr>

        <tr>
          <td>
            `db.conflicts.snapshotPerSecond`
          </td>

          <td>
            Number of queries in this database that have been canceled due to old snapshots.
          </td>
        </tr>

        <tr>
          <td>
            `db.conflicts.bufferpinPerSecond`
          </td>

          <td>
            Number of queries in this database that have been canceled due to pinned buffers.
          </td>
        </tr>

        <tr>
          <td>
            `db.conflicts.deadlockPerSecond`
          </td>

          <td>
            Number of queries in this database that have been canceled due to deadlocks.
          </td>
        </tr>

        <tr>
          <td>
            `db.tempFilesCreatedPerSecond`
          </td>

          <td>
            Number of temporary files created by queries in this database. All temporary files are counted, regardless of why the temporary file was created (for example, sorting or hashing), and regardless of the `log_temp_files` setting.
          </td>
        </tr>

        <tr>
          <td>
            `db.tempWrittenInBytesPerSecond`
          </td>

          <td>
            Total amount of data written to temporary files by queries in this database. All temporary files are counted, regardless of why the temporary file was created, and regardless of the `log_temp_files` setting.
          </td>
        </tr>

        <tr>
          <td>
            `db.deadlocksPerSecond`
          </td>

          <td>
            Number of deadlocks detected in this database.
          </td>
        </tr>

        <tr>
          <td>
            `db.readTimeInMillisecondsPerSecond`
          </td>

          <td>
            Time spent reading data file blocks by backends in this database, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `db.writeTimeInMillisecondsPerSecond`
          </td>

          <td>
            Time spent writing data file blocks by backends in this database, in milliseconds.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="indexSample"
    title="PostgresqlIndexSample metrics"
  >
    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            PostgreSQLIndexSample attributes
          </th>

          <th>
            Description
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `index.sizeInBytes`
          </td>

          <td>
            The size of an index.
          </td>
        </tr>

        <tr>
          <td>
            `index.rowsReadPerSecond`
          </td>

          <td>
            The number of index entries returned by scans on this index.
          </td>
        </tr>

        <tr>
          <td>
            `index.rowsFetchedPerSecond`
          </td>

          <td>
            The number of index entries fetched by scans on this index.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="instanceSample"
    title="PostgresqlInstanceSample metrics"
  >
    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            PostgreSQLInstanceSample attributes
          </th>

          <th>
            Description
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `bgwriter.checkpointsScheduledPerSecond`
          </td>

          <td>
            Number of scheduled checkpoints that have been performed.
          </td>
        </tr>

        <tr>
          <td>
            `bgwriter.checkpointsRequestedPerSecond`
          </td>

          <td>
            Number of requested checkpoints that have been performed.
          </td>
        </tr>

        <tr>
          <td>
            `bgwriter.buffersWrittenForCheckpointsPerSecond`
          </td>

          <td>
            Number of buffers written during checkpoints.
          </td>
        </tr>

        <tr>
          <td>
            `bgwriter.buffersWrittenByBackgroundWriterPerSecond`
          </td>

          <td>
            Number of buffers written by the background writer.
          </td>
        </tr>

        <tr>
          <td>
            `bgwriter.backgroundWriterStopsPerSecond`
          </td>

          <td>
            Number of times the background writer stopped a cleaning scan because it had written too many buffers.
          </td>
        </tr>

        <tr>
          <td>
            `bgwriter.buffersWrittenByBackendPerSecond`
          </td>

          <td>
            Number of buffers written directly by a backend.
          </td>
        </tr>

        <tr>
          <td>
            `bgwriter.buffersAllocatedPerSecond`
          </td>

          <td>
            Number of buffers allocated.
          </td>
        </tr>

        <tr>
          <td>
            `bgwriter.backendFsyncCallsPerSecond`
          </td>

          <td>
            Number of times a backend had to execute its own `fsync` call. Normally the background writer handles them even when the backend does its own write.
          </td>
        </tr>

        <tr>
          <td>
            `bgwriter.checkpointWriteTimeInMillisecondsPerSecond`
          </td>

          <td>
            Total amount of time that has been spent in the portion of checkpoint processing where files are written to disk, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `bgwriter.checkpointSyncTimeInMillisecondsPerSecond`
          </td>

          <td>
            Total amount of time that has been spent in the portion of checkpoint processing where files are synchronized to disk, in milliseconds.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="tableSample"
    title="PostgresqlTableSample metrics"
  >
    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            PostgreSQLTableSample attributes
          </th>

          <th>
            Description
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `table.totalSizeInBytes`
          </td>

          <td>
            The total disk space used by the table, including indexes and TOAST data.
          </td>
        </tr>

        <tr>
          <td>
            `table.indexSizeInBytes`
          </td>

          <td>
            The total disk space used by indexes attached to the specified table.
          </td>
        </tr>

        <tr>
          <td>
            `table.liveRows`
          </td>

          <td>
            Number of live rows.
          </td>
        </tr>

        <tr>
          <td>
            `table.deadRows`
          </td>

          <td>
            Number of dead rows.
          </td>
        </tr>

        <tr>
          <td>
            `table.indexBlocksReadPerSecond`
          </td>

          <td>
            The number of disk blocks read from all indexes on this table.
          </td>
        </tr>

        <tr>
          <td>
            `table.indexBlocksHitPerSecond`
          </td>

          <td>
            The number of buffer hits in all indexes on this table.
          </td>
        </tr>

        <tr>
          <td>
            `table.indexToastBlocksReadPerSecond`
          </td>

          <td>
            The number of disk blocks read from this table's TOAST table index.
          </td>
        </tr>

        <tr>
          <td>
            `table.indexToastBlocksHitPerSecond`
          </td>

          <td>
            The number of buffer hits in this table's TOAST table index.
          </td>
        </tr>

        <tr>
          <td>
            `table.lastVacuum`
          </td>

          <td>
            Time of last vacuum on table.
          </td>
        </tr>

        <tr>
          <td>
            `table.lastAutoVacuum`
          </td>

          <td>
            Time of last automatic vacuum on table.
          </td>
        </tr>

        <tr>
          <td>
            `table.lastAnalyze`
          </td>

          <td>
            Time of last analyze on table.
          </td>
        </tr>

        <tr>
          <td>
            `table.lastAutoAnalyze`
          </td>

          <td>
            Time of last automatic analyze on table.
          </td>
        </tr>

        <tr>
          <td>
            `table.sequentialScansPerSecond`
          </td>

          <td>
            Number of sequential scans initiated on this table per second.
          </td>
        </tr>

        <tr>
          <td>
            `table.sequentialScanRowsFetchedPerSecond`
          </td>

          <td>
            Number of live rows fetched by sequential scans per second.
          </td>
        </tr>

        <tr>
          <td>
            `table.indexScansPerSecond`
          </td>

          <td>
            Number of index scans initiated on this table.
          </td>
        </tr>

        <tr>
          <td>
            `table.indexScanRowsFetchedPerSecon`
          </td>

          <td>
            Number of live rows fetched by index scans.
          </td>
        </tr>

        <tr>
          <td>
            `table.rowsInsertedPerSecond`
          </td>

          <td>
            Rows inserted per second.
          </td>
        </tr>

        <tr>
          <td>
            `table.rowsUpdatedPerSecond`
          </td>

          <td>
            Rows updated per second.
          </td>
        </tr>

        <tr>
          <td>
            `table.rowsDeletedPerSecond`
          </td>

          <td>
            Rows deleted per second.
          </td>
        </tr>

        <tr>
          <td>
            `table.bloatSizeInBytes`
          </td>

          <td>
            Size of bloat in bytes.
          </td>
        </tr>

        <tr>
          <td>
            `table.dataSizeInBytes`
          </td>

          <td>
            Size of disk spaced used by the main fork of the table.
          </td>
        </tr>

        <tr>
          <td>
            `table.bloatRatio`
          </td>

          <td>
            Fraction of table data size that is bloat.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="pgBouncerSample"
    title="PgBouncerSample metrics"
  >
    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            PgBouncerSample attributes
          </th>

          <th>
            Description
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `pgbouncer.stats.transactionsPerSecond`
          </td>

          <td>
            The transaction rate.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.stats.queriesPerSecond`
          </td>

          <td>
            The query rate.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.stats.bytesInPerSecond`
          </td>

          <td>
            The total network traffic received.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.stats.bytesOutPerSecond`
          </td>

          <td>
            The total network traffic sent.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.stats.totalTransactionDurationInMillisecondsPerSecond`
          </td>

          <td>
            Time spent by `pgbouncer` in transaction.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.stats.totalQueryDurationInMillisecondsPerSecond`
          </td>

          <td>
            Time spent by `pgbouncer` actively querying PostgreSQL.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.stats.avgTransactionCount`
          </td>

          <td>
            The average number of transactions per second in last stat period.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.stats.avgTransactionDurationInMilliseconds`
          </td>

          <td>
            The average transaction duration.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.stats.avgQueryCount`
          </td>

          <td>
            The average number of queries per second in last stat period.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.stats.avgBytesIn`
          </td>

          <td>
            The client network traffic received.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.stats.avgBytesOut`
          </td>

          <td>
            The client network traffic sent.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.stats.avgQueryDurationInMilliseconds`
          </td>

          <td>
            The average query duration.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.pools.clientConnectionsActive`
          </td>

          <td>
            Client connections linked to server connection and able to process queries.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.pools.clientConnectionsWaiting`
          </td>

          <td>
            Client connections waiting on a server connection.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.pools.clientConnectionsWaitingCancelReq`
          </td>

          <td>
            Client connections that have not forwarded query cancellations to the server yet.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.pools.clientConnectionsActiveCancelReq`
          </td>

          <td>
            Client connections that have forwarded query cancellations to the server and are waiting for the server response.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.pools.serverConnectionsActiveCancel`
          </td>

          <td>
            Server connections that are currently forwarding a cancel request.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.pools.serverConnectionsBeingCancel`
          </td>

          <td>
            Servers that normally could become idle but are waiting to do so until all in-flight cancel requests have completed that were sent to cancel a query on this server.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.pools.serverConnectionsActive`
          </td>

          <td>
            Server connections linked to a client connection.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.pools.serverConnectionsIdle`
          </td>

          <td>
            Server connections idle and ready for a client query.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.pools.serverConnectionsUsed`
          </td>

          <td>
            Server connections idle more than `server_check_delay`, needing `server_check_query`.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.pools.serverConnectionsTested`
          </td>

          <td>
            Server connections currently running either `server_reset_query` or `server_check_query`.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.pools.serverConnectionsLogin`
          </td>

          <td>
            Server connections currently in the process of logging in.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.pools.maxwaitInMilliseconds`
          </td>

          <td>
            Age of oldest unserved client connection.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>
</CollapserGroup>

## Metrics collected by the query monitoring [#metrics]

The PostgreSQL query monitoring integration collects the following metrics

<CollapserGroup>
  <Collapser
    id="slowQueries"
    title="PostgresSlowQueries metrics"
  >
    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            PostgresSlowQueries attributes
          </th>

          <th>
            Description
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `query_id`
          </td>

          <td>
            The unique identifier for each query.
          </td>
        </tr>

        <tr>
          <td>
            `query_text`
          </td>

          <td>
            Contains the normalized and anonymized version of the SQL query where literal values are replaced with placeholders.
          </td>
        </tr>

        <tr>
          <td>
            `database_name`
          </td>

          <td>
            The name of the database where the query is run.
          </td>
        </tr>

        <tr>
          <td>
            `schema_name`
          </td>

          <td>
            The schema involved in the query.
          </td>
        </tr>

        <tr>
          <td>
            `execution_count`
          </td>

          <td>
            The number of times the query is run.
          </td>
        </tr>

        <tr>
          <td>
            `avg_elapsed_time_ms`
          </td>

          <td>
            The average time to run in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `avg_disk_reads`
          </td>

          <td>
            The average number of disk reads performed by the query.
          </td>
        </tr>

        <tr>
          <td>
            `avg_disk_writes`
          </td>

          <td>
            The average number of disk writes performed by the query.
          </td>
        </tr>

        <tr>
          <td>
            `statement_type`
          </td>

          <td>
            The type of SQL statement (e.g., SELECT, INSERT).
          </td>
        </tr>

        <tr>
          <td>
            `collection_timestamp`
          </td>

          <td>
            The timestamp that indicates when the data is collected.
          </td>
        </tr>

      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="waitEvents"
    title="PostgresWaitEvents metrics"
  >
    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            PostgresWaitEvents attributes
          </th>

          <th>
            Description
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `wait_event_name`
          </td>

          <td>
            The name of the wait event encountered.
          </td>
        </tr>

        <tr>
          <td>
            `wait_category`
          </td>

          <td>
            The category of the wait event.
          </td>
        </tr>

        <tr>
          <td>
            `total_wait_time_ms`
          </td>

          <td>
            The total time spent on the wait event, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `collection_timestamp`
          </td>

          <td>
            The timestamp when the data was collected.
          </td>
        </tr>

        <tr>
          <td>
            `query_id`
          </td>

          <td>
            The unique identifier for each query.
          </td>
        </tr>

        <tr>
          <td>
            `query_text`
          </td>

          <td>
            Contains the normalized and anonymized version of the SQL query where literal values are replaced with placeholders.
          </td>
        </tr>

         <tr>
          <td>
            `database_name`
          </td>

          <td>
            The name of the database where the query ran.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="blockingSessions"
    title="PostgresBlockingSessions metrics"
  >
    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            PostgresBlockingSessions attributes
          </th>

          <th>
            Description
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `blocked_pid`
          </td>

          <td>
            The Process ID of the blocked query.
          </td>
        </tr>

        <tr>
          <td>
            `blocked_query`
          </td>

          <td>
            Contains the anonymized version of the SQL query where literal values are replaced with placeholders.
          </td>
        </tr>

        <tr>
          <td>
            `blocked_query_id`
          </td>

          <td>
            The unique identifier for the blocked query.
          </td>
        </tr>

        <tr>
          <td>
            `blocked_query_start`
          </td>

          <td>
            The time at which the blocked query is started.
          </td>
        </tr>

        <tr>
          <td>
            `database_name`
          </td>

          <td>
            The name of the database in which blocking occurs.
          </td>
        </tr>

        <tr>
          <td>
            `blocking_query`
          </td>

          <td>
            Contains the anonymized version of the SQL query where literal values are replaced with placeholders.
          </td>
        </tr>

        <tr>
          <td>
            `blocking_pid`
          </td>

          <td>
            The process ID of the query causing the block.
          </td>
        </tr>

        <tr>
          <td>
            `blocking_query_id`
          </td>

          <td>
            The unique identifier of the query causing the block.
          </td>
        </tr>

        <tr>
          <td>
            `blocking_query_start`
          </td>

          <td>
            The time at which blocking query was executed.
          </td>
        </tr>

      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="individualQueries"
    title="PostgresIndividualQueries metrics"
  >
    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            PostgresIndividualQueries attributes
          </th>

          <th>
            Description
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `query_id`
          </td>

          <td>
            The unique identifier for a query.
          </td>
        </tr>

        <tr>
          <td>
            `query_text`
          </td>

          <td>
            Contains the normalized and anonymized version of the SQL query where literal values are replaced with placeholders.
          </td>
        </tr>

        <tr>
          <td>
            `database_name`
          </td>

          <td>
            The name of the database where the query was run.
          </td>
        </tr>

        <tr>
          <td>
            `cpu_time_ms`
          </td>

          <td>
            The CPU time used by the query, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `exec_time_ms`
          </td>

          <td>
            The execution time in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `plan_id`
          </td>

          <td>
            The query identifier for the plan.
          </td>
        </tr>

      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="executionPlan"
    title="PostgresExecutionPlanMetrics metrics"
  >
    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            PostgresExecutionPlanMetrics attributes
          </th>

          <th>
            Description
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `node_type`
          </td>

          <td>
            The type of operation performed at a node in the plan.
          </td>
        </tr>

        <tr>
          <td>
            `parallel_aware`
          </td>

          <td>
            Indicates if the node supports parallel operation.
          </td>
        </tr>

        <tr>
          <td>
            `async_capable`
          </td>

          <td>
            Indicates if the node can perform asynchronous operations.
          </td>
        </tr>

        <tr>
          <td>
            `scan_direction`
          </td>

          <td>
            The direction of scanning such as, forward or backward.
          </td>
        </tr>

        <tr>
          <td>
            `index_name`
          </td>

          <td>
            The name of the index used in the plan, if applicable.
          </td>
        </tr>

        <tr>
          <td>
            `relation_name`
          </td>

          <td>
            The name of the table or relation involved in the operation.
          </td>
        </tr>

        <tr>
          <td>
            `alias`
          </td>

          <td>
            The alias used in the query for the relation.
          </td>
        </tr>

        <tr>
          <td>
            `startup_cost`
          </td>

          <td>
            The estimated cost to start the node operation.
          </td>
        </tr>

        <tr>
          <td>
            `total_cost`
          </td>

          <td>
            The estimated total cost to complete the node operation.
          </td>
        </tr>

        <tr>
          <td>
            `plan_rows`
          </td>

          <td>
            The estimated number of rows this plan node returns.
          </td>
        </tr>

        <tr>
          <td>
            `plan_width`
          </td>

          <td>
            The estimated average width of rows this node output in bytes.
          </td>
        </tr>

        <tr>
          <td>
            `rows_removed_by_filter`
          </td>

          <td>
            The number of rows removed from this node by filters.
          </td>
        </tr>

        <tr>
          <td>
            `database_name`
          </td>

          <td>
            The name of the database where the query runs.
          </td>
        </tr>

        <tr>
          <td>
            `query_id`
          </td>

          <td>
            The unique identifier for the particular query operation.
          </td>
        </tr>

        <tr>
          <td>
            `plan_id`
          </td>

          <td>
            The identifier for this specific plan.
          </td>
        </tr>

        <tr>
          <td>
            `level_id`
          </td>

          <td>
            The depth or level of the node in the plan hierarchy.
          </td>
        </tr>

      </tbody>
    </table>
  </Collapser>
</CollapserGroup>