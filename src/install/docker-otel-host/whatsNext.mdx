---
headingText: Metrics collected
componentType: default
---

## Metric data [#docker-metrics]

The OpenTelemetry Collector Contrib's [dockerstatsreceiver](https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/receiver/dockerstatsreceiver) collects the following metrics from the Docker Stats API:

<CollapserGroup>
<Collapser
id="docker-metrics"
title="Metrics"
>
<table>
<thead>
<tr>
<th style={{ width: "350px" }}>
Metric
</th>
<th>
Description
</th>
<th>
Type
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
`container.blockio.io_merged_recursive`
</td>
<td>
Number of bios/requests merged into requests belonging to this cgroup and its descendant cgroups
</td>
<td>
Sum
</td>
</tr>
<tr>
<td>
`container.blockio.io_queued_recursive`
</td>
<td>
Number of requests queued up for this cgroup and its descendant cgroups
</td>
<td>
Sum
</td>
</tr>
<tr>
<td>
`container.blockio.io_service_bytes_recursive`
</td>
<td>
Number of bytes transferred to/from the disk by the group and descendant groups
</td>
<td>
Sum
</td>
</tr>
<tr>
<td>
`container.blockio.io_service_time_recursive`
</td>
<td>
Total amount of time in nanoseconds between request dispatch and request completion for the IOs done by this cgroup and descendant cgroups
</td>
<td>
Sum
</td>
</tr>
<tr>
<td>
`container.blockio.io_serviced_recursive`
</td>
<td>
Number of IOs (bio) issued to the disk by the group and descendant groups
</td>
<td>
Sum
</td>
</tr>
<tr>
<td>
`container.blockio.io_time_recursive`
</td>
<td>
Disk time allocated to cgroup (and descendant cgroups) per device in milliseconds
</td>
<td>
Sum
</td>
</tr>
<tr>
<td>
`container.blockio.io_wait_time_recursive`
</td>
<td>
Total amount of time the IOs for this cgroup (and descendant cgroups) spent waiting in the scheduler queues for service
</td>
<td>
Sum
</td>
</tr>
<tr>
<td>
`container.cpu.usage.kernelmode`
</td>
<td>
CPU kernel mode usage
</td>
<td>
Sum
</td>
</tr>
<tr>
<td>
`container.cpu.usage.percpu`
</td>
<td>
Per-core CPU usage by the container (disabled by default)
</td>
<td>
Sum
</td>
</tr>
<tr>
<td>
`container.cpu.usage.system`
</td>
<td>
System CPU usage
</td>
<td>
Sum
</td>
</tr>
<tr>
<td>
`container.cpu.usage.total`
</td>
<td>
Total CPU time consumed by the container
</td>
<td>
Sum
</td>
</tr>
<tr>
<td>
`container.cpu.usage.usermode`
</td>
<td>
CPU user mode usage
</td>
<td>
Sum
</td>
</tr>
<tr>
<td>
`container.cpu.percent`
</td>
<td>
Percent of CPU used by the container (deprecated, use container.cpu.utilization instead)
</td>
<td>
Gauge
</td>
</tr>
<tr>
<td>
`container.cpu.utilization`
</td>
<td>
Percent of CPU used by the container
</td>
<td>
Gauge
</td>
</tr>
<tr>
<td>
`container.cpu.throttling_data.periods`
</td>
<td>
Number of periods with throttling active
</td>
<td>
Sum
</td>
</tr>
<tr>
<td>
`container.cpu.throttling_data.throttled_periods`
</td>
<td>
Number of periods when the container hit its throttling limit
</td>
<td>
Sum
</td>
</tr>
<tr>
<td>
`container.cpu.throttling_data.throttled_time`
</td>
<td>
Aggregate time the container was throttled
</td>
<td>
Sum
</td>
</tr>
<tr>
<td>
`container.memory.usage.limit`
</td>
<td>
Memory usage limit
</td>
<td>
Sum
</td>
</tr>
<tr>
<td>
`container.memory.usage.max`
</td>
<td>
Maximum memory usage
</td>
<td>
Sum
</td>
</tr>
<tr>
<td>
`container.memory.usage.total`
</td>
<td>
Memory usage of the container. This excludes the cache
</td>
<td>
Sum
</td>
</tr>
<tr>
<td>
`container.memory.percent`
</td>
<td>
Percentage of memory used
</td>
<td>
Gauge
</td>
</tr>
<tr>
<td>
`container.memory.active_anon`
</td>
<td>
Amount of memory used in anonymous mappings such as brk(), sbrk(), and mmap(MAP_ANONYMOUS) that are actively used
</td>
<td>
Sum
</td>
</tr>
<tr>
<td>
`container.memory.active_file`
</td>
<td>
Amount of cache memory used by files that are actively used
</td>
<td>
Sum
</td>
</tr>
<tr>
<td>
`container.memory.cache`
</td>
<td>
The amount of memory used by the processes of this control group that can be associated with a block on a block device
</td>
<td>
Sum
</td>
</tr>
<tr>
<td>
`container.memory.dirty`
</td>
<td>
Bytes that are waiting to get written back to the disk, from this cgroup
</td>
<td>
Sum
</td>
</tr>
<tr>
<td>
`container.memory.hierarchical_memory_limit`
</td>
<td>
The max amount of physical memory that the cgroup can use
</td>
<td>
Sum
</td>
</tr>
<tr>
<td>
`container.memory.hierarchical_memsw_limit`
</td>
<td>
The max amount of RAM + swap that the cgroup can use
</td>
<td>
Sum
</td>
</tr>
<tr>
<td>
`container.memory.inactive_anon`
</td>
<td>
Amount of memory used in anonymous mappings such as brk(), sbrk(), and mmap(MAP_ANONYMOUS) that are not actively used
</td>
<td>
Sum
</td>
</tr>
<tr>
<td>
`container.memory.inactive_file`
</td>
<td>
Amount of cache memory used by files that are not actively used
</td>
<td>
Sum
</td>
</tr>
<tr>
<td>
`container.memory.mapped_file`
</td>
<td>
Indicates the amount of memory mapped by the processes in the control group
</td>
<td>
Sum
</td>
</tr>
<tr>
<td>
`container.memory.pgfault`
</td>
<td>
Indicate the number of times that a process of the cgroup triggered a page fault
</td>
<td>
Sum
</td>
</tr>
<tr>
<td>
`container.memory.pgmajfault`
</td>
<td>
Indicate the number of times that a process of the cgroup triggered a major fault
</td>
<td>
Sum
</td>
</tr>
<tr>
<td>
`container.memory.pgpgin`
</td>
<td>
Number of pages read from disk by the cgroup
</td>
<td>
Sum
</td>
</tr>
<tr>
<td>
`container.memory.pgpgout`
</td>
<td>
Number of pages written to disk by the cgroup
</td>
<td>
Sum
</td>
</tr>
<tr>
<td>
`container.memory.rss`
</td>
<td>
The amount of memory that doesn't correspond to anything on disk: stacks, heaps, and anonymous memory maps
</td>
<td>
Sum
</td>
</tr>
<tr>
<td>
`container.memory.rss_huge`
</td>
<td>
Number of bytes of anonymous transparent hugepages in this cgroup
</td>
<td>
Sum
</td>
</tr>
<tr>
<td>
`container.memory.unevictable`
</td>
<td>
The amount of memory that cannot be reclaimed
</td>
<td>
Sum
</td>
</tr>
<tr>
<td>
`container.memory.writeback`
</td>
<td>
Number of bytes of file/anon cache that are queued for syncing to disk in this cgroup
</td>
<td>
Sum
</td>
</tr>
<tr>
<td>
`container.network.io.usage.rx_bytes`
</td>
<td>
Bytes received by the container via its network interface
</td>
<td>
Sum
</td>
</tr>
<tr>
<td>
`container.network.io.usage.rx_dropped`
</td>
<td>
Number of received packets dropped by the container
</td>
<td>
Sum
</td>
</tr>
<tr>
<td>
`container.network.io.usage.rx_errors`
</td>
<td>
Received errors by the container
</td>
<td>
Sum
</td>
</tr>
<tr>
<td>
`container.network.io.usage.rx_packets`
</td>
<td>
Packets received by the container via its network interface
</td>
<td>
Sum
</td>
</tr>
<tr>
<td>
`container.network.io.usage.tx_bytes`
</td>
<td>
Bytes sent by the container via its network interface
</td>
<td>
Sum
</td>
</tr>
<tr>
<td>
`container.network.io.usage.tx_dropped`
</td>
<td>
Number of sent packets dropped by the container
</td>
<td>
Sum
</td>
</tr>
<tr>
<td>
`container.network.io.usage.tx_errors`
</td>
<td>
Transmission errors by the container
</td>
<td>
Sum
</td>
</tr>
<tr>
<td>
`container.network.io.usage.tx_packets`
</td>
<td>
Packets sent by the container via its network interface
</td>
<td>
Sum
</td>
</tr>
<tr>
<td>
`container.pids.count`
</td>
<td>
Number of PIDs in the container's cgroup
</td>
<td>
Sum
</td>
</tr>
<tr>
<td>
`container.pids.limit`
</td>
<td>
Maximum number of PIDs in the container's cgroup
</td>
<td>
Sum
</td>
</tr>
</tbody>
</table>
</Collapser>

<Collapser
id="docker-attributes"
title="Attributes"
>
<table>
<thead>
<tr>
<th style={{ width: "350px" }}>
Attribute
</th>
<th>
Description
</th>
<th>
Values
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
`container.id`
</td>
<td>
The full container ID
</td>
<td>
String (64-character hex)
</td>
</tr>
<tr>
<td>
`container.image.name`
</td>
<td>
Name of the container image
</td>
<td>
String
</td>
</tr>
<tr>
<td>
`container.name`
</td>
<td>
Container name
</td>
<td>
String
</td>
</tr>
<tr>
<td>
`container.runtime`
</td>
<td>
Container runtime
</td>
<td>
`docker`
</td>
</tr>
<tr>
<td>
`device_major`
</td>
<td>
Device major number (for block I/O metrics)
</td>
<td>
Integer
</td>
</tr>
<tr>
<td>
`device_minor`
</td>
<td>
Device minor number (for block I/O metrics)
</td>
<td>
Integer
</td>
</tr>
<tr>
<td>
`operation`
</td>
<td>
Type of block I/O operation
</td>
<td>
`read`, `write`
</td>
</tr>
<tr>
<td>
`interface`
</td>
<td>
Network interface name (for network metrics)
</td>
<td>
String
</td>
</tr>
<tr>
<td>
`core`
</td>
<td>
CPU core identifier (for per-CPU metrics when enabled)
</td>
<td>
String
</td>
</tr>
</tbody>
</table>
</Collapser>

</CollapserGroup>

For more details, see the [Docker Stats receiver documentation](https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/main/receiver/dockerstatsreceiver/documentation.md).