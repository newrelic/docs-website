---
componentType: default
headingText: Metrics collected by the integration
---

## Configure the integration [#config]

An integration's YAML-format configuration is where you can place required login credentials and configure how data is collected. Which options you change depend on your setup and preference.

To configure the vSphere integration, you must define the URL of the vSphere API endpoint, and your vSphere username and password. For configuration examples, see the [sample configuration files](#example-config). Some vSphere integration features are optional and can be enabled via configuration settings.

In addition, with [secrets management](/docs/integrations/host-integrations/installation/secrets-management), you can configure on-host integrations with New Relic's infrastructure agent to use sensitive data (such as passwords) without having to write them as plain text into the integration's configuration file.

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="vsphere-events"
    title="Collect vSphere events"
  >
    To collect vSphere events, use the `ENABLE_VSPHERE_EVENTS` environment variable.

    The integration collects events between the current time and the last fetched event for each data center. It stores the information regarding the last fetched event in a cache that is updated after each execution. Events are only available if the integration is connected to a vCenter and not directly to an ESXi host.

    The number of events collected per request can be tuned by modifying `EVENTS_PAGE_SIZE`, which is set to `100` by default.

    Events are available in the <DNT>**Events**</DNT> page and can be queried via [NRQL](/docs/query-data/nrql-new-relic-query-language/getting-started/introduction-nrql) as `InfrastructureEvent` under `vSphereEvent`. Here is an example of vSphere events data:

    ```json
    "summary": "User dcui@127.0.0.1 logged out (login time: Tuesday, 14 July, 2020 08:32:09 AM, number of API invocations: 0, user agent: VMware-client/6.5.0)",
    "vSphereEvent.computeResource": "cluster1",
    "vSphereEvent.datacenter": "Prod Datacenter",
    "vSphereEvent.date": "Tue, 14 Jul 2020 09:03:51 UTC",
    "vSphereEvent.host": "192.168.0.230",
    "vSphereEvent.userName": "dcui"
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="snapshot-data"
    title="Collect snapshots data"
  >
    To collect snapshot data, use the `ENABLE_VSPHERE_SNAPSHOTS` environment variable.

    Snapshot data can be found in `VSphereSnapshotVmSample`. Collected data covers total and unique space occupied by disk and memory files, snapshot tree, and creation time.

    You can use this information to create [NRQL](/docs/query-data/nrql-new-relic-query-language/getting-started/introduction-nrql) queries, [dashboards](/docs/dashboards/new-relic-one-dashboards/get-started/introduction-new-relic-one-dashboards), and [alerts](/docs/alerts/new-relic-alerts/defining-conditions/create-alert-conditions-nrql-queries), since it's linked to the corresponding virtual machine entity.
  </Collapser>

  <Collapser
    className="freq-link"
    id="vsphere-tags"
    title="Collect vSphere tags"
  >
    To collect vSphere tags, use the `ENABLE_VSPHERE_TAGS` environment variable.

    Tags are available as attributes in the corresponding entity sample as `label.tagCategory:tagName`.

    If two tags of the same category are assigned to a resource, they are added to a unique attribute separated by a pipe character. For example: `label.tagCategory:tagName|tagName2`.

    Tags can be used to run [NRQL](/docs/query-data/nrql-new-relic-query-language/getting-started/introduction-nrql) queries, filter entities in our [entity explorer](/docs/new-relic-one/use-new-relic-one/ui-data/new-relic-one-entity-explorer), and to create [dashboards](/docs/dashboards/new-relic-one-dashboards/get-started/introduction-new-relic-one-dashboards) and [alerts](/docs/alerts/new-relic-alerts/defining-conditions/create-alert-conditions-nrql-queries).
  </Collapser>

  <Collapser
    className="freq-link"
    id="vsphere-filter"
    title="Filter resources by tags"
  >
    Resource filtering allows you to specify which resources you want to monitor by declaring a set of tags that resources must have in order to be monitored.

    Resources require a match on any (one or more) of the filter tags in order to be included. If none of the resource tags match any of the filter tags, no information about that resource is sent to New Relic.

    To use filtering resources by tag you need to have the `ENABLE_VSPHERE_TAGS` environment variable enabled.

    A tag filter expression is a space-separated list of pairs of strings with the format `category=name`.

    For example, to only retrieve resources with a tag category `region` and include regions `us` and `eu` use a filter expression like: `region=us region=eu`

    ```yml
    INCLUDE_TAGS: >
      region=us
      region=eu
    ```

    To enable resource filtering by tag, edit your integration configuration file and add the option `INCLUDE_TAGS` with the filter expression you want.

    <Callout variant="caution">
      Note that data center resources acting as the root of the resource tree MUST have tags attached AND match the filter expression in order for other child resources to be fetched.
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="perf-metrics"
    title="Enable and configure performance metrics (preview)"
  >
    Performance metrics provide a better understanding of the current status of VMware resources and can be collected <DNT>**in addition**</DNT> to the metrics collected by default and included in the samples described at the bottom of the page.

    All metrics collected are included in the corresponding sample with the `perf.` prefix attached to the name. For example, `net.packetsRx.summation` is collected and sent as `perf.net.packetsRx.summation`.

    To collect vSphere performance metrics, use the `ENABLE_VSPHERE_PERF_METRICS` environment variable.

    Data is collected according to the settings in the [`vsphere-performance.metrics`](https://github.com/newrelic/nri-vsphere/blob/master/vsphere-performance.metrics) configuration file. You can override the location of the performance metrics config file using `PERF_METRIC_FILE` environment variable. Notice that the integration follows [VMware's data collection levels](https://docs.vmware.com/en/VMware-vSphere/7.0/com.vmware.vsphere.monitoring.doc/GUID-25800DE4-68E5-41CC-82D9-8811E27924BC.html) (1 to 4).

    When `ENABLE_VSPHERE_PERF_METRICS` is set, all level 1 metrics are collected. The data collection level of the performance metrics collected can be modified using `PERF_LEVEL`. Each metric in the config file can be commented out and new ones can be added if needed.

    <Callout variant="caution">
      Collection of performance data can increase the load in vCenter and the time needed by to collect data. We recommended to only include the metrics you need in the configuration file.
    </Callout>

    To fine-tune data collection, the number of entities and metrics retrieved per request can be modified using `BATCH_SIZE_PERF_ENTITIES` and `BATCH_SIZE_PERF_METRICS`.

    <Callout variant="tip">
      For more information on vSphere performance metrics, see the [VMware documentation](https://docs.vmware.com/en/VMware-vSphere/6.7/vsphere-esxi-vcenter-server-67-monitoring-performance-guide.pdf).
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="multi-instance"
    title="Multiple instances"
  >
    In this configuration we are monitoring multiple vSphere servers from the same integration. For the first instance (`FIRST_VSPHERE_API_URL`) we are collecting events and tags while for the second instance (`SECOND_VSPHERE_API_URL`) we have turned them off.

    ```yaml
    integrations:
      - name: nri-vsphere
        env:
          # vSphere API connection data (vCenter or ESXi servers)
          URL: https://<FIRST_VSPHERE_API_URL>/sdk
          USER: <FIRST_VSPHERE_USER>
          PASS: <FIRST_PASSWORD>

          # Collect events data
          ENABLE_VSPHERE_EVENTS: true

          # Collect vSphere tags
          ENABLE_VSPHERE_TAGS: true

        # Execution interval. Set a value higher than 20s, as real-time vSphere samples are run every 20s.
        interval: 120s
      - name: nri-vsphere
        env:
          # vSphere API connection data (vCenter or ESXi servers)
          URL: https://<SECOND_VSPHERE_API_URL>/sdk
          USER: <SECOND_VSPHERE_USER>
          PASS: <SECOND_PASSWORD>

          # Collect events data
          ENABLE_VSPHERE_EVENTS: false

          # Collect vSphere tags
          ENABLE_VSPHERE_TAGS: false

        # Execution interval. Set a value higher than 20s, as real-time vSphere samples are run every 20s.
        interval: 300s
    ```
  </Collapser>
</CollapserGroup>

<Callout variant="important">
  If you connect the integration directly to the ESXi host, vCenter data is not available (for example, events, tags, or data center metadata).
</Callout>

### Example configuration [#example-config]

Here are examples of the vSphere integration configuration, including performance metrics:

* [`vsphere-config.yml.sample`](https://github.com/newrelic/nri-vsphere/blob/master/vsphere-config.yml.sample) (Linux)
* [`vsphere-win-config.yml.sample`](https://github.com/newrelic/nri-vsphere/blob/master/vsphere-win-config.yml.sample) (Windows)
* [`vsphere-performance.metrics`](https://github.com/newrelic/nri-vsphere/blob/master/vsphere-performance.metrics) (Performance metrics)

For more information, see our documentation about the [general structure of on-host integration configurations](/docs/integrations/integrations-sdk/file-specifications/host-integration-configuration-overview).

<Callout variant="important">
  The configuration option [inventory_source](/docs/integrations/integrations-sdk/file-specifications/host-integrations-newer-configuration-format#inventory_source) is not compatible with this integration.
</Callout>

## Update your integration [#update]

<DNT>
  **On-host integrations do not automatically update.**
</DNT>

For best results, regularly [update the integration package](/docs/integrations/host-integrations/installation/update-infrastructure-host-integration-package) and the [infrastructure agent](/docs/infrastructure/new-relic-infrastructure/installation/update-infrastructure-agent).

## Metric data [#metrics]

The vSphere integration provides metric data attached to the following New Relic [events](/docs/telemetry-data-platform/ingest-manage-data/understand-data/new-relic-data-types#events-new-relic):

* `VSphereHostSample`
* `VSphereVmSample`
* `VSphereDatastoreSample`
* `VSphereDatacenterSample`
* `VSphereResourcePoolSample`
* `VSphereClusterSample`
* `VSphereSnapshotVmSample`

### VSphereHostSample

<table>
  <thead>
    <tr>
      <th style={{ width: "300px" }}>
        Name
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `cpu.totalMHz`
      </td>

      <td>
        Sum of the MHz for all the individual cores on the host
      </td>
    </tr>

    <tr>
      <td>
        `cpu.coreMHz`
      </td>

      <td>
        Speed of the CPU cores
      </td>
    </tr>

    <tr>
      <td>
        `cpu.available`
      </td>

      <td>
        Amount of free CPU MHz in the host
      </td>
    </tr>

    <tr>
      <td>
        `cpu.overallUsage`
      </td>

      <td>
        CPU usage across all cores on the host in MHz
      </td>
    </tr>

    <tr>
      <td>
        `cpu.percent`
      </td>

      <td>
        Percentage of CPU utilization in the host
      </td>
    </tr>

    <tr>
      <td>
        `cpu.cores`
      </td>

      <td>
        Number of physical CPU cores on the host. Physical CPU cores are the processors contained by a CPU package
      </td>
    </tr>

    <tr>
      <td>
        `cpu.threads`
      </td>

      <td>
        Number of physical CPU threads on the host
      </td>
    </tr>

    <tr>
      <td>
        `disk.totalMiB`
      </td>

      <td>
        Total capacity of disks mounted in host, in MiB
      </td>
    </tr>

    <tr>
      <td>
        `mem.free`
      </td>

      <td>
        Amount of available memory in the host, in MiB
      </td>
    </tr>

    <tr>
      <td>
        `mem.usage`
      </td>

      <td>
        Amount of used memory in the host, in MiB
      </td>
    </tr>

    <tr>
      <td>
        `mem.size`
      </td>

      <td>
        Total memory capacity of the host, in MiB
      </td>
    </tr>

    <tr>
      <td>
        `vmCount`
      </td>

      <td>
        Number of virtual machines in the host
      </td>
    </tr>

    <tr>
      <td>
        `hypervisorHostname`
      </td>

      <td>
        Name of the host
      </td>
    </tr>

    <tr>
      <td>
        `uuid`
      </td>

      <td>
        The hardware BIOS identification
      </td>
    </tr>

    <tr>
      <td>
        `datacenterName`
      </td>

      <td>
        Name of the data center related to the host
      </td>
    </tr>

    <tr>
      <td>
        `clusterName`
      </td>

      <td>
        Name of the cluster related to the host
      </td>
    </tr>

    <tr>
      <td>
        `resourcePoolNameList`
      </td>

      <td>
        List of names of the resource pools related to the host
      </td>
    </tr>

    <tr>
      <td>
        `datastoreNameList`
      </td>

      <td>
        List of names of datastores related to the host
      </td>
    </tr>

    <tr>
      <td>
        `datacenterLocation`
      </td>

      <td>
        Data center location
      </td>
    </tr>

    <tr>
      <td>
        `networkNameList`
      </td>

      <td>
        List of names of networks related to the host
      </td>
    </tr>

    <tr>
      <td>
        `overallStatus`
      </td>

      <td>
        * `gray`: Status is unknown
        * `green`: Entity is OK
        * `yellow`: Entity might have a problem
        * `red`: Entity definitely has a problem
      </td>
    </tr>

    <tr>
      <td>
        `connectionState`
      </td>

      <td>
        The host connection state:

        * `connected`: Connected to the server. For ESX Server, this is the default setting.
        * `disconnected`: The user has explicitly taken the host down. VirtualCenter does not expect to receive heartbeats from the host. The next time a heartbeat is received, the host is moved to the connected state again and an event is logged.
        * `notResponding`: VirtualCenter is not receiving heartbeats from the server. The state automatically changes to connected once heartbeats are received again. This state is typically used to trigger an alarm on the host.
      </td>
    </tr>

    <tr>
      <td>
        `inMaintenanceMode`
      </td>

      <td>
        The flag to indicate whether or not the host is in maintenance mode. This flag is set when the host has entered the maintenance mode. It is not set during the entering phase of maintenance mode.
      </td>
    </tr>

    <tr>
      <td>
        `inQuarantineMode`
      </td>

      <td>
        The flag to indicate whether or not the host is in quarantine mode. `InfraUpdateHa` will recommend to set this flag based on the `HealthUpdates` received by the `HealthUpdateProviders` configured for the cluster.

        A host that is reported as degraded will be recommended to enter quarantine mode, while a host that is reported as healthy will be recommended to exit quarantine mode. Execution of these recommended actions will set this flag.

        Hosts in quarantine mode will be avoided by vSphere DRS as long as the increased consolidation in the cluster does not negatively affect VM performance.
      </td>
    </tr>

    <tr>
      <td>
        `powerState`
      </td>

      <td>
        The host power state:

        * `poweredOff`: The host was specifically powered off by the user through VirtualCenter. This state is not a cetain state, because after VirtualCenter issues the command to power off the host, the host might crash, or kill all the processes but fail to power off.
        * `poweredOn`: The host is powered on. A host that is entering standby mode entering is also in this state.
        * `standBy`: The host was specifically put in standby mode, either explicitly by the user or automatically by DPM. This state is not a certain state, because after VirtualCenter issues the command to put the host in standby state, the host might crash, or kill all the processes but fail to power off. A host that is exiting standby mode s also in this state.
        * `unknown`: If the host is disconnected or `notResponding`, we know its power state, so the host is marked as `unknown`.
      </td>
    </tr>

    <tr>
      <td>
        `standbyMode`
      </td>

      <td>
        The host’s standby mode. The property is only populated by vCenter server. If queried directly from the ESX host, the property is `unset`.

        * `entering`: The host is entering standby mode.
        * `exiting`: The host is exiting standby mode.
        * `in`: The host is in standby mode.
        * `none`: The host is not in standby mode, and it is not in the process of entering or exiting standby mode.
      </td>
    </tr>

    <tr>
      <td>
        `cryptoState`
      </td>

      <td>
        Encryption state of the host. Valid values are enumerated by the CryptoState type:

        * `incapable`: The host is not safe for receiving sensitive material.
        * `prepared`: The host is prepared for receiving sensitive material but does not have a host key set yet.
        * `safe`: The host is crypto safe and has a host key set.
      </td>
    </tr>

    <tr>
      <td>
        `bootTime`
      </td>

      <td>
        The time when the host was booted.
      </td>
    </tr>
  </tbody>
</table>

### VSphereVmSample [#vspherevirtualmachine]

<table>
  <thead>
    <tr>
      <th style={{ width: "300px" }}>
        Name
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `mem.size`
      </td>

      <td>
        Memory size of the virtual machine, in MiB
      </td>
    </tr>

    <tr>
      <td>
        `mem.usage`
      </td>

      <td>
        Guest memory utilization statistics, in MiB. This is also known as active guest memory. The value can range between `0` and the configured memory size of the virtual machine. Valid while the virtual machine is running.
      </td>
    </tr>

    <tr>
      <td>
        `mem.free`
      </td>

      <td>
        Guest memory available, in MiB. The value can range between `0` and the configured memory size of the virtual machine. Valid while the virtual machine is running.
      </td>
    </tr>

    <tr>
      <td>
        `mem.ballooned`
      </td>

      <td>
        The size of the balloon driver in the virtual machine, in MiB. The host will inflate the balloon driver to reclaim physical memory from the virtual machine. This is a sign that there is memory pressure on the host.
      </td>
    </tr>

    <tr>
      <td>
        `mem.swapped`
      </td>

      <td>
        The portion of memory, in MiB, that is granted to this virtual machine from the host's swap space. This is a sign that there is memory pressure on the host.
      </td>
    </tr>

    <tr>
      <td>
        `mem.swappedSsd`
      </td>

      <td>
        The amount of memory swapped to fast disk device such as SSD, in MiB
      </td>
    </tr>

    <tr>
      <td>
        `cpu.allocationLimit`
      </td>

      <td>
        Resource limits for CPU, in MHz. If set to `-1`, there is no fixed allocation limit.
      </td>
    </tr>

    <tr>
      <td>
        `cpu.overallUsage`
      </td>

      <td>
        Basic CPU performance statistics, in MHz. Valid while the virtual machine is running.
      </td>
    </tr>

    <tr>
      <td>
        `cpu.hostUsagePercent`
      </td>

      <td>
        Percent of the host CPU used by the virtual machine. In case a limit is configured, the percentage is calculated by taking the limit as the total.
      </td>
    </tr>

    <tr>
      <td>
        `cpu.cores`
      </td>

      <td>
        Number of processors in the virtual machine
      </td>
    </tr>

    <tr>
      <td>
        `disk.totalMiB`
      </td>

      <td>
        Total storage space, committed to this virtual machine across all datastores, in MiB
      </td>
    </tr>

    <tr>
      <td>
        `ipAddress`
      </td>

      <td>
        Primary guest IP address, if available
      </td>
    </tr>

    <tr>
      <td>
        `ipAddresses`
      </td>

      <td>
        List of IPs associated with the VM (except `ipAddress`). A pipe or vertical bar character (`|`) is used as a separator.
      </td>
    </tr>

    <tr>
      <td>
        `connectionState`
      </td>

      <td>
        Indicates whether or not the virtual machine is available for management:

        * `connected`: Server has access to the virtual machine.
        * `disconnected`: Server is currently disconnected from the virtual machine, since its host is disconnected.
        * `inaccessible`: One or more of the virtual machine configuration files are inaccessible.
        * `invalid`: The virtual machine configuration format is invalid.
        * `orphaned`: The virtual machine is no longer registered on its associated host.
      </td>
    </tr>

    <tr>
      <td>
        `powerState`
      </td>

      <td>
        The current power state of the virtual machine: `poweredOff`, `poweredOn`, or `suspended`.
      </td>
    </tr>

    <tr>
      <td>
        `guestHeartbeatStatus`
      </td>

      <td>
        * `gray`: Status is unknown.
        * `green`: Entity is OK.
        * `yellow`: Entity might have a problem.
        * `red`: Entity definitely has a problem.
      </td>
    </tr>

    <tr>
      <td>
        `operatingSystem`
      </td>

      <td>
        Operating system of the virtual machine
      </td>
    </tr>

    <tr>
      <td>
        `guestFullName`
      </td>

      <td>
        Guest operating system full name, if available from guest tools
      </td>
    </tr>

    <tr>
      <td>
        `hypervisorHostname`
      </td>

      <td>
        Name of the host where the virtual machine is running
      </td>
    </tr>

    <tr>
      <td>
        `instanceUuid`
      </td>

      <td>
        Unique identification of the virtual machine
      </td>
    </tr>

    <tr>
      <td>
        `datacenterName`
      </td>

      <td>
        Name of the data center
      </td>
    </tr>

    <tr>
      <td>
        `clusterName`
      </td>

      <td>
        Name of the cluster
      </td>
    </tr>

    <tr>
      <td>
        `resourcePoolNameList`
      </td>

      <td>
        List of names of the resource pools
      </td>
    </tr>

    <tr>
      <td>
        `datastoreNameList`
      </td>

      <td>
        List of names of datastores
      </td>
    </tr>

    <tr>
      <td>
        `networkNameList`
      </td>

      <td>
        List of names of networks
      </td>
    </tr>

    <tr>
      <td>
        `datacenterLocation`
      </td>

      <td>
        Data center location
      </td>
    </tr>

    <tr>
      <td>
        `overallStatus`
      </td>

      <td>
        * `gray`: Status is unknown.
        * `green`: Entity is OK.
        * `yellow`: Entity might have a problem.
        * `red`: Entity definitely has a problem.
      </td>
    </tr>

    <tr>
      <td>
        `disk.suspendMemory`
      </td>

      <td>
        Size of the snapshot file (bytes).
      </td>
    </tr>

    <tr>
      <td>
        `disk.suspendMemoryUnique`
      </td>

      <td>
        Size of the snapshot file, unique blocks (bytes).
      </td>
    </tr>

    <tr>
      <td>
        `disk.totalUncommittedMiB`
      </td>

      <td>
        Additional storage space potentially used by this virtual machine on all datastores. Essentially an aggregate of the property uncommitted across all datastores that this virtual machine is located on (Mebibytes).
      </td>
    </tr>

    <tr>
      <td>
        `disk.totalUnsharedMiB`
      </td>

      <td>
        Total storage space occupied by the virtual machine across all datastores, that is not shared with any other virtual machine (Mebibytes).
      </td>
    </tr>

    <tr>
      <td>
        `mem.hostUsage`
      </td>

      <td>
        Host memory usage (Mebibytes).
      </td>
    </tr>

    <tr>
      <td>
        `resourcePoolName`
      </td>

      <td>
        Resource Pool Name.
      </td>
    </tr>

    <tr>
      <td>
        `vmConfigName`
      </td>

      <td>
        Vm Config Name.
      </td>
    </tr>

    <tr>
      <td>
        `vmHostname`
      </td>

      <td>
        Vm Hostname.
      </td>
    </tr>
  </tbody>
</table>

### VSphereDatastoreSample

<table>
  <thead>
    <tr>
      <th style={{ width: "300px" }}>
        Name
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `capacity`
      </td>

      <td>
        Maximum capacity of this datastore, in GiB, if accessible is `true`
      </td>
    </tr>

    <tr>
      <td>
        `freeSpace`
      </td>

      <td>
        Available space of this datastore, in GiB, if accessible is `true`
      </td>
    </tr>

    <tr>
      <td>
        `uncommitted`
      </td>

      <td>
        Total additional storage space, potentially used by all virtual machines on this datastore, in GiB, if accessible is `true`
      </td>
    </tr>

    <tr>
      <td>
        `vmCount`
      </td>

      <td>
        Number of virtual machines attached to the datastore
      </td>
    </tr>

    <tr>
      <td>
        `datacenterLocation`
      </td>

      <td>
        Data center location
      </td>
    </tr>

    <tr>
      <td>
        `datacenterName`
      </td>

      <td>
        Data center name
      </td>
    </tr>

    <tr>
      <td>
        `hostCount`
      </td>

      <td>
        Number of hosts attached to the datastore
      </td>
    </tr>

    <tr>
      <td>
        `overallStatus`
      </td>

      <td>
        * `gray`: Status is unknown.
        * `green`: Entity is OK.
        * `yellow`: Entity might have a problem.
        * `red`: Entity definitely has a problem.
      </td>
    </tr>

    <tr>
      <td>
        `accessible`
      </td>

      <td>
        Connectivity status of the datastore. If this is set to `false`, the datastore is not accessible.
      </td>
    </tr>

    <tr>
      <td>
        `url`
      </td>

      <td>
        Unique locator for the datastore, if accessible is `true`
      </td>
    </tr>

    <tr>
      <td>
        `fileSystemType`
      </td>

      <td>
        Type of file system volume, such as `VMFS` or `NFS`
      </td>
    </tr>

    <tr>
      <td>
        `name`
      </td>

      <td>
        Name of the datastore
      </td>
    </tr>

    <tr>
      <td>
        `nas.remoteHost`
      </td>

      <td>
        Host that runs the NFS/CIFS server
      </td>
    </tr>

    <tr>
      <td>
        `nas.remotePath`
      </td>

      <td>
        Remote path of NFS/CIFS mount point
      </td>
    </tr>
  </tbody>
</table>

### VSphereDatacenterSample

<table>
  <thead>
    <tr>
      <th style={{ width: "300px" }}>
        Name
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `datastore.totalUsedGiB`
      </td>

      <td>
        Total used space in the datastores, in GiB
      </td>
    </tr>

    <tr>
      <td>
        `datastore.totalFreeGiB`
      </td>

      <td>
        Total free space in the datastores, in GiB
      </td>
    </tr>

    <tr>
      <td>
        `datastore.totalGiB`
      </td>

      <td>
        Total size of the datastores, in GiB
      </td>
    </tr>

    <tr>
      <td>
        `cpu.cores`
      </td>

      <td>
        Total CPU count per data center
      </td>
    </tr>

    <tr>
      <td>
        `cpu.overallUsagePercentage`
      </td>

      <td>
        Total CPU usage, in percentage
      </td>
    </tr>

    <tr>
      <td>
        `cpu.overallUsage`
      </td>

      <td>
        Total CPU usage, in MHz
      </td>
    </tr>

    <tr>
      <td>
        `cpu.totalMHz`
      </td>

      <td>
        Total CPU capacity, in MHz
      </td>
    </tr>

    <tr>
      <td>
        `mem.usage`
      </td>

      <td>
        Total memory usage, in MiB
      </td>
    </tr>

    <tr>
      <td>
        `mem.size`
      </td>

      <td>
        Total memory, in MiB
      </td>
    </tr>

    <tr>
      <td>
        `mem.usagePercentage`
      </td>

      <td>
        Total memory usage as percentage
      </td>
    </tr>

    <tr>
      <td>
        `clusters`
      </td>

      <td>
        Total cluster count per data center
      </td>
    </tr>

    <tr>
      <td>
        `resourcePools`
      </td>

      <td>
        Total resource pools per data center
      </td>
    </tr>

    <tr>
      <td>
        `datastores`
      </td>

      <td>
        Total datastores per data center
      </td>
    </tr>

    <tr>
      <td>
        `networks`
      </td>

      <td>
        Total network adapter count per data center
      </td>
    </tr>

    <tr>
      <td>
        `overallStatus`
      </td>

      <td>
        * `gray`: Status is unknown
        * `green`: Entity is OK
        * `yellow`: Entity might have a problem
        * `red`: Entity definitely has a problem
      </td>
    </tr>

    <tr>
      <td>
        `hostCount`
      </td>

      <td>
        Total host system count per data center
      </td>
    </tr>

    <tr>
      <td>
        `vmCount`
      </td>

      <td>
        Total virtual machines count per data center
      </td>
    </tr>
  </tbody>
</table>

### VSphereResourcePoolSample

<table>
  <thead>
    <tr>
      <th style={{ width: "300px" }}>
        Name
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `cpu.TotalMHz`
      </td>

      <td>
        Resource pool CPU total capacity, in MHz
      </td>
    </tr>

    <tr>
      <td>
        `cpu.overallUsage`
      </td>

      <td>
        Resource pool CPU usage, in MHz
      </td>
    </tr>

    <tr>
      <td>
        `mem.size`
      </td>

      <td>
        Resource pool total memory reserved, in MiB
      </td>
    </tr>

    <tr>
      <td>
        `mem.usage`
      </td>

      <td>
        Resource pool memory usage, in MiB
      </td>
    </tr>

    <tr>
      <td>
        `mem.free`
      </td>

      <td>
        Resource pool memory available, in MiB
      </td>
    </tr>

    <tr>
      <td>
        `mem.ballooned`
      </td>

      <td>
        Size of the balloon driver in the resource pool, in MiB
      </td>
    </tr>

    <tr>
      <td>
        `mem.swapped`
      </td>

      <td>
        Portion of memory, in MiB, that is granted to this resource pool from the host's swap space
      </td>
    </tr>

    <tr>
      <td>
        `vmCount`
      </td>

      <td>
        Number of virtual machines in the resource pool
      </td>
    </tr>

    <tr>
      <td>
        `overallStatus`
      </td>

      <td>
        * `gray`: Status is unknown.
        * `green`: Entity is OK.
        * `yellow`: Entity might have a problem.
        * `red`: Entity definitely has a problem.
      </td>
    </tr>

    <tr>
      <td>
        `resourcePoolName`
      </td>

      <td>
        Name of the resource pool
      </td>
    </tr>

    <tr>
      <td>
        `datacenterLocation`
      </td>

      <td>
        Data center location
      </td>
    </tr>

    <tr>
      <td>
        `datacenterName`
      </td>

      <td>
        Name of the data center
      </td>
    </tr>

    <tr>
      <td>
        `clusterName`
      </td>

      <td>
        Name of the cluster
      </td>
    </tr>
  </tbody>
</table>

### VSphereClusterSample

<table>
  <thead>
    <tr>
      <th style={{ width: "300px" }}>
        Name
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `cpu.totalEffectiveMHz`
      </td>

      <td>
        Effective CPU resources, in MHz, available to virtual machines. This is the aggregated effective resource level from all running hosts. Hosts that are in maintenance mode or are unresponsive are not counted. Resources used by the VMware Service Console are not included in the aggregate. This value represents the amount of resources available for the root resource pool for running virtual machines.
      </td>
    </tr>

    <tr>
      <td>
        `cpu.totalMHz`
      </td>

      <td>
        Aggregated CPU resources of all hosts, in MHz. It does not filter out cpu used by system or related to hosts under maintenance.
      </td>
    </tr>

    <tr>
      <td>
        `cpu.cores`
      </td>

      <td>
        Number of physical CPU cores. Physical CPU cores are the processors contained by a CPU package.
      </td>
    </tr>

    <tr>
      <td>
        `cpu.threads`
      </td>

      <td>
        Aggregated number of CPU threads.
      </td>
    </tr>

    <tr>
      <td>
        `mem.size`
      </td>

      <td>
        Aggregated memory resources of all hosts, in MiB. It does not filter out memory used by system or related to hosts under maintenance.
      </td>
    </tr>

    <tr>
      <td>
        `mem.effectiveSize`
      </td>

      <td>
        Effective memory resources, in MiB, available to run virtual machines. This is the aggregated effective resource level from all running hosts. Hosts that are in maintenance mode or are unresponsive are not counted. Resources used by the VMware Service Console are not included in the aggregate. This value represents the amount of resources available for the root resource pool for running virtual machines.
      </td>
    </tr>

    <tr>
      <td>
        `effectiveHosts`
      </td>

      <td>
        Total number of effective hosts. This number exclude hosts under maintenance.
      </td>
    </tr>

    <tr>
      <td>
        `hosts`
      </td>

      <td>
        Total number of hosts
      </td>
    </tr>

    <tr>
      <td>
        `overallStatus`
      </td>

      <td>
        * `gray`: Status is unknown.
        * `green`: Entity is OK.
        * `yellow`: Entity might have a problem.
        * `red`: Entity definitely has a problem.
      </td>
    </tr>

    <tr>
      <td>
        `datastoreList`
      </td>

      <td>
        List of datastore used by the cluster. A pipe or vertical bar character (`|`) is used as a separator.
      </td>
    </tr>

    <tr>
      <td>
        `hostList`
      </td>

      <td>
        List of hosts belonging to the cluster. A pipe or vertical bar character (`|`) is used as a separator.
      </td>
    </tr>

    <tr>
      <td>
        `networkList`
      </td>

      <td>
        List of networks attached to the cluster. A pipe or vertical bar character (`|`) is used as a separator.
      </td>
    </tr>

    <tr>
      <td>
        `drsConfig.vmotionRate`
      </td>

      <td>
        Threshold for generated ClusterRecommendations. DRS generates only those recommendations that are above the specified `vmotionRate`. Ratings vary from `1` to `5`. This setting applies to manual, `partiallyAutomated`, and `fullyAutomated` DRS clusters.
      </td>
    </tr>

    <tr>
      <td>
        `dasConfig.restartPriorityTimeout`
      </td>

      <td>
        Maximum time the lower priority VMs should wait for the higher priority VMs to be ready (Seconds).
      </td>
    </tr>

    <tr>
      <td>
        `datacenterName`
      </td>

      <td>
        Data center name.
      </td>
    </tr>

    <tr>
      <td>
        `datacenterLocation`
      </td>

      <td>
        Data center location.
      </td>
    </tr>

    <tr>
      <td>
        `drsConfig.enabled`
      </td>

      <td>
        Flag indicating whether or not the service is enabled.
      </td>
    </tr>

    <tr>
      <td>
        `drsConfig.enableVmBehaviorOverrides`
      </td>

      <td>
        Flag that dictates whether DRS Behavior overrides for individual virtual machines (`ClusterDrsVmConfigInfo`) are enabled.
      </td>
    </tr>

    <tr>
      <td>
        `drsConfig.defaultVmBehavior`
      </td>

      <td>
        Specifies the cluster-wide default DRS behavior for virtual machines. You can override the default behavior for a virtual machine by using the `ClusterDrsVmConfigInfo` object.
      </td>
    </tr>

    <tr>
      <td>
        `dasConfig.enabled`
      </td>

      <td>
        Flag to indicate whether or not vSphere HA feature is enabled.
      </td>
    </tr>

    <tr>
      <td>
        `dasConfig.admissionControlEnabled`
      </td>

      <td>
        Flag that determines whether strict admission control is enabled
      </td>
    </tr>

    <tr>
      <td>
        `dasConfig.isolationResponse`
      </td>

      <td>
        Indicates whether or not the virtual machine should be powered off if a host determines that it is isolated from the rest of the compute resource.
      </td>
    </tr>

    <tr>
      <td>
        `dasConfig.restartPriority`
      </td>

      <td>
        Restart priority for a virtual machine.
      </td>
    </tr>

    <tr>
      <td>
        `dasConfig.hostMonitoring`
      </td>

      <td>
        Determines whether HA restarts virtual machines after a host fails.
      </td>
    </tr>

    <tr>
      <td>
        `dasConfig.vmMonitoring`
      </td>

      <td>
        Level of HA Virtual Machine Health Monitoring Service.
      </td>
    </tr>

    <tr>
      <td>
        `dasConfig.vmComponentProtecting`
      </td>

      <td>
        This property indicates if vSphere HA VM Component Protection service is enabled.
      </td>
    </tr>

    <tr>
      <td>
        `dasConfig.hbDatastoreCandidatePolicy`
      </td>

      <td>
        The policy on what datastores will be used by vCenter Server to choose heartbeat datastores: `allFeasibleDs`, `allFeasibleDsWithUserPreference`, `userSelectedDs`
      </td>
    </tr>
  </tbody>
</table>

### VSphereSnapshotVmSample [#vspheresnapshot]

<table>
  <thead>
    <tr>
      <th style={{ width: "300px" }}>
        Name
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `snapshotTreeInfo`
      </td>

      <td>
        Tree info for the snapshot. Es: `Cluster:Vm:Snapshot1:Snapshot2`
      </td>
    </tr>

    <tr>
      <td>
        `name`
      </td>

      <td>
        Snapshot name
      </td>
    </tr>

    <tr>
      <td>
        `creationTime`
      </td>

      <td>
        Snapshot creation time
      </td>
    </tr>

    <tr>
      <td>
        `powerState`
      </td>

      <td>
        The power state of the virtual machine when this snapshot was taken
      </td>
    </tr>

    <tr>
      <td>
        `snapshotId`
      </td>

      <td>
        The unique identifier that distinguishes this snapshot from other snapshots of the virtual machine
      </td>
    </tr>

    <tr>
      <td>
        `quiesced`
      </td>

      <td>
        Flag to indicate whether or not the snapshot was created with the "quiesce" option, ensuring a consistent state of the file system
      </td>
    </tr>

    <tr>
      <td>
        `backupManifest`
      </td>

      <td>
        The relative path from the snapshotDirectory pointing to the backup manifest. Available for certain quiesced snapshots only
      </td>
    </tr>

    <tr>
      <td>
        `description`
      </td>

      <td>
        Description of the snapshot
      </td>
    </tr>

    <tr>
      <td>
        `replaySupported`
      </td>

      <td>
        Flag to indicate whether this snapshot is associated with a recording session on the virtual machine that can be replayed
      </td>
    </tr>

    <tr>
      <td>
        `totalMemoryInDisk`
      </td>

      <td>
        Total size of memory in disk.
      </td>
    </tr>

    <tr>
      <td>
        `totalUniqueMemoryInDisk`
      </td>

      <td>
        Total size of the file corresponding to the file blocks that were allocated uniquely to store memory. In other words, if the underlying storage supports sharing of file blocks across disk files, the property corresponds to the size of the file blocks that were allocated only in context of this file. It does not include shared blocks that were allocated in other files. This property will be unset if the underlying implementation is unable to compute this information.
      </td>
    </tr>

    <tr>
      <td>
        `totalDisk`
      </td>

      <td>
        Total size of snapshot files in disk
      </td>
    </tr>

    <tr>
      <td>
        `totalUniqueDisk`
      </td>

      <td>
        Total size of the file corresponding to the file blocks that were allocated uniquely to store snapshot data in disk. In other words, if the underlying storage supports sharing of file blocks across disk files, the property corresponds to the size of the file blocks that were allocated only in context of this file. It does not include shared blocks that were allocated in other files. This property will be unset if the underlying implementation is unable to compute this information.
      </td>
    </tr>

    <tr>
      <td>
        `datastorePathDisk`
      </td>

      <td>
        Disk file path in the datastore
      </td>
    </tr>

    <tr>
      <td>
        `datastorePathMemory`
      </td>

      <td>
        Memory file path in the datastore
      </td>
    </tr>
  </tbody>
</table>

## Troubleshooting [#troubleshooting]

<CollapserGroup>
  <Collapser
    id="data-gaps"
    title="Gaps on reported data"
  >
    One possible reason for data gaps could be because of the integration taking too long to collect and process data from vCenter. In case the integration exceeds the [timeout](https://docs.newrelic.com/docs/infrastructure/host-integrations/infrastructure-integrations-sdk/specifications/host-integrations-standard-configuration-format/#timeout), which by default is `120s`, the infrastructure agent will kill the integration, and a log message like the following will be printed:

    ```shell
    [output] level=warn msg="HeartBeat timeout exceeded after 120000000000" integration_name=nri-vsphere
    ```

    In order to fix this, you could extend the [timeout](https://docs.newrelic.com/docs/infrastructure/host-integrations/infrastructure-integrations-sdk/specifications/host-integrations-standard-configuration-format/#timeout) parameter in the config file.

    ```yaml
    integrations:
      - name: nri-vsphere
        env:
          # Integration configuration parameters.

        interval: 120s
        timeout: 300s
    ```
  </Collapser>
</CollapserGroup>
