---
headingText: Install and configure the OpenTelemetry Collector
componentType: default
---

Deploy the OpenTelemetry Collector to your Kubernetes cluster using Helm. The collector will automatically discover and scrape metrics from your NGINX pods.

1. Create a Kubernetes secret to store your New Relic credentials. Replace `YOUR_LICENSE_KEY` and `YOUR_OTLP_ENDPOINT` with your actual values. Refer to the OTLP endpoint configuration [documentation](https://docs.newrelic.com/docs/opentelemetry/best-practices/opentelemetry-otlp/#configure-endpoint-port-protocol) to select the appropriate endpoint for your region.

   ```bash
   kubectl create secret generic newrelic-licenses --from-literal=NEWRELIC_LICENSE_KEY=YOUR_LICENSE_KEY --from-literal=NEWRELIC_OTLP_ENDPOINT=YOUR_OTLP_ENDPOINT -n newrelic --create-namespace
   ```

2. Create a `values.yaml` file to configure the OpenTelemetry Collector. Update the placeholders for your cluster name, NGINX pod labels, and stub status endpoint.

   ```yaml
   opentelemetry-collector:
     mode: deployment

     image:
       repository: otel/opentelemetry-collector-contrib
       pullPolicy: IfNotPresent

     command:
       name: otelcol-contrib

     resources:
       limits:
         cpu: 500m
         memory: 300Mi
       requests:
         cpu: 100m
         memory: 100Mi

     extraEnvs:
       - name: NEWRELIC_LICENSE_KEY
         valueFrom:
           secretKeyRef:
             name: newrelic-licenses
             key: NEWRELIC_LICENSE_KEY
       - name: NEWRELIC_OTLP_ENDPOINT
         valueFrom:
           secretKeyRef:
             name: newrelic-licenses
             key: NEWRELIC_OTLP_ENDPOINT
       - name: K8S_NODE_NAME
         valueFrom:
           fieldRef:
             fieldPath: spec.nodeName
       - name: K8S_CLUSTER_NAME
         value: nginx-cluster # Update with your cluster name

     clusterRole:
       create: true
       rules:
         - apiGroups: [""]
           resources: ["pods", "nodes", "nodes/stats", "nodes/proxy"]
           verbs: ["get", "list", "watch"]
         - apiGroups: ["apps"]
           resources: ["replicasets"]
           verbs: ["get", "list", "watch"]
       clusterRoleBinding:
         name: ""

     config:
       extensions:
         health_check:
           endpoint: 0.0.0.0:13133
         k8s_observer:
           auth_type: serviceAccount
           observe_pods: true
           observe_nodes: true

       receivers:
         receiver_creator/nginx:
           watch_observers: [k8s_observer]
           receivers:
             nginx:
               rule: type == "pod" && labels["app"] == "nginx" && labels["role"] == "reverse-proxy" # Update with your labels
               config:
                 endpoint: 'http://`endpoint`:<stub_status_port>/status'
                 metrics:
                   nginx.requests:
                     enabled: true
                   nginx.connections_accepted:
                     enabled: true
                   nginx.connections_handled:
                     enabled: true
                   nginx.connections_current:
                     enabled: true
                 collection_interval: 30s
                 resource_attributes:
                   nginx.server.endpoint: 'http://`endpoint`:<stub_status_port>/status'
                   nginx.port: '<stub_status_port>'

       processors:
         batch:
           send_batch_size: 1024
           timeout: 30s

         resource/cluster:
           attributes:
             - key: k8s.cluster.name
               value: "${env:K8S_CLUSTER_NAME}"
               action: insert

         transform/nginx:
           metric_statements:
             - context: resource
               statements:
                 - set(attributes["nginx.display.name"], Concat([
                     "server",
                     "k8s",
                     attributes["k8s.cluster.name"],
                     attributes["k8s.namespace.name"],
                     "pod",
                     attributes["k8s.pod.name"],
                     "nginx",
                     attributes["nginx.port"]
                     ], ":"))
                 - set(attributes["nginx.deployment.name"], attributes["k8s.pod.name"])

       exporters:
         otlphttp:
           endpoint: "${env:NEWRELIC_OTLP_ENDPOINT}"
           headers:
             api-key: "${env:NEWRELIC_LICENSE_KEY}"

       service:
         extensions: [health_check, k8s_observer]
         pipelines:
           metrics/nginx:
             receivers: [receiver_creator/nginx]
             processors: [batch, resource/cluster, transform/nginx]
             exporters: [otlphttp]
   ```

3. Install the [Helm chart](https://github.com/open-telemetry/opentelemetry-helm-charts) using your values.yaml file.

   ```bash
   helm repo add open-telemetry https://open-telemetry.github.io/opentelemetry-helm-charts
   helm repo update
   helm upgrade --install nginx-otel-collector open-telemetry/opentelemetry-collector --namespace newrelic --create-namespace -f values.yaml
   ```

4. Ensure the pods have successfully spun up.

   ```bash
   kubectl get pods -n newrelic --watch
   ```

   You should see pods with names like `nginx-otel-collector-<hash>` in a `Running` state in the `newrelic` namespace.

5. Run an NRQL query in New Relic to confirm data is arriving. Replace the cluster name with the value you set in the values file:

   ```sql
   FROM Metric
   SELECT *
   WHERE metricName LIKE 'nginx.%'
     AND instrumentation.provider = 'opentelemetry'
     AND k8s.cluster.name = 'nginx-cluster'
   SINCE 10 minutes ago
   ```
